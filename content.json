{"meta":{"title":"Hexo","subtitle":"","description":"","author":"zhang0224gz","url":"https://zhang0224gz.github.io","root":"/"},"pages":[],"posts":[{"title":"PTA 第三章栈和列表","slug":"专业课作业类/数据结构PTA/第三章 栈和列表","date":"2021-12-04T09:05:47.076Z","updated":"2021-12-04T10:40:12.829Z","comments":true,"path":"2021/12/04/专业课作业类/数据结构PTA/第三章 栈和列表/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E4%B8%93%E4%B8%9A%E8%AF%BE%E4%BD%9C%E4%B8%9A%E7%B1%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84PTA/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%88%E5%92%8C%E5%88%97%E8%A1%A8/","excerpt":"","text":"判断题（错题：1-10）1-1 若一个栈的输入序列为1，2，3，…，N，输出序列的第一个元素是i，则第j个输出元素是j−i−1。F 1-2 所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。F 1-3 在对不带头结点的链队列作出队操作时，不会改变头指针的值。F 1-4 不论是入队列操作还是入栈操作,在顺序存储结构上都需要考虑”溢出”情况。T 1-5 队列和栈都是运算受限的线性表，只允许在表的两端进行运算。F 1-6 栈和队列的存储方式，既可以是顺序方式，也可以是链式方式。T 1-7 循环队列也存在着空间溢出问题。T 1-8 循环队列执行出队操作时会引起大量元素的移动。F 1-9 栈是插入和删除只能在一端进行的线性表；队列是插入在一端进行，删除在另一端进行的线性表。T 1-10 在n个元素连续进栈以后，它们的出栈顺序和进栈顺序一定正好相反。T 1-11 环形队列中有多少个元素可以根据队首指针和队尾指针的值来计算。T 1-12 栈和队列的插入和删除操作特殊，所以，栈和队列是非线性结构。F 1-13 序列{1,2,3,4,5}依次入栈，则不可能得到{3,4,1,2,5}的出栈序列。 T 1-14 队列中允许插入的一端叫队头，允许删除的一端叫队尾。F 单选题（错题：2-2、2-18）2-1 若用大小为6的数组来实现循环队列，且当前front和rear的值分别为0和4。当从队列中删除两个元素，再加入两个元素后，front和rear的值分别为多少？ A.2和0 2-2 如果循环队列用大小为m的数组表示，且用队头指针front和队列元素个数size代替一般循环队列中的front和rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数最多为： 不知道 2-3 以下数据结构中，（ ）是非线性数据结构。 A.树 2-4 设栈S和队列Q的初始状态均为空，元素{1, 2, 3, 4, 5, 6, 7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2, 5, 6, 4, 7, 3, 1}，则栈S的容量至少是： D.4 2-5 线性表、堆栈、队列的主要区别是什么？ B.堆栈和队列都是插入、删除受到约束的线性表 2-6 栈和队列的共同点( )。 C.只允许在端点处插入和删除元素 2-7 下列关于线性表,栈和队列叙述,错误的是( )。 A.线性表是给定的n(n必须大于零)个元素组成的序列 2-8 设用一个数组A[1……N]来存储一个栈，令A[N]为栈底，用整型变量T指示当前栈顶位置，A[T]为栈顶元素。当从栈中弹出一个元素时，变量T的变化为（ ）。 A.T=T+1 2-9 链式栈与顺序栈相比，一个比较明显的优点是（ ）。 B.通常不会出现栈满的情况 2-10 (neuDS)在循环顺序队列中，假设以少用一个存储单元的方法来区分队列判满和判空的条件，front和rear分别为队首和队尾指针，它们分别指向队首元素和队尾元素的下一个存储单元，队列的最大存储容量为maxSize，则队列的长度是（ ）。 C.(rear-front+maxSize)%maxSize 2-11 (nueDS_C++)设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5、e6依次通过栈S，一个元素出栈后即进入队列Q，若6个元素出队的顺序是e2、e4、e3、e6、e5、e1，则栈S的容量至少应该是（ ）。提示：对于栈，可以全进再依次出；也可以进一个出一个；也可以进一部分，出一个，再进一部分；但是出栈之后，不能再入栈。 A.3 2-12 关于栈和队列的下列说法正确的是（） B.栈是后进先出的结构，出栈时除了栈顶元素，其余元素无需移动； 2-13 一个栈的入栈序列是a,b,c,d,e，则栈的出栈序列不可能的是（ ）。 C.dceab 2-14 在一个链表表示的队列中， f和r分别指向队列的头和尾。下列哪个操作能正确地将s结点插入到队列中： B.r-&gt;next=s; r=s; 2-15 栈和队列具有相同的。 B.逻辑结构 2-16 假定利用数组a[n]顺序存储一个栈，用top表示栈顶指针，用top==-1表示栈空，并已知栈未满，当元素x进栈时所执行的操作为（ ）。 C.a[++top]=x 2-17 队列的“先进先出”特性是指（ ）。 Ⅰ.最后插入队列中的元素总是最后被删除Ⅱ.当同时进行插入、删除操作时，总是插入操作优先Ⅲ.每当有删除操作时，总要先做一次插入操作Ⅳ.每次从队列中删除的总是最早插入的元素 B.Ⅰ、Ⅳ 2-18 已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。 B.0,n-1（原因：……） 2-19 执行函数时，其局部变量一般采用（ ）进行存储。 C.栈结构 2-20 对空栈 S 进行 Push 和 Pop 操作，入栈序列为 a, b, c, d, e，经过 Push, Push, Pop, Push, Pop, Push, Push, Pop 操作后，得到的出栈序列是： D.b, c, e 2-21 用S表示入栈操作，X表示出栈操作，若元素入栈的顺序为1234，为了得到1342出栈顺序，相应的S和X的操作串为( )。 D.SXSSXSXX 填空题（错题：4-3）4-1 栈的运算遵循 后进先出 的原则。 4-2 以下运算实现在链队上的入队列，请在空白处用适当句子予以填充。 12345678void EnQueue(QueptrTp *lq,DataType x)&#123; LqueueTp *p; p=(LqueueTp *)malloc(sizeof(LqueueTp)); p-&gt;data=x; p-&gt;next=NULL; (lq-&gt;rear)-&gt;next=p; lq-&gt;rear=p; &#125; 4-3 以下运算实现在链栈上的初始化，请在空白处用请适当句子予以填充。 12345typedef struct Node&#123; DataType data; struct Node *next;&#125;StackNode,*LStackTp;void InitStack(LStackTp &amp;ls)&#123; 不知……;&#125;。 函数题6-3 jmu-ds-舞伴问题 (20 分) 12345678910111213141516171819202122232425262728293031323334353637383940int QueueLen(SqQueue Q)&#123; return (Q-&gt;rear-Q-&gt;front+MAXQSIZE)%MAXQSIZE;&#125;int EnQueue(SqQueue &amp;Q, Person e)&#123; Q-&gt;rear = (Q-&gt;rear+1)%MAXQSIZE; Q-&gt;data[Q-&gt;rear] = e; return 0;&#125;int QueueEmpty(SqQueue &amp;Q)&#123; if(Q-&gt;rear==Q-&gt;front)return 1; else return 0;&#125;int DeQueue(SqQueue &amp;Q, Person &amp;e)&#123; Q-&gt;front = (Q-&gt;front+1)%MAXQSIZE; e = Q-&gt;data[Q-&gt;front]; return 0;&#125;void DancePartner(Person dancer[], int num)&#123; for(int i=0;i&lt;num;i++) &#123; if(dancer[i].sex==&#x27;M&#x27;) EnQueue(Mdancers,dancer[i]); else EnQueue(Fdancers,dancer[i]); &#125; while(!QueueEmpty(Mdancers)&amp;&amp;!QueueEmpty(Fdancers)) &#123; Person x,y; DeQueue(Mdancers,x); DeQueue(Fdancers,y); cout&lt;&lt;y.name&lt;&lt;&quot; &quot;&lt;&lt;x.name&lt;&lt;endl; &#125;&#125; 6-4 十进制转二进制（顺序栈设计和应用） (10 分) 12345678910111213141516171819202122232425bool isEmpty()&#123; if(top==-1)return 1; else return 0;&#125;/* 元素x入栈 */void Push(int x)&#123; //if(x==MaxSize)cout&lt;&lt;&quot;上溢&quot;&lt;&lt;endl; //else mystack[++top]=x;&#125;/* 取栈顶元素 */int getTop()&#123; return mystack[top];&#125;/* 删除栈顶元素 */void Pop()&#123; top--;&#125; 编程题7-1 银行业务队列简单模拟 (25 分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int arr[1000];int main()&#123; int n; int flag1=0,flag2=0; int top1=0,top2=0,top=0; cin&gt;&gt;n; int a1[n+1],a2[n+1],a[n+1]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; if(arr[i]%2!=0)a1[top1++]=arr[i]; else a2[top2++]=arr[i]; &#125; int t1=0,t2=0; for(int i=0;i&lt;n;i++) &#123; if(arr[i]%2==0)flag2++; else flag1++; if(flag2%2==0&amp;&amp;flag1%4==0) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; a[top++]=a2[t2++]; &#125;else&#123; if(t1!=top1&amp;&amp;(flag1%2==0||t2==top2)) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; &#125; if(t2!=top2&amp;&amp;(flag2%2==0||t1==top1||flag1%2==0)) &#123; a[top++]=a2[t2++]; &#125; &#125; if(top==n)break; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;a[n-1]&lt;&lt;endl; return 0;&#125; 7-2 堆栈操作合法性 (20 分) 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N,M; string str; int n,x=0; cin&gt;&gt;N&gt;&gt;M; for(int i=0; i&lt;N; i++) &#123; cin&gt;&gt;str; n = str.size(); for(int j=0; j&lt;n; j++) &#123; if(str[j]==&#x27;S&#x27;) &#123; x++; if(x&gt;M)break; &#125; else if(str[j]==&#x27;X&#x27;) &#123; x--; if(x&lt;0)break; &#125; &#125; if(x==0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; x=0; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-11-27T13:15:34.628Z","updated":"2021-11-27T13:15:34.628Z","comments":true,"path":"2021/11/27/hello-world/","link":"","permalink":"https://zhang0224gz.github.io/2021/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}