{"meta":{"title":"Hexo","subtitle":"","description":"","author":"zhang0224gz","url":"https://zhang0224gz.github.io","root":"/"},"pages":[{"title":"书单","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"books/index.html","permalink":"https://zhang0224gz.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":true,"path":"links/index.html","permalink":"https://zhang0224gz.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"categories/index.html","permalink":"https://zhang0224gz.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"about/index.html","permalink":"https://zhang0224gz.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"tags/index.html","permalink":"https://zhang0224gz.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-04T10:33:16.481Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"repository/index.html","permalink":"https://zhang0224gz.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"数据结构/Untitled","date":"2021-12-29T12:23:27.423Z","updated":"2021-12-29T12:23:46.708Z","comments":true,"path":"2021/12/29/数据结构/Untitled/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"一些小知识点","slug":"数据结构/一些小知识点","date":"2021-12-28T12:36:46.476Z","updated":"2021-12-29T11:43:36.170Z","comments":true,"path":"2021/12/28/数据结构/一些小知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"随机存取、顺序存取、随机存储和顺序存储的区别1.存取结构:随机存取和顺序存取随机存取（直接存取，Random Access）指当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关微观栗子：编程语言中的数组宏观栗子：随机存取存储器（RAM：Random Access Memory,内存条）（因为RAM利用电容存储电荷的原理保存信息，所以RAM可以高速存取，且与物理地址无关。）顺序存取（Sequential Access）一种按记录的逻辑顺序进行读、写操作的存取方法，所需要的时间与该数据所在的物理地址有关。顺序存取表现为:在存取第N个数据时，必须先访问前（N-1）个数据。微观栗子：数据结构中的链表宏观栗子：录音磁带、光盘、机械硬盘里面的磁盘（磁带、光盘、磁盘上的数据分别存储在不同扇区、不同磁道上，磁盘的读写磁头通过切换不同扇区和磁道来读取物理地址不连续的数据时，该过程中要经过不同扇区和不同磁道上的无关数据，磁盘的读写磁头在切换不同扇区和磁道所需时间也不同，故为顺序存取。）2.存储结构:顺序存储、随机存储按ctrl+D键将本页面保存为书签，下次可直接打开网页；按F11(或Fn+F11)键把网页设置成全屏，学习效率更高。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"","slug":"数据结构/考试","date":"2021-12-28T07:47:11.987Z","updated":"2021-12-29T09:56:06.510Z","comments":true,"path":"2021/12/28/数据结构/考试/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%80%83%E8%AF%95/","excerpt":"","text":"直接插入排序 希尔排序 起泡排序 快速排序 简单选择排序 堆排序 归并排序 最好情况 正序 O(n) O(n**1.3) 正序 O(n) 都是中值O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 最坏情况 逆序 O(n**2) 逆序 O(n**2) 正序逆序O(n**2) O(n2) O(nlog2n) O(nlog2n) 平均情况 O(n**2) O(n**2) O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 稳定性 稳定 不稳定 稳定 不稳定 不稳定 不稳定 稳定 时间性能 O(n**2) 取决于增量序列O(n**2) ~ O(nlogn) O(n**2) O(nlog2n) O(n**2) O(nlog2n) O(nlog2n) 空间性能 O(1) O(1) O(1) O(log2n)~O(n) O(1) O(1) O(n) 稳定性：直接插入排序，起泡排序，归并排序 不稳定：希尔排序，快速排序，简单选择排序，堆排序 直接插入排序、简单选择排序和起泡排序 O(n2) 堆排序、快速排序和归并排序 O(nlogn) 希尔排序的时间性能取决于增量序列，介于O(n2)和O(nlog2n)之间 缓冲区应该是一个（队列 ）结构。 最快的速度挑选出前10个最大的，采用（ 堆排序）方法最好。 （插入排序）可能会出现下面情况：在最后一趟开始之前，所有元素都不在最终位置上 （1）时间性能：排序算法在各种情况（最好、最坏、平均）下的时间复杂度。 例如，基于比较的内排序在排序过程中的基本操作： ① 比较：关键码之间的比较； ② 移动：记录从一个位置移动到另一个位置。 （2）空间性能：排序过程中占用的辅助存储空间。 辅助存储空间是除了存放待排序记录占用的存储空间之外，执行算法所需要的其他存储空间。 直接插入排序：（正序）循环第k个元素开始，向前进行比较，大于就交换，小于就结束，进行下一趟 -&gt;排序过程：前面k-1个有序，后面无序 希尔排序：步数为n，序列中索引值为(i += n)的作为一个子序列进行排序，再全部进行直接插入排序 起泡排序：两两比较，如果反序则交换 -&gt;排序过程：后面k+1个有序，前面无序 快速排序：将第一个作为中间值mid，从后向前找比mid小的，找到就交换位置，i++；从前向后开始找比mid大的，找到就交换位置,j–；重复，直到i&gt;=j,一趟结束。i==j的位置作为下一趟的mid值。 简单选择排序：将前n-1个值和和该值后面的进行比较，找到最小的和该值交换 -&gt;排序过程：前面k-1个有序，后面无序 堆排序：（大根堆）原顺序作为层序形成完全二叉树，从大到小的根节点和孩子比较，小就交换，然后向下继续比较小就交换直到底。形成大根堆，将第一个0和最后一个n-1交换，剩下n-1个进行堆调整。 归并排序：将序列划分为2*n个子序列进行单独排序，两两合并为2n-1个子序列进行单独排序,一直到合并为一个排序 基数排序：栗子三位数排序(有明显界限的个位，十位，百位) 创建10个链表09,先后按个位按09连进属于的表头（尾插），结束将其串成整表，再按照十位做相同的行为","categories":[],"tags":[]},{"title":"第二，三，四章 线性表","slug":"数据结构/线性表","date":"2021-12-28T07:14:34.053Z","updated":"2021-12-29T12:52:45.783Z","comments":true,"path":"2021/12/28/数据结构/线性表/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/","excerpt":"","text":"字符串：线性表特例 多维数组：线性表推广（严格不是） 线性表（表）：具有相同类型的数据元素的有限序列 -&gt; 将元素类型限制为字符：字符串（串）：零个或多个字符组成的有限序列 串长：串中所包含的字符个数 空串：长度为 0 的串 子串：串中任意个连续的字符组成的子序列(包含空串)主串：包含子串的串子串的位置：子串的第一个字符在主串中的序号 串的存储结构 字符串通常采用顺序存储，即用数组存储 模式匹配-&gt; BF算法模式匹配：在主串 S 中寻找子串 T 的过程，T 也称为模式 如果匹配成功，返回 T 在 S 中的位置；否则返回 0 模式匹配问题有什么特点？ （1） 算法的一次执行时间：问题规模通常很大，常常在大量信息中进行匹配 （2） 算法改进所取得的积累效益：模式匹配操作经常被调用，执行频率高 -&gt; KMP算法数组的存储结构 如何存储（多维）数组呢？ 数组没有插入和删除操作，所以，不用预留空间，适合采用顺序存储 按行优先：先存储行号较小的元素，行号相同者先存储列号较小的元素 按列优先：先存储列号较小的元素，列号相同者先存储行号较小的元素 特殊矩阵的压缩存储什么是特殊矩阵？ 特殊矩阵：矩阵中很多值相同的元素并且它们的分布有一定的规律 特殊矩阵如何压缩存储？ 为值相同的元素分配一个存储空间 特殊矩阵压缩存储后有什么要求吗？ 保证随机存取，即在O(1)时间内寻址 -&gt; 对称矩阵的压缩存储如何压缩存储对称矩阵呢？ 只存储下三角部分的元素 aij 在一维数组中的下标 k = i×(i-1)/2+ j-1 对称矩阵压缩存储后的寻址方法 对于下三角中的元素aij（i ≥ j）：k＝i×(i-1)/2＋j -1 对于上三角中的元素aij（i＜j），因为aij＝aji，则 k＝j×(j-1)/2＋i -1 -&gt; 三角矩阵的压缩存储如何压缩存储三角矩阵呢？ 下（上）三角部分的元素；相同的常数只存储一个 下三角矩阵压缩存储后的寻址方法 对于下三角中的元素aij（i ≥ j）：k＝i×(i -1)/2 + j-1 对于上三角中的元素aij（i＜j）：k＝n×(n + 1)/2 -&gt; 对角矩阵的压缩存储对角矩阵：所有非零元素都集中在以主对角线为中心的带状区域中，所有其他元素都为零 稀疏矩阵的压缩存储什么是稀疏矩阵？ 稀疏矩阵：矩阵中有很多零元素，并且分布没有规律 稀疏矩阵如何压缩存储？ 只存储非零元素，零元素不分配存储空间 如何只存储非零元素？ 三元组：（行号，列号，非零元素值） -&gt; 三元组顺序表 三元组表：将稀疏矩阵的非零元素对应的三元组所构成的集合，按行优先的顺序排列成一个线性表 -&gt; 十字链表","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"第五章 树和二叉树","slug":"数据结构/树和二叉树","date":"2021-12-28T05:23:23.691Z","updated":"2021-12-29T11:15:30.927Z","comments":true,"path":"2021/12/28/数据结构/树和二叉树/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"树的前序遍历等价于二叉树的前序遍历！树的后序遍历等价于二叉树的中序遍历！ 先访问该结点打标记，再孩子入队列-&gt;图结构时，不会造成重复入队先访问左右孩子入队列，再打标记 -&gt;图结构时会造成重复入队 逻辑关系线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继； 树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子 图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接 树树：n个结点(数据元素)的有限集合 ，当 n＝0 时，称为空树；任意一棵非空树 T 满足以下条件：（1）有且仅有一个特定的称为根的结点；（2）当 n＞1 时，除根结点之外的其余结点被分成 m（m &gt; 0）个互不相交的有限集合 T1,T2,… , Tm，其中每个集合又是一棵树，并称为这个根结点的子树。 ​ *树的定义是采用递归方法 互不相交的具体含义是什么？结点：结点不能属于多个子树边：子树之间不能有关系 *互不相交-&gt;没有回路-&gt;树结构具有层次性 结点的度：结点所拥有的子树的个数树的度：树中各结点度的最大值叶子结点：度为 0 的结点，也称为终端结点分支结点：度不为 0 的结点，也称为非终端结点 *在树结构中，逻辑关系表现为双亲——孩子 路径：结点序列 n1, n2, …, nk 称为一条由 n1 至 nk 的路径，当且仅当满足如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k） 路径长度：路径上经过的边的个数在树结构中，路径是唯一的祖先、子孙：如果有一条路径从结点 x 到结点 y，则 x 称为 y 的祖先，而 y 称为 x 的子孙 结点所在层数：根结点的层数为 1；对其余结点，若某结点在第 k 层，则其孩子结点在第 k+1 层 树的深度（高度）：树中所有结点的最大层数树的宽度：树中每一层结点个数的最大值树的遍历-&gt;前序，中序，后序和层序树的遍历：从根结点出发，按照某种次序访问树中所有结点，并且每个结点仅被访问一次 树的存储结构-&gt;双亲，孩子，孩子兄弟表示法实现树的存储结构，关键是什么? 如何表示树中结点之间的逻辑关系 什么是存储结构? 数据元素及其逻辑关系在存储器中的表示 树中结点之间的逻辑关系是什么? 思考问题的出发点：如何表示结点的双亲和孩子 二叉树-&gt;斜树，满二叉树，完全二叉树二叉树： n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树是度为 2 的树吗？ 二叉树是度小于等于 2 的树吗？ 二叉树有什么特点？（1）每个结点最多有两棵子树（2）二叉树是有序的，其次序不能任意颠倒 左斜树：所有结点都只有左子树的二叉树右斜树：所有结点都只有右子树的二叉树斜树：左斜树和右斜树的统称 斜树有什么特点呢？（1）每一层只有一个结点（2）结点个数与其深度相同 斜树是树结构的特例，是从树结构*退化成了线性结构 满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上的二叉树 满二叉树有什么特点呢？（1）叶子只能出现在最下一层（2）只有度为 0 和度为 2 的结点（3）在同样深度的二叉树中结点个数最多（4）在同样深度的二叉树中叶子结点个数最多 满二叉树是树结构的特例，是最丰满的二叉树 完全二叉树：在满二叉树中，从最后一个结点开始，连续去掉任意个结点得到的二叉树 完全二叉树有什么特点呢？ （1）叶子结点只能出现在最下两层且最下层的叶子结点都集中在二叉树的左面（2）完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子（3）深度为 k 的完全二叉树在 k-1 层上一定是满二叉树（4）在同样结点个数的二叉树中，完全二叉树的深度最小 二叉树性质-&gt; n0＝n2＋1性质 5-1：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2＋1 n＝n0＋n1＋n2 ;n＝n1＋2n2＋1;n0＝n2＋1 -&gt; 第i层：2**(i-1)个结点性质 5-2：二叉树的第 i 层上最多有2i-1个结点（i≥1） -&gt;最多有2**(k-1)个结点性质 5-3：一棵深度为 k 的二叉树中，最多有 2k-1个结点 深度为 k 且具有 2k-1个结点的二叉树一定是满二叉树 -&gt;深度：log n下取整+1性质 5-4：具有 n 个结点的完全二叉树的深度为[ logn] +1/log(n+1)上取整 -&gt;双亲i/2，左孩子2i，右孩子2i+1性质 5-5：对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，对于任意的序号为 i（1≤i≤n）的结点（简称结点 i），有：（1）如果 i＞1，则结点 i 的双亲结点的序号为 i/2，否则结点 i 无双亲结点（2）如果 2i≤n，则结点 i 的左孩子的序号为 2i，否则结点 i 无左孩子（3）如果 2i+1≤n，则结点 i 的右孩子的序号为2i+1，否则结点 i 无右孩子 二叉树的遍历-&gt;前序，中序，后序和层序O(n)123456789101112131415161718192021222324252627282930313233343536373839404142434445template &lt;typename DataType&gt;class BiTree&#123;public: BiTree( )&#123;root = Creat(root);&#125; ~BiTree( )&#123;Release(root);&#125; void PreOrder( )&#123;PreOrder(root);&#125; void InOrder( )&#123;InOrder(root);&#125; void PostOrder( )&#123;PostOrder(root);&#125; void LeverOrder( ); private: BiNode&lt;DataType&gt; *Creat(BiNode&lt;DataType&gt; *bt); void Release(BiNode&lt;DataType&gt; *bt); void PreOrder(BiNode&lt;DataType&gt; *bt); void InOrder(BiNode&lt;DataType&gt; *bt); void PostOrder(BiNode&lt;DataType&gt; *bt); BiNode&lt;DataType&gt; *root; &#125;;template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; :: PreOrder(BiNode&lt;DataType&gt; *bt) &#123; if (bt == nullptr) return; //递归调用的结束条件 else &#123; cout &lt;&lt; bt-&gt;data; //访问根结点bt的数据域 PreOrder(bt-&gt;lchild); //前序递归遍历bt的左子树 PreOrder(bt-&gt;rchild); //前序递归遍历bt的右子树 &#125;&#125;template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; :: LeverOrder( )&#123; BiNode&lt;DataType&gt; *Q[100], *q = nullptr; int front = -1, rear = -1; if (root == nullptr) return; Q[++rear] = root; while (front != rear) &#123; q = Q[++front]; cout &lt;&lt; q-&gt;data; if (q-&gt;lchild != nullptr) Q[++rear] = q-&gt;lchild; if (q-&gt;rchild != nullptr) Q[++rear] = q-&gt;rchild; &#125;&#125; 二叉树的存储结构-&gt;顺序存储结构顺序存储结构的要求是什么？用一组连续的存储单元依次存储数据元素，由存储位置表示元素之间的逻辑关系 二叉树的顺序存储结构是用一维数组存储二叉树的结点，结点的存储位置（下标）应能体现结点之间的逻辑关系——父子关系 缺点：浪费存储空间二叉树的顺序存储结构一般仅存储完全二叉树 1234567void PreOrder(char a[],int i,int n)&#123; if(i&gt;=n)return; cout&lt;&lt;a[i]&lt;&lt;endl; PreOrder(a,2*i,n); PreOrder(a,2*i+1,n);&#125; -&gt;二叉链表二叉链表：二叉树的每个结点对应一个链表结点，链表结点存放结点的数据信息和指示左右孩子的指针 叶子结点的标志？ 左右孩子指针均为空 n 个结点的二叉链表有多少个空指针？ 2n-(n-1) = n+1 个空指针 如何由一种遍历序列生成该二叉树？ 扩展二叉树：将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值如 ‘#’ -&gt;扩展二叉树123456789101112131415template &lt;typename DataType&gt;BiNode&lt;DataType&gt; *BiTree&lt;DataType&gt; :: Creat(BiNode&lt;DataType&gt; *bt)&#123; char ch; cin &gt;&gt; ch; //输入结点的数据信息，假设为字符 if (ch == ‘#’) bt = nullptr; //建立一棵空树 else &#123; bt = new BiNode&lt;DataType&gt;; bt-&gt;data = ch; bt-&gt;lchild = Creat(bt-&gt;lchild); //递归建立左子树 bt-&gt;rchild = Creat(bt-&gt;rchild); //递归建立右子树 &#125; return bt;&#125;扩展二叉树的前序遍历序列：A B # D # # C # # 森林森林：m（m≥0）棵互不相交的树的集合 森林的遍历：按照某种次序(前序（根）、后序（根）)依次遍历构成森林的 m（m≥0）棵树 最优二叉树叶子结点的权值：对叶子结点赋予的一个有意义的数值量 二叉树的带权路径长度：从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和 最优二叉树（哈夫曼树）：给定一组具有确定权值的叶子结点，带权路径长度最小的二叉树 最优二叉树有什么特点?（1）权值越大的叶子结点越靠近根结点（2）只有度为 0 和度为 2 的结点，不存在度为 1 的结点 -&gt;哈夫曼算法1选取权值最小的两棵二叉树进行合并，重新排序，再选权值最小的两棵二叉树进行合并 -&gt;哈夫曼编码编码：给每一个对象标记一个二进制位串来表示一组对象 等长编码：用长度相等的二进制位串表示一组对象 编码的目的是什么? 数字化（编码效率取决于编码长度） 不等长编码：表示一组对象的二进制位串的长度不相等 设计不等长编码时，必须考虑解码的唯一性 前缀编码：在一组编码中，任一编码都不是其它任何编码的前缀 ​ *前缀（无歧义）编码保证了在解码时不会有多种可能 线索二叉树 线索：指向前驱和和后继结点的指针 线索二叉树：加入线索的二叉树 缺点：指针和线索无法区分-&gt;加标记 0孩子,1前驱后继 以一定规则将二叉树中的结点排列成一个线性序列，使每个结点(除第一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继 优点：如果右链中中序后继，左链中中序前趋，则中序遍历的效率高","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"第六章 图","slug":"数据结构/图","date":"2021-12-27T10:11:07.173Z","updated":"2021-12-28T13:59:03.030Z","comments":true,"path":"2021/12/27/数据结构/图/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/","excerpt":"","text":"单链表的逆置，寻找叶子结点，树的遍历，折半查找，哈夫曼树 逻辑关系线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继； 树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子 图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接 连通图（无向图）连通顶点：在无向图中，如果顶点vi和顶点vj(i≠j)之间有路径，则称顶点vi和vj是连通的 连通图：在无向图中，如果任意两个顶点都是连通的，则称该无向图是连通图 连通分量：非连通图的极大连通子图：含有极大顶点数，依附于这些顶点的所有边 强连通图、强连通分量（有向图）强连通顶点：在有向图中，如果从顶点vi到顶点vj和从顶点vj到顶点vi均有路径，则称顶点vi和vj是强连通的 强连通图：在有向图中，如果任意两个顶点都是强连通的，则称该有向图是强连通图 强连通分量：非强连通图的极大连通子图 图的遍历图的遍历：从图中某一顶点出发访问图中所有顶，并且每个结点仅被访问一次 在图中，如何选取遍历的起始顶点？解决方案：将图中的顶点按任意顺序排列起来， 从编号最小的顶点开始 从某顶点出发能访问其他所有顶点吗？解决方案：多次调用图遍历算法 如何避免遍历不会因回路而陷入死循环？解决方案：附设访问标志数组visited[n] 采用什么次序依次访问图中所有顶点？ -&gt; 深度优先遍历和广度优先遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061深度优先遍历DFTraverse（类似树的前序遍历）广度优先遍历BFTraverse（类似树的层序遍历） template &lt;typename DataType&gt;void MGraph&lt;DataType&gt; :: DFTraverse(int v) &#123; cout &lt;&lt; vertex[v]; visited[v] = 1; for (int j = 0; j &lt; vertexNum; j++) if (edge[v][j] == 1 &amp;&amp; visited[j] == 0) DFTraverse( j );&#125;template &lt;typename DataType&gt;void MGraph&lt;DataType&gt; :: BFTraverse(int v) &#123; int w, j, Q[MaxSize]; //采用顺序队列 int front = -1, rear = -1; //初始化队列 cout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v; //被访问顶点入队 while (front != rear) //当队列非空时 &#123; w = Q[++front]; //将队头元素出队并送到v中 for (j = 0; j &lt; vertexNum; j++) if (edge[w][j] == 1 &amp;&amp; visited[j] == 0 ) &#123; cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j; &#125; &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: DFTraverse(int v)&#123; int j; EdgeNode *p = nullptr; cout &lt;&lt; adjlist[v].vertex; visited[v] = 1; p = adjlist[v].firstEdge; while (p != nullptr) &#123; j = p-&gt;adjvex; if (visited[j] == 0) DFTraverse(j); p = p-&gt;next; &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: BFTraverse(int v) &#123; int w, j, Q[MaxSize]; int front = -1, rear = -1; EdgeNode *p = nullptr; cout &lt;&lt; adjlist[v].vertex; visited[v] = 1; Q[++rear] = v; while (front != rear) &#123; w = Q[++front]; p = adjlist[w].firstEdge; while (p != nullptr) &#123; j = p-&gt;adjvex; if (visited[j] == 0) &#123; cout &lt;&lt; adjlist[j].vertex; visited[j] = 1; Q[++rear] = j; &#125; p = p-&gt;next; &#125;&#125; 存储结构-&gt; 邻接矩阵和邻接表 1234567891011struct EdgeNode&#123; int adjvex; EdgeNode *next;&#125; ;template &lt;typename DataType&gt; struct VertexNode&#123; DataType vertex; EdgeNode *firstEdge;&#125;; 边表中的结点表示什么？对应图中的一条边 设图有n个顶点e条边，邻接表的空间复杂度是多少？O(n+e) 如何求顶点 v 的度？顶点 v 的边表中结点的个数 12345p = adjlist[v].firstEdge; count = 0;while (p != nullptr)&#123; count++; p = p-&gt;next;&#125; 如何求顶点 v 的所有邻接点?顶点 i 的边表中的所有结点 123456p = adjlist[v].firstEdge; while (p != nullptr)&#123; j = p-&gt;adjvex; //j是v的邻接点 p = p-&gt;next;&#125; 最小生成树（无向图）-&gt; Prim算法O(n2)生成树：连通图的生成树是包含全部顶点的一个极小连通子图（含有n-1条边） 生成树的代价：在无向连通网中，生成树上各边的权值之和 最小生成树(Minimum Spanning Tree) ：在无向连通网中，代价最小的生成树 贪心算法的应用：Prim算法，Kruskal算法和Boruvka算法 Prim算法：先构造满足条件的候选最短边集，再查找最短边 Kruskal算法：先查找最短边，再判断是否满足条件 123456Prim算法 O(n2)*每步添加一条边及其相连的顶点(min)到一棵树，从而逐步生成最小生成树(可能不唯一，但代价唯一)通过第一个顶点，将第一个顶点和其他顶点的权值进行比较，找到最小边邻接的顶点该邻接顶点和剩余顶点比较，比第一个顶点和其权值小就替换进数组，找到更新后的最小边的邻接顶点……（创建一个数组存放当前顶点和邻接顶点的边，当邻接顶点和当前顶点的边权值更小就更新。每次找出更新的最小边，并将选择出的顶点从数组中标除去） -&gt; Kruskal算法O(elog2e)12345678910？Kruskal算法 O(elog2e)*将所有的点放入，每次选最小的边，但不能形成回路图采用什么存储结构呢？ 边集数组表示法Kruskal算法在图中存在相同权值的边时也有效如何存储连通分量呢？ 并查集（并查集：集合中的元素组织成树的形式：（1）查找两个元素是否属于同一集合：所在树的根结点是否相同（2）合并两个集合——将一个集合的根结点作为另一个集合根结点的孩子）*如何判断两个顶点是否位于同一个连通分量呢？*如何合并两个连通分量呢？ 最短路径（有向图）-&gt; Dijkstra算法O(n2)最短路径：非带权图——边数最少的路径 最短路径：带权图——边上的权值之和最少的路径 路径上第一个顶点称为源点；最后一个顶点称为终点 对于非带权图，如何求最短路径？ 广度优先遍历 对于带权图，如何求最短路径？ 123Dijkstra算法 O(n2)针对一个源点，求出中转（mini)；将中转和剩下点连接，比剩下点与上一个点的路径短就替换，再在整合好的表中找到最短的当前最短路径中最小路为最终最短路（路径长度递增） (dist,path) v1 v2 v3 v4 {v0} (10,’v0v1’) (**,’ ‘) (30,’v0v3’) (100,’v0v4’) {v0v1} (60，‘v0v1v2’) (30,’v0v3’) (100,’v0v4’) {v0v1v3} (50,’v0v3v2’) (60,’v0v3v4’) {v0v1v3v2} (60,’v0v3v2v4’) {v0v1v3v2v4} 疑惑性很大，如何当点&gt;2时，进行判断不同可能性（类似Prim但必须包含源点得出的路径？） -&gt; Floyd算法O(n3)123456Floyd算法 O(n3)*可有权值为负，但不能有负的回路(*)-&gt; 使用邻接矩阵初始化path0（两点相连的所有可能性9种，以a/b/c为源点），在两点间插入a(保持源点不变，以a为源点的一行可忽视,6种；如果值比原来小就替换)形成path1,在path1中插入b……同理……dist保存路径权值，path保存路径中的点-&gt;该算法将所有的可能性都计算出来，只有最后一步有效 有向无环图-&gt; AOV网和拓扑排序 O(n+e)什么是工程？工程有什么共性？几乎所有的工程都可以分为若干个称作活动的子工程某些活动之间通常存在一定的约束条件 AOV网（顶点表示活动的网）：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系 AOV网（activity on vertex network） AOV网中出现回路意味着什么？活动之间的优先关系是矛盾的 拓扑序列:v2必须满足v0和v1才能成立（栗子：排课系统），可能不唯一 拓扑排序：对一个有向图构造拓扑序列的过程 12345678图采用什么存储结构呢？ 邻接表在邻接表中，如何求顶点的入度？ 顶点表中增加入度域如何查找没有前驱的顶点？ 设置栈或队列成功标志：排完后，所有点都排序（NULL），不剩余点 1.重复下述操作，直到输出全部顶点，或AOV网中不存在没有前驱的顶点 1.1从AOV网中选择一个没有前驱的顶点并且输出； 1.2从AOV网中删去该顶点，并且删去所有以该顶点为尾的弧； -&gt;AOE网和关键路径什么是工程？工程有什么共性？几乎所有的工程都可以分为若干个称作活动的子工程活动之间存在某些制约关系每个活动通常需要一个持续的时间 源点：整个工程的开始点，其入度为0终点：整个工程的结束点，其出度为0 AOE网（边表示活动的网）：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间 AOE网（activity on edge network） AOE网的性质：（1）只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生（2）只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始 AOE网能够解决什么问题？（1） 完成整个工程至少需要多少时间?（2）为缩短完成工程所需的时间， 应当加快哪些活动? 关键路径：AOE网中从源点到终点的最长路径关键活动：关键路径上的活动 不按期完成关键活动就会影响整个工程的进度；换言之，要缩短整个工期，必须加快关键活动的进度 1234567891011121314151617如何求关键路径呢？ 求关键活动如何求关键活动呢？关键活动为什么是关键的？关键活动的开始时间不能推迟-&gt;关键活动的最早开始时间和最晚开始时间相等 1. 计算各个活动的最早开始时间和最晚开始时间 2. 计算各个活动的时间余量，时间余量为 0 即为关键活动设带权有向图 G=(V，E)含有 n 个顶点 e 条边，设置 4 个一维数组：（1）事件的最早发生时间 ve[n] -&gt; 从v0=0开始到该顶点的相加ai和取最大（正序计算）（2）事件的最迟发生时间 vl[n] -&gt; 从v3=10开始到该点减去ai被减差取最小（倒序计算）（3）活动的最早开始时间 ae[e] -&gt; 等于ve[以ai为出度的事件] （4）活动的最晚开始时间 al[e] -&gt; vl[以ai为入度的事件]-ai-&gt; al[i]-ae[i]=0 取为0的相连作为关键路径书P205 表格 一个关键活动的延期，会影响延误工期；一个关键活动的提前，不一定提前工期","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"新核心知识点","slug":"英语/新核心知识点","date":"2021-12-27T06:29:35.146Z","updated":"2021-12-27T07:21:28.288Z","comments":true,"path":"2021/12/27/英语/新核心知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/27/%E8%8B%B1%E8%AF%AD/%E6%96%B0%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.When she realized most of China’s top causes of death could be tied to smoking, she began pushing officials to tackle the problem. tackle/solve/resolve/address/handle/tackle/deal with 2.Its population rises and falls unpredictably, destroying clumps of pinewood as it peaks which then regenerate/grow again as the bug recedes/die away. 树皮甲虫的繁殖不可预测，或暴增，或减弱，当树皮甲虫繁殖高峰时会杀害大量松树，只有甲虫消退后松树才能再生。 recede: to move back from a previous point 自原处后退 3.… says that the current outbreak is “unprecedented in history”: a natural background-noise disturbance has become a major outbreak. adj. 前所未有的，史无前例的；（大小、数量、程度等）前所未知的，空前的 n. 干扰，扰乱；骚乱，动乱；失调，紊乱 4.Other parts of North America have also been affected, but the damage in British Columbia is particularly severe and particularly troubling in a province whose economy is dominated by timber. dominated /ˈdɒmɪneɪtɪd/adj. 占主导地位的；强势的；受控的v. 控制，支配；处于支配地位（dominate 的过去式和过去分词 ） n.林木 北美的其他地方也受到了影响，但是英属哥伦比亚的损失是相当严重的，尤其对一个依赖木材产业的省伤害更甚。 5.It could be caused by the higher temperatures that now prevail in northern areas, … V-I If a proposal, principle, or opinion prevails, it gains influence or is accepted, often after a struggle or argument. 占上风 V-I If a situation, attitude, or custom prevails in a particular place at a particular time, it is normal or most common in that place at that time. 盛行; 普遍存在 V-I If one side in a battle, contest, or dispute prevails, it wins. 获胜 6.Its aim was to “achieve stabilization of greenhouse-gas concentrations in the atmosphere at a level that would prevent dangerous anthropogenic interference with the climate system”. 《联合国气候变化框架公约》的目标是“为全面控制二氧化碳等温室气体排放，阻止人类对气候系统的危险干预。” n. 稳定；稳定化 adj. 人为的；[人类] 人类起源的 interference with 干涉；妨碍，打扰 7.According to the Intergovernmental Panel on Climate Change(政府间气候变化专门委员会), the body set up to establish a scientific consensus on what is happening, heat waves, droughts, floods and serious hurricanes have increased in frequency over the past few decades. consensus n. a general agreement; the opinion of most of the people in a group （意见等的）一致,一致同意 build a consensus 达成一致 reach a consensus 取得一致 unspoken consensus 默契 Extreme weather/natural disaster heat wave, drought, flood, hurricane 热浪，干旱，洪水，飓风 earthquake, mudslide, typhoon, cyclone, blizzard/snow storm暴风雪, storm, hail冰雹，landslide, sandstorm, tsunami, volcanic eruption 地震,泥石流,台风,飓风,暴风雪/暴风雪暴风雪,风暴,雹冰雹,山体滑坡,沙尘暴,海啸,火山喷发 snowslide,avalanche,acid rain 雪崩,雪崩,酸雨","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[]},{"title":"细小知识点","slug":"Python/细小知识点","date":"2021-12-22T03:03:46.564Z","updated":"2021-12-22T13:51:54.724Z","comments":true,"path":"2021/12/22/Python/细小知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/22/Python/%E7%BB%86%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.复数 我们把形如z=a+bj（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，j称为虚数单位。 一个复数时一对有序浮点数 (x,y)，其中 x 是实数部分，y 是虚数部分。 Python 语言中有关复数的概念： 1、虚数不能单独存在，它们总是和一个值为 0.0 的实数部分一起构成一个复数 2、复数由实数部分和虚数部分构成 3、表示复数的语法：real+imagej 4、实数部分和虚数部分都是浮点数 5、虚数部分必须有后缀j或J 2.and,or(有0,逻辑数据时进行c/c++中的&amp;&amp;与运算(1,0)，or取前and取后) 10 and 20 -&gt; 20 10 or 20 -&gt; 10 10 &amp; 20 -&gt; 0 （01010&amp;10100=00000）每位进行与运算 10 | 20 -&gt;30 逻辑数据，是一种操作数类型。是用来表示二值逻辑中的 “是”与 “否” 、或称 “真”与 “假” 两个状态的数据。 3.Python浮点数占4个字节 4.pass 表示空语句","categories":[{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"}],"tags":[]},{"title":"线性结构：字符串——KMP算法","slug":"数据结构/KMP","date":"2021-12-11T07:51:52.920Z","updated":"2021-12-17T15:01:47.531Z","comments":true,"path":"2021/12/11/数据结构/KMP/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP/","excerpt":"","text":"i 0 1 2 3 4 5 6 char[i] a b a b a b c next -1 0 0 1 2 3 4 nextval -1 0 -1 0 -1 0 4 一、过程： 求next值： 1.两个固定值：char[0]_next=-1; char[1]_next=0（一个，没有匹配的，长度为0） 2.开始求：char[2]匹配出错，前面a!=b（两组字符不同），故next=0(重头开始） char[3]匹配出错，前面有aba, a(char[3]前面的a)和a（匹配必从第一个开始）相同，字符a长度为1，故next=1 char[4]匹配出错，前面有abab,ab和ab相同，长度为2，故next=2 char[5]匹配出错，前面有ababa，aba和aba(123和345)相同，长度为3，故next=3 char[6]匹配出错，前面有ababab,abab和abab(1234和3456)相同,长度为4，故next=4 求nextval值： 1.一个固定值：char[0]_nextval=-1 2.开始求：char[1]_next=0(char[0]=a), a!=b,所以nextval=char[1]_next char[2]_next=0(char[0]=a),a==a,所以nextval=char[0]_nextval 同理可得…… 二、总结： 求next的值： 看当前字符的前面的一组字符是否有相似的一组字符（开头开始）与之相同，取其最大长度作为next的值 求nextval值（修正值）： 当前字符的next值(索引值)所指向的字符是否和当前字符相同：相同则修正值为当前字符的next值所指向的字符的修正值；不同则去当前字符的next值 三、例子再来一个： 0 1 2 3 4 5 6 7 8 9 a b c a b c a b a a next -1 0 0 0 1 2 3 4 5 1 nextval -1 0 0 -1 0 0 -1 0 5 1 求next值：next0=-1,next1=0 a!=b,next2=0; abc不可能(ab!=bc),next3=0; 0==3,next4=1; 01==34,next5=2;012==345,next6=3; abca==abca(1234==3456),next7=4; 01234==34567,next8=5 1==8,next9=1 求nextval值：nextval0=-1 b!=char[next1]=a, nextval=next1=0 c!=char[next2]=a, nextval=next2=0 a==char[next3]=a,nextval=nextval0=-1 同理可得…… 这个思路也可以： (7条消息) KMP算法中计算next值和nextval的值_threecat.up的博客-CSDN博客_kmp算法next修正值计算方法https://blog.csdn.net/qq_43919400/article/details/103736457","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"数据结构笔记","slug":"数据结构/数据结构","date":"2021-12-09T05:52:57.914Z","updated":"2021-12-25T07:19:59.859Z","comments":true,"path":"2021/12/09/数据结构/数据结构/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"第6章 图图的定义图的基本术语第七章 查找技术基本概念关键码：可以标识一个**记录(数据元素、结点、顶点)**的某个数据项 键值：关键码的值 主关键码：可以唯一标识一个记录的关键码 次关键码：不能唯一标识一个记录的关键码 什么是查找？查找：在相同类型的记录构成的集合中找出满足给定条件的记录 静态查找 ：不涉及插入和删除操作的查找 静态查找只注重查找效率，适用于： （1）查找集合一经生成，便只对其进行查找，而不进行插入和删除操作 （2）经过一段时间的查找之后，集中地进行插入和删除等修改操作 动态查找 ：涉及插入和删除操作的查找 动态查找要求插入、删除、查找均有较好的效率，适用于：查找与插入和删除操作在同一个阶段进行 例如：当查找成功时，要删除查找到的记录 当查找不成功时，要插入被查找的记录 查找结构 ：面向查找操作的数据结构 ，即查找基于的数据结构 查找基于的数据模型是什么？集合 集合 ：线性表：适用于静态查找，顺序查找、折半查找等技术 树 表：适用于动态查找，二叉排序树的查找技术 散列表：静态查找和动态查找均适用，采用散列技术 查找算法的性能如何评价查找算法的效率呢？和关键码的比较次数 关键码的比较次数与哪些因素有关呢？ 平均查找长度ASL：查找算法进行的关键码比较次数的数学期望值 查找算法线性表1234567891011121314151617/*顺序查找（线性查找）O(n)改进：设置“哨兵”，就是待查值，放在查找方向的尽头处，免去了每一次比较后都要判断查找位置是否越界不要求元素的有序性，插入、删除的性能是O(1)查找性能是O(n)*/ int LineSearch :: SeqSearch2(int k) &#123; int i = n; data[0] = k; while (data[i] != k) i--; return i;&#125; 12345678910111213141516171819202122232425262728293031323334353637/*折半查找（对半查找、二分查找）在有序表（假设为递增）中，取中间记录作为比较对象，若给定值与中间记录相等，则查找成功；若给定值小于中间记录，则在有序表的左半区继续查找；若给定值大于中间记录，则在有序表的右半区继续查找。不断重复上述过程，直到查找成功，或查找区域无记录，查找失败查找性能是O(log2n)为保证元素的有序性，插入、删除要移动元素，性能是O(n)*///非递归算法：int LineSearch :: BinSearch1(int k) /*查找集合存储在r[1]~r[n]*/&#123; int mid, low = 1, high = n; /*初始查找区间是[1, n]*/ while (low &lt;= high) /*当区间存在时*/ &#123; mid = (low + high) / 2; if (k &lt; data[mid]) high = mid - 1; else if (k &gt; data[mid]) low = mid + 1; else return mid; /*查找成功，返回元素序号*/ &#125; return 0; /*查找失败，返回0*/&#125;//递归算法：int LineSearch :: BinSearch2(int low, int high, int k) &#123; int mid; if (low &gt; high) return 0; /*递归的边界条件*/ else &#123; mid = (low + high) / 2; if (k &lt; data[mid]) return BinSearch2(low, mid-1, k); else if (k &gt; data[mid]) return BinSearch2(mid+1, high, k); else return mid; /*查找成功，返回序号*/ &#125;&#125; 判定树（折半查找判定树）：描述折半查找判定过程的二叉树 查找成功的平均比较次数 = (1×1+2×2+3×4+4×4)/11 = 3查找不成功的平均比较次数 = (3×4+4×8)/12 = 11/3 树表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*二叉排序树（二叉查找树）：或者是一棵空的二叉树，或者是具有下列性质的二叉树：（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值（3）它的左右子树也都是二叉排序树中序序列是元素升序排序存储：二叉链表*/class BiSortTree &#123;public: BiSortTree(int a[ ], int n); ~ BiSortTree( ) &#123;Release(root);&#125; BiNode&lt;int&gt; *InsertBST(int x) &#123;return InsertBST(root, x);&#125; void DeleteBST(BiNode&lt;int&gt; *p, BiNode&lt;int&gt; *f ); BiNode&lt;int&gt; *SearchBST(int k) &#123;return SearchBST(root, k);&#125;private: BiNode&lt;int&gt; *InsertBST(BiNode&lt;int&gt; *bt , int x); BiNode&lt;int&gt; *SearchBST(BiNode&lt;int&gt; *bt, int k); void Release(BiNode&lt;DataType&gt; *bt); BiNode&lt;int&gt; *root; &#125;;BiSortTree::BiSortTree(int a[ ], int n)//构造函数&#123; root = nullptr; for (int i = 0; i &lt; n; i++) root = InsertBST(root, a[i]);&#125;BiNode&lt;int&gt; * BiSortTree :: SearchBST(BiNode&lt;int&gt; *bt, int k)//查找函数&#123; if (bt == nullptr) return nullptr; if (bt-&gt;data == k) return bt; else if (bt-&gt;data &gt; k) return SearchBST(bt-&gt;lchild, k); else return SearchBST(bt-&gt;rchild, k);&#125;BiNode&lt;int&gt; * BiSortTree::InsertBST(BiNode&lt;int&gt; *bt, int x)//插入函数&#123; if (bt == nullptr) &#123; BiNode&lt;int&gt; *s = new BiNode&lt;int&gt;; s-&gt;data = x; s-&gt;lchild = s-&gt;rchild = nullptr; bt = s; return bt; &#125; else if (bt-&gt;data &gt; x) bt-&gt;lchild = InsertBST(bt-&gt;lchild, x); else bt-&gt;rchild = InsertBST(bt-&gt;rchild, x);&#125;二叉排序树的性能分析最坏情况：退化为线性查找最好情况：相当于折半查找平均情况：O(n) ~ O(logn) 123456789101112/*平衡二叉树（二叉排序树优化-&gt;深度尽可能小的二叉排序树）二叉排序树的深度取决于给定查找集合的排列，即结点的插入顺序平衡因子：该结点的左子树的深度减去右子树的深度平衡二叉树：或者是一棵空的二叉排序树，或者是具有下列性质的二叉排序树：（1）根结点的左子树和右子树的深度最多相差 1;（2）根结点的左子树和右子树也都是平衡二叉树在平衡二叉树中，结点的平衡因子是1、0 或 -1平衡调整扁担原理：将根结点看成是扁担中肩膀的位置*/ 123456/*B树：一棵m阶的B树或者为空树，或者为满足下列特性的m叉树：（1）每个结点至多有 m 棵子树；（2）根结点至少有两棵子树；（3）除根结点和叶子结点外，所有结点至少有[m/2]棵子树；*/ 散列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*散列的基本思想：在记录的关键码和存储地址之间建立一个确定的对应关系，通过计算得到待查记录的地址。散列表：采用散列技术存储查找集合的连续存储空间。散列函数：将关键码映射为散列表中适当存储位置的函数。散列地址：由散列函数所得的存储地址。冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj)。同义词：ki 和 kj 相对于H 称做同义词。 散列是一种完整的存储结构吗？散列只是通过记录的关键码定位该记录，没有完整地表达记录之间的逻辑关系，所以，散列主要是面向查找的存储结构散列技术能进行范围查找吗？适合于哪种类型的查找？散列技术最适合回答的问题是：如果有的话，哪个记录的关键码等于待查值除留余数法 H(key)=key mod p 处理冲突的方法——开放定址法（数组）对于给定的关键码key执行下述操作：（1）计算散列地址：j = H(key)（2）如果地址 j 的存储单元没有存储记录，则存储key对应的记录；（3）如果在地址 j 发生冲突，则寻找一个空的散列地址，存储key对应的记录；闭散列表：用开放定址法处理冲突得到的散列表线性探测法：从冲突位置的下一个位置起，依次寻找空的散列地址。堆积：非同义词对同一个散列地址争夺的现象二次探测法：以冲突位置为中心，跳跃式寻找空的散列地址。Hi=(H(key)＋di) % m （di = 12,-12,22,-22,… , q2,-q2(q≤m/2)）处理冲突的方法——拉链法（链表）对于给定的关键码key执行下述操作：（1）计算散列地址：j = H(key)（2）将key对应的记录插入到同义词子表 j 中；（头插）同义词子表：所有散列地址相同的记录构成的单链表。开散列表：用拉链法处理冲突得到的散列表。开散列表中存储同义词子表的头指针，开散列表不会出现堆积现象散列查找的性能分析散列技术的查找性能取决于什么？产生冲突后，仍然是给定值与关键码进行比较影响冲突产生的因素有什么？（1）散列函数是否均匀（2）处理冲突的方法 （3）散列表的装填因子α= 表中填入的记录数/散列表的长度*/ 堆积：非同义词对同一个散列地址争夺的现象冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj) 第8章 排序技术基本概念1.排序：给定一组记录（数据元素，结点，顶点）的集合{r1,r2,…,rn}，其相应的关键码分别为{k1,k2,…,kn},将这些记录排列为{s1,s2,…,sn}的序列，使得相应关键码满足升序或降序。 （排序是对线性结构(数据模型)的一种操作） 2.排序码(关键码)：排序的依据 3.趟：在排序过程中，将待排序的记录序列扫描一遍称为一趟 4.排序算法的稳定性：相同关键码的相对次序经过排序保持不变 （只是算法的一种属性，且有具体算法决定） 排序算法的性能1.时间性能：排序算法在各种情况（最好、最坏、平均）下的时间复杂度 （基于比较的内排序在排序过程中的基本操作：（1）比较：关键码之间的比较；（2）移动：记录从一个位置移动到另一个位置） 2.空间性能：排序过程中占用的辅助存储空间（额外申请的辅助空间个数，除代码规模和输入空间） 基于比较的内排序1234567891011121314151617//直接插入排序void Sort :: InsertSort( ) &#123; int i, j, temp; for (i = 1; i &lt; length; i++) &#123; temp = data[i]; j = i - 1; while (j &gt;= 0 &amp;&amp; temp &lt; data[j]) &#123; data[j + 1] = data[j]; j--; &#125; data[j + 1] = temp; &#125;&#125; 12345678910111213141516//希尔排序void Sort :: ShellSort( ) &#123; int d, i, j, temp; for (d = length/2; d &gt;= 1; d = d/2) //增量为d进行直接插入排序 &#123; for (i = d; i &lt; length; i++) //进行一趟希尔排序 &#123; temp = data[i]; //暂存待插入记录 for (j = i - d; j &gt;= 0 &amp;&amp; temp &lt; data[j]; j = j - d) data[j + d] = data[j]; //记录后移d个位置 data[j + d] = temp; &#125; &#125;&#125; 12345678910111213141516//起泡排序void Sort :: BubbleSort( ) &#123; int j, exchange, bound, temp; exchange = length - 1; //第一趟起泡排序的区间是[0~length-1] while (exchange != 0) &#123; bound = exchange; exchange = 0； for (j = 0; j &lt; bound; j++) //一趟起泡排序的区间是[0~bound] if (data[j] &gt; data[j+1]) &#123; temp = data[j]; data[j] = data[j+1]; data[j+1] = temp; exchange = j； //记载每一次记录交换的位置 &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"SET4-翻译","slug":"英语/CET4--翻译","date":"2021-12-06T08:36:53.397Z","updated":"2021-12-17T15:19:39.748Z","comments":true,"path":"2021/12/06/英语/CET4--翻译/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4--%E7%BF%BB%E8%AF%91/","excerpt":"","text":"Hot pot has a history of over 2000 years in China.Initially,it was only popular in the coldest places,and subsequentlg became widely accepted in many other areas,where distinct regional variations developed.When eating a hot pot,family and friends sit around the table with a steaming hot pot at the center of it.People can put their preferred meal,seafood,vegetables and ingredients into the pot to cook their own food,and chat to their hearts’ content over a good meal.","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"SET4-作文","slug":"英语/CET4--作文","date":"2021-12-06T02:20:39.278Z","updated":"2021-12-17T15:19:33.154Z","comments":true,"path":"2021/12/06/英语/CET4--作文/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4--%E4%BD%9C%E6%96%87/","excerpt":"","text":"“use”类栗子：the use of translation apps is becoming increasingly popular 开篇可概述翻译应用程序在生活中的应用越发广泛的趋势 主体部分应详述其应用情况：多种应用场景 + 积极影响/受欢迎的原因 结尾部分可总结其带来的益处，适当提及不足之处和未来的应用或发展趋势 The use of translation apps is becoming increasely popular.They play a critical role in removing the language barrier in this globalized era(全球化的时代). These technology tools are especially helpful for both leisure(闲暇，业余时间；休闲活动) and business travelers. With the ever-increasing input of linguistic data,these apps will be smarter and thus applied in broader fields.As a result,more people will enjoy the fruits of this technological advance. 123456789101112131415词汇：machine translation 机器翻译convert speech to text 将语音转换为文字voice/speech recognition 语音识别voice translator apps 语音翻译应用程序photo/camera translator apps 拍照翻译应用程序an offline multilingual dictionary 可离线使用的多语种词典translate text into multiplelanguages 将文本翻译为多种语言offer instant speech-to-speech translation 提供即使语音翻译foreign/overseas/international travel 出国游have a short conversation with locals 与当地人进行简短的交流bridge the information and communication gap 架起信息与沟通的桥梁keep in contact with clients/customers worldwide 与世界各地的客户保持联系conduct trade negotiations with foreign companies 与外国公司进行贸易洽谈 “changes of ways”类栗子：Changes in the way of education 开篇可铺陈背景，引入对“教育方式发生改变”的探讨，或开门见山，直接概述教育领域发生的变化 主体部分应详细阐述具体变化（今昔对比/当下变化）+ 这些变化的成因/影响 结尾部分可对这些变化简要作评，或展望未来的发展趋势并呼吁人们做好准备 The past decades have witnessed a surge of technological innovations.Irresistibly useful and convenient,tools resulting from these innovations have prompted(促使，导致) radical changes in our lifestyle.Among them,changes in the way of education are some of the most noticeable ones. Nowadays,the computer and projector(投影仪) have become indispensable(不可或缺的) in every classroom.Compared with old-fashioned chalk and talk(板书口授),multimedia-based teaching enables teachers to demonstrate what they found hard or even impossible in the past,such as abstract geometric(几何的) concepts and bizarre lanscapes. The trend of distance learning is another significant change.With a wide array of(大量各式各样的) online courses to choose from,teaching and learning are no longer confined(局限) to the classroom or school day.Students now can attend lectures by prominent(著名的，卓越的) professors in far-away locations in their own bedroom anytime they want.And all this happens just within a few clicks. Although these changes are by and large(大体上) constructive,they do have a couple of unintended(无意地的，意想不到的) negative consequences.For instance,distance learning is likely to lead to a detached(冷淡的，疏远的) relationship between the student and the teacher. 其他作文： the changes of communication:At one time,people communicated primarily face to face and via letters.Nowadays,however,the advancement of network technology offers us more options such as text messaging,voice calling and video chatting.These changes bring a great deal of benefits.Perhaps the most obvious one is convenience.Irrespective of (不考虑，不管)the geographical locations and time zones,we can now keep in touch with each other through the Internet at a previously unimaginable speed. This increased efficiency,in turn,leads to reduced costs.For instance,the advent of video conferencing(视频会议) allows people to meet each other without having to worry about travel expenses. More excitingly,changes in the way of communication make possible remote “importance of quality”类栗子：Self-confidence:an importance factor for success 开篇可概述没有自信的危害来强调自信的重要性 主体部分：自信的定义+例子论证自信是成功的必要因素 结尾部分总结其带来的益处 If we don’t feel self-confident about our ability,we will not be able to take up a task and get it done.If we dont’t have confidence in our competence,we won’t be courageous enough to face up to a challenge.Only when we think we are capable of doing something,will we be able to succeed in doing that. Self-confidence is different from complacency(自满).It is solidly(坚固地，坚硬地) based on our knowledge,judgement,abilities and skills.To develop it takes years of learning and to consolidate(巩固) it takes years of practicing.Self-confidence means more than mental preparedness(准备就绪).It serves as an indication(象征，暗示，迹象) of professional readiness(敏捷；准备就绪).It is also an expression of intellectual maturity. With self-confidence,we are able to firmly take each step in our journey of life(坚定地迈出人生旅途中的每一步) and it is self-confidencet that has been paving the way to the ultimate(最终的，最后的) goal of our professional career(为我们职业生涯的终极目标铺路). 新闻写作：记叙类报道栗子：a news report to your campus newspaper (on a volunteer activity organized by Student Union to assist elderly people in the neighbor hood) 开篇应为导语，介绍活动的时间、地点及参与者（基本事实+抓人眼球） 主体部分应介绍活动目的及具体内容/流程 结语部分应总结活动的意义、影响或收获，也可简要提及活动举办的大背景 ​ 记叙方式：时间循序（暖场-&gt;活动主体-&gt;结束）​ 空间顺序（不同区域举办的活动依次参观）​ 组别顺序（一人负责一件事，另一组人负责另一件事）​ 记叙类新闻写作五个基本要素5W（when,where,what,why,who）+ 1H:how The students,organized by the Student Union,visited a senior center close to our school on Wednesday,June 12th,for the purpose of providing help for the elderly there. Our volunteer were warmly welcomed when they arrived there at about 1 p.m.They presented the elderly with fresh fruits before dividing themselves into two groups,one responsible for cleaning and the other for chatting.It took nearly an hour for half a dozen volunteers to sweep and mop the floor and then wash all the windows.The rest were,meanwhile,listening attentively to the elderly who looked back on their good old days(过去美好时光) with a certain amount of nostalgia(n.怀旧，念旧).The activity ended with a certain lecture on how to send voice messages and make video calls on WeChat. “I’m impressed with their vigor(n.活力，精力) and optimism(n.乐观),”says one of the volunteers.”And I’m glad that the entire afternoon we spent together means something to them.They expressed their gratitude for our company,which may be,in my opinion,what they need most.” “whether正反观点观点”类栗子：Whether technology will make people lazy With the continus progress of science and technology,great changes have taken place in the way people live.This progress has brought great convenience to people.Nonetheless,it has also made many people lazy.First,the widespread use of Internet technology,especially smart phones ,allows people to know what is happening outside without going out.People just need to pick up a mobile phone,connect to the Internet,and open the corresponding software,then the major events of the world will be caught in their eyes.They no longer have to open books and newspapers or go out to get information.Second,the appearance of takeaways has also made people lazier.People can get whatever they want to eat without cooking for themselves or even getting up to go to a restaurant…To sum up ,the ever-changing technology brings convenience to people,but it also make people laxy.Consequently,while improving the quality of life,people should learn to use science and technology correctly instead of relying on it blindly. 栗子：Whether violent video games online will cause students violent behaviors With the progress of the times, the use of smart phones, computers and other electronic products is becoming more and more common among students. And many students like violent video games online. This raises a question, whether violent online games will lead to students’ violent tendency? From my point of view, the answer is no.First of all, through online games, students can relieve the pressure in real life and find like-minded people to communicate with, which will reduce students’ irritable tendency in real life. In this way, these video games will not increase students’ violent tendency. On the contrary, to a certain extent they will reduce students’irritable behaviors. Moreover, online video games are virtual and the violent elements in the games are unrealistic, and these violent scenes can hardly be implemented in real life. So the violence in online games has little impact on real life.To sum up, from my point of view, violent online games will not lead to students’ violent tendency. The development of science and technology is bound to change people’s way of life, which will bring about a lot of influence on people’s life. It is only necessary for us to learn to use it properly. 栗子：Are People Becoming Addicted to Technology? Numerous studies claim that addiction to technology is real and it has the same effect on the brain as drug addiction. First, no one can deny the fact that technology is of great importance to our daily life. However, as a matter of fact, its adverse effect should not be ignored by the public.Confronted with such phenomenon, we should take a series of effective measures to cope with the situation. For one thing, it is obvious that the universitiesand mass media should increase publicity and educationto encourage people to apply technology more appropriately. For another, we should bear in mind that we are supposed to take a reasonable attitude toward modern technology, andmake its advantages over-weigh disadvantages.Personally, I believe that only by doing so can we better ourselves in every aspect of our life. Consequently, I’m confident that a bright future is awaiting us because technology makes our life rich and colorful. 高级替换：1234end/finish with sth;end/finish by doing sth(do sth at last) 以某事收尾mean something/a lot to sb;matter to sb(be important to sb) 对某人来说很重要show/express one&#x27;s gratitude/appreciation for (doing) sth(thanks for (doing) sth) 对某事表示感谢 单词12345678副词应用：solidly(坚固地，坚硬地)/firmlymore than + n./no longer/by and largeincreaselyespeciallyAs a result/For instanceIrresistibly 12345同义转换：feel self-confident about our ability/have confidence in our competencetake up a task/face up to a challengeare capable of doing/be able to take/be courageous enough to facemean/ an indication(象征，暗示，迹象) of/an expression of","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"SET4-词汇","slug":"英语/CET4--词汇","date":"2021-12-06T01:41:11.803Z","updated":"2021-12-17T13:18:51.349Z","comments":true,"path":"2021/12/06/英语/CET4--词汇/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4--%E8%AF%8D%E6%B1%87/","excerpt":"","text":"2021/12/13 生词 翻译 airline,carrier,aviation,aircraft,cabin seat n.航空公司，航线；客运航空公司；航空；飞机；机舱座位 definitely，alternatively，incredibly,possibly adv.肯定，当然，确实；确切地，明确地，清楚地 adv.或者，要么 adv.极端的，及其；难以置信地 adv.可能，或许；尽可能，尽量 budget adj.廉价的 v.安排开支，编制预算 across the globe 全球 integrate various shades/tones of blue 融合(v.合并,成为一体;加入,融入群体)各种色调(n.)的蓝 aircraft interior n.内部，室内设计 reinforce v.加固，强化 induce/endure v.引起，诱导/忍耐，忍受 bold adj.大胆的 the principal aim adj.最重要的，主要的 n.大学校长，学院院长；本金，资本；主角 domestic，earthy adj.家庭的；朴实的 become the color of choice 首选的，广受欢迎的 to the point of complete inaction 达到完全不作为的程度 imitate v.模仿，效仿 rebell v.反叛；叛逆；反对（rebell against） indication n.表明，显示；象征 be unable and unprepared to endure the long haul 无法或不愿意忍受长期的煎熬 adj.不愿意的，不甘心的，未准备好的 长期艰巨的任务。 inaction n.不行动，不采取措施；无作为 destructive adj.破坏性的，毁灭性的 proposition n.提议；主张，观点；（美国）法律修正议案；事情，问题，任务 熟词 翻译 coincidence n.（令人吃惊的）巧合，巧事；同时存在；（意见）相同，一致 credit card,debt,loan,mortgage,financial difficulty,financial stress n.信用卡；债务；贷款；按揭贷款，房屋抵押贷款；经济困难 trust,efficiency,quietness,coolness,reflection,calm n.信任；高效；平静；冷静；沉思；沉着 domestic,natural,earthy adj.居家，自然，质朴 conservative,agreeable,corporate adj.保守的；令人愉快的；公司的 trustworthy adj.可靠的，值得信赖的 natural adj.天然的，自然地；正常的，意料之中的；天生的，本能的 n.有天赋的人，擅长做某事的人 associated v.-ed 联想，联系；交往；表明支持，表示同意 adj.相关的；有联系的；联合的 psychology n.心理学，心理课堂 leading adj.杰出的 brand n.品牌 recognizable adj.易于识别的，可承认的 primary concern maximize v.使增加到最大限度；充分利用 softened adj.柔和的 traditional adj.传统的，习俗的，惯例地；守旧地 simply stick 就这么沿用下来 adv.仅仅，不过；确实，简直；简单地，简朴地；不过，只是 v.经久驻留 symbolize v.象征，代表 encounter v.遭遇，遇到 convince v.坚信，深信，确信 argue v.争吵，争辩（argue with sb about/over sth)；论证，说理（argue for/against sth) the normal ups and downs of investment markets 投资市场正常的涨涨跌跌 adj.正常的，一般的；精神正常的，意识健全的 n.常态，通常标准，一般水平 起伏，涨跌，兴衰 gateway，household，pattern n.大门入口，途径;家庭，一家人;模式 statement n.声明，陈述；结算单，报表（financial statement财务报表） era n.souvenir n.stall n.fruit n.advance n.phrase bookintroduce v.indispensable adj.adequate adj.casual adj.lingual,linguistic adj.when it comes to …find the right way to deal with sthmake a big effort to do sthbe not as good as sb accessible adj.account v.adaptation n.appropriately adv.considerable adj.effective adj.ladder n.miseread v.nomination n.overlook v.promote v.senior n.submission n.suggest v.thankfullg adv.separate v.utter v.pioneering adj.pursuit n.in one’s lifetimeplay an importannt part/role in …higher educationadvance and promote gender equalityundergraduate n./adj.postgraduate n./adj.make upacademic staffat senior levelsstark adj.median adj. knit(knitting,knitter) v.(crocheter)stitch v.handiwork n.crafts n.throughout college prep.thereafter adv.hook v.on one’s way to doing sthrestore v./ renewal n.council n.swell the ranksin honer ofpioneer n.repetitive adj.induce a relaxed statebe associated withinitial learning curveheart ratetangible adj.self-esteem/self-respect n.singular adj.boost my spiritshundreds of thousands of …routinely adv.fulfillment n.a prematurely born babyintensive care unit(ICU)stick withcope withprompte v.go well adv.replace A with Bconduct v.heal for v.autoimmune adj.mindless adj.stiff agj.disorder n.significant improvementslessen their fearswellness n.therapeutic adi.respondent n.clinically adv.persistent adj.redirect their focus/ divert their attention from their painprocessat onceregister pain signalssample n.be engaged in …diminished adj.speculate v.nerve pathwaysintellectually adv.sustained adj.maximize v.like-minded adj.for onestay away from tobaccoenhance v.prolong one’s lifekeenly adv.relieve stresssuffer mild cognitive damage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869vanish v.prospect n.there is almost no hard evidence for ... other than ...pilot adj.autopilot n.the bulk ofa shifting of gearsterrifying adj.a rebirth n.choose purpose over happinessgive priority tofar from gloomyphase v.identity n.built up your resourcesprecisely adv.foundation n.secure adj.sowing n.reap v.the runleap v.venture n.measured adj.haste n.energetic adj.presidential candidatelifespan n.narrativedescent cn.a turning pointtake full advantage ofmisrepresent real liferosy adj.burdensome adj.undergo(undergoes) v.turn offdone adj.science fictionincreasingly adv.absorb v.fragmented adj.bizarre adj.popular notionretain v.replay v.a neural virtual realityvivid adj.sleep disorderssleepwalk v.physical movementvideotape the subjectsdraw v.integrate ... into10-fold adj.respondent,candidate,subject,participantbedtime n.a napa study sessionodd n.intensified adj.systematize v.substitute ... with","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"PTA 数据结构","slug":"数据结构/PTA","date":"2021-12-04T15:24:25.366Z","updated":"2021-12-28T05:33:59.130Z","comments":true,"path":"2021/12/04/数据结构/PTA/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/PTA/","excerpt":"","text":"第一章 绪论判断题1-1 数据元素是数据的最小单位。F(数据项) 1-2 数据的逻辑结构是指数据的各数据项之间的逻辑关系。F（数据元素之间） 1-3 数据结构概念包括数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三个方面。T 1-4 数据结构的抽象操作的定义与具体实现有关。F 1-5 算法和程序没有区别，在数据结构中二者是通用的。F 1-6 数据结构包括数据对象集以及它们的逻辑结构和物理结构，还包括与数据对象相关联的操作集，以及实现这些操作的高效的算法。T 选择题（错题：2-9,2-13）2-1 在 Data_Structure = (D，R)中，D 是（ ）的有限集合。 A.数据元素 2-2 以下关于数据结构的说法中错误的是（ ）。 A.数据结构相同，对应的存储结构也相同 2-4 算法分析的目的是( ) C.分析算法的效率以求改进 2-5 算法分析的两个主要方面是( ) A.空间复杂度和时间复杂度 2-6 采用链结构存储线性表时，其地址（ ）。 B.连续不连续都可以 2-7 一个正确的算法应该具有 5 个特性，除输入、输出特性外，另外 3 个特性是（ ）。 A.确定性、可行性、有穷性 2-8 算法的时间复杂度取决于（ ） C.问题的规模和待处理数据的初态 2-9 以下数据结构中，哪一个是线性结构（ ） D.串 2-10 以下数据结构中，（ ）是非线性数据结构 B.字符串 2-11 算法的时间复杂度与（ ）有关。 A.问题规模 2-12 以下程序段的空间复杂度为 12345int a = 1, b = 1, i;for (i=0; i&lt;=10; i++) &#123; b += a; a = b - a;&#125; B.O(1) 2-13 下列程序段的时间复杂度是（ ）。 1234count=0;for(k=1;k&lt;=n;k*=2) for(j=1;j&lt;=n;j++) count++; C.O*(nlog2*n) 2-14 下面说法中，错误的是（ ）。 ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间 ⅱ.在相同规模n下，复杂度为O(n)的算法在时间上总是优于复杂度为O(2n)的算法 ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界 ⅳ.同一个算法，实现语言的级别越高，执行效率越低 C.ⅰ,ⅳ 2-15 算法的计算量的大小称为算法的____。 B.复杂度 2-16 在下面的程序段中，对x的赋值语句的频度为（ ） 123for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++) x=x+1; C.O(n2) 2-17 下面程序段的时间复杂度是 ( ) 123i ＝ 0；while（i&lt;=n） i = i * 3； D.O(log3n) 填空题（错题：4-1, 4-4, 4-6，4-7，4-10）4-1 算法效率的比较 假设为解决某问题而设计的若干算法的时间复杂度分别为： A) O(n)B) O(n2)C) O(log2​n)D) O(nlog2​n)E) O(2n)F) O(n​)G) O(n!)H) O(1)I) O(n**n​)J) O(n**n) 这些算法按效率由高到低的顺序是 HCFADIBEGJ 4-2 基本术语 数据 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。 4-3 数据结构的数学定义 数据结构的数学定义为一个二元组： D**S=(D,R) 其中：D 是数据元素的有限集，R 是 D 上的关系 的有限集。 4-4 存储结构存储结构包括数据元素的表示和关系的表示。 4-5 基本术语 抽象数据类型 一般指由用户定义的、表示应用问题的数学模型，以及定义在该模型上的一组操作。 4-6 在数据结构中，数据的逻辑结构分为线性结构和非线性结构 。 4-7 数据结构由数据的逻辑结构、存储结构 和运算|操作三部分组成。 4-8 算法的特性 一个算法必须满足以下五个重要特性： (1) 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都可以有穷有时间内完成。 (2) 确定性 一个算法中每一条指令必须有确切的含义。 (3) 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 (4) 输入一个算法有零个或多个输入。 (5) 输出一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果。 4-9 基本术语 数据元素是数据的基本单位，数据项是数据的不可分割最小单位。其中：前者在计算机中通常作为一个整体进行考虑和处理，它可以由一个或多个后者组成。 4-10 数据的实例 观察下面的表格： 学号 姓名 性别 语文 数学 物理 化学 英语 总分 15160101 王克强 男 87 95 93 76 84 435 15160102 刘铭志 男 77 82 80 97 95 431 15160103 孙勇 男 78 85 87 86 65 401 15160104 李瀚东 男 93 82 72 75 95 417 15160105 赵敏 女 95 90 88 82 96 451 15160106 张毅 男 78 76 65 81 80 380 15160107 柳青 女 82 91 82 84 85 424 15160108 蔡文婷 女 85 78 80 86 95 424 整张表格称为一个 数据对象，其中每一行称为一个 数据元素，任意一行中的每一个栏目称为一个数据项。 4-11 沃斯的名言 瑞士科学家尼古拉斯·沃斯(Niklaus Wirth)有一句在计算机领域里人尽皆知的名言： 算法 + 数据结构 = 程序 编程题7-1 求最小值和次小值 (25 分)123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int main()&#123; int n,x; cin&gt;&gt;n; cin&gt;&gt;x; if(n&gt;1)&#123; int mini = x; int mini2 = x; int a[n]=&#123;x&#125;; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; if(mini&gt;a[i])mini=a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; if(a[i]==mini)continue; if(mini2==mini)mini2=a[i]; if(mini2&gt;a[i])mini2=a[i]; &#125; if(mini==mini2) cout&lt;&lt;&quot;There is no second smallest element&quot;&lt;&lt;endl; else cout&lt;&lt;mini&lt;&lt;&quot; &quot;&lt;&lt;mini2; &#125; else &#123; cout&lt;&lt;&quot;Invalid Input&quot;&lt;&lt;endl; &#125; return 0;&#125; 7-2 求素数个数 (30 分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=0; cin&gt;&gt;n; int *a=new int[n+1]; for(int i=2;i&lt;=n;i++) a[i]=1; a[0]=a[1]=0; for(int i=2;i*i&lt;=n;i++) &#123; if(a[i]) &#123; for(int j=2*i;j&lt;=n;j+=i) a[j]=0; &#125; &#125; for(int i=2;i&lt;=n;i++) &#123; if(a[i])num++; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125;/*#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=1,flag=1; cin&gt;&gt;n; if(n==1)cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else if(n==2)cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; else &#123; for(int i=3;i&lt;=n;i+=2) &#123; for(int j=3;j*j&lt;=i;j+=2) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag) num++; flag=1; &#125; cout&lt;&lt;num&lt;&lt;endl; &#125; return 0;&#125;*//*#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=0,flag=1; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; for(int j=2;j*j&lt;=i;j++) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag) &#123; num++; &#125; flag=1; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125;*/ 第二章 线性表判断题（错题：1-2,1-4,1-15,1-17）1-1 顺序存储方式只能用于存储线性结构。F 1-2在顺序表中取出第i个元素所花费的时间与i成正比。F 1-3 线性表的顺序存储表示优于链式存储表示。F 1-4带头结点的单循环链表中，任一结点的后继结点的指针域均不空。T 1-5 顺序表 - 存储结构 顺序表中逻辑上相邻的元素，其物理位置也一定相邻。T 1-6 链式存储的优点是插入、删除元素时不会引起后续元素的移动，缺点是只能顺序访问各元素。T 1-7 线性表若采用链式存储结构时，要求内存中可用存储单元的地址一定不连续。F 1-8 链表是采用链式存储结构的线性表,进行插入、删除操作时，在链表中比在顺序存储结构中效率高。T 1-9 若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。T 1-10 对于顺序存储的长度为N的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为O(1)和O(N)。F 1-11 在线性表的顺序存储结构中，插入和删除元素时，移动元素的个数与该元素的位置有关。T 1-12 顺序存储方式的优点是存储密度大，且插入、删除运算效率高。F 1-13 在具有N个结点的单链表中，访问结点和增加结点的时间复杂度分别对应为O(1)和O(N)。F 1-14 线性表采用链式存储表示时，所有结点之间的存储单元地址可以连续也可以不连续。T 1-15在单链表中，要访问某个结点，只要知道该结点的指针即可。因此，单链表是一种随机存取结构。F 1-16 在具有头结点的链式存储结构中，头指针指向链表中的第一个元素结点。F 1-17在一个设有头指针和尾指针的单链表中，执行删除该单链表中最后一个元素的操作与链表的长度无关。F 1-18 循环链表可以做到从任一结点出发，访问到链表的全部结点。T 1-19 在单链表中，逻辑上相邻的元素，其物理位置必定相邻。F 1-20 在双向链表中，可以从当前结点出发访问到任何一个结点。T 选择题(错题：2-10,2-13,2-16,2-20)2-1 在一个长度为n的顺序表中，向第i个元素(1≤i≤n+1)位置插入一个新元素时需要从后向前移动多少个元素。 B.n-i+1 2-2 对于线性表，在顺序存储结构和链式存储结构中查找第k个元素，其时间复杂性分别是多少？ D.O(1)和O(k) 2-3 在顺序结构表示的线性表中，删除第i个元素（数组下标为i-1)，需要把后面的所有元素都往前挪一位，相应的语句是： 12for (___________ ) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; 其中空缺部分的内容应该是 A.j = i; j&lt; = PtrL-&gt;Last; j++ 2-4 向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（ ） B.63.5 2-5 顺序表是线性表的( ) B.顺序存储结构 2-6 以下说法错误的是 ( )。 C.在链表上实现读表元运算的平均时间复杂度为O（1） 2-7 哪个选项不是线性表的链式存储结构（ ） B.顺序表 2-8 在向表中第i个元素（1≤i≤n+1）位置插入一个新元素时，为保持插入后表中原有元素的相对次序不变，需要从后向前依次后移（ ）个元素。 B.n-i+1 2-9 在删除表中第i个元素时，同样地，为保持删除后表中原有元素的相对次序不变，需要从前向后依次前移（ ）个元素。 A.n-i 2-10与单链表相比，双链表的优点之一是（）。 D.顺序访问相邻结点更加灵活 2-11 在单链表中，要删除某一指定结点，必须先找到该结点的（）。 A.直接前驱 2-12 循环链表的主要优点是（）。 D.从表中的任意结点出发都能扫描到整个链表 2-13若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点，则采用（）存储方式最节省运算时间。 D.带表头附加结点的双循环链表 2-14 单链表又称为线性链表，在单链表上实施插入和删除操作（ ）。 B.不需移动结点，只需改变结点指针 2-15 链表不具有的特点是( )。 A.可随机访问任一个元素 2-16下面关于线性表的叙述中，错误的是____。 B.线性表采用顺序存储，便于进行插入和删除操作。 2-17 单链表L（带头结点）为空的判断条件是____。 B.L-&gt;next==NULL 2-18 在单链表指针为p的结点之后插入指针为s的结点，正确的操作是：（ ）。 B.s-&gt;next=p-&gt;next;p-&gt;next=s 2-19 对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（ ） B.head→next==NULL 2-20设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用( )最节省时间。 D.带头结点的双循环链表 填空题4-1 顺序表 - 地址计算 假设顺序表第 1 个元素的内存地址是 100，每个元素占用 2 字节内存空间，则第 5 个元素的内存地址是 108 4-2 在有n个元素的顺序表中删除任意一个元素所需移动元素的平均次数为 （n-1)/2 4-3 在有n个元素的顺序表中的任意位置插入一个元素所需移动元素的平均次数为 n/2 4-4 在长度为n的顺序表L中将所有值为x的元素替换成y，该算法的时间复杂度为 O(n) 4-5 在顺序表中，逻辑上相邻的元素，其物理位置 一定 相邻。在单链表中，逻辑上相邻的元素，其物理位置 不一定 相邻。 4-6 对于顺序表的插入算法insert_sqlist来说，若以结点移动为标准操作，则插入算法的在最坏情况下的移动次数为 n ，时间复杂度是 **O(n)**。在平均情况下的移动次数为 n/2 ，时间复杂度是 **O(n)**。 4-7 线性表L=(a1, a2, … , an)用数组表示，假定删除表中任一元素的概率相同，则删除一个元素平均需要移动元素的个数是 (n-1)/2 程序填空题5-1 顺序表删除操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0#define MAXSIZE 100typedef int datatype;typedef struct &#123; datatype *elem; int length;&#125; SqList;int ListDelete_Sq(SqList &amp;L, int i) &#123; if ((i &lt; 1) || (i &gt; L.length)) return ERROR; for (int j = i; j &lt;= L.length; j++) ; (2&#x27;) --L.length; return OK;&#125;int main() &#123; SqList L; int i = 0, n,a; datatype e; L.elem = new datatype[MAXSIZE]; L.length = 0; cin &gt;&gt; n; for (i=0;i&lt;n;i++) cin &gt;&gt; L.elem[i]; L.length = i; cin &gt;&gt; a; if (ListDelete_Sq(L, a)) &#123; for (i = 0; i &lt; L.length; i++) if(i==0) cout &lt;&lt; L.elem[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; L.elem[i]; &#125; else cout &lt;&lt; &quot;ERROR&quot;; return 0;&#125; 5-2单链表删除操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0typedef int ElemType;typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; void CreateList(LinkList &amp;L, int n) ;//该函数未显示细节 int ListDelete_L(LinkList &amp;L, int i) &#123; LinkList p, q; int j; p = L; j = 0; while((p-&gt;next) &amp;&amp; (j &lt;i)) (2&#x27;) &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || (j &gt; i - 1)) return ERROR; q = p-&gt;next; p-&gt;next=q-&gt;next;(2&#x27;) delete q; return OK;&#125; void print(LinkList &amp;L)&#123; LinkList p; int flag=1; p = L-&gt;next; while (p) &#123; if(flag) cout &lt;&lt; p-&gt;data; else cout &lt;&lt; &quot; &quot;&lt;&lt; p-&gt;data; flag=0; p = p-&gt;next; &#125;&#125;int main() &#123; LinkList L; ElemType e; int length; int i; cin &gt;&gt; length; CreateList(L, length); cin &gt;&gt; i; ListDelete_L(L,i); print(L); return 0;&#125; 函数题6-1 求顺序表最大值 (10 分) 123456789int GetMax(SqList L)&#123; int maxi=0; for(int i=0;i&lt;L.length;i++) &#123; if(maxi&lt;L.elem[i])maxi=L.elem[i]; &#125; return maxi;&#125; 6-2 单链表逆置* (10 分)1234567891011121314void Reverse(NODE *head)&#123; NODE *p,*p1,*p2,*p3; p = head-&gt;next; p1 = head; p1-&gt;next = NULL; while(p!=NULL) &#123; p2 = p; p = p-&gt;next; p2-&gt;next = p1-&gt;next; p1-&gt;next = p2; &#125;&#125; 6-3 单链表统计正数个数 (6 分) 123456789101112int PositiveInt(LinkList L)&#123; LNode *p; int n=0; p = L-&gt;next; while(p!=NULL) &#123; if(p-&gt;data&gt;0)n++; p = p-&gt;next; &#125; return n;&#125; 编程题7-1 学生顺序表的建立 (10 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576法一：#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;using namespace std;struct Node&#123; int id; string name; float s1,s2,s3; Node *next;&#125;;int main()&#123; int n; int id; string name; float s1,s2,s3; Node *p,*first,*last=NULL; last = new Node; first = last; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;id&gt;&gt;name&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; p = new Node; p-&gt;id = id; p-&gt;name = name; p-&gt;s1 = s1; p-&gt;s2 = s2; p-&gt;s3 = s3; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; p = first-&gt;next; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;p-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s1&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s2&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s3&lt;&lt;endl; p = p-&gt;next; &#125; return 0;&#125;法二：#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct Students&#123; int ID; string name; double score1; double score2; double score3; &#125;students[5];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;students[i].ID&gt;&gt;students[i].name&gt;&gt;students[i].score1&gt;&gt;students[i].score2&gt;&gt;students[i].score3; &#125; cout.precision(1); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;students[i].ID&lt;&lt;&quot; &quot;&lt;&lt;students[i].name&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score1&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score2&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score3; if(i!=n-1) cout&lt;&lt;endl; &#125; return 0;&#125; 7-2 求两个一元多项式的和 (20 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129法一：链表#include&lt;iostream&gt;using namespace std;struct Node&#123; int coef,exp; Node *next;&#125;;int main()&#123; int n,coef,exp; Node *p,*p1,*q,*q1,*temp; Node *first1,*first2,*last; last = new Node; first1=last; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; p=new Node; p-&gt;coef = coef; p-&gt;exp = exp; last-&gt;next=p; last = p; &#125; last-&gt;next = NULL; last = new Node; first2=last; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; p=new Node; p-&gt;coef = coef; p-&gt;exp = exp; last-&gt;next=p; last = p; &#125; last-&gt;next = NULL; p=first1-&gt;next; p1=first1; q=first2-&gt;next; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;exp&gt;q-&gt;exp) &#123; p=p-&gt;next; p1=p1-&gt;next; &#125; else if(p-&gt;exp&lt;q-&gt;exp) &#123; temp=q-&gt;next; p1-&gt;next=q; q-&gt;next=p; q = temp; &#125; else &#123; p-&gt;coef+=q-&gt;coef; if(p-&gt;coef==0) &#123; p1-&gt;next=p-&gt;next; delete p; p=p1-&gt;next; &#125; else &#123; p=p-&gt;next; p1=p1-&gt;next; &#125; q = q-&gt;next; &#125; &#125; if(q!=NULL)p1-&gt;next=q; p=first1-&gt;next; if(p!=NULL) &#123; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;coef&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;exp&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; cout&lt;&lt;p-&gt;coef&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;exp&lt;&lt;endl; &#125; else cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; return 0;&#125;法二：数组#include&lt;iostream&gt;using namespace std;int a[1001]=&#123;0&#125;;int main()&#123; int n,coef,exp; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; a[exp]=coef; &#125; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; a[exp]+=coef; &#125; n=0; for(int i=1000;i&gt;-1;i--) &#123; if(n==0&amp;&amp;a[i]) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;i; n=1; &#125; else if(a[i]) cout&lt;&lt;&quot; &quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;i; &#125; if(n)cout&lt;&lt;endl; else cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl;&#125; 7-3 两个有序链表合并（新表不含重复元素） (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242法一：刘俊兄弟的代码……emm……#include&lt;iostream&gt;using namespace std;int main()&#123; int a[1000], b[1000]; int flog = 1; int lengtha = 0, lengthb = 0; while (flog) &#123; int c; cin &gt;&gt; c; if (c == -1) flog = 0; else &#123; a[lengtha++] = c; &#125; &#125; flog = 1; while (flog) &#123; int c; cin &gt;&gt; c; if (c == -1) flog = 0; else &#123; b[lengthb++] = c; &#125; &#125; int j = 0; for (int i = lengtha ; i &lt; lengtha + lengthb; i++) &#123; a[i] = b[j++]; &#125; if (lengtha + lengthb == 0) &#123; cout &lt;&lt; &quot;NULL&quot;; &#125; int n = lengtha + lengthb; for (int i = 0; i &lt; n-1; i++) //冒泡循环 &#123; for (int j = i + 1; j &lt; n; j++)//从i后的一个元素一直往len-1位置寻找 &#123; if (a[j] == a[i]) //如果发现重复 &#123; for (int k = j + 1; k &lt; n; k++)//j+1的位置到len-1的位置 &#123; a[k - 1] = a[k]; //将后面的数依次赋值给前一个位置 &#125; n--; //数组长度-1 j--; //重复点再次进行查重 &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++) &#123; for (int j = 0; j &lt; n - i-1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; n-1; i++) &#123; cout &lt;&lt; a[i]&lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; a[n - 1]&lt;&lt;endl; return 0;&#125;法二：数组#include&lt;iostream&gt;using namespace std;int a1[10000];int a2[10000];int main()&#123; int x,n=0; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; a1[n++] = x; &#125; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; a1[n++] = x; &#125; for(int i=0;i&lt;n-1;i++) &#123; int mini=i; for(int j=i+1;j&lt;n;j++) &#123; if(a1[mini]&gt;a1[j])mini=j; &#125; if(mini!=i)swap(a1[mini],a1[i]); &#125; int flag=0; for(int i=0;i&lt;n;i++) &#123; if(a1[i]==flag)a1[i]=0; else flag = a1[i];//? &#125; int n1=0; for(int i=0;i&lt;n;i++) &#123; if(a1[i]) a2[n1++]=a1[i]; &#125; for (int i = 0; i &lt; n1-1; i++) &#123; cout &lt;&lt; a2[i]&lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; a2[n1 - 1]&lt;&lt;endl; return 0;&#125;法三：链表#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;int main()&#123; int x,flag=-1; Node *first1,*first2,*first3,*p,*p1,*p2,*last; last=new Node; first1 = last; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; if(x == flag)continue; p = new Node; p-&gt;data = x; flag = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; last=new Node; first2 = last; flag = -1; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; if(x == flag)continue; p = new Node; p-&gt;data = x; flag = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; last = new Node; first3 = last; p1 = first1-&gt;next; p2 = first2-&gt;next; while(p1!=NULL||p2!=NULL) &#123; if(p1!=NULL&amp;&amp;p2!=NULL) &#123; if(p2-&gt;data&gt;p1-&gt;data) &#123; p= new Node; p-&gt;data = p1-&gt;data; last-&gt;next = p; last = p; p1=p1-&gt;next; &#125; else if(p2-&gt;data&lt;p1-&gt;data) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; &#125; else if(p2-&gt;data==p1-&gt;data) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; p1=p1-&gt;next; &#125; &#125; else if(p2==NULL) &#123; p= new Node; p-&gt;data = p1-&gt;data; last-&gt;next = p; last = p; p1=p1-&gt;next; &#125; else if(p1==NULL) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; &#125; &#125; last-&gt;next = NULL; p= first3-&gt;next; if(p!=NULL) &#123; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl; return 0;&#125; 7-4 在有序链表中插入数据 (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;int main()&#123; int n,x; Node *p,*p2,*p1,*first,*last=new Node; first=last; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; p = new Node; p-&gt;data = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; cin&gt;&gt;x; p1 = first-&gt;next; p2 = first; while(p1!=NULL) &#123; if(x == p1-&gt;data)break; if(x&lt;p1-&gt;data) &#123; p = new Node; p-&gt;data = x; p-&gt;next = p1; p2-&gt;next = p; break; &#125; else if(x&gt;p1-&gt;data&amp;&amp;(p1-&gt;next==NULL||x&lt;p1-&gt;next-&gt;data)) &#123; p = new Node; p-&gt;data = x; p-&gt;next = p1-&gt;next; p1-&gt;next = p; break; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; if(first-&gt;next == NULL) &#123; p = new Node; p-&gt;data = x; p-&gt;next = NULL; first-&gt;next = p; &#125; p = first-&gt;next; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return 0;&#125; 第三章 栈和列表判断题（错题：1-10）1-1 若一个栈的输入序列为1，2，3，…，N，输出序列的第一个元素是i，则第j个输出元素是j−i−1。F 1-2 所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。F 1-3 在对不带头结点的链队列作出队操作时，不会改变头指针的值。F 1-4 不论是入队列操作还是入栈操作,在顺序存储结构上都需要考虑”溢出”情况。T 1-5 队列和栈都是运算受限的线性表，只允许在表的两端进行运算。F 1-6 栈和队列的存储方式，既可以是顺序方式，也可以是链式方式。T 1-7 循环队列也存在着空间溢出问题。T 1-8 循环队列执行出队操作时会引起大量元素的移动。F 1-9 栈是插入和删除只能在一端进行的线性表；队列是插入在一端进行，删除在另一端进行的线性表。T 1-10 在n个元素连续进栈以后，它们的出栈顺序和进栈顺序一定正好相反。T 1-11 环形队列中有多少个元素可以根据队首指针和队尾指针的值来计算。T 1-12 栈和队列的插入和删除操作特殊，所以，栈和队列是非线性结构。F 1-13 序列{1,2,3,4,5}依次入栈，则不可能得到{3,4,1,2,5}的出栈序列。 T 1-14 队列中允许插入的一端叫队头，允许删除的一端叫队尾。F 单选题（错题：2-2、2-18）2-1 若用大小为6的数组来实现循环队列，且当前front和rear的值分别为0和4。当从队列中删除两个元素，再加入两个元素后，front和rear的值分别为多少？ A.2和0 2-2如果循环队列用大小为m的数组表示，且用队头指针front和队列元素个数size代替一般循环队列中的front和rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数最多为： B.m 2-3 以下数据结构中，（ ）是非线性数据结构。 A.树 2-4 设栈S和队列Q的初始状态均为空，元素{1, 2, 3, 4, 5, 6, 7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2, 5, 6, 4, 7, 3, 1}，则栈S的容量至少是： D.4 2-5 线性表、堆栈、队列的主要区别是什么？ B.堆栈和队列都是插入、删除受到约束的线性表 2-6 栈和队列的共同点( )。 C.只允许在端点处插入和删除元素 2-7 下列关于线性表,栈和队列叙述,错误的是( )。 A.线性表是给定的n(n必须大于零)个元素组成的序列 2-8 设用一个数组A[1……N]来存储一个栈，令A[N]为栈底，用整型变量T指示当前栈顶位置，A[T]为栈顶元素。当从栈中弹出一个元素时，变量T的变化为（ ）。 A.T=T+1 2-9 链式栈与顺序栈相比，一个比较明显的优点是（ ）。 B.通常不会出现栈满的情况 2-10 (neuDS)在循环顺序队列中，假设以少用一个存储单元的方法来区分队列判满和判空的条件，front和rear分别为队首和队尾指针，它们分别指向队首元素和队尾元素的下一个存储单元，队列的最大存储容量为maxSize，则队列的长度是（ ）。 C.(rear-front+maxSize)%maxSize 2-11 (nueDS_C++)设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5、e6依次通过栈S，一个元素出栈后即进入队列Q，若6个元素出队的顺序是e2、e4、e3、e6、e5、e1，则栈S的容量至少应该是（ ）。提示：对于栈，可以全进再依次出；也可以进一个出一个；也可以进一部分，出一个，再进一部分；但是出栈之后，不能再入栈。 A.3 2-12 关于栈和队列的下列说法正确的是（） B.栈是后进先出的结构，出栈时除了栈顶元素，其余元素无需移动； 2-13 一个栈的入栈序列是a,b,c,d,e，则栈的出栈序列不可能的是（ ）。 C.dceab 2-14 在一个链表表示的队列中， f和r分别指向队列的头和尾。下列哪个操作能正确地将s结点插入到队列中： B.r-&gt;next=s; r=s; 2-15 栈和队列具有相同的。 B.逻辑结构 2-16 假定利用数组a[n]顺序存储一个栈，用top表示栈顶指针，用top==-1表示栈空，并已知栈未满，当元素x进栈时所执行的操作为（ ）。 C.a[++top]=x 2-17 队列的“先进先出”特性是指（ ）。 Ⅰ.最后插入队列中的元素总是最后被删除Ⅱ.当同时进行插入、删除操作时，总是插入操作优先Ⅲ.每当有删除操作时，总要先做一次插入操作Ⅳ.每次从队列中删除的总是最早插入的元素 B.Ⅰ、Ⅳ 2-18已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。 B.0,n-1（原因：……） 2-19 执行函数时，其局部变量一般采用（ ）进行存储。 C.栈结构 2-20 对空栈 S 进行 Push 和 Pop 操作，入栈序列为 a, b, c, d, e，经过 Push, Push, Pop, Push, Pop, Push, Push, Pop 操作后，得到的出栈序列是： D.b, c, e 2-21 用S表示入栈操作，X表示出栈操作，若元素入栈的顺序为1234，为了得到1342出栈顺序，相应的S和X的操作串为( )。 D.SXSSXSXX 填空题（错题：4-3）4-1 栈的运算遵循 后进先出|先进后出 的原则。 4-2 以下运算实现在链队上的入队列，请在空白处用适当句子予以填充。 12345678void EnQueue(QueptrTp *lq,DataType x)&#123; LqueueTp *p; p=(LqueueTp *)malloc(sizeof(LqueueTp)); p-&gt;data=x;(1&#x27;) p-&gt;next=NULL; (lq-&gt;rear)-&gt;next=p;(1&#x27;) lq-&gt;rear=p;(1&#x27;) &#125; 4-3 以下运算实现在链栈上的初始化，请在空白处用请适当句子予以填充。 12345typedef struct Node&#123; DataType data; struct Node *next;&#125;StackNode,*LStackTp;void InitStack(LStackTp &amp;ls)&#123; ls=NULL;&#125;。(1&#x27;) 函数题6-3 jmu-ds-舞伴问题 (20 分)12345678910111213141516171819202122232425262728293031323334353637383940int QueueLen(SqQueue Q)&#123; return (Q-&gt;rear-Q-&gt;front+MAXQSIZE)%MAXQSIZE;&#125;int EnQueue(SqQueue &amp;Q, Person e)&#123; Q-&gt;rear = (Q-&gt;rear+1)%MAXQSIZE; Q-&gt;data[Q-&gt;rear] = e; return 0;&#125;int QueueEmpty(SqQueue &amp;Q)&#123; if(Q-&gt;rear==Q-&gt;front)return 1; else return 0;&#125;int DeQueue(SqQueue &amp;Q, Person &amp;e)&#123; Q-&gt;front = (Q-&gt;front+1)%MAXQSIZE; e = Q-&gt;data[Q-&gt;front]; return 0;&#125;void DancePartner(Person dancer[], int num)&#123; for(int i=0;i&lt;num;i++) &#123; if(dancer[i].sex==&#x27;M&#x27;) EnQueue(Mdancers,dancer[i]); else EnQueue(Fdancers,dancer[i]); &#125; while(!QueueEmpty(Mdancers)&amp;&amp;!QueueEmpty(Fdancers)) &#123; Person x,y; DeQueue(Mdancers,x); DeQueue(Fdancers,y); cout&lt;&lt;y.name&lt;&lt;&quot; &quot;&lt;&lt;x.name&lt;&lt;endl; &#125;&#125; 6-4 十进制转二进制（顺序栈设计和应用） (10 分) 12345678910111213141516171819202122232425bool isEmpty()&#123; if(top==-1)return 1; else return 0;&#125;/* 元素x入栈 */void Push(int x)&#123; //if(x==MaxSize)cout&lt;&lt;&quot;上溢&quot;&lt;&lt;endl; //else mystack[++top]=x;&#125;/* 取栈顶元素 */int getTop()&#123; return mystack[top];&#125;/* 删除栈顶元素 */void Pop()&#123; top--;&#125; 编程题7-1 银行业务队列简单模拟 (25 分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int arr[1000];int main()&#123; int n; int flag1=0,flag2=0; int top1=0,top2=0,top=0; cin&gt;&gt;n; int a1[n+1],a2[n+1],a[n+1]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; if(arr[i]%2!=0)a1[top1++]=arr[i]; else a2[top2++]=arr[i]; &#125; int t1=0,t2=0; for(int i=0;i&lt;n;i++) &#123; if(arr[i]%2==0)flag2++; else flag1++; if(flag2%2==0&amp;&amp;flag1%4==0) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; a[top++]=a2[t2++]; &#125;else&#123; if(t1!=top1&amp;&amp;(flag1%2==0||t2==top2)) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; &#125; if(t2!=top2&amp;&amp;(flag2%2==0||t1==top1||flag1%2==0)) &#123; a[top++]=a2[t2++]; &#125; &#125; if(top==n)break; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;a[n-1]&lt;&lt;endl; return 0;&#125; 7-2 堆栈操作合法性 (20 分) 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N,M; string str; int n,x=0; cin&gt;&gt;N&gt;&gt;M; for(int i=0; i&lt;N; i++) &#123; cin&gt;&gt;str; n = str.size(); for(int j=0; j&lt;n; j++) &#123; if(str[j]==&#x27;S&#x27;) &#123; x++; if(x&gt;M)break; &#125; else if(str[j]==&#x27;X&#x27;) &#123; x--; if(x&lt;0)break; &#125; &#125; if(x==0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; x=0; &#125; return 0;&#125; 第四章 串和数组判断题1-1 假设模式串是abababaab，则KMP模式匹配算法中的next[j] = 0 1 1 2 3 4 5 6 2。T 选择题(错题：2-3,2-6,2-9,2-13)2-1 KMP算法下，长为n的字符串匹配长度为m的字串的时间复杂度为 B.O（M+N） 2-2 串的长度是指 B.串中所含字符的个数 2-3设主串 T = abaabaabcabaabc，模式串 S = abaabc，采用 KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是： B.10（6+4） 2-4 串“ababaaababaa”的next数组为（ ）。 C.011234223456 2-5 已知字符串S为“abaabaabacacaabaabcc”，模式串t为“abaabc”。采用KMP算法进行匹配，第一次出现“失配”(s[i]≠t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是()。 C.i=5,j=2 2-62 符号串abcde的子串共有： C.16（1+2+3+4+5+1(空串)） [^长度为n的字符串]: 1、有n(n+1)/2 +1个子串；2、非空子串：n（n+1）/2；3、非空真子串：n（n+1）/2– 1 2-7 适用于压缩存储稀疏矩阵的两种存储结构是： A.三元组表和十字链表 2-8 (neuDS)以下( )是稀疏矩阵的一种存储方法。 A.十字链表 2-9一个稀疏矩阵采用压缩后，和直接采用二维数组存储相比会失去（ ） 特性。 B.随机存取 2-10 对特殊矩阵采用压缩存储的主要目的是（ ）。 D.减少不必要的存储空间 2-11 对n阶对称矩阵压缩存储时，需要表长为（ ）的顺序表。 C.n(n+1)/2 2-12 顺序查找法适合于存储结构为（ ）的线性表。 B.顺序存储或链式存储 2-13（SWPU-DS）设有一个 10 阶的对称矩阵 A，采用压缩存储方式，以行序为主存储，a[1, 1] 为第一元素，其存储地址为 1，每个元素占一个地址空间，则 a[8, 5] 的地址为（ ）。 *C.33（对称矩阵：(7+1)7/2+5)） 第五章 树和二叉树选择题2-1 设一棵非空完全二叉树 T 的所有叶节点均位于同一层，且每个非叶结点都有 2 个子结点。若 T 有 k 个叶结点，则 T 的结点总数是： A.2k−1 2-2 已知字符集{ a, b, c, d, e, f }，若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是： A.00, 1011, 01, 1010, 11, 100 2-3 已知二叉树的先序遍历序列为ABCDEFGH，中序遍历序列为CBEDFAGH，则该二叉树形态中，父节点的右子节点为（）。 C.G 2-4若将一棵树 T 转化为对应的二叉树 BT，则下列对 BT 的遍历中，其遍历序列与 T 的后根遍历序列相同的是： B.中序遍历 2-5对 n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有 115 个结点，则 n 的值是： C.58 2-6 设 T 是非空二叉树，若 T 的先序遍历和中序遍历序列相同，则 T 的形态是 __ D.所有结点只有右孩子 2-7以二叉链表作为二叉树的存储结构，在具有 n 个结点的二叉链表中（n&gt;0），空链域的个数为 __ A.n+1 2-8 已知二叉树的前序遍历序列为 ABDCEFG，中序遍历序列为 DBCAFEG，则后序遍历序列为 __ B.DCBFGEA 2-9 对于任意一棵高度为 5 且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占 1 个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元的数量至少是： A.31 2-10已知森林 F 及与之对应的二叉树 T，若 F 的先根遍历序列是 a, b, c, d, e, f，后根遍历序列是 b, a, d, f, e, c，则 T 的后序遍历序列是： C.b, f, e, d, c, a 填空题4-1 已知一棵完全二叉树的第5层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是：47 4-2 一棵二叉树的前序遍历序列是ABDFECGHK，中序遍历序列是DBEFAGHCK，则它的后序遍历序列是 DEFBHGKCA 4-3具有n个结点的二叉树中,一共有 2n 个指针域,其中只有 n-1 个用来指向结点的左右孩子，其余的 n+1 个指针域为NULL。 4-4 若以{4，5，6，7，8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是 69 程序填空题5-2 下列代码的功能是将二叉树T中的结点按照层序遍历的顺序输出。 123456789101112131415161718192021222324typedef struct TreeNode *Tree;struct TreeNode&#123; int Key; Tree Left; Tree Right;&#125;;void Level_order ( Tree T )&#123; Queue Q; if ( !T ) return; Q = CreateQueue( MaxElements ); Enqueue( T, Q ); while ( !IsEmpty( Q ) )&#123; T = Front_Dequeue ( Q ); /* return the front element and delete it from Q */ printf(&quot;%d &quot;, T-&gt;Key); if ( T-&gt;Left ) Enqueue( T-&gt;Left)3分; if (T-&gt;Right 3分 ) Enqueue( T-&gt;Right)3分; &#125;&#125; 5-3 下列代码的功能是计算给定二叉树T的宽度。二叉树的宽度是指各层结点数的最大值。函数Queue_rear和Queue_front分别返回当前队列Q中队尾和队首元素的位置。 12345678910111213141516171819202122232425262728293031323334typedef struct TreeNode *BinTree;struct TreeNode&#123; int Key; BinTree Left; BinTree Right;&#125;;int Width( BinTree T )&#123; BinTree p; Queue Q; int Last, temp_width, max_width; temp_width = max_width = 0; Q = CreateQueue(MaxElements); Last = Queue_rear(Q); if ( T == NULL) return 0; else &#123; Enqueue(T, Q); while (!IsEmpty(Q)) &#123; p = Front_Dequeue(Q); temp_width++3分; if ( p-&gt;Left != NULL ) Enqueue(p-&gt;Left, Q); if ( p-&gt;Right != NULL ) Enqueue (p-&gt;Right)3分; if ( Queue_front(Q) &gt; Last ) &#123; Last = Queue_rear(Q); if ( temp_width &gt; max_width ) max_width = temp_width; temp_width=0 3分; &#125; /* end-if */ &#125; /* end-while */ return max_width; &#125; /* end-else */&#125; 函数题6-1 求二叉树高度 (20 分)1234567891011int GetHeight( BinTree BT )&#123; int LH,RH; if(!BT)return 0; else &#123; LH = GetHeight(BT-&gt;Left); RH = GetHeight(BT-&gt;Right); return LH&gt;RH?++LH:++RH; &#125;&#125; 6-2 二叉树的遍历 (25 分)123456789101112131415161718192021222324252627282930313233343536void InorderTraversal( BinTree BT )&#123; if(!BT)return; InorderTraversal(BT-&gt;Left); printf(&quot; %c&quot;,BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;void PreorderTraversal( BinTree BT )&#123; if(!BT)return; printf(&quot; %c&quot;,BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void PostorderTraversal( BinTree BT )&#123; if(!BT)return; PostorderTraversal(BT-&gt;Left); PostorderTraversal(BT-&gt;Right); printf(&quot; %c&quot;,BT-&gt;Data);&#125;void LevelorderTraversal( BinTree BT )&#123; if(!BT)return; BinTree que[101],t; int first=0,rear=0; que[rear++]=BT; while(first!=rear) &#123; t=que[first++]; printf(&quot; %c&quot;,t-&gt;Data); if(t-&gt;Left)que[rear++]=t-&gt;Left; if(t-&gt;Right)que[rear++]=t-&gt;Right; &#125;&#125; 6-3 先序输出叶结点 (15 分)123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT) &#123; if(!BT-&gt;Left&amp;&amp;!BT-&gt;Right) printf(&quot; %c&quot;,BT-&gt;Data); PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right); &#125;&#125; 6-4 二叉树的非递归遍历 (25 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void InorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); T = T-&gt;Left; &#125; T = Pop(S); printf(&quot; %c&quot;,T-&gt;Data); T=T-&gt;Right; &#125;&#125;void PreorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); printf(&quot; %c&quot;,T-&gt;Data); T = T-&gt;Left; &#125; T = Pop(S); T = T-&gt;Right; &#125;&#125;void PostorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); T-&gt;flag=0; T = T-&gt;Left; &#125; T = Peek(S); if(T-&gt;flag==0) &#123; T-&gt;flag++; T=T-&gt;Right; &#125; else&#123; T = Pop(S); printf(&quot; %c&quot;,T-&gt;Data); T = NULL; &#125; &#125;&#125; 编程题7-1 根据后序和中序遍历输出先序遍历 (25 分)1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* Creat(int *Post,int *In,int n)&#123; if(n&lt;=0)return NULL; int len=0; Node *p=new Node; p-&gt;data = *(Post+n-1); while(*(In+len)!=p-&gt;data)len++; p-&gt;left=Creat(Post,In,len); p-&gt;right=Creat(Post+len,In+len+1,n-len-1);//右子树……emmm……记住吧…… return p;&#125;void Preorder(Node *t)&#123; if(!t)return; cout&lt;&lt;&quot; &quot;&lt;&lt;t-&gt;data; Preorder(t-&gt;left); Preorder(t-&gt;right);&#125;int main()&#123; int n; cin&gt;&gt;n; int a[n],b[n]; Node *t; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; t=Creat(a,b,n); cout&lt;&lt;&quot;Preorder:&quot;; Preorder(t); return 0;&#125; 7-2 玩转二叉树 (25 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* creat(int *In,int *Pre,int n)&#123; if(n&lt;=0)return NULL; int len=0; while(*(In+len)!=*Pre)len++; Node *p=new Node; p-&gt;data=*(In+len); p-&gt;left=creat(In,Pre+1,len); p-&gt;right=creat(In+len+1,Pre+len+1,n-len-1);//n-len-1我也不清楚…… return p;&#125;void Level(Node *t,int n)&#123; if(!t)return; int first=0,last=0,i; Node* Q[n],*w; Q[last++]=t; while(last!=first) &#123; w=Q[first++]; //镜面也可以看做先右子树再左子树 if(w-&gt;right)Q[last++]=w-&gt;right; if(w-&gt;left)Q[last++]=w-&gt;left; &#125; for(i=0;i&lt;n-1;i++) cout&lt;&lt;Q[i]-&gt;data&lt;&lt;&quot; &quot;; cout&lt;&lt;Q[i]-&gt;data&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; int In[n],Pre[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;In[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;Pre[i]; Node* t=creat(In,Pre,n); Level(t,n); return 0;&#125; 7-3 树的遍历 (25 分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* creat(int* In,int* Post,int n)&#123; if(n&lt;=0)return NULL; int len=0; while(*(In+len)!= *(Post+n-1))len++; Node *p=new Node; p-&gt;data=In[len]; p-&gt;left=creat(In,Post,len); p-&gt;right=creat(In+len+1,Post+len,n-len-1); return p;&#125;void Level(Node* t,int n)&#123; int last=0,first=0,i; Node* Q[n],*w; Q[last++]=t; while(last!=first) &#123; w=Q[first++]; if(w-&gt;left)Q[last++]=w-&gt;left; if(w-&gt;right)Q[last++]=w-&gt;right; &#125; for(i=0;i&lt;n-1;i++) cout&lt;&lt;Q[i]-&gt;data&lt;&lt;&quot; &quot;; cout&lt;&lt;Q[i]-&gt;data&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; int In[n],Post[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;Post[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;In[i]; Node* t=creat(In,Post,n); Level(t,n); return 0;&#125; 7-4 哈夫曼编码 (30 分) 1 7-5 二叉搜索树的最近公共祖先 (30 分) 1 第六章 图判断题1-1 无向连通图所有顶点的度之和为偶数。T 1-2无向连通图至少有一个顶点的度为1。F 1-3 用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。T 1-4 在一个有向图中，所有顶点的入度与出度之和等于所有边之和的2倍。T 1-5如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。F 1-6在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。T 1-7 用一维数组G[]存储有4个顶点的无向图如下： 1G[] = &#123; 0, 1, 0, 1, 1, 0, 0, 0, 1, 0 &#125; 则顶点2和顶点0之间是有边的。T 1-8 Kruskal 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。F 1-9 Prim 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。T 1-10 若图G有环，则G不存在拓扑排序序列。T 1-11 若图G为连通图且不存在拓扑排序序列，则图G必有环。T 1-12 P 是顶点 S 到 T 的最短路径，如果该图中的所有路径的权值都加 1，P 仍然是 S 到 T 的最短路径。F 1-13 对于带权无向图 G = (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。F 1-14如果从有向图 G 的每一点均能通过深度优先搜索遍历到所有其它顶点，那么该图一定不存在拓扑序列。T 1-15 如果 e 是有权无向图 G 唯一的一条最短边，那么边 e 一定会在该图的最小生成树上。T 选择题2-1在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？ (1分) A. 是的肯定不同 B. 肯定是相同的 C. 有可能会不同 D. 以上全不对 2-2若要检查有向图中有无回路，除了可以利用拓扑排序算法外，下列哪种算法也可以用？ A. Dijkstra算法 B. Prim算法 C. 广度优先搜索 D. 深度优先搜索 2-3下图为一个AOV网，其可能的拓扑有序序列为： (2分) A. ABCDFEG B. ADFCEBG C. ACDFBEG D. ABDCEFG 2-4下列选项中，不是下图深度优先搜索序列的是： (2分) A. V1, V5, V4, V3, V2 B. V1, V3, V2, V5, V4 C. V1, V2, V5, V4, V3 D. V1, V2, V3, V4, V5 2-5 若将n个顶点e条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是： (1分) A. O(n) B. O(n+e) C. O(n2) D. O(n×e) 2-6 使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是： (2分) A. 5, 2, 3, 4, 6 B. 5, 2, 3, 6, 4 C. 5, 2, 4, 3, 6 D. 5, 2, 6, 3, 4 2-7 使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是： (2分) A. 6, 7, 5, 3, 2, 4 B. 6, 2, 5, 7, 3, 4 C. 2, 3, 4, 5, 6, 7 D. 2, 4, 3, 6, 5, 7 2-8设无向图为 G=(V，E)，其中 V={v1,v2,v3,v4}，E={(v1,v2)，(v3,v4)，(v4,v1)，(v2,v3)，(v1,v3)}。则每个顶点的度依次为： (2分) A. 2, 1, 1, 1 B. 1, 1, 2, 1 C. 3, 2, 3, 2 D. 2, 3, 2, 3 2-9 对于给定的有向图如下，其逆邻接表为： (2分) A. B. C. D. 2-10 已知一个无向图的顶点集为 {V0,V1,⋯,V7}，其邻接矩阵如下所示： 以下哪项不可能是从 V0 出发的广度优先遍历序？ (2分) A. V0,V1,V3,V4,V2,V6,V5,V7 B. V0,V3,V1,V4,V2,V6,V5,V7 C. V0,V3,V1,V4,V6,V2,V7,V5 D. V0,V4,V3,V1,V6,V2,V7,V5 2-11 给定一个图的邻接矩阵如下，则从V1出发的宽度优先遍历序列（BFS，有多种选择时小标号优先）是： (2分) A. V1, V2, V4, V3, V6, V8, V10, V9, V7, V5 B. V1, V2, V3, V4, V5, V6, V7, V9, V8, V10 C. V1, V2, V4, V6, V8, V10, V9, V7, V5, V3 D. V1, V2, V3, V5, V7, V9, V10, V6, V8, V4 2-12 给出如下图所示的具有 7 个结点的网 G，哪个选项对应其正确的邻接矩阵？ A. B. C. D. 2-13 已知无向图 G 如下所示，使用克鲁斯卡尔（Kruskal）算法求图 G 的最小生成树，加入到最小生成树中的边依次是： A. (b,f), (b,d), (a,e), (c,e), (b,e) B. (b,f), (b,d), (b,e), (a,e), (c,e) C. (a,e), (b,e), (c,e), (b,d), (b,f) D. (a,e), (c,e), (b,e), (b,f), (b,d) 2-14 若使用 AOE 网估算工程进度，则下列叙述中正确的是： (2分) A. 关键路径是从源点到汇点边数最多的一条路径 B. 关键路径是从源点到汇点路径长度最长的路径 C. 增加任一关键活动的时间不会延长工程的工期 D. 缩短任一关键活动的时间将会缩短工程的工期 2-15下列关于无向连通图特征的叙述中，正确的是： 所有顶点的度之和为偶数 边数大于顶点个数减1 至少有一个顶点的度为1 A.只有1 B.只有2 C.1和2 D.1和3 2-16若无向图G =（V，E）中含7个顶点，要保证图G在任何情况下都是连通的，则需要的边数最少是： (3分) A.6 B.15 C.16 D.21 2-17 具有N（N&gt;0）个顶点的无向图至少有多少个连通分量？ A.0 B.1 C.N−1 D.N 2-18用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是？ A. 无序的 B. 拓扑有序 C. 逆拓扑有序 D. 以上都不对 2-19若要求在找到从S到其他顶点最短路的同时，还给出不同的最短路的条数，我们可以将Dijkstra算法略作修改，增加一个count[]数组：count[V]记录S到顶点V的最短路径有多少条。则count[V]应该被初始化为： A. 对所有顶点都有count[V]=1 B. 对所有顶点都有count[V]=0 C. 1count[S]=1; `对于其他顶点`V`则令`count[V]=0 D. 1count[S]=0; `对于其他顶点`V`则令`count[V]=1 2-20任何一个带权无向连通图的最小生成树—— A. 是唯一的 B. 是不唯一的 C. 有可能不唯一 D. 有可能不存在 程序填空题函数题6-1 邻接矩阵存储图的深度优先遍历 (20 分)12345678910111213141516/*void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )&#123; //cout &lt;&lt; vertex[v]; Visit(V); Visited[V] = true; for (int j = 0; j &lt; Graph-&gt;Nv; j++) if (Graph-&gt;G[V][j] == 1 &amp;&amp; Visited[j] == false) DFS(Graph,j,Visit);&#125;*/void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )&#123; Visit(V); Visited[V]=true; for(int j=0;j&lt;Graph-&gt;Nv;j++) &#123; if(Graph-&gt;G[V][j]==1&amp;&amp;Visited[j]==false)DFS(Graph, j, Visit); &#125;&#125; 6-2 邻接表存储图的广度优先遍历 (20 分)1234567891011121314151617181920212223242526void BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) )&#123; int w,j,Q[MaxVertexNum]; int first=0,late=0; Visit(S); Visited[S]=true; Q[late++]=S; PtrToAdjVNode tmp; while(late!=first) &#123; w=Q[first++]; tmp=Graph-&gt;G[w].FirstEdge; while(tmp) &#123; Vertex pos=tmp-&gt;AdjV; if(!Visited[pos]) &#123; Visit(pos); Visited[pos]=true; Q[late++]=pos; &#125; tmp=tmp-&gt;Next; &#125; &#125;&#125; 编程题第七章 查找判断题（错题：1-1,1-4,1-6）1-1在散列中，函数“插入”和“查找”具有同样的时间复杂度。T 1-2 当记录个数小于哈希表长度时，哈希查找平均查找长度必然为0。F 1-3 用向量和单链表表示的有序表均可使用折半查找方法来提高查找速度。F 1-4有n个数存放在一维数组A[1..n]中，在进行顺序查找时，这n个数的排列有序或无序其平均查找长度不同。F 1-5 折半查找法的查找速度一定比顺序查找法快。F 1-6就平均查找长度而言，分块查找最小，折半查找次之，顺序查找最大。F 1-7 hash表的平均查找长度与处理冲突的方法无关。F 选择题(错题：2-9,2-10)2-1 用二分查找从100个有序整数中查找某数，最坏情况下需要比较的次数是： A.7 2-2 在有n（n&gt;1000）个元素的升序数组A中查找关键字x。查找算法的伪代码如下所示： 123456k = 0;while ( k&lt;n 且 A[k]&lt;x ) k = k+3;if ( k&lt;n 且 A[k]==x ) 查找成功;else if ( k-1&lt;n 且 A[k-1]==x ) 查找成功; else if ( k-2&lt;n 且 A[k-2]==x ) 查找成功; else 查找失败; 本算法与二分查找（折半查找）算法相比，有可能具有更少比较次数的情形是： B.当x接近数组开头处 2-3 下列二叉树中，可能成为折半查找判定树（不含外部结点）的是： A. 2-4 在顺序表（8,11,15,19,25,26,30,33,42,48,50）中，用二分（折半）法查找关键码值20，需做的关键码比较次数为( )。 B.4 2-5 顺序查找n个元素的顺序表，若查找成功，则比较关键字的次数最多为( )次。 (2分) A.n 2-6 输入一个正整数序列（53,17,12,66,58,70,87,25,56,60），按次序构造一棵二叉排序树BS为（ ）。 A. 2-7 在下列查找的方法中，平均查找长度与结点个数无关的查找方法是： C.利用哈希（散列）表 2-8 对哈希(HASH)函数H(k)= k MOD m, 一般来说,m应取 (2分) A.素数 2-9将元素序列{18, 23, 4, 26, 31, 33, 17, 39}按顺序插入一个初始为空的、大小为13的散列表中。散列函数为：H(Key)=Key%13，采用线性探测法处理冲突。问：当第一次发现有冲突时，散列表的装填因子大约是多少？ C.0.31 2-10现有长度为 11 且初始为空的散列表 HT，散列函数是 H(k**ey)=k**ey%7，采用线性探查（线性探测再散列）法解决冲突。将关键字序列 87,40,30,6,11,22,98,20 依次插入到 HT 后，HT 查找失败的平均查找长度是： C.6 2-11 设有一组关键字 { 29，01， 13，15，56，20，87，27，69，9，10，74 }，散列函数为 H(k**ey)=k**ey%17，采用线性探测方法解决冲突。试在 0 到 18 的散列地址空间中对该关键字序列构造散列表，则成功查找的平均查找长度为 __ D.1.33 2-12 设有一组关键字 { 29，01， 13，15，56，20，87，27，69，9，10，74 }，散列函数为 H(k**ey)=k**ey%17，采用平方探测方法解决冲突。试在 0 到 18 的散列地址空间中对该关键字序列构造散列表，则成功查找的平均查找长度为 __ C.1.25 填空题（错题：4-1）4-1执行以下程序， 123456789101112131415161718#include &lt;stdio.h&gt;int main( )&#123; int array[10]=&#123;2, 12, 24, 36, 48, 49, 2333, 6666, 23333, 99999&#125;; int key=2333, flag=0, low=0, m, h=9, times=0; while(low &lt;= h)&#123; m = (low + h) / 2; times++; if(array[m] == key) &#123; printf(&quot;Found-%d-%d&quot;, m, times); flag = 1; break; &#125; else if(array[m] &gt; key) h = m - 1; else low = m + 1; &#125; if(flag == 0) printf(&quot;Not Found!&quot;); return 0;&#125; 程序运行结果（即：在屏幕上打印的内容）是Found-6-4 。 （注意：要严格按照程序打印的格式填写答案，包括字母的大小写、空格的多少、连字符-和叹号!的格式等，不得随意增加引号、空格等无关字符，否则不得分。例如printf(&quot;hello World&quot;);打印的内容就是hello World，而不是&quot;hello World&quot;。为防止格式书写错误，建议直接从上面的代码中复制部分相关内容。） 4-2 顺序查找算法的平均查找长度 在下面的线性表中 1( 15, 24, 32, 47, 50, 58, 62, 79, 83, 96 ) 若采用顺序查找算法，假设各元素的检索概率相同，则平均查找长度为 5.5 4-3 二分查找算法的最大查找长度 在下面的有序表中 1( 15, 24, 32, 47, 50, 58, 62, 79, 83, 96 ) 若采用二分查找算法，则最大查找长度为 4 函数题6-1 二分查找 (20 分)123456789101112Position BinarySearch( List L, ElementType x )&#123; int high=L-&gt;Last,low=1,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(x&lt;L-&gt;Data[mid])high=mid-1; else if(x&gt;L-&gt;Data[mid])low=mid+1; else return mid; &#125; return NotFound;&#125; 6-2 线性探测法的查找函数 (20 分)12345678910111213141516Position Find( HashTable h, ElementType key )&#123; int p0,p; int num=0; p=p0=Hash(key,h-&gt;TableSize); while(h-&gt;Cells[p].Info!=Empty&amp;&amp;h-&gt;Cells[p].Data!=key) &#123; num++; if(num==MAXTABLESIZE) &#123; return ERROR; &#125; p=(p0+num)%h-&gt;TableSize; &#125; return p;&#125; 6-3 有序数组的插入 (20 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445/*bool Insert( List L, ElementType X )&#123; if(L -&gt; Last + 1 == MAXSIZE)//满了 return false; for (int i = 0; i &lt;= L -&gt; Last; i++ ) &#123; if (L -&gt; Data[i] == X) //已经有了 return false; else if (L -&gt; Data[i] &lt; X) &#123; for (int j = L -&gt;Last; j &gt;= i; j -- )//i之后的后移一位 &#123; L -&gt; Data[j + 1] = L -&gt; Data[j]; &#125; L-&gt;Data[i] = X; L-&gt;Last ++; break; &#125; else if (i==L-&gt;Last &amp;&amp; L-&gt;Data[i]&gt; X)//插在最后一位 &#123; L-&gt;Data[L-&gt;Last+1] = X; L-&gt;Last ++; break; &#125; &#125; return true;&#125;*/bool Insert( List L, ElementType X )&#123; if(L-&gt;Last==MAXSIZE-1)return false; int low=0,high=L-&gt;Last,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(L-&gt;Data[mid]&gt;X)low=mid+1; else if(L-&gt;Data[mid]&lt;X)high=mid-1; else return false; &#125; for(int i=L-&gt;Last;i&gt;high;i--) L-&gt;Data[i+1]=L-&gt;Data[i]; L-&gt;Data[high+1]=X; L-&gt;Last++; return true;&#125; 6-4 创建哈希表及查找(拉链法) (10 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445void CreateHash(HashTable HT[],int n)&#123; int x,num; HashNode *p; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; num=x%P; p=new HashNode; p-&gt;key = x; if(HT[num]==NULL) &#123; HT[num]=new HashNode; p-&gt;next=NULL; HT[num]-&gt;next=p; &#125; else &#123; p-&gt;next=HT[num]-&gt;next; HT[num]-&gt;next=p; &#125; &#125;&#125;float ASL(HashTable HT[])&#123; HashNode *p; int sum=0,len=0; for(int i=0;i&lt;P;i++) &#123; if(HT[i]==NULL)continue; else &#123; int cnt=1; p=HT[i]-&gt;next; while(p!=NULL) &#123; sum+=cnt; cnt++; len++; p=p-&gt;next; &#125; &#125; &#125; return sum*1.0/len;&#125; 编程题7-1 电话聊天狂人 (25 分) 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;string, int&gt; m; map&lt;string, int&gt;::iterator it;//迭代器（指针） int n, cnt = 0, people= 1; string s;//s存手机号 cin &gt;&gt; n; for (int i = 0; i &lt; n * 2; i++) &#123; cin &gt;&gt; s; m[s]++; &#125; for (it = m.begin(); it != m.end(); it++) &#123; if (it-&gt;second &gt; cnt) &#123;//第一个位置存储的second的大于人数，则 people = 1; s = it-&gt;first; cnt = it-&gt;second; &#125; else if (it-&gt;second == cnt) &#123;//电话狂人不唯一 people++;//电话狂人有几个 if (it-&gt;first &lt; s)//找最小的号码 s = it-&gt;first; &#125; &#125; cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; cnt; if (people != 1) cout &lt;&lt; &quot; &quot; &lt;&lt; people;&#125;//map容器 7-2 愤怒的牛 (25 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int a[100010];int l, r;int n,c; /*bool juge(int m)//判断距离m是否可以 &#123; int s = 0, last = 1;//记录上一个 for (int i = 2; i &lt;= n; i++)//依次枚举每个牛栏 &#123; if (a[i] - a[last]&lt;m)s++;//若此距离不满足当前答案，那么需要的牛栏数+1，即把当前牛放到下一个牛栏 else last = i;//否则就更新上一次的牛栏位置 ，即上一头牛放的位置 if (s&gt;n - c) return false;//若需要牛栏数大于最大牛栏数，此答案不可行 &#125; return true;&#125;*/ bool juge(int m) &#123; int ans = 1, last = 1; //因为第一个牛一定要占据第一个隔间（这样能使本题的答案最优），所以ans初始化为1 for (int i = 2; i &lt;=n; i++) &#123; if (a[i] - a[last] &gt;= m) &#123; ans++; //如果比最近距离要大的话，那么该隔间就放牛 last = i; &#125; &#125; if (ans &gt;= c)return true; //如果所选取的隔间数量&gt;=c，则说明枚举的最近距离成立，但是不够大，所以return true,继续枚举更大的距离 return false;&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;=n; i++)cin &gt;&gt; a[i]; l = 1; r = a[n] - a[1]; //右边界为n个隔间的总长度，最近距离一定小于等于这个数值 sort(a + 1, a + 1 + n); while (l &lt;=r) &#123; int mid = (l + r)/2; if (juge(mid))l = mid+1; //如果当前枚举的最近距离符合，那么就让l=mid,看更大的距离是否也符合（因为要求最大的最近距离） else r = mid-1; &#125; cout &lt;&lt; r&lt;&lt; endl; //由于最后l&lt;=r的时候还会运行一次，会让l-1(如果答案正确的话)，所以应该输出的是r return 0;&#125; 第八章 排序判断题1-1 仅基于比较的算法能得到的最好的“最坏时间复杂度”是O(NlogN)。T 1-2 对N个记录进行简单选择排序，比较次数和移动次数分别为O(N2)和O(N)。T 1-3 对N个记录进行快速排序，在最坏的情况下，其时间复杂度是O(NlogN)。F 1-4 希尔排序是稳定的算法。F 1-5 堆排序是稳定的排序算法。F 1-6 在堆排序中，若要进行升序排序，则需要建立大根堆。T 1-7 排序算法中的比较次数与初始元素序列的排列无关。F 1-8 排序的稳定性是指排序算法中的比较次数保持不变，且算法能够终止。F 1-9 对于n个记录的集合进行冒泡排序，在最坏情况下需要的时间是O(n2)。T 1-10 直接选择排序的时间复杂度为O(n2)，不受数据初始排列的影响。T 选择题(错题：2-6,2-11,2-12,2-13)2-1 对N个不同的数据采用冒泡算法进行从大到小的排序，下面哪种情况下肯定交换元素次数最多？ A.从小到大排好的 2-2 在对N个元素进行排序时，基于比较的算法中，其“最坏时间复杂度”中最好的是： C.O(Nlog**N) 2-3 对N个记录进行归并排序，归并趟数的数量级是： A.O(log**N) 2-4 有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为： D.84，79，56，38，40，46 2-5 采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是： C.递归次数与每次划分后得到的分区处理顺序无关 2-6有组记录的排序码为{46，79，56，38，40，84 }，采用快速排序（以位于最左位置的对象为基准而）得到的第一次划分结果为： D.{40,38,46,56,79,84} 2-7 对于10个数的简单选择排序，最坏情况下需要交换元素的次数为： A.9 将序列{ 2, 12, 16, 88, 5, 10, 34 }排序。若前2趟排序的结果如下： 第1趟排序后：2, 12, 16, 10, 5, 34, 88 第2趟排序后：2, 5, 10, 12, 16, 34, 88 则可能的排序算法是： C.快速排序 2-9 对初始数据序列{ 8, 3, 9, 11, 2, 1, 4, 7, 5, 10, 6 }进行希尔排序。若第一趟排序结果为（ 1, 3, 7, 5, 2, 6, 4, 9, 11, 10, 8 ），第二趟排序结果为（ 1, 2, 6, 4, 3, 7, 5, 8, 11, 10, 9 ），则两趟排序采用的增量（间隔）依次是： D.5, 3 2-10 下列排序算法中，占用辅助空间最多的是：( ) A.归并排序 2-11选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是： I、数据的规模 II、数据的存储方式 III、算法的稳定性 IV、数据的初始状态 D.I、II、III、IV 2-12 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列序列中，不可能是快速排序第二趟结果的是： D.5, 2, 12, 28, 16, 32, 72, 60 2-13 对大部分元素已有序的数组进行排序时，直接插入排序比简单选择排序效率更高，其原因是： (I). 直接插入排序过程中元素之间的比较次数更少 (II). 直接插入排序过程中所需要的辅助空间更少 (III). 直接插入排序过程中元素的移动次数更少 A.仅 I 2-14 下述几种排序方法中,( )是稳定的排序方法。 C.归并排序 填空题4-1 基于比较的排序方法，其最好的时间复杂度为O(nlogn) 4-2 时间复杂度为O(nlogn)的排序算法有归并排序、堆排序和快速排序 4-3对包含10个记录的表r[1..10]进行简单选择排序，所需进行的关键字间的比较次数为45 函数题6-1 快速排序 (15 分)12345678910111213141516171819202122int Partition(SqList &amp;L,int low,int high)&#123; int i=low,j=high; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;L.r[i].key&lt;=L.r[j].key)j--; if(i&lt;j)&#123;swap(L.r[i].key,L.r[j].key);i++;&#125; while(i&lt;j&amp;&amp;L.r[i].key&lt;=L.r[j].key)i++; if(i&lt;j)&#123;swap(L.r[i].key,L.r[j].key);j--;&#125; &#125; return i;&#125;void QuickSort(SqList &amp;L, int low, int high)&#123; if(low&gt;=high)return; else &#123; int pivot=Partition(L,low,high); QuickSort(L,low,pivot-1); QuickSort(L,pivot+1,high); &#125;&#125; 6-2 冒泡排序 (10 分)1234567891011void bubbleSort(int arr[], int n)&#123; int i,j; for(i=0;i&lt;n-1;i++) &#123; for(j=0;j&lt;n-i-1;j++) &#123; if(arr[j]&gt;arr[j+1])swap(&amp;arr[j],&amp;arr[j+1]); &#125; &#125;&#125; 6-3 简单选择排序 (10 分)1234567891011121314void SelectSort(SqList L)&#123; int i,j,mini,temp; int n = L.Length; for(i=1;i&lt;n;i++) &#123; mini=i; for(j=i+1;j&lt;n+1;j++) &#123; if(L.elem[mini]&gt;L.elem[j])mini=j; &#125; if(mini!=i)&#123;temp=L.elem[i];L.elem[i]=L.elem[mini];L.elem[mini]=temp;&#125; &#125;&#125; 6-4 堆排序 (10 分)12345678910111213141516171819void HeapAdjust( HeapType H, int s, int m)&#123; int dad,son,last,temp; dad=s;son=2*dad,last=m; while(son&lt;=last) &#123; if(son+1&lt;=last&amp;&amp;H.elem[son]&lt;H.elem[son+1])son++; if(H.elem[dad]&gt;H.elem[son])return; else &#123; temp=H.elem[son]; H.elem[son]=H.elem[dad]; H.elem[dad]=temp; dad=son; son=dad*2; &#125; &#125;&#125; 6-5 归并排序 (10 分)12345678910111213141516171819202122void Merge(SqList L,int low,int m,int high)&#123; int Q[high-low+1]; int i=low,j=m+1,k=0; while(i&lt;=m&amp;&amp;j&lt;=high) &#123; if(L.elem[i]&gt;=L.elem[j]) &#123; Q[k++]=L.elem[j++]; &#125; else if(L.elem[i]&lt;=L.elem[j]) &#123; Q[k++]=L.elem[i++]; &#125; &#125; while(i&lt;=m)Q[k++]=L.elem[i++]; while(j&lt;=high)Q[k++]=L.elem[j++]; for(int i=low,k=0;i&lt;=high;i++) &#123; L.elem[i]=Q[k++]; &#125;&#125; 编程题7-1 字符串的冒泡排序 (20 分) 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; string arr[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; &#125; for(int i=0;i&lt;n-1;i++) &#123; for(int j=0;j&lt;n-i-1;j++) &#123; if(arr[j]&gt;arr[j+1])swap(arr[j],arr[j+1]); &#125; if(i==k-1)break; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i]&lt;&lt;endl; return 0;&#125; 7-2 模拟EXCEL排序 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*#include&lt;iostream&gt;using namespace std;struct Info&#123; string id; string name; int score;&#125;;int main()&#123; int n,c,mini; cin&gt;&gt;n&gt;&gt;c; Info arr[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i].id&gt;&gt;arr[i].name&gt;&gt;arr[i].score; &#125; if(c==1) &#123; for(int i=0;i&lt;n-1;i++) &#123; mini=i; for(int j=i+1;j&lt;n;j++) &#123; if(arr[mini].id&gt;arr[j].id)mini=j; &#125; if(mini!=i)swap(arr[mini],arr[i]); &#125; &#125; else if(c==2) &#123; int exchange,bound,temp; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].id&gt;arr[j+1].id)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].name&gt;arr[j+1].name)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; &#125; else if(c==3) &#123; int exchange,bound,temp; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].id&gt;arr[j+1].id)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].score&gt;arr[j+1].score)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i].id&lt;&lt;&quot; &quot;&lt;&lt;arr[i].name&lt;&lt;&quot; &quot;&lt;&lt;arr[i].score&lt;&lt;endl; return 0;&#125;*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt; using namespace std;const int maxn = 100000 + 7;int n, c; struct node &#123; int id, sc; char name[22];&#125;a[maxn]; bool cmp1(node a, node b) &#123; return a.id &lt; b.id;&#125;bool cmp2(node a, node b) &#123; if(strcmp(a.name, b.name) == 0) return a.id &lt; b.id; return strcmp(a.name, b.name) &lt; 0;&#125;bool cmp3(node a, node b) &#123; if(a.sc == b.sc) return a.id &lt; b.id; return a.sc &lt; b.sc;&#125; int main() &#123; //char s[22], t[22]; //scanf(&quot;%s %s&quot;, s, t); //printf(&quot;%d\\n&quot;, strcmp(s, t)); scanf(&quot;%d %d&quot;, &amp;n, &amp;c); for(int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d %s %d&quot;, &amp;a[i].id, a[i].name, &amp;a[i].sc); &#125; if(c == 1) sort(a, a+n, cmp1); if(c == 2) sort(a, a+n, cmp2); if(c == 3) sort(a, a+n, cmp3); for(int i = 0; i &lt; n; ++i) printf(&quot;%.6d %s %d\\n&quot;, a[i].id, a[i].name, a[i].sc); return 0;&#125; 7-3 悄悄关注 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/*#include&lt;iostream&gt;using namespace std;struct Info&#123; string name; int zan;&#125;;int main()&#123; int n1,n2,avg=0; cin&gt;&gt;n1; string guanzhu[n1]; for(int i=0; i&lt;n1; i++) cin&gt;&gt;guanzhu[i]; cin&gt;&gt;n2; Info dianzan[n2],temp[n2]; for(int i=0; i&lt;n2; i++) &#123; cin&gt;&gt;dianzan[i].name&gt;&gt;dianzan[i].zan; avg+=dianzan[i].zan; &#125; avg /= n2; int flag=1,k=0; for(int i=0; i&lt;n2; i++) &#123; for(int j=0; j&lt;n1; j++) &#123; if(guanzhu[j]==dianzan[i].name) &#123; flag=0; break; &#125; &#125; if(flag&amp;&amp;dianzan[i].zan&gt;avg) &#123; temp[k++]=dianzan[i]; &#125; flag=1; &#125; if(k==0)cout&lt;&lt;&quot;Bing Mei You&quot;&lt;&lt;endl; else &#123; for(int i=0; i&lt;k-1; i++) &#123; int mini=i; for(int j=i+1; j&lt;k; j++) &#123; if(temp[j].name&lt;temp[mini].name)mini=j; &#125; if(mini!=i)swap(temp[mini],temp[i]); &#125; for(int i=0; i&lt;k; i++) cout&lt;&lt;temp[i].name&lt;&lt;endl; &#125; return 0;&#125;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;struct Info&#123; string name; int zan;&#125;;struct List&#123; Info dianzan[10000];&#125;;int Partition(List &amp;l,int first,int last)&#123; int i=first,j=last; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;l.dianzan[i].name&lt;=l.dianzan[j].name)j--; if(i&lt;j) &#123; swap(l.dianzan[i],l.dianzan[j]); i++; &#125; while(i&lt;j&amp;&amp;l.dianzan[i].name&lt;l.dianzan[j].name)i++; if(i&lt;j) &#123; swap(l.dianzan[i],l.dianzan[j]); j--; &#125; &#125; return i;&#125;void quicksort(List&amp;l,int first,int last)&#123; if(first&gt;=last)return; else &#123; int mid=Partition(l,first,last); quicksort(l,first,mid-1); quicksort(l,mid+1,last); &#125;&#125;int main()&#123; int n1,n2,zan,sum=0,flag=1,k=0; string name; List l; set&lt;string&gt; guanzhu; cin&gt;&gt;n1; for(int i=0;i&lt;n1;i++) &#123; cin&gt;&gt;name; guanzhu.insert(name); &#125; cin&gt;&gt;n2; for(int i=0;i&lt;n2;i++) &#123; cin&gt;&gt;name&gt;&gt;zan; sum+=zan; if(guanzhu.find(name)==guanzhu.end()) &#123; l.dianzan[k].name=name; l.dianzan[k++].zan=zan; &#125; &#125; sum/=n2; quicksort(l,0,k); for(int i=0;i&lt;k;i++) &#123; if(l.dianzan[i].zan&gt;=sum) &#123; cout&lt;&lt;l.dianzan[i].name&lt;&lt;endl; flag=0; &#125; &#125; if(flag)cout&lt;&lt;&quot;Bing Mei You&quot;&lt;&lt;endl; return 0;&#125;*/#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;int main()&#123; int n,m,i,j,k=0,s=0,f=0,a,fag=0; string s1,s2; map&lt;string,int&gt;p; set&lt;string&gt;p1; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;s1; p[s1]=0; &#125; cin&gt;&gt;m; int c[m]; char b[m][10]; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;s2&gt;&gt;a; s=s+a; if(p.find(s2)==p.end()) &#123; for(j=0;j&lt;sizeof(s2);j++) &#123; b[k][j]=s2[j]; &#125; c[k]=a; k++; &#125; else &#123; p[s2]=a; &#125; &#125; s=s/m; for(i=0;i&lt;k;i++) &#123; if(c[i]&gt;s) &#123; p1.insert(b[i]); f++; fag=1; &#125; &#125; if(fag==0) &#123; printf(&quot;Bing Mei You&quot;); &#125; else &#123; set&lt;string&gt;::iterator it; for(it=p1.begin();it!=p1.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://zhang0224gz.github.io/tags/PTA/"}]},{"title":"静态博客的创建","slug":"静态博客的建立","date":"2021-12-04T11:35:25.302Z","updated":"2021-12-11T07:50:01.476Z","comments":true,"path":"2021/12/04/静态博客的建立/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/","excerpt":"","text":"下载node​ D:\\my app\\nodejs github注册​ -&gt;Zhang2002GZ.github.io（用户名.github.io） 下载git​ git for windows-&gt;cmd+r: git（D:\\my app\\Git） SHH配置 (1)git_bash打开:$ ssh-keygen -t rsa -C “&#50;&#50;&#53;&#x31;&#55;&#x38;&#55;&#57;&#50;&#x33;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;“-&gt;回车(4次)直至结束 记住这行Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa) 括号里面的地址是后面要用到的 (2)打开github-&gt;setting-&gt;SHH:title:Zhang2002GZ ;key:粘贴文本文档 user-&gt;zhangguozhi-&gt;.ssh-&gt;.pub 在github上建秘钥 hexo使用​ -&gt;文档 npm install hexo-cli -g //安装 hexo init blog //初始化博客 cd blog npm install //hexo server 新建目录blog-&gt;cmd+r-&gt;D:-&gt;cd blog-&gt;npm install hexo-cli -g-&gt;hexo init myblog-&gt;cd myblog-&gt;npm install -&gt;hexo s -p 4000 浏览器输入网址：localhost:4000 sublime安装​ -&gt;将博客目录直接拖进-&gt;## hello hexo hexo发布至github hexo-&gt;文档-&gt;部署repo sublime-&gt;_config.yml 1234567891011开头： \\# URL \\## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27; **url**: https://Zhang2002GZ.github.io末尾 \\# Deployment \\## Docs: https://hexo.io/docs/one-command-deployment deploy: **type: git repo: https://github.com/Zhang2002GZ/Zhang2002GZ.github.io.git branch: master** hexo-&gt;文档-&gt;部署 hexo g-&gt;npm install hexo-deployer-git –save-&gt;hexo d 123type: git repository: https://github.com/zhang2002gz/zhang2002gz.github.io.git branch: main hexo init( Start blogging with Hexo!)-&gt;静态生成本地的hexo页面hexo s(打开本地服务器：将http://localhost:4000可以看见博客；ctrl+c关闭服务器就看不见页面） -&gt;npm install hexo-deployer-git –save-&gt;生成页面hexo g-&gt;将本地文件上传github hexo d （error10054:这个保错就执行git config –global http.sslVerify “false”） **!**登入页面弹窗只在第一次创建的时候出现 美化 git clone https://github.com/theme-nexmoe/hexo-theme-nexmoe.git themes/nexmoe (git clone 改页面代码所在地址.git 存到themes目录下/新建的nexmoe) sublime修改_config.yml:theme: nexmoe 也可以在release里下载压缩包将它解压到themes中 npm install –save hexo-renderer-pug git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun theme: sbun 清理一下hexo clean ,生成一下 hexo g,hexo s(打开服务器），hexo d(上传） 其他检查： 123456789101112node -v git --version npm -v hexo -vssh $ ssh -T git@github.com （Hi zhang2002gz! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.）查看npm安装hexo插件的情况 npm ls --depth 0安装缺失的插件 npm install acorn --save 万能三件套： 12345git config --global --unset http.proxygit config --global --unset https.proxygit config --global http.sslVerify &quot;false&quot; 一些pure主题的配置hexo-theme-pure/README.cn.md at master · cofess/hexo-theme-pure (github.com) 1234567891011121314151617181920212223242526272829文章索引目录title: 文章标题categories: - 文章分类tags: - 文章标签toc: true # 是否启用内容索引sidebar侧边栏文章侧边栏默认为开启状态，如果某篇文章不想开启侧边栏，在文章开头配置加入“sidebar: none”即可：title: 文章标题categories: - 文章分类tags: - 文章标签sidebar: none # 是否启用sidebar侧边栏，none：不启用友情链接Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot; 安装主题git clone https://github.com/cofess/hexo-theme-pure.git themes/pure更新主题cd themes/puregit pull 相关视频【2021最新版】保姆级Hexo+github搭建个人博客_哔哩哔哩_bilibili Hexo博客开发之——WARN No layout index.html - 程序员大本营 (pianshen.com) 12345678910111213141516Git 全局设置: git config --global user.name &quot;zhang-guozhi&quot; git config --global user.email &quot;10094335+zhang-guozhi@user.noreply.gitee.com&quot; 创建 git 仓库: mkdir zhang-guozhi cd zhang-guozhi git init touch README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://gitee.com/zhang-guozhi/zhang-guozhi.git git push -u origin master 已有仓库? cd existing_git_repo git remote add origin https://gitee.com/zhang-guozhi/zhang-guozhi.git git push -u origin master","categories":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/categories/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-11-27T13:15:34.628Z","updated":"2021-11-27T13:15:34.628Z","comments":true,"path":"2021/11/27/hello-world/","link":"","permalink":"https://zhang0224gz.github.io/2021/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"},{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"},{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/categories/%E5%88%9D%E5%A7%8B%E5%8C%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"},{"name":"PTA","slug":"PTA","permalink":"https://zhang0224gz.github.io/tags/PTA/"}]}