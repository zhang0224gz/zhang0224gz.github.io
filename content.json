{"meta":{"title":"Hexo","subtitle":"","description":"","author":"zhang0224gz","url":"https://zhang0224gz.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-01-10T12:34:35.638Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"books/index.html","permalink":"https://zhang0224gz.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"tags/index.html","permalink":"https://zhang0224gz.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"categories/index.html","permalink":"https://zhang0224gz.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-10T12:34:35.626Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"about/index.html","permalink":"https://zhang0224gz.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2021-12-04T10:33:16.481Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"repository/index.html","permalink":"https://zhang0224gz.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":true,"path":"links/index.html","permalink":"https://zhang0224gz.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"两个蓝牙的配置","slug":"智能车/两个蓝牙的配置","date":"2022-04-18T02:16:09.468Z","updated":"2022-04-19T01:06:18.682Z","comments":true,"path":"2022/04/18/智能车/两个蓝牙的配置/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/18/%E6%99%BA%E8%83%BD%E8%BD%A6/%E4%B8%A4%E4%B8%AA%E8%93%9D%E7%89%99%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配蓝牙视频https://www.bilibili.com/video/BV1zW411y7vq/?spm_id_from=333.788.recommend_more_video.-1（我比较偏爱这个英文版，看完了再看下面的）https://www.bilibili.com/video/BV1ii4y1s79z 设置从机（电脑端：接受）COM-CH-&gt;端口号设置主机（小车：发送）XCOM-&gt;端口号 （usb转ttl接口和接收蓝牙引脚：tx接rx, rx接tx）（注意插在小车上的蓝牙和小车的插针/引脚是否也是tx接rx, rx接tx）UART4_RX_C11UART4_TX_C10 以XCOM软件分别配置主从蓝牙为例 第一步：进入AT模式按住蓝牙上黑色按钮将usb转ttl插在电脑上放下，显示结果：蓝牙每隔一秒亮一次调好软件波特率和COM串口，打开串口（蓝牙调试软件使用此默认波特率：38400）（串口查看：此电脑-&gt;右键菜单：管理-&gt;设备管理器-&gt;端口(COM和LPT)-&gt;USB-SERIAL CH340(COM x）)发送框中输入AT：黑窗口有ok即成功，可以进行蓝牙配置！！！使用XCOM软件只能该行输入不能有回车,可以输完使用ctrl+enter！ 第二步：配置蓝牙有两个usb转ttl时，能同时插在电脑上配置的情况：恢复出厂设置AD+ORGL-&gt;获得配对码-&gt;主从模式-&gt;绑定从机地址(恢复出厂设置-&gt;使用和从机一致的配对码AT+PSWD-&gt;从机模式-&gt;查询地址-&gt;波特率)-&gt;设置波特率-&gt;确定波特率-&gt;连接地址只有一个usb转ttl时，先配置从机（电脑）再配置主机（小车）-&gt;这里分开配置 第三步：配置从机恢复默认设置：AT+ORGL配置配对码：AT+PSWD=“0000”(主从机要一致）配置为从机模式：AT+ROLE=0查询从机的地址：AT+ADDR?（栗子：+ADDR:98d3:34:912ba8，主机绑定时要冒号变逗号）设置波特率：AT+UART=115200,0,0 第四步：配置主机恢复默认设置：AT+ORGL配置配对码：AT+PSWD=“0000”(主从机要一致）配置为从机模式：AT+ROLE=1主机绑定从机地址：AT+BIND=98d3,34,912ba8（注意把地址的冒号换成逗号）设置波特率：AT+UART=115200,0,0 第五步：确定是否配置成功重新插上，不按按钮，呈灯不断闪烁；然后等两蓝牙连接连接成功是每秒闪一次，一次闪两下，两灯同时两同时灭如果连接失败，重新配置一次。 PS：查询主从机 AT+ROLE?https://blog.csdn.net/DaMercy/article/details/102514684https://blog.csdn.net/weixin_42417585/article/details/105232263发送在黑窗口不显示：1.波特率配置错了，2.命令写错了，检查 3.是否多按了一个回车键 第六步：连接Visual Scope菜单栏找到Setup选择Communication Setup在界面里只更改波特率115200（根据蓝牙设置的波特率)和串口COM x（蓝牙的串口）选择Communication Protocal勾选CRC16配置完成 第七步：代码初始化：uart_init(UART_4,115200,UART4_TX_C10,UART4_RX_C11); （在zf_uart.c中)UART_x根据硬件选择引脚(我们硬件选的C10和C11在zf_uart.h中找到就是UART_4)在while或中断中调用data_conversion(int16 data1, int16 data2, int16 data3, int16 data4, uint8 dat)函数（在SEEKFREE_VIRSCO.c中）前四个是Visual Scope显示的自己选择放置，后面dat改为virtual_scope_data（在SEEKFREE_VIRSCO.h中）将data_conversion函数中**//uart_putbuff(UART_1,dat,10);** 取消注释(打开)并将UART_1更改为使用的UART_x 第八步：确定代码是否正确下载程序，打开小车电源和电机电源（因为我观察的是电机PID）点击Visual Scope中RUN按钮（右下角）点击Visual Scope中RESUME按钮（左上角绿色三角）若能看见线不断地变化（我给的变化量）则成功不使用点击Visual Scope中STOP按钮保存菜单栏File-&gt;Save 附录","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"总结","slug":"刷题/总结","date":"2022-04-06T02:26:51.915Z","updated":"2022-04-19T01:10:21.665Z","comments":true,"path":"2022/04/06/刷题/总结/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/06/%E5%88%B7%E9%A2%98/%E6%80%BB%E7%BB%93/","excerpt":"","text":"全排列\\DFS(深度优先搜索算法)\\堆排序算法 枚举法C(m,n)12345678910111213141516171819202122232425int n;//共计N个数int m;//选m个数vector&lt;int&gt; chosen;void calc(int x) &#123; if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝:超过m和选不够m return; if (x == n + 1) &#123; //选够了m个数输出 for (int i = 0; i &lt; chosen.size(); i++) printf(&quot;%d &quot;, chosen[i]); //也可以不输出，存放起来也是可以的，主要是看题目。 puts(&quot;&quot;); return; &#125; //选x calc(x + 1); chosen.push_back(x); //不选x calc(x + 1); chosen.pop_back();//消除痕迹&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; calc(1);&#125; A(m,n)123456789101112131415161718192021222324252627282930int n; //共计N个数int order[20];bool chosen[20];void calc(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; order[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (chosen[i])//选过跳过 continue; order[k] = i; chosen[i] = 1;//标准搜索方式 calc(k + 1);//回溯并恢复现场 chosen[i] = 0; order[k] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; calc(1);&#125; 常用STL库stack模板12345678910111213141516171819top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。push(const T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。push(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。pop()：弹出栈顶元素。size()：返回栈中元素的个数。 vector容器123456789#include &lt;vector&gt; //头文件vector&lt;int&gt; a; //定义了一个int类型的vector容器avector&lt;int&gt; b[100]; //定义了一个int类型的vector容器b组struct rec&#123; ···&#125;;vector&lt;rec&gt; c; //定义了一个rec类型的vector容器cvector&lt;int&gt;::iterator it; //vector的迭代器，与指针类似 123456789a.size() //返回实际长度（元素个数），O(1)复杂度a.empty() //容器为空返回1，否则返回0，O(1)复杂度a.clear() //把vector清空a.begin() //返回指向第一个元素的迭代器，*a.begin()与a[0]作用相同a.end() //越界访问，指向vector尾部，指向第n个元素再往后的边界a.front() //返回第一个元素的值，等价于*a.begin和a[0]a.back() //返回最后一个元素的值，等价于*--a.end()和a[size()-1]a.push_back(x) //把元素x插入vector尾部a.pop_back() //删除vector中最后一个元素 1234for ( vector&lt;int&gt;::iterator it=a.begin() ; it!=a.end() ; it++ )cout&lt;&lt;*iterator&lt;&lt;endl;for( int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; 队列 Queue12queue&lt;string&gt; myqueue;queue&lt;int&gt; myqueue_int; 123456front()：返回 queue 中第一个元素的引用。back()：返回 queue 中最后一个元素的引用。push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。pop()：删除 queue 中的第一个元素。size()：返回 queue 中元素的个数。empty()：如果 queue 中没有元素的话，返回 true。 Map 映射12map&lt;char, int&gt; mymap1;map&lt;string, int&gt; mymap2; 12345678910111213141516171819202122232425261.看容量int map.size();//查询map中有多少对元素bool empty();// 查询map是否为空2.插入map.insert(make_pair(key,value));//或者map.insert(pair&lt;char, int&gt;(key, value))//或者map[key]=value3.取值map&lt;int, string&gt; map;//如果map中没有关键字2233，使用[]取值会导致插入//因此，下面语句不会报错，但会使得输出结果结果为空cout&lt;&lt;map[2233]&lt;&lt;endl;//但是使用使用at会进行关键字检查，因此下面语句会报错map.at(2016) = &quot;Bob&quot;;4.遍历操作map&lt;string, string&gt;::iterator it;for (it = mapSet.begin(); it != mapSet.end(); ++it)&#123; cout &lt;&lt; &quot;key&quot; &lt;&lt; it-&gt;first &lt;&lt; endl; cout &lt;&lt; &quot;value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;5.查找操作m.count(key)：//由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。m.find(key)：//返回迭代器，判断是否存在。 差分与前缀和差分与前缀和是一对互逆的操作，常常用于处理区间问题，差分法是解决区间加减问题，前缀和是解决区间求和问题的常用办法。 差分法的应用主要是用于处理区间问题。当某一个数组要在很多不确定的区间，加上相同的一个数。 如果我们采用差分法，将数组拆分，构造出一个新的拆分数组，通过对数组区间的端点进行加减操作，最后将数组和并就能完成原来的操作。 b[1]=a[1] b[i] = a[i]-a[i-1] b[l,r] + N = b[l]+N, b[r+1]-N b[1]=b[1] b[i] = b[i]+b[i-1]; 前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和。 如果我们采用前缀和，构造出一个前缀和数组，通过对于端点的值的减法操作就能 O(1) 的求出 [l,r] 的和。然后 N 次查询的,就将复杂度降低为 O(n) a[1]=a[1]; sum[i] += sum[i-1]+a[i]; 或 a[i]+=a[i-1]; sum[l,r] = sum[r] - sum[l - 1] 哈希12345678910111213141516const long long h = 999983;int b = 131;int Hx(string s)&#123; int n = s.size(); int sum1 = 0; for (int i = 0; i &lt; n; i++) &#123; sum1 = sum1 * 131 % h + (s[i] - &#x27;a&#x27; + 1) % h; &#125; return (sum1 + h) % h;&#125; 递推和递归12345678910111213141516//递推开始:从尾部开始 for (int i=n-1; i&gt;=1; i--)//从最后一层逆推 &#123; for (int j=1; j&lt;=i; j++) &#123; if (a[i+1][j]&gt;=a[i+1][j+1]) a[i][j]+=a[i+1][j]; //路径选择 else a[i][j]+=a[i+1][j+1]; &#125; &#125; cout&lt;&lt;a[1][1]&lt;&lt;endl; 二分法12345678910111213141516171819202122// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high)&#123; int mid = (low + high) / 2; if (a[mid] &gt;= x) high = mid; else low = mid + 1;&#125;// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high)&#123; int mid = (low + high + 1) / 2; if (a[mid] &lt;= x) low = mid; else high = mid - 1;&#125; 其他123456789#include&lt;iomanip&gt; //用于浮点数输出cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l; //一般使用print //printf(&quot;%x.yf&quot;,n) //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0 //y是保留小数位数，不够补零 //printf(&quot;%.7f&quot;,l); 12345678910#include &lt;iostream&gt;#include &lt;numeric&gt;using namespace std;int main()&#123; int array[]=&#123;1,2,3,4,5,6,7,8,9&#125;;//定义数组array int sum = accumulate(array,array+size(array),0); cout &lt;&lt; &quot;数组的和 = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617181920#include&lt;string.h&gt;//数组全部置0memset(move, 0, sizeof(move));#include&lt;algorithm&gt;bool judge(Cach a,Cach b)&#123; return a.avg&gt;b.avg;&#125;sort(cash,cash+n,judge);#include&lt;iomanip&gt;cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l; //一般使用print //printf(&quot;%x.yf&quot;,n) //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0 //y是保留小数位数，不够补零 //printf(&quot;%.7f&quot;,l); 123//映射：对称的奇偶可以有一样的值from = (from - 1)/2;to = (to - 1)/2;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zhang0224gz.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"涉及的C/C++的知识点","slug":"刷题/编程知识点","date":"2022-04-03T04:00:52.435Z","updated":"2022-04-19T01:12:35.335Z","comments":true,"path":"2022/04/03/刷题/编程知识点/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/03/%E5%88%B7%E9%A2%98/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.二维数组作为函数参数传入静态数组（维数确定）二维数组作为函数的参数，实参可以直接使用二维数组名，在被调用函数中可以定义形参所有维数的大小，也可以省略以为大小的说明。例如： 12void find（char a[3][10]）;void find (char a[ ][10]); 也可以使用数组指针来作为函数参数，例如： 1void find （char (*p)[10]); 但是不能像下面这样使用，例如： 12void find（char a[ ][ ]）;void find (char a[3][ ]); 因为从实参传递来的是数组的起始地址，如果在形参中不说明列数，编译器将无法定位元素的的位置。 栗子： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;void range(char str[ ][100]);//传进二维数组int main(void)&#123; char str[8][100]; int i; for(i=0;i&lt;8;i++) gets(str[i]); range(str); for(i=0;i&lt;8;i++) printf(&quot;%s\\n&quot;,str[i]);&#125; void range(char str[ ][100])&#123; int i,j; char temp[100]; for(i=0;i&lt;8-1;i++) &#123; for(j=0;j&lt;8-i-1;j++) &#123; if(strcmp(str[j],str[j+1])&gt;0) &#123; strcpy(temp,str[j]); strcpy(str[j],str[j+1]); strcpy(str[j+1],temp); &#125; &#125; &#125; &#125; 动态数组（维数不确定）如果不确定二维数组的维数的话，我们不能使用上面的方法，可以用下面的方法： 手工转变寻址方式对于数组 int p[m][n]; 如果要取p[i][j]的值（i&gt;=0 &amp;&amp; m&lt;=0 &amp;&amp; j&gt;=0 &amp;&amp; n&lt;=0)，编译器是这样寻址的，它的地址为：p + (i*n + j) ; 二维数组的定义并非一个确定的值，也就是动态数组，这时候我们如果像之前那样进行函数调用就会报错，错误提示为: 1[Error] cannot convert &#x27;int (*)[N]&#x27; to &#x27;int**&#x27; for argument &#x27;2&#x27; to &#x27;int threeOrder_evaluation(int, int**)&#x27; 1void printf_int(int hhh[][Dim]); 所以我们只能这样来调用 1void printf_int(int** hhh); C++ Code:动态分配数组内存的六种方法1、利用“malloc-free”动态分配一维数组：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;stdlib.h&gt; //该头文件为malloc必须 using namespace std;int main()&#123; int len; int *p; cout&lt;&lt;&quot;请输入开辟动态数组的长度：&quot;&lt;&lt;endl; cin&gt;&gt;len; //长度乘以int的正常大小，才是动态开辟的大小 p = (int*)malloc(len*sizeof(int)); cout&lt;&lt;&quot;请逐个输入动态数组成员：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; //此处不可以写成：cin&gt;&gt;*p[i] cin&gt;&gt;p[i]; &#125; cout&lt;&lt;&quot;您输入的动态数组为：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; //时刻记住：有malloc就要有free free(p); &#125; 2、利用“malloc-free”动态分配二维数组：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; #include&lt;stdlib.h&gt; //该头文件为malloc必须 using namespace std; int main() &#123; int row,col; int **p; cout&lt;&lt;&quot;请输入开辟动态数组的行 &amp; 列：&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col; //开始开辟 p = (int**)malloc(row*sizeof(int*));//为数组的行开辟空间 for(int i=0; i&lt;row; ++i) &#123; *(p+i)=(int*)malloc(col*sizeof(int));//为数组的列开辟空间 &#125; //输入成员 cout&lt;&lt;&quot;请逐个输入动态数组 各行各列 成员：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; //此处不可以写成：cin&gt;&gt;*p[i] [j] cin&gt;&gt;p[i][j]; &#125; //输出成员 cout&lt;&lt;&quot;您输入的动态数组 各行各列 成员如下：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; cout&lt;&lt;p[i][j]; &#125; //时刻记住：有malloc就要有free for(int i=0; i&lt;row; ++i) &#123; free(*(p+i)); &#125; &#125; 3、利用“new-delete”动态分配一维数组：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int len; cout&lt;&lt;&quot;请输入开辟数组的长度：&quot;&lt;&lt;endl; cin&gt;&gt;len; int *p = new int [len]; //数据输入 cout&lt;&lt;&quot;请逐个输入数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; cin&gt;&gt;p[i]; &#125; //数据反馈 cout&lt;&lt;&quot;您分配的动态数组为：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; //释放内存： delete []p; &#125; 4、利用“new-delete”动态分配二维数组：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main()&#123; int row,col; cout&lt;&lt;&quot;请输入开辟数组的行 &amp; 列：&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col; //行的开辟 int **p = new int*[row]; for(int i=0; i&lt;row; ++i) &#123; //列的开辟 p[i] = new int[col]; &#125; //数据输入 cout&lt;&lt;&quot;请逐个输入 各行各列 数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; cin&gt;&gt;p[i][j]; &#125; //数据反馈 cout&lt;&lt;&quot;您分配的动态数组为：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; cout&lt;&lt;p[i][j]&lt;&lt;&quot;&quot;; &#125; //释放内存： delete []p; &#125; 5、利用“new-delete”动态分配二维数组：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int row,col; cout&lt;&lt;&quot;请输入行 &amp; 列：&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col; //很复杂的结构：对于某些编译器，注意连空格都不可以忽略 vector&lt;vector&lt;int&gt; &gt; p(row,vector&lt;int&gt;(col)); //数据输入 cout&lt;&lt;&quot;请逐一输入 各行各列 数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; j++) &#123; cin&gt;&gt;p[i][j]; &#125; //数据输出 cout&lt;&lt;&quot;您输入的数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; j++) &#123; cout&lt;&lt;p[i][j]&lt;&lt;&quot; &quot;; &#125; //该方法利用的是两重的vector而无需释放 &#125; 6、利用while的极其简单输入实现求和、求平均之类算法：12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int sum=0,value=0; //实际上非数字就会结束循环 cout&lt;&lt;&quot;请输入求和数字，以*号作为结束；&quot; while(cin&gt;&gt;value) sum += value; cout&lt;&lt;&quot;您输入数据之和为：&quot;&lt;&lt;sum&lt;&lt;endl; &#125; ————————————————版权声明：本文为CSDN博主「Errors_In_Life」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Errors_In_Life/article/details/78889951 2.求逆矩阵行列式的计算方法1.对角线法 对角线法也是三阶行列式计算使用最广泛的方法 ▍ 对角线法适用于二、三阶行列式，对于更高阶的行列式暂时未找到规律 2.代数余子式法 3.等价转化法 4.逆序法 总结本文讲述了四种行列式的计算方法： ▍其中对角线法，是使用最简单、最广泛的方法 ▍代数余子式法和等价转化法，在特定情况下能极大程度上简便运算，但需要读者对行列式进行灵活地观察 ▍逆序数法，是一种更加基础的方法，使用起来比较复杂 3.函数返回一个数组，二维数组与其他高级语言相比，c语言，c++ 最大的不方便之处就是 函数只能返回一个数值。若要返回一个数组，必须用到指针以及动态分配内存。 方法之一：返回一个结构体，结构体里面包括一个数组。 因为结构体运行效率略慢，这个方法我干脆不用了。 方法之二：利用指针函数，并结合动态内存。 1234567891011121314151617int *fun()&#123;声明一个动态数组 a;return a;&#125;void main()&#123;用指针调用函数 int *p=fun();释放该指针 free(p); (相当于释放了指针函数里面的动态数组)&#125; 举例：下面程序返回一个一维数组 123456789101112131415161718192021222324#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;int * Max(int *arr,int n)&#123; int *a=(int *)malloc(2*sizeof(int)); int maxNum=0,maxIndex,i; for (i=0;i&lt;n;i++) if (arr[i]&gt;maxNum) &#123;maxNum=arr[i];maxIndex=i+1;&#125; a[0]=maxNum;a[1]=maxIndex; return a;&#125;void main()&#123; int a[2]=&#123;5,2&#125;;//a[0]=5,a[1]=2; int *b=Max(a,2); int i; for(i=0;i&lt;2;i++) printf(&quot;b[%d]=%d\\n&quot;,i,b[i]); free(b);&#125; 这个程序中的max函数不仅能够返回一个数组的最大值，还能够显示这个最大值在数组中的位置。 下列程序返回一个二维数组，求出一个二维数组各行的最大值以及所在位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;int **Max(int **arr,int n,int m)&#123; int **data; data=(int **)malloc(n*sizeof(int *)); for (int i=0;i&lt;n;i++) data[i]=(int *)malloc(2*sizeof(int)); for (int i=0;i&lt;n;++i) &#123; int maxNum=0; for (int j=0;j&lt;m;++j) &#123; //printf(&quot;arr[%d][%d]=%d &quot;,i,j,*((int *)arr+m*i+j)); if (*((int *)arr+m*i+j)&gt;maxNum) &#123; maxNum=*((int *)arr+m*i+j); data[i][0]=maxNum;data[i][1]=j; &#125; &#125; //printf(&quot;\\n&quot;); &#125; return data;&#125;void main()&#123; int a[2][3]=&#123;5,2,4,6,3,9&#125;; int **b=Max((int **)a,2,3); for (int i=0;i&lt;2;i++) &#123; printf(&quot;the maximum num for row %d is %d\\n&quot;,i+1,b[i][0]); printf(&quot;the maximum num for row %d is in %d&quot;,i+1,b[i][1]+1); printf(&quot;\\n&quot;); &#125; for(int i=0;i&lt;2;i++) free(b[i]); free(b);&#125; 4.头文件#include&lt;stdlib.h&gt;#include&lt;math.h&gt;1、 三角函数double sin(double);正弦 double cos(double);余弦 double tan(double);正切 2 、反三角函数double asin (double); 结果介于[-PI/2,PI/2] double acos (double); 结果介于[0,PI] double atan (double); 反正切（主值），结果介于[-PI/2,PI/2] double atan2 (double,double); 反正切（整圆值），结果介于[-PI,PI] 3 、双曲三角函数double sinh (double); double cosh (double); double tanh (double); 4 、指数与对数double frexp(double value,int exp);这是一个将value值拆分成小数部分f和（以2为底的）指数部分exp，并返回小数部分f，即f2^exp。其中f取值在0.5~1.0范围或者0。 double ldexp(double x,int exp);这个函数刚好跟上面那个frexp函数功能相反，它的返回值是x*2^exp double modf(double value,double *iptr);拆分value值，返回它的小数部分，iptr指向整数部分。 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x,double y);计算x的y次幂 float powf(float x,float y); 功能与pow一致，只是输入与输出皆为单精度浮点数 double exp (double);求取自然数e的幂 double sqrt (double);开平方根 5 、取整double ceil (double); 取上整，返回不比x小的最小整数 double floor (double); 取下整，返回不比x大的最大整数，即高斯函数[x] 6 、绝对值double fabs (double);求实型的绝对值 double cabs(struct complex znum);求复数的绝对值 7 、标准化浮点数double frexp (double f,int *p); 标准化浮点数，f = x * 2^p，已知f求x,p (x介于[0.5,1]) double ldexp (double x,int p); 与frexp相反，已知x,p求f 8 、取整与取余double modf (double,double*); 将参数的整数部分通过指针回传，返回小数部分 double fmod (double,double); 返回两参数相除的余数 9 、其他double hypot(double x,double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x,int exponent);计算x*（2的指数幂） double poly(double x,int degree,double coeffs []);计算多项式 int matherr(struct exception *e);数学错误计算处理程序 5.关于模取余1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;3%2&lt;&lt;endl;//1 cout&lt;&lt;-3%2&lt;&lt;endl;//-1 cout&lt;&lt;3%-2&lt;&lt;endl;//1 cout&lt;&lt;-3%-2&lt;&lt;endl;//-1 return 0;&#125;","categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"慎终追远(转载)","slug":"文化/句子/慎终追远","date":"2022-04-02T00:42:02.098Z","updated":"2022-04-03T06:20:33.191Z","comments":true,"path":"2022/04/02/文化/句子/慎终追远/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/02/%E6%96%87%E5%8C%96/%E5%8F%A5%E5%AD%90/%E6%85%8E%E7%BB%88%E8%BF%BD%E8%BF%9C/","excerpt":"","text":"谈谈对“慎终追远”的四种看法 曾子曰：慎终追远，民德归厚矣。 这句话大概有四种释义，每一种释义我都加入了自己的理解，相对来说，我更认同南老的观点。 释义一 慎终：谨慎的思考人生于天地之间的意义。****追远：看看老祖宗们都留下了些什么，在自身与先贤之间做一个对比，应效法先古圣贤。每个人都这样的去思考，人民的道德就自然敦厚了。 诚然，“谨慎的思考人生于天地之间的意义”与“看看老祖宗们都留下了些什么，在自身与先贤之间做一个对比，应效法先古圣贤”，可以使人的德行增加，但是这样的说法好像是针对于读书人而言的。 很多老百姓都是目不识丁的，不会去思考人生之意义，也不会与先贤去做对比，就像那个放牛娃的一生，“放牛、挣钱、娶媳妇、生娃、让娃放牛”，但如果每个人都可以像放牛娃一样活的简单，社会风气也是可以趋于厚道的呀。 在春秋时期，读书人只是小部分人，如果只针对小部分人说，那也太不普遍了吧。 释义二宋儒的解释，这好像也是语文教科书上的解释。 终，人死；远，指祖先。慎终追远，慎重地办理父母丧事，虔诚地祭祀远代祖先。 宋儒是把这句话归于孝道，“圣朝以孝治天下”，我们向来都重视孝道。但慎重地办理父母丧事，虔诚地祭祀远代祖先真的能使风气趋于厚道？要慎重办理丧事，就意味着要找风水宝地，要算五行八卦，这难道不会形成攀比之分吗？虔诚祭祀祖先，因为相信列祖列宗在护佑、审视自己。我感觉这在某种程度上是使迷信之风越演越烈吧。 重视办理父母丧事，每年祭祀祖宗，民德就归厚了，就没人犯罪了？感觉有些牵强。 释义三 慎，害怕；终，结果；追远，指找当初的动机和原因。慎终追远的意思是说一个人要想好的结果，不如有好的开始。如果大家都能认识到这个道理，则“民德归厚矣”，社会道德的风气，自然都归于厚道严谨。佛家有言“菩萨畏因，凡夫畏果”，跟这句话是一个意思。这是南老对这句话的解释。 有人对南老的解释提出了异议，举了反例，“有些人专门损人利己，干尽坏事，他总是思前顾后、深思熟虑的，要把每件坏事做得不露声色。这样能做到民德归厚吗？”我觉得他的反例举的不对，他没有理解南老的意思，如果按他的说法，这些干尽坏事、深思熟虑的人都跟菩萨一样畏因了吗？他把因果弄错的，这些坏人畏的不是因，而是果。什么样的例子是畏因呢？ 我觉得孟母三迁其实就是一个畏因的例子，一般父母都畏果，比如最终孩子变成一个不学无术的人，这个后果来了他才怕。但孟母害怕的是动机，这个动机是初因，比如孟母希望孟子能成为一个品德高尚的人，那么住在这里，是否是从这个初因出发的呢？如果不是，怎么可能有这个果呢？如果每个人在开始的时候都很慎重，都是从善因出发，那么民德自然就会严谨厚重了呀。 释义四； 慎，谨慎。《礼记·中庸》：“天命之谓性，率性之谓道，修道之谓教。道也者，不可须臾离也；可离，非道也。是故君子戒慎乎其所不睹，恐惧乎其所不闻。莫见乎隐，莫显乎微，故君子慎其独也。” 这句话就是说，人如果能谨慎一生，就几乎接近了‘道’。这样的人必将会受到后人的景仰，如果每个人都可以谨慎一生，那自然就是一个厚德的人啦。 可是如果要每个人谨慎一生才能民德归厚的吧，那民德离厚应该远远不及吧，因为就连大家公认谨慎的诸葛孔明，也做不到谨慎一生吧，孔夫子虽然是圣人，也不可能一生谨慎呀。这个说法简直离谱。 作者：灰堆积木链接：https://www.jianshu.com/p/91aae9b45104来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"语文","slug":"语文","permalink":"https://zhang0224gz.github.io/categories/%E8%AF%AD%E6%96%87/"}],"tags":[]},{"title":"摄像头--信标","slug":"智能车/摄像头","date":"2022-04-01T09:14:46.059Z","updated":"2022-04-13T08:35:43.433Z","comments":true,"path":"2022/04/01/智能车/摄像头/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/01/%E6%99%BA%E8%83%BD%E8%BD%A6/%E6%91%84%E5%83%8F%E5%A4%B4/","excerpt":"","text":"信标车，摄像头处理部分技术报告–摄像头处理(2条消息) 智能车竞赛技术报告 | 节能信标组组 - 大连民族大学 - 粉红靓车队_卓晴的博客-CSDN博客_智能车信标灯算法 红外光虽然不可见，但却是最稳定的光源，除了受到自然光中红外光的干扰，不会受到其他光源的干扰，于是我们选择了通红外的170°广角摄像头。在国赛的比赛规则中，两个信标灯之间的距离最远有4.61米，本着减少算法复杂度的原则，我们通过加长摄像头支架的高度来解决视野问题，摄像头支撑加到了45cm 智能车竞赛技术报告 | 节能信标组-哈尔滨工业大学紫丁香五队-面包板社区 (eet-china.com) 本智能车采用的是2个逐飞的170度红外摄像头，前后分别一个。在单片机采集图像后需要对其进行处理，以提取主要的图像信息。对于节能信标组，需要提取的就是亮着的信标灯的坐标。十六届信标灯的灯罩是扁平的，距离较远时，接收到的光较弱，而且由于场地灯光和太阳光的存在，会存在杂点、光斑，对信标灯的识别有着很大的影响。因此，在软件上必须排除干扰因素，对图像进行精准识别，并尽可能提取出更多的信息以供控制使用。 在图像处理中，我们提取的信息主要包括：信标灯的坐标、信标灯的长、宽、面积、周长，以及信标灯距离。由于信标灯为扁平状，当距离较远时，接收到的光比较少，提取到的信标灯仅为一个像素点；距离较近时，形状近似为一个椭圆。 当场地光线足够理想时，通过固定阈值二值化，便可将场地与信标灯区分开，再通过连通域提取，即可精确地收集到信标灯的所有信息。当场地光线不够理想时，当信标灯的距离较近时，由于图像画面中信标灯占了很大一部分，所以直接提取面积最大的连通域作为信标灯即可；当信标灯距离较远时，由于信标灯在画面上仅为一个像素点，所以杂光会对信标灯的提取造成很大的困难，甚至一些杂光的亮度大于信标灯的亮度，仅通过固定阈值很难提取出真正的信标灯位置。我们尝试过了许多二值化方法，大津法、平均值法等等，但是效果都比较一般，因为较远处的信标灯只有一个像素点，全局二值化显然不太合适。最后还是采取了分段固定阈值法，主要思想就是距离远的部分给低阈值，距离近的部分给高阈值，这样通过二值化，即可滤掉比信标灯暗的部分。剩下来的就是在图像中滤除杂光干扰，我们采用的方法是通过计算信标灯的坐标和形状，来去除一些形状不可能是信标灯的连通域，通过这种方法，可以排除大部分干扰。剩下满足条件的连通域中，我们选取与上一张图信标灯最近的连通域作为信标灯的位置，来计算其各个信息。 上位机：上位机指可以直接发送操作指令的计算机或单片机，一般提供用户操作交互界面并向用户展示反馈数据。典型设备类型：电脑，手机，平板，面板，触摸屏 下位机：下位机指直接与机器相连接的计算机或单片机，一般用于接收和反馈上位机的指令，并且根据指令控制机器执行动作以及从机器传感器读取数据。典型设备类型：PLC，STM32，51，FPGA，ARM等各类可编程芯片 信标位置提取 首先通过前摄像头采集的图像进行图像处理，来判断前方是否有信标灯。如果正前方采集到了信标灯的信息，那么便通过这个信息提取出其坐标，以坐标为基础来控制车的运动。如果前摄像头采集到的图片中没有信标灯的信息，那么这时候对后摄像头进行图像处理，来判断信标灯和车的相对位置，从而确定转向方向。整体逻辑在状态机中体现。 智能车竞赛技术报告 | 节能信标组 - 兰州交通大学 - 先锋队_卓晴的博客-程序员宝宝_智能车信标组 - 程序员宝宝 (cxybb.com) 摄像头处理算法 我们采用总钻风摄像头来识别场地中的信标和障碍,总钻风摄像头采集回来 的图像是大小是188*120，以左上角为坐标原点向右下方为图像坐标正方向。在理想的图像中，应该只存在信标，但是由于环境光线，杂点，远处图像太小等因素干扰，图像效果难免会不理想。所以我们不仅通过调节、镜头焦距等方式来获得识别效果最佳的图像。通过图像膨胀对远处的图像进行膨胀操作；采用均值滤波，采用动态阈值二值化，忽略无效点等手段排除干扰因素，对赛场信息进行有效的识别。 寻灯算法实现 由于摄像头采集到的是一个188*120的图像矩阵，首先通过均值滤波对图像进行二值化，同时对图像图像有效像素点进行计数，如果有效点数过少则对图像进行膨胀操作，之后对于信标灯进行每一个像素点横坐标及纵坐标进行累加，以及像素点的个数进行累加，之后通过横纵坐标累加和除以像素点个数，即可得到信标灯的坐标。其中纵坐标为当前车模的方向，用信标灯的纵坐标与图像画面中轴线的纵坐标做差，得到小车车头朝向与信标灯方向的偏差，用此偏差放入PD控制器来控制舵机打角即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643■ 附录 程序源代码void Get_Bin_Image (unsigned char mode) &#123; unsigned short i = 0, j = 0; unsigned long tv = 0; //char txt[16]; if (mode == 0) &#123; Threshold = GetOSTU(mt9v03x_image); //大津法阈值 &#125; else if (mode == 1) &#123; //累加 for (i = 33; i &lt; MT9V03X_H; i++) &#123; for (j = 0 ; j &lt; Image_W; j++) &#123; tv += mt9v03x_image[i][j]; //累加 &#125; &#125; Threshold =(unsigned short)(tv / 87 / 120); //求平均值,光线越暗越小，全黑约35，对着屏幕约160，一般情况下大约100 Threshold = Threshold + lqv; //此处阈值设置，根据环境的光线来设定 &#125; else if (mode == 2) &#123; // Threshold = 110; //累加 for (i = 0; i &lt; MT9V03X_H; i++) &#123; for (j = 0; j &lt; MT9V03X_W; j++) &#123; tv += mt9v03x_image[i][j]; //累加 &#125; &#125; Threshold =(unsigned short)(tv / MT9V03X_H / MT9V03X_W); //求平均值,光线越暗越小，全黑约35，对着屏幕约160，一般情况下大约100 Threshold = Threshold + lqv; //此处阈值设置，根据环境的光线来设定//手动调节阈值 lq_sobel(mt9v03x_image, Bin_Image, (unsigned char) Threshold); return; &#125; else if (mode == 3) &#123; lq_sobelAutoThreshold(mt9v03x_image, Bin_Image); //动态调节阈值 return; &#125; white_1 = 0; /* 二值化 */ for (i = 33; i &lt; MT9V03X_H; i++) &#123; for (j = 0; j &lt; Image_W; j++) &#123; if (mt9v03x_image[i][j] &gt; Threshold) //数值越大，显示的内容越多，较浅的图像也能显示出来 &#123; Bin_Image[i][j] = 255; white_1++; //数出第一次二值化完后的白点数 white_1 &#125; else Bin_Image[i][j] = 0; &#125; &#125; &#125; short GetOSTU (unsigned char tmImage[MT9V03X_H][MT9V03X_W]) &#123; signed short i, j; unsigned long Amount = 0; unsigned long PixelBack = 0; unsigned long PixelshortegralBack = 0; unsigned long Pixelshortegral = 0; signed long PixelshortegralFore = 0; signed long PixelFore = 0; float OmegaBack, OmegaFore, MicroBack, MicroFore, SigmaB, Sigma; // 类间方差; signed short MinValue, MaxValue; signed short Threshold = 0; unsigned char HistoGram[256]; // for (j = 0; j &lt; 256; j++) HistoGram[j] = 0; //初始化灰度直方图 for (j = 0; j &lt; MT9V03X_H; j++) &#123; for (i = 0; i &lt; MT9V03X_W; i++) &#123; HistoGram[tmImage[j][i]]++; //统计灰度级中每个像素在整幅图像中的个数 &#125; &#125; for (MinValue = 0; MinValue &lt; 256 &amp;&amp; HistoGram[MinValue] == 0; MinValue++); //获取最小灰度的值 for (MaxValue = 255; MaxValue &gt; MinValue &amp;&amp; HistoGram[MinValue] == 0; MaxValue--); //获取最大灰度的值 if (MaxValue == MinValue) return MaxValue; // 图像中只有一个颜色 if (MinValue + 1 == MaxValue) return MinValue; // 图像中只有二个颜色 for (j = MinValue; j &lt;= MaxValue; j++) Amount += HistoGram[j]; // 像素总数 Pixelshortegral = 0; for (j = MinValue; j &lt;= MaxValue; j++) &#123; Pixelshortegral += HistoGram[j] * j; //灰度值总数 &#125; SigmaB = -1; for (j = MinValue; j &lt; MaxValue; j++) &#123; PixelBack = PixelBack + HistoGram[j]; //前景像素点数 PixelFore = Amount - PixelBack; //背景像素点数 OmegaBack = (float) PixelBack / Amount; //前景像素百分比 OmegaFore = (float) PixelFore / Amount; //背景像素百分比 PixelshortegralBack += HistoGram[j] * j; //前景灰度值 PixelshortegralFore = Pixelshortegral - PixelshortegralBack; //背景灰度值 MicroBack = (float) PixelshortegralBack / PixelBack; //前景灰度百分比 MicroFore = (float) PixelshortegralFore / PixelFore; //背景灰度百分比 Sigma = OmegaBack * OmegaFore * (MicroBack - MicroFore) * (MicroBack - MicroFore); //计算类间方差 if (Sigma &gt; SigmaB) //遍历最大的类间方差g //找出最大类间方差以及对应的阈值 &#123; SigmaB = Sigma; Threshold = j; &#125; &#125; return Threshold; //返回最佳阈值; &#125; /*! * @brief 基于soble边沿检测算子的一种边沿检测 * * @param imageIn 输入数组 * imageOut 输出数组 保存的二值化后的边沿信息 * Threshold 阈值 * * @return * * @note * * @example * * @date 2020/5/15 */ void lq_sobel (unsigned char imageIn[MT9V03X_H][MT9V03X_W], unsigned char imageOut[MT9V03X_H][MT9V03X_W], unsigned char Threshold) &#123; /** 卷积核大小 */ short KERNEL_SIZE = 3; short xStart = KERNEL_SIZE / 2; short xEnd = MT9V03X_W - KERNEL_SIZE / 2; short yStart = KERNEL_SIZE / 2; short yEnd = MT9V03X_H - KERNEL_SIZE / 2; short i, j, k; short temp[4]; for (i = yStart; i &lt; yEnd; i++) &#123; for (j = xStart; j &lt; xEnd; j++) &#123; /* 计算不同方向梯度幅值 */ temp[0] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i - 1][j + 1] //&#123; &#123; -1, 0, 1&#125;, - (short) imageIn[i][j - 1] + (short) imageIn[i][j + 1] // &#123; -1, 0, 1&#125;, - (short) imageIn[i + 1][j - 1] + (short) imageIn[i + 1][j + 1]; // &#123; -1, 0, 1&#125;&#125;; temp[1] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j - 1] //&#123; &#123; -1, -1, -1&#125;, - (short) imageIn[i - 1][j] + (short) imageIn[i + 1][j] // &#123; 0, 0, 0&#125;, - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j + 1]; // &#123; 1, 1, 1&#125;&#125;; temp[2] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j - 1] // 0, -1, -1 - (short) imageIn[i][j + 1] + (short) imageIn[i + 1][j] // 1, 0, -1 - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j - 1]; // 1, 1, 0 temp[3] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j + 1] // -1, -1, 0 - (short) imageIn[i][j - 1] + (short) imageIn[i + 1][j] // -1, 0, 1 - (short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j + 1]; // 0, 1, 1 temp[0] = abs(temp[0]); temp[1] = abs(temp[1]); temp[2] = abs(temp[2]); temp[3] = abs(temp[3]); /* 找出梯度幅值最大值 */ for (k = 1; k &lt; 4; k++) &#123; if (temp[0] &lt; temp[k]) &#123; temp[0] = temp[k]; &#125; &#125; if (temp[0] &gt; Threshold) &#123; imageOut[i][j] = 255; &#125; else &#123; imageOut[i][j] = 0; &#125; &#125; &#125; &#125; /*! * @brief 基于soble边沿检测算子的一种自动阈值边沿检测 * * @param imageIn 输入数组 * imageOut 输出数组 保存的二值化后的边沿信息 * * @return * * @note * * @example * * @date 2020/5/15 */ void lq_sobelAutoThreshold (unsigned char imageIn[MT9V03X_H][MT9V03X_W], unsigned char imageOut[MT9V03X_H][MT9V03X_W]) &#123; /** 卷积核大小 */ short KERNEL_SIZE = 3; short xStart = KERNEL_SIZE / 2; short xEnd = MT9V03X_W - KERNEL_SIZE / 2; short yStart = KERNEL_SIZE / 2; short yEnd = MT9V03X_H - KERNEL_SIZE / 2; short i, j, k; short temp[4]; for (i = yStart; i &lt; yEnd; i++) &#123; for (j = xStart; j &lt; xEnd; j++) &#123; /* 计算不同方向梯度幅值 */ temp[0] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i - 1][j + 1] //&#123; &#123; -1, 0, 1&#125;, - (short) imageIn[i][j - 1] + (short) imageIn[i][j + 1] // &#123; -1, 0, 1&#125;, - (short) imageIn[i + 1][j - 1] + (short) imageIn[i + 1][j + 1]; // &#123; -1, 0, 1&#125;&#125;; temp[1] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j - 1] //&#123; &#123; -1, -1, -1&#125;, - (short) imageIn[i - 1][j] + (short) imageIn[i + 1][j] // &#123; 0, 0, 0&#125;, - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j + 1]; // &#123; 1, 1, 1&#125;&#125;; temp[2] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j - 1] // 0, -1, -1 - (short) imageIn[i][j + 1] + (short) imageIn[i + 1][j] // 1, 0, -1 - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j - 1]; // 1, 1, 0 temp[3] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j + 1] // -1, -1, 0 - (short) imageIn[i][j - 1] + (short) imageIn[i + 1][j] // -1, 0, 1 - (short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j + 1]; // 0, 1, 1 temp[0] = abs(temp[0]); temp[1] = abs(temp[1]); temp[2] = abs(temp[2]); temp[3] = abs(temp[3]); /* 找出梯度幅值最大值 */ for (k = 1; k &lt; 4; k++) &#123; if (temp[0] &lt; temp[k]) &#123; temp[0] = temp[k]; &#125; &#125; /* 使用像素点邻域内像素点之和的一定比例 作为阈值 */ temp[3] = (short) imageIn[i - 1][j - 1] + (short) imageIn[i - 1][j] + (short) imageIn[i - 1][j + 1] + (short) imageIn[i][j - 1] + (short) imageIn[i][j] + (short) imageIn[i][j + 1] + (short) imageIn[i + 1][j - 1] + (short) imageIn[i + 1][j] + (short) imageIn[i + 1][j + 1]; if (temp[0] &gt; temp[3] / 12.0f) &#123; imageOut[i][j] = 255; &#125; else &#123; imageOut[i][j] = 0; &#125; &#125; &#125; &#125; void Bin_Image_Filter (void) &#123; sint16 nr; //行 sint16 nc; //列 for (nr = 33; nr &lt; MT9V03X_H - 1; nr++) &#123; for (nc = 1; nc &lt; Image_W - 1; nc = nc + 1) &#123; if ((Bin_Image[nr][nc] == 0)//黑点 &amp;&amp; (Bin_Image[nr - 1][nc] + Bin_Image[nr + 1][nc] + Bin_Image[nr][nc + 1] + Bin_Image[nr][nc - 1] &gt; (2*255)))//若黑点上下右三方向有大于两个白点 &#123; Bin_Image[nr][nc] = 255;//将该黑点置为白点 &#125; else if ((Bin_Image[nr][nc] == 255)//白点 &amp;&amp; (Bin_Image[nr - 1][nc] + Bin_Image[nr + 1][nc] + Bin_Image[nr][nc + 1] + Bin_Image[nr][nc - 1] &lt; (2*255)))//若白点上下右三方向有小于两个白点 &#123; Bin_Image[nr][nc] = 0;//将该白点置为黑点 &#125; &#125; &#125; &#125; void Bin_Image_Filter_peng(void) &#123; sint16 nr; //行 sint16 nc; //列 for (nr = 33; nr &lt; MT9V03X_H - 1; nr++) &#123; for (nc = 31; nc &lt; Image_W - 1; nc = nc + 1) &#123; if ((dilation_Image[nr][nc] == 0)//黑点 &amp;&amp; (dilation_Image[nr - 1][nc] + dilation_Image[nr + 1][nc] + dilation_Image[nr][nc + 1] + dilation_Image[nr][nc - 1] &gt; (2*255)))//若黑点上下右三方向有大于两个白点 &#123; dilation_Image[nr][nc] = 255;//将该黑点置为白点 &#125; else if ((dilation_Image[nr][nc] == 255)//白点 &amp;&amp; (dilation_Image[nr - 1][nc] + dilation_Image[nr + 1][nc] + dilation_Image[nr][nc + 1] + dilation_Image[nr][nc - 1] &lt; (2*255)))//若白点上下右三方向有小于两个白点 &#123; dilation_Image[nr][nc] = 0;//将该白点置为黑点 &#125; &#125; &#125; &#125; void Seek_Road (void) &#123; sint16 nr; //行 sint16 nc; //列 sint16 temp = 0; //临时数值 //for(nr=1; nr&lt;MAX_ROW-1; nr++) temp = 0; for (nr = 8; nr &lt; 24; nr++) &#123; for (nc = MAX_COL / 2; nc &lt; MAX_COL; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; ++temp; &#125; &#125; for (nc = 0; nc &lt; MAX_COL / 2; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; --temp; &#125; &#125; &#125; OFFSET0 = temp; temp = 0; for (nr = 24; nr &lt; 40; nr++) &#123; for (nc = MAX_COL / 2; nc &lt; MAX_COL; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; ++temp; &#125; &#125; for (nc = 0; nc &lt; MAX_COL / 2; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; --temp; &#125; &#125; &#125; OFFSET1 = temp; temp = 0; for (nr = 40; nr &lt; 56; nr++) &#123; for (nc = MAX_COL / 2; nc &lt; MAX_COL; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; ++temp; &#125; &#125; for (nc = 0; nc &lt; MAX_COL / 2; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; --temp; &#125; &#125; &#125; OFFSET2 = temp; return; &#125; /***********通过边沿提取找到灯的重心点********/ void Seek_Beacon(void) &#123; uint8 nr=0; //行 uint8 nc=0; //列 dotcnt=0; y_sum = 0; x_sum = 0; for (nr = x_zuobiao; nr &lt; MT9V03X_H - 1; nr++)//7.22 nr=1 &#123; for (nc = 1; nc &lt;Image_W - 1; nc++) &#123; if ((Bin_Image[nr - 1][nc] + Bin_Image[nr + 1][nc] + Bin_Image[nr][nc + 1] + Bin_Image[nr][nc - 1] &gt; 255))//若该点上下左右有大于一个白点，记录坐标信息 &#123; y_sum += nc; x_sum += nr; dotcnt++; &#125; &#125; &#125; dotcnt_new = dotcnt; x_sum_new = x_sum; y_sum_new = y_sum; &#125; void Seek_Beacon_peng (void) &#123; uint8 nr=0; //行 uint8 nc=0; //列 dotcnt=0; y_sum = 0; x_sum = 0; for (nr = 33; nr &lt; MT9V03X_H - 1; nr++)//7.24-30 &#123; for (nc = 0; nc &lt; Image_W - 1; nc++) &#123; // if ((dilation_Image[nr - 1][nc] + dilation_Image[nr + 1][nc] + dilation_Image[nr][nc + 1] + dilation_Image[nr][nc - 1] &gt; (1*255)))//若该点左右下有大于一个白点，记录坐标信息 if(dilation_Image[nr][nc]) &#123; y_sum += nc; x_sum += nr; dotcnt++; &#125; &#125; &#125; dotcnt_new = dotcnt; x_sum_new = x_sum; y_sum_new = y_sum; return; &#125;//膨胀运算void dilation(unsigned char *data, uint8 width, uint8 height)&#123; uint8 i, j, flag; for(i = 1;i &lt; height - 1;i++) &#123; for(j = 1;j &lt; width - 1;j++) &#123; flag = 1; for(int m = i - 1;m &lt; i + 2;m++) &#123; for(int n = j - 1; n &lt; j + 2;n++) &#123; //自身及领域中若有一个为255 //则将该点设为255 if(data[i * width + j] == 255 || data[m * width + n] == 255) &#123; flag = 0; break; &#125; &#125; if(flag == 0) &#123; break; &#125; &#125; if(flag == 0) &#123; dilation_Image[i][j] = 255; &#125; else &#123; dilation_Image[i][j] = 0; &#125; &#125; &#125;&#125;void select_pengzhang(void)&#123; if(white_1 &gt;= 0 &amp;&amp; white_1 &lt; 35) &#123; dilation(&amp;Bin_Image[0][0], MT9V03X_W, MT9V03X_H); Bin_Image_Filter_peng(); Seek_Beacon_peng (); &#125; if(white_1 &gt;= 35) &#123; // Bin_Image_Filter(); Bin_Image_Filter(); Seek_Beacon(); &#125;&#125;void getspeed(void) &#123; Pulses_l = gpt12_get(GPT12_T2);//左轮速度 Pulses_r = -gpt12_get(GPT12_T6);//右轮速度 gpt12_clear(GPT12_T2); gpt12_clear(GPT12_T6); speed_ave_now = (Pulses_l + Pulses_r) / 2; // 总速度 占空比与速度对应关系3000--44,10000--145 &#125;/********位置式PID********/float pid_pos(float *err, float *PID_pos, float now, float target)&#123; float pe, ie, de; float out; err[1] = err[0]; err[0] = target - now; if(err[0] &lt; 10) err[2] += err[0] * PID_pos[1]; //积分误差 err[2] = (err[2] &gt; PID_pos[3]) ? PID_pos[3] : err[2]; //限幅保护 err[2] = (err[2] &lt; -PID_pos[3]) ? -PID_pos[3] : err[2]; pe = err[0]; ie = err[2]; de = err[0] - err[1]; out = pe * PID_pos[0] + de * PID_pos[2] + ie; return out;&#125;/******增量式PID******/float pid_increase(float *err, float *PID_inc, float now, float target)&#123; float pe, ie, de; float out; err[2] = err[1]; err[1] = err[0]; err[0] = target - now; pe = err[0] - err[1]; ie = err[0]; de = err[0] - 2 * err[1] + err[2]; out = pe * PID_inc[0] + ie * PID_inc[1] + de * PID_inc[2]; return out;&#125; csdn– 摄像头处理(1条消息) 节能信标组：让我们一起来内卷_卓晴的博客-CSDN博客 (1条消息) 十三届智能汽车竞赛 信标对抗组 思路参考 程序参考（二）图像处理_ZZM丶的博客-CSDN博客 有了图像矩阵之后，就可以进行处理了，最终找出信标灯中心在画面中的坐标。信标灯在亮起时会以一定频率闪烁，发出一定频率范围的红光和红外光。摄像头镜头使用了红外滤光片，环境光线比较好的情况下，当信标灯亮起时，其红外光能够很明显在图像上显示为一个光斑，我们则通过逐行扫描图像矩阵的方式来求出这个光斑在画面中的像素坐标，具体操作如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************找坐标***************************/void find_LR(void) &#123; unsigned int i,j; unsigned char lside=80,rside=0; for(i=0;i&lt;DATALINE;i++) &#123; lside=80,rside=0; for(j=0;j&lt;80-1;j++) &#123; if(!image_dec[i][j]&amp;&amp;!image_dec[i][j+1]) //同一行中连续两个像素点亮 &#123; if(lside==80) lside=j; //定左边缘 rside=j+1; //定又边缘 &#125; &#125; if(lside&lt;rside) PianCha[i]=(lside+rside)/2; //最大为80 else PianCha[i]=0xff; &#125;&#125;void find_XY(void)&#123; int i=0,k=0,p=0,g=0,m=0,q=0; float Xx=0; for(i=0;i&lt;DATALINE-1;i++) &#123; if((PianCha[i]!=0xff)&amp;&amp;(PianCha[i+1]!=0xff)) //连续四个点表示确定为信标灯而不是噪点 &#123; if(g==0) &#123; k=i; g=1; &#125; if(m==0) p++; &#125; else if(g==1) m=1; &#125; for(q=0;q&lt;p-1;q++) Xx+=PianCha[k+q]; x_MID=Xx/(p-1); y_MID=(k+(p&gt;&gt;1)); //右移一位相当于除以二 而运算速度更快&#125; 在某些光线条件比较差（比如存在阳光、带红外光的灯管等）的情况下，阳光中有红外光的分量，带红外光的灯管直接发出红外光。图像中的光斑就不仅仅是信标灯发出的红外光了了，恶劣时甚至被大片的光干扰淹没，此时想要克服或者减弱这个影响，就需要利用到一个点：信标灯的红外光是以一定频率闪烁的而其他的红外光是常亮的。利用这个特性，可以对相邻的或一定帧间隔内的两张或多张图像之间做 差 或者做 异或 操作，能将常亮的红外光滤除掉，信标灯又能清晰的出现在图像中了： 在某些光线条件比较差（比如存在阳光、带红外光的灯管等）的情况下，阳光中有红外光的分量，带红外光的灯管直接发出红外光。图像中的光斑就不仅仅是信标灯发出的红外光了了，恶劣时甚至被大片的光干扰淹没，此时想要克服或者减弱这个影响，就需要利用到一个点：信标灯的红外光是以一定频率闪烁的而其他的红外光是常亮的。利用这个特性，可以对相邻的或一定帧间隔内的两张或多张图像之间做 差 或者做 异或 操作，能将常亮的红外光滤除掉，信标灯又能清晰的出现在图像中了： 1234567891011121314151617181920/************************闪烁识别***************************/void SHANSHUOSHIBIE(void)&#123; int q,w; Image_Decompression((uint8 *)ADdata,(uint8 *)image_dec[0]); //解压图像 if(shan&gt;0) &#123; shan=0; for(q=0;q&lt;60;q++) &#123; for(w=0;w&lt;80;w++) &#123; shanshuo[q][w]=copy[q][w]^image_dec[q][w]; //两幅图像对应位置像素异或操作 copy[q][w]=image_dec[q][w]; &#125; &#125; &#125; shan++;&#125; (1条消息) 十六届智能车信标组的浅析_wuxing4550的博客-CSDN博客_智能车信标 (1条消息) 浅谈全国大学生智能车竞赛-摄像头组图像处理及控制算法_Q792499178的博客-CSDN博客_智能车摄像头图像处理 初学图像处理的人，一般首先熟悉图像格式，图像存储方式，8位灰度图，24位彩色图等基础知识，然后接触到的图像算法一般都是图像直方图、图像二值化处理等基础算法。二值化算法作为图像处理入门级算法，在很多场合都有应用。常用的二值化算法是固定阈值二值化，算法本身很简单，机器视觉处理的很多都是8位灰度图像，灰度值从0到255,。所谓二值化就是给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来就是一幅黑白图像。 threshold(src, dst, 100, 255, 0); 第一个参数是输入图像，第二个是输出图像，第三个是阈值，第四个是指将大于等于阈值的灰度值设置为多大的值，最后一个参数是二值化方式 如果直接用大律法进行二值化，实际效果并不是很好，因为这是全局阈值，比较好的二值化方法应该用局部阈值，毕竟图像上每个地方的灰度值差别是比较大的。所以，opencv里面有提供了一个局部自适应二值化函数adaptiveThreshold。这个函数的效果比较好，但是，很多人用这个函数的时候，却不知道参数怎么设置比较好，结果往往出来的效果不理想，反而认为算法不好。其实，就算固定阈值二值化算法，在很多时候都能得到很好的效果，只不过我们很多人不是很清楚算法怎么配合使用而已。 (2条消息) 二值化_初探图像二值化_twxy的博客-CSDN博客 二值图像即为每个像素只有两个可能值的数字图像，常出现在图像掩码，图像分割，二值化和dithering。 其将大于某个临界灰度值的像素灰度设为灰度极大值，小于这个值的为灰度极小值，从而实现二值化 根据域值，二值化分为固定阈值和自适应阈值。比较常用的二值化方法有：双峰法，P参数法，迭代法和OTSU法等。 直方图是图像的重要特质，它可以帮助我们分析图像中的灰度变化。因此，如果物体与背景的灰度值对比明显，直方图就会包含双峰(bimodal histogram)，它们分别为图像的前景和背景。而它们之间的谷底即为边缘附近相对较少数目的像素点，一般来讲，这个最小值就为最优二值化的分界点，通过这个点可以把前景和背景很好地分开。 算法 中值滤波(4条消息) 图像处理——中值滤波_lixiao0314的博客-CSDN博客_图像中值滤波 (4条消息) 数字图像处理——中值滤波_ranjiewen的博客-CSDN博客_数字图像处理中值滤波算法 突变的噪声 核心思路： 当数据出现很大的跳变时，均值滤波会有很大的影响，中值滤波没有，消去阶跃性噪声 中位数更加能反应数据所处的位置 原图： 进入干扰数据： 均值滤波能反映数据的变化 可以适应数据整体上升，也随之上升 12//中值滤波核心：快而准的排序","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"模块一 教育基础知识和基本原理——第二章 教育与社会发展","slug":"教资/模块一 教育基础知识和基本原理/第二章 教育与社会发展","date":"2022-03-28T16:00:07.273Z","updated":"2022-04-03T06:24:23.941Z","comments":true,"path":"2022/03/29/教资/模块一 教育基础知识和基本原理/第二章 教育与社会发展/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/29/%E6%95%99%E8%B5%84/%E6%A8%A1%E5%9D%97%E4%B8%80%20%E6%95%99%E8%82%B2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%99%E8%82%B2%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95/","excerpt":"","text":"第一节：教育与人口 1.人口功能： ①提高人口素质 ②控制人口增长 ③改善人口结构 2.人口对教育的反作用 ①人口数量、速度——教育的发展规模、速度 ②就业结构——内部结构 ③地域分布——布局和办学形式 ④人口流动 第二节：教育与生产力【选择】 1.经济功能： ①再生产劳动力——“我们” ②再生产科学技术知识——“知识变为生产力“ ③生产新的科学技术知识——“旧知识变为新知识” 2.生产力对教育的决定作用（根本作用） ①教育发展的规模和速度 ②教育结构的变化 ③教育的内容和手段 ④教育目的 速归（规）借（结）木（目）手内 3.教育对科技进步和经济发展的贡献 人力资本理论——舒尔茨 （人所拥有的可以为社会创造价值） 第三节：教育与社会政治经济制度【简答】 1.政治功能（社会民主需要政治人才的思想舆论） ①教育通过年轻一代的政治社会化和培养政治人才为政治服务 ②教育通过思想传播、制造舆论为政治经济制度服务 ③教育是促进社会民主化的重要力量 2.社会政治经济制度决定教育的社会性质（两权一目的） ①教育的领导权 ②受教育的权利 ③教育目的的性质和思想品德教育的内容 第四节：教育与文化【简答】 1.教育的文化功能 ①教育具有筛选、整理、传递和保存文化的作用 ②教育具有传播和交流文化的作用 ③教育具有更新和创造文化的作用 传递：前 后（时间） 传播：空间的扩大 第一节人的身心发展及其规律 1.顺序性 人的身心发展过程由低级到高级，具有一定的顺序性 （举例：三躺六坐八爬，机械记忆到意义记忆，具体思维到抽象思维） 关键词：教育要循序渐进，不能“揠苗助长” 2.阶段性 个体在不同年龄阶段表现出不同的总体特征和主要矛盾，面临着不同的发 展任务 关键词：量变—质变、一刀切、一锅煮（针对个人） 3.不平衡性 ①同一因素在不同时期有不同表现（举例:身高） ②不同因素在同一时期有不同表现（举例：身体发育和心智发育） 关键词：抓住关键期 4.个别差异性 ①不同群体之间 ②不同个体之间 关键词：长善救失、因材施教 5.互补性 ①身身互补 ②身心互补 第二节 影响人身心发展的主要因素 1.遗传（辨析、简答） 概念：遗传素质，是指从上代继承下来的、与生俱来的生理解剖上的特点。 作用： ①是人的身心发展的物质基础和生物前提，为个体的身心发展提供了可能性。 ②遗传素质的个别差异为人的身心发展的个别差异提供了最初的可能 ③遗传素质的成熟机制制约着人的身心发展水平和阶段 ④不宜夸大遗传素质的作用 2.环境（选择） ①为个体发展提供了多种可能 ②环境制约个体的发展水平，决定人的身心发展方向、水平、速度和个别差异 ③通过人的内部因素实现 ④有积极和消极之分 3.学校教育在人的身心发展中起主导作用（简答、辨析） （1）原因（三有一训练，控制很全面） ①有目的有计划有组织地培养人地活动 ②通过受专门训练的老师来进行 ③有效地控制和协调影响学生发展的各种因素 ④给人的影响比较全面 、系统和深刻 （2）表现 ①对个体发展做出社会性规范 ②加速个体发展的特殊功能 ③对个体发展的影响具有即时和延时的价值 ④具有开发个体特殊才能和发展个性的功能 4.个体主观能动性起决定作用（选择） ①个体的能动性是人在活动中产生和表现出来的 ②个体的能动性是人发展的内在动力 ③个体的能动性影响人的自我设计和自我奋斗 第二节 关于人身心发展的典型观点 1.遗传决定论（内发论）： ①高尔顿 ②霍尔：一两的遗传胜过一吨的教育 ③格塞尔：双生子爬梯实验 ④孟子：仁义礼智非由外铄我也，我固有之也 2.环境决定论（外铄论）： ①荀子：性恶论 ②洛克：白板说 ③华生：教育万能论 ④斯金纳：行为主义强化论 3.调和论 ①伍德沃斯：遗传和环境的乘积 ②斯特恩：内部性质和外部环境的合并 材料分析题答题思路 ①先读问题，明确考察的知识点 ②回忆并呈现知识点 ③阅读材料与知识点一一对应 ④整理答案，知识点+材料的形式 ⑤总结 第四章第一节 我国现代学制的沿革 1.教育制度的含义【选择】 广义的教育制度：国民教育制度 狭义的教育制度：一个国家各级各类学校的系统及其管理规则（总体系） 2.学制是现代教育制度的核心 3.一个国家学制建立的主要依据【简答】 ①社会生产力发展的水平和科学技术发展情况 ②社会制度的制约 ③人口状况 ④儿童的年龄特征 ⑤原有和外国学制的经验 4.旧中国的学制 （壬颁布，癸实施，资本主义丑男女，六三三制美长戌） ①1902年“壬寅学制”《钦定学堂章程》 首次颁布第一个现代学制 日本 只颁布，未实行 ②1904年“癸卯学制” 《奏定学堂章程》首次得到实施 中学为体，西学为用 不允许男女同校 ③1912年“壬子癸丑学制” 男女同校 资产阶级 ④1922年 “壬戌学制”=“六三三制” 美国 小学6年初中3年高中3年","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"教育知识与能力","slug":"教育知识与能力","permalink":"https://zhang0224gz.github.io/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/"}]},{"title":"《应用密码学》——第二章 古典密码技术","slug":"笔记/密码学/第二章 古典密码技术","date":"2022-03-28T15:48:59.635Z","updated":"2022-04-06T13:45:01.765Z","comments":true,"path":"2022/03/28/笔记/密码学/第二章 古典密码技术/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/28/%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/","excerpt":"","text":"2.1 替代密码单表替代密码一般单表替代密码 a b c d e f g h i j k l m n o p q i s t u v w x y z q w e r t y u i o p a s d f g h j k l z x c v b n m 明文根据转化表将明文字母转换为密文字母(a -&gt; q)，密钥是键盘字母的排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; string table_c = &quot;qwertyuiopasdfghjklzxcvbnm&quot;;string table_m = &quot;abcdefghijklmnopqrstuvwxyz&quot;;int N = 26; int index(char x)&#123; for(int i=0;i&lt;N;i++) &#123; if(table_c[i]==x)return i; &#125;&#125;string pi_1(string c)&#123; string temp_m = &quot;&quot;; int n; for(int i=0;i&lt;N;i++) &#123; n = index(c[i]); temp_m += table_m[n]; &#125; return temp_m;&#125;string pi(string m)&#123; string temp_c=&quot;&quot;; int n; for(int i=0;i&lt;N;i++) &#123; n = m[i]-&#x27;a&#x27;; temp_c += table_c[n]; &#125; return temp_c;&#125;int main()&#123; string m = &quot;abcdefghijklmnopqrstuvwxyz&quot;; string c = &quot;qwertyuiopasdfghjklzxcvbnm&quot;; cout&lt;&lt;pi(m)&lt;&lt;endl; cout&lt;&lt;pi_1(c)&lt;&lt;endl; return 0;&#125; 移位密码 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; string c = &quot;efghijklmnopqrstuvwxyzabcd&quot;;string m = &quot;abcdefghijklmnopqrstuvwxyz&quot;;int n = 26;string pi_1(string c)&#123; string temp_m = &quot;&quot;; int k_1 = 4; for(int i=0;i&lt;n;i++) &#123; temp_m += (c[i]-&#x27;a&#x27;-k_1+26)%26 + &#x27;a&#x27;; &#125; return temp_m;&#125;string pi(string m)&#123; string temp_c = &quot;&quot;; int k = 4; for(int i=0;i&lt;n;i++) &#123; temp_c += (m[i]-&#x27;a&#x27;+ k)%26 + &#x27;a&#x27;; &#125; return temp_c;&#125;int main()&#123; cout&lt;&lt;pi(m)&lt;&lt;endl; cout&lt;&lt;pi_1(c)&lt;&lt;endl; return 0; &#125; 仿射密码这边写错了，k1=7,取模的26不是k2，而且只有7,26互质(最大公因数为1)才能解密:ax-by=1 扩展欧几里德变换求a逆： 欧几里得算法非递归求逆密钥 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; string Atoa(string x);string E(string x);//a指进行乘法逆元的密钥，b指的模的那个数int gcd(int a,int b);//欧几里德算法求公约数int bianli(int a,int b);//暴力计算int ex_gcd(int a,int b,int &amp;x,int &amp;y);//扩展欧几里德算法递归求逆密钥int gcd_1(int a,int b,int &amp;x,int &amp;y)；//欧几里得算法非递归求逆密钥string D(string x); int main()&#123; string m,c; cout&lt;&lt;&quot;请输入明文m:&quot;; cin&gt;&gt;m; //m = &quot;China&quot;; //c = &quot;UnwPc&quot;; //cout&lt;&lt;Atoa(m)&lt;&lt;endl; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; //cout&lt;&lt;gcd(9,26)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; cin&gt;&gt;c; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125; string Atoa(string x)&#123; string temp=&quot;&quot;; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; if(x[i]&gt;&#x27;Z&#x27;) temp += x[i]; else temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; return temp;&#125;string E(string x)&#123; x = Atoa(x); string temp=&quot;&quot;; int k1=9,k2=2,m=26; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; temp += (k1*(x[i]-&#x27;a&#x27;)+k2)%m+&#x27;a&#x27;; &#125; return temp;&#125;int gcd(int a,int b)&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int bianli(int a,int b)&#123; int x; for(int i=1;i&lt;=b;i++) &#123; x = (a*i)%b; if(x==1)return i; &#125;&#125;string D(string x)&#123; x = Atoa(x); string temp=&quot;&quot;; int k1=9,k2=2,m=26,n,k1_1; int flag=gcd(k1,m); if(flag!=1) &#123; cout&lt;&lt;&quot;k1与m不互质，无法解密！&quot;&lt;&lt;endl; return temp; &#125; else &#123; //k1_1=bianli(k1,m); int x0=0,y0=0; k1_1 = gcd_1(k1,m,x0,y0); n = x.size(); for(int i=0;i&lt;n;i++) &#123; temp += k1_1*(x[i]-&#x27;a&#x27;-k2)%m +&#x27;a&#x27;; &#125; return temp; &#125;&#125;int ex_gcd(int a,int b,int &amp;x,int &amp;y)//扩展欧几里德变换ax+by=gcd(a,b)&#123; if(b==0) &#123; x=1; y=0; //cout&lt;&lt;k++&lt;&lt;&quot; dao di le&quot;&lt;&lt;endl; return a; &#125; int res = ex_gcd(b,a%b,x,y); //通过证明得，如何获得上一层x,y //x1=y2,y1=x2-(a/b)*y2 int temp=x; x = y; y = temp-(a/b)*y; //cout&lt;&lt;k++&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl; return x;&#125;int gcd_1(int a,int b,int &amp;x,int &amp;y)//欧几里得算法非递归求逆密钥&#123; int X1=1,X2=0,X3=b; int Y1=0,Y2=1,Y3=a; int T1,T2,T3; int Q; while(1) &#123; if(Y3==0)return X2; if(Y3==1)return Y2; Q=X3/Y3; T1=X1-Q*Y1; T2=X2-Q*Y2; T3=X3-Q*Y3; X1=Y1;X2=Y2;X3=Y3; Y1=T1;Y2=T2;Y3=T3; &#125;&#125; 密钥短语密码 选用一个英文单词或单词串作为密钥。去掉重复字母的到一个字符串排在首端将字母表其余字母依次写入。其他类似一般单表替代密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;using namespace std; string Table_m=&quot;&quot;;char Table_c[26]; void creatTable(char letter[]);string Atoa(string x);string E(string x);string D(string x); int main()&#123; string m,c; char letter[26]; m = &quot;China&quot;; c = &quot;yfgmk&quot;; for(int i=0;i&lt;26;i++) &#123; letter[i]=&#x27;a&#x27;+i; &#125; creatTable(letter); //cout&lt;&lt;Table&lt;&lt;endl; cout&lt;&lt;&quot;请输入明文m:&quot;; cin&gt;&gt;m; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; cin&gt;&gt;c; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;void creatTable(char letter[])&#123; string k=&quot;key&quot;; Table_m += k; int n=k.size(),index; for(int i=0;i&lt;n;i++) &#123; index = k[i]-&#x27;a&#x27;; letter[index]=&#x27;0&#x27;; &#125; for(int i=0;i&lt;26;i++) &#123; if(letter[i]!=&#x27;0&#x27;) Table_m += letter[i]; &#125; for(int i=0;i&lt;26;i++) &#123; index = Table_m[i]-&#x27;a&#x27;; Table_c[index]=letter[i]; &#125;&#125;string Atoa(string x)&#123; string temp=&quot;&quot;; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; if(x[i]&gt;&#x27;Z&#x27;) temp += x[i]; else temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; return temp;&#125;string E(string x)&#123; int n=x.size(),index; string temp=&quot;&quot;; x = Atoa(x); for(int i=0;i&lt;n;i++) &#123; index=x[i]-&#x27;a&#x27;; temp += Table_m[index]; &#125; return temp;&#125;string D(string x)&#123; int n=x.size(),index; string temp=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; index = x[i]-&#x27;a&#x27;; temp += Table_c[index]; &#125; return temp;&#125; 多表替代密码维吉尼亚密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string Atoa(string x);string E(string x);string D(string x);int main()&#123; string m,c; //m = &quot;appliedcryptosystem&quot;; //c = &quot;cxesmvfkgftkqanzxvo&quot;; cout&lt;&lt;&quot;请输入明文m:&quot;; getline(cin,m); cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; getline(cin,c); cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;string Atoa(string x)&#123; string temp=&quot;&quot;; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; if(x[i]==&#x27; &#x27;)continue; if(x[i]&gt;&#x27;Z&#x27;) temp += x[i]; else temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; return temp;&#125;string E(string x)&#123; string k=&quot;chipher&quot;; k=Atoa(k); string temp=&quot;&quot;; int index; x = Atoa(x); int n=x.size(); for(int i=0;i&lt;n;i++) &#123; index=i%6; temp += (k[index]-&#x27;a&#x27;+x[i]-&#x27;a&#x27;)%26+&#x27;a&#x27;; &#125; return temp;&#125;string D(string x)&#123; string k=&quot;chipher&quot;; k=Atoa(k); string temp=&quot;&quot;; int index; int n=x.size(); for(int i=0;i&lt;n;i++) &#123; index=i%6; temp += (x[i]-k[index]+26)%26+&#x27;a&#x27;; &#125; return temp;&#125; 希尔(Hill)密码密钥是一个矩阵，解密是其逆矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277/*后期还要观摩别人的代码将思路进行优化。我觉得我的思路还是比较暴力的，而且有些地方代码重复性比较高，比如加解密矩阵相乘得结果是一样的步骤可以合并，求逆矩阵可以再封成一个函数但现在我还是把他直接写在解密函数里。感觉求解|A|可以利用三阶那个函数迭代……相关知识点转看博客：涉及的C/C++的知识点*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;using namespace std;//以密钥矩阵可逆，加解密成功为前提条件int threeOrder_evaluation(int N,int **K);//三阶行列式|A|求值(对角线方法只适用于二、三阶) int Evaluation_of_Determinant(int N,double **K);//n阶行列式求值 / 判断矩阵是否可逆|A|?=0 double **Adjoint_Matrix(int N,double **K);//求伴随矩阵A* string E(string x);string D(string x); int main()&#123; string c,m; m = &quot;good&quot;; c = &quot;wmwl&quot;; cout&lt;&lt;&quot;E(m) = &quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;D(c) = &quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;string D(string x) &#123; int n=x.size(),N=2; int K[N][N]=&#123;&#123;11,8&#125;,&#123;3,7&#125;&#125;;//53 //int K[N][N]=&#123;&#123;1,1,1&#125;,&#123;0,1,3&#125;,&#123;2,2,5&#125;&#125;;//3 //int K[N][N]=&#123;&#123;3,1,1,1&#125;,&#123;1,3,1,1&#125;,&#123;1,1,3,1&#125;,&#123;1,1,1,3&#125;&#125;;//48 int evaluation;//|A| int K_1[N][N]; int M[N],C[N]; string temp=&quot;&quot;; //创建动态二维数组 double **Key;//密钥A double **BanSui;//伴随矩阵 Key = (double **)malloc(N*sizeof(double *));//行开辟空间 for(int i=0;i&lt;N;i++)//列开辟空间 *(Key+i)=(double*)malloc(N*sizeof(double)); //*(BanSui+i)=(double*)malloc(N*sizeof(double)); for(int i=0;i&lt;N;i++)//将值输入动态数组 for(int j=0;j&lt;N;j++) Key[i][j]=K[i][j]; //求A* BanSui = Adjoint_Matrix(N,Key); //求|A| evaluation = Evaluation_of_Determinant(N,Key)%26; //求A逆 for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) K_1[i][j]=((int(BanSui[i][j])/evaluation)+26)%26; //解密 for(int i=0;i&lt;n;i++) &#123; M[i%N]=x[i]-&#x27;a&#x27;; if(i%N==N-1) &#123; for(int j=0;j&lt;N;j++) &#123; C[j]=0; for(int k=0;k&lt;N;k++) &#123; C[j] += M[k]*K_1[j][k]; &#125; temp += C[j]%26 + &#x27;a&#x27;; &#125; &#125; &#125; for(int i=0;i&lt;N;i++)//释放空间：行 &#123; free(*(Key+i)); free(*(BanSui+i)); &#125; return temp;&#125;double **Adjoint_Matrix(int N,double **K)&#123; double **adjoint,**cofactor;//伴随矩阵，代数余子式 int m,n; int temp[N][N]; //创建动态数组 adjoint = (double **)malloc(N*sizeof(double)); for(int i=0;i&lt;N;i++) adjoint[i] = (double *)malloc(N*sizeof(double)); cofactor = (double **)malloc(N*sizeof(double)); for(int i=0;i&lt;N;i++) cofactor[i] = (double *)malloc(N*sizeof(double)); //求n=2阶伴随矩阵 if(N==2) &#123; m=0,n=0; for(int i=N-1;i&gt;-1;i--) &#123; for(int j=N-1;j&gt;-1;j--) &#123; adjoint[m++][n]=pow(-1,i+j)*K[i][j]; &#125; m=0; n++; &#125; return adjoint; &#125; //求n&gt;2阶伴随矩阵 for(int i=0;i&lt;N;i++) &#123; m=0,n=0; for(int k=0;k&lt;N;k++) &#123; if(k==i)continue; for(int l=0;l&lt;N;l++) &#123; temp[m][n++]=K[k][l]; &#125; m++; n=0; &#125; for(int j=0;j&lt;N;j++) &#123; m=0,n=0; for(int l=0;l&lt;N;l++) &#123; if(l==j)continue; for(int k=0;k&lt;N-1;k++) &#123; cofactor[m++][n]=temp[k][l]; //cout&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;temp[k][l]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;endl; &#125; n++; m=0; //cout&lt;&lt;endl; &#125; //伴随矩阵 adjoint[j][i]=pow(-1,i+j)*K[i][j]*Evaluation_of_Determinant(N-1,cofactor); &#125; &#125; return adjoint;&#125;string E(string x)&#123; int n=x.size(),N=2; int K[N][N]=&#123;&#123;11,8&#125;,&#123;3,7&#125;&#125;; int M[N],C[N]; string temp=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; M[i%N]=x[i]-&#x27;a&#x27;; if(i%N==N-1) &#123; for(int j=0;j&lt;N;j++) &#123; C[j]=0; for(int k=0;k&lt;N;k++) &#123; C[j] += M[k]*K[j][k]; &#125; temp += C[j]%26 + &#x27;a&#x27;; &#125; &#125; &#125; return temp;&#125;int threeOrder_evaluation(int N,int **K)//三阶矩阵求值(对角线方法只适用于二、三阶) &#123; int k,sum=0; int Temp[N][2*N-1]; //第一步：形成对称矩阵 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;2*N-1;j++) &#123; Temp[i][j]=K[i][j%N]; cout&lt;&lt;Temp[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; //第二步：求出每个ai*aj*ak*al int cunzhi1[N],cunzhi2[N]; for(int i=0;i&lt;N;i++) &#123; cunzhi1[i]=1; k=0; for(int j=i;j&lt;i+N;j++) &#123; cunzhi1[i] *= Temp[k++][j]; cout&lt;&lt;cunzhi1[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; for(int i=0;i&lt;N;i++) &#123; cunzhi2[i]=1; k=0; for(int j=N+i-1;j&gt;N+i-4;j--) &#123; cunzhi2[i] *= Temp[k++][j]; cout&lt;&lt;cunzhi2[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; //第三步：求出矩阵的值 for(int i=0;i&lt;N;i++) &#123; sum += cunzhi1[i]-cunzhi2[i]; &#125; return sum; &#125; int Evaluation_of_Determinant(int N,double **K)//n阶行列式求值&#123; float z,ji=1,sum=1; int p=0; for(int i=0;i&lt;N-1;i++)//列 &#123; z = K[i][i]; //这块解决当为&#123;&#123;0,1&#125;,&#123;2,3&#125;&#125;这样矩阵时的情况 while(z==0) &#123; p++; for(int k=0;k&lt;N;k++) &#123; K[i][k]+= K[i+p][k]; &#125; z=K[i][i]; &#125; p=0; ji *= z; //cout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;ji&lt;&lt;endl; for(int k=i;k&lt;N;k++) &#123; K[i][k] /= z; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;K[i][k]&lt;&lt;endl; &#125; for(int j=i+1;j&lt;N;j++)//行 &#123; z = K[j][i]; if(z==0)continue; //cout&lt;&lt;z&lt;&lt;endl; for(int k=i;k&lt;N;k++) &#123; K[j][k] -= z*K[i][k]; //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;K[j][k]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;K[i][k]&lt;&lt;endl; &#125; &#125; &#125; for(int i=0;i&lt;N;i++) &#123; sum *= K[i][i]; //cout&lt;&lt;sum&lt;&lt;&quot; &quot;; &#125; //cout&lt;&lt;endl; return sum*ji;&#125; 一次一密密码(One Time Pad)Playfair 密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; char keyTable[6][6];string key; void Modify_key(string k);//密钥创建+内容修改string Modify_m(string x);//明文格式内容修改string Modify_c(string x);void Init();int index(char x);string E(string x);string D(string x); int main()&#123; string m,c; //m=&quot;playfair cipher&quot;; //c=&quot;layfpyrsmramcd&quot;; Init(); cout&lt;&lt;&quot;请输入明文m:&quot;; getline(cin,m); cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; getline(cin,c); cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125; string Modify_c(string x)&#123; string temp=&quot;&quot;; int n=x.size(); char k=&#x27;x&#x27;; for(int i=0;i&lt;n;i++) &#123; if(x[i]==x[i+2]&amp;&amp;x[i+1]==k) &#123; temp+=x[i]; temp+=x[i+2]; i += 2; continue; &#125; if(x[n-1]==k)continue; temp += x[i]; &#125; return temp;&#125;string D(string x)&#123; int n=x.size(),N1,N2,x1,x2,y1,y2; string temp=&quot;&quot;; for(int i=0;i&lt;n;i+=2) &#123; N1=index(x[i]); N2=index(x[i+1]); x1=N1/5;y1=N1%5; x2=N2/5;y2=N2%5; if(x1==x2) &#123; y1=(y1+4)%5; y2=(y2+4)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else if(y1==y2) &#123; x1=(x1+4)%5; x2=(x2+4)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else &#123; temp+=keyTable[x1][y2]; temp+=keyTable[x2][y1]; &#125; &#125; temp=Modify_c(temp); return temp;&#125; string Modify_m(string x)&#123; int n=x.size(); char k=&#x27;x&#x27;; string temp=&quot;&quot;,temp1=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; if(x[i]==&#x27; &#x27;)continue; temp1+=x[i]; &#125; n=temp1.size(); for(int i=0;i&lt;n;i+=2) &#123; temp+=temp1[i]; if(x[i]==x[i+1]) &#123; temp+=k; i--; continue; &#125; temp+=temp1[i+1]; &#125; n=temp.size(); if(n%2!=0)temp+=k; return temp;&#125;void Modify_key(string k)&#123; int n=k.size(),index,flag=1; int x=0,y=0; char letter[26]; string temp=&quot;&quot;;//关于去重：可以创建一个顺序的字母数组，循环的时候当key中第一次出现该字符将索引值下内容改为‘0’，下一次再遇到该值因为为‘0’所以就不管啦 for(int i=0; i&lt;26; i++) &#123; letter[i]=&#x27;a&#x27;+i; &#125; for(int i=0; i&lt;n; i++) &#123; if(k[i]==&#x27; &#x27;)continue; else &#123; index = k[i]-&#x27;a&#x27;; if(k[i]==letter[index]) &#123; temp += k[i]; letter[index]=&#x27;0&#x27;; if(k[i]==&#x27;i&#x27;||k[i]==&#x27;j&#x27;)flag=0; &#125; &#125; &#125; for(int i=0; i&lt;26; i++) &#123; if(flag==1&amp;&amp;(k[i]==&#x27;i&#x27;||k[i]==&#x27;j&#x27;)) &#123; temp+=letter[i]; flag = 0; &#125; if(letter[i]!=&#x27;0&#x27;&amp;&amp;k[i]!=&#x27;i&#x27;&amp;&amp;k[i]!=&#x27;j&#x27;) &#123; temp += letter[i]; &#125; if(letter[i]==&#x27;w&#x27;)temp+=letter[i];//不知道为啥w就是判断不了QAQ &#125; key = temp; for(int i=0;i&lt;25;i++) &#123; keyTable[x][y]=temp[i]; y++; if(y%5==0) &#123; x++; y=0; &#125; &#125;&#125;int index(char x)&#123; int i; for(i=0;i&lt;26;i++) &#123; if(key[i]==x)break; &#125; return i;&#125;string E(string x)&#123; string temp=&quot;&quot;; x=Modify_m(x); int n=x.size(),N1,N2,x1,x2,y1,y2; for(int i=0;i&lt;n;i+=2) &#123; N1=index(x[i]); N2=index(x[i+1]); x1=N1/5;y1=N1%5; x2=N2/5;y2=N2%5; if(x1==x2) &#123; y1=(y1+1)%5; y2=(y2+1)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else if(y1==y2) &#123; x1=(x1+1)%5; x2=(x2+1)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else &#123; temp+=keyTable[x1][y2]; temp+=keyTable[x2][y1]; &#125; &#125; return temp;&#125;void Init()&#123; string k=&quot;playfair is a digram cipher&quot;; Modify_key(k);&#125; 2.2 置换密码周期置换密码给予的明文必须是以密钥k的倍数形式（因为要以k个字母为一组进行每组置换） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;string E(string x)；string D(string x)；int main()&#123; string m,c; m = &quot;cryptographycry&quot;; c = &quot;ytcoprahgypr&quot;; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;string E(string x)&#123; int k=6; int k_m[k]=&#123;2,4,0,5,3,1&#125;; int n=x.size(),index,flag=0; string temp1=&quot;&quot;,temp2=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; temp1 += x[i]; if(i%k==5) &#123; for(int i=0;i&lt;6;i++) &#123; index = k_m[i]; temp2+= temp1[index]; &#125; temp1 = &quot;&quot;; &#125; &#125; return temp2;&#125;string D(string x)&#123; int k=6; int k_m[k]=&#123;2,4,0,5,3,1&#125;; int k_c[k]; for(int i=0;i&lt;k;i++) &#123; for(int j=0;j&lt;k;j++) &#123; if(k_m[j]==i) &#123; k_c[i]=j; // cout&lt;&lt;j&lt;&lt;endl; break; &#125; &#125; &#125; int n=x.size(),index; string temp1=&quot;&quot;,temp2=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; temp1 += x[i]; if(i%k==5) &#123; for(int i=0;i&lt;6;i++) &#123; index = k_c[i]; temp2+= temp1[index]; //cout&lt;&lt;index&lt;&lt;temp2&lt;&lt;endl; &#125; temp1 = &quot;&quot;; &#125; &#125; return temp2;&#125;/*1 2 3 4 5 63 5 1 6 4 21 2 3 4 5 63 6 1 5 2 4*/ 列置换密码原本解密想不用数组的……但没写出比较好的QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;using namespace std; string Modify_m(string x);string E(string x);string D(string x); int main()&#123; string m,c; m = &quot;This boy is a worker Th&quot;; //c = &quot;sioriywehoaktbsr&quot;; c = &quot;sioriywehoakhtbsrt&quot;; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125; string Modify_m(string x)&#123; int n=x.size(); string temp=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; if(x[i]==&#x27; &#x27;)continue; if(x[i]&lt;&#x27;a&#x27;) temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; else temp += x[i]; &#125; return temp;&#125;string E(string x)&#123; x = Modify_m(x); int n=x.size(),k=4,index; int k_m[k]=&#123;3,2,1,0&#125;; string temp0=&quot;&quot;,temp1=&quot;&quot;,temp2=&quot;&quot;; if(n%k!=0) &#123; for(int i=0;i&lt;k-n%k;i++) x += &#x27;?&#x27;; n += k-n%k; &#125; for(int i=0;i&lt;n;i++) &#123; temp0 += x[i]; if(i%k==3) &#123; for(int i=0;i&lt;k;i++) &#123; index = k_m[i]; temp1 += temp0[index]; &#125; temp0=&quot;&quot;; &#125; &#125; for(int i=0;i&lt;k;i++) &#123; for(int j=i;j&lt;n;j+=k) &#123; if(temp1[j]==&#x27;?&#x27;) continue; else temp2 += temp1[j]; &#125; &#125; return temp2;&#125;string D(string x)&#123; int n=x.size(),k=4,m=n/4+1,p=0; int k_m[k]=&#123;3,2,1,0&#125;,k_c[k]; string temp=&quot;&quot;; char table[m][k]; for(int i=0;i&lt;k;i++) &#123; for(int j=0;j&lt;k;j++) &#123; if(k_m[j]==i) &#123; k_c[i]=j; break; &#125; &#125; &#125; if(n%4==0)m=n/4; for(int i=0;i&lt;k;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(j==m-1&amp;&amp;k_m[i]&gt;(n-1)%4) &#123; table[j][i]=&#x27;?&#x27;; p++; &#125; else table[j][i]=x[i*m+j-p]; //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i*m+j-p&lt;&lt;&quot; &quot;&lt;&lt;table[j][i]&lt;&lt;endl; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;k;j++) &#123; p=k_c[j]; if(table[i][p]==&#x27;?&#x27;)continue; else temp += table[i][p]; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;table[i][p]&lt;&lt;endl; &#125; &#125; return temp;&#125; 2.3 转轮机密码艾尼格玛，多表替代，密钥：三个轮子的初态","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"《计算机网络》——第三章 数据链路层","slug":"笔记/计算机网络/第三章 数据链路层","date":"2022-03-28T15:40:41.892Z","updated":"2022-03-28T15:48:54.628Z","comments":true,"path":"2022/03/28/笔记/计算机网络/第三章 数据链路层/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/28/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《计算机网络》——第二章 物理层","slug":"笔记/计算机网络/第二章 物理层","date":"2022-03-28T15:40:41.892Z","updated":"2022-04-03T06:16:10.678Z","comments":true,"path":"2022/03/28/笔记/计算机网络/第二章 物理层/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/28/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"通信、难处理 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流（传输媒体本身并不属于物理层的范围） 物理层的作用是尽可能地屏蔽传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到差异，使其只需要考虑如何完成本层协议和服务。 物理层的协议，常称为物理层规程（使用更早的原因） 物理层的主要任务 BIOS/POST 通电自检，确保硬件是否准备好 串行传输和并行传输数据在计算机内部多采用并行传输方式。但数据在通信线路(传输媒体)上的传输方式一般都是串行传输(经济)，即逐个比特按照时间顺序传输。因此，物理层还要完成传输方式的转换。 PC数字信号(离散，失真小)，电话模拟信号(连续)–&gt;有空查一下 数据通信数据通信系统模型 术语-&gt; 数据、信号、码元 通信的目的就是传送消息(message)。话音、文字、图像、视频等都是消息 数据(data)：运送消息的实体 数据是信息的载体，信息是有用的数据 信号：数据的电子的/电磁的表现 模拟信号(用户线)、数字信号(中继线) 物质、能量和信息是构成客观世界的三要素 1.消息、信息、信号的区别消息的定义：是指包含信息的语言，文字和图像等，可表达客观事物和主观思维活动的状态信号：是把消息变换成电信号，声信号等适合信道传输的物理量 那什么是信息呢?1）指事物中包含的内容2）是事物在运动状态或存在形式上的不确定性的描述（即不确定性越大，信息越多） 信息与消息的关系是什么？消息是信息的载体，包含关系 消息与信号的联系是什么？信号是把消息转换成电信号等，然后在信道上面传输，所以信号是消息的运载工具 数据和信息之间是相互联系的。数据是反映客观事物属性的记录，是信息的具体表现形式。数据经过加工处理之后，就成为信息；而信息需要经过数字化转变成数据才能存储和传输。 数据=信息+数据冗余 码元(code)：一个时间域(时间段)表示离散数值的基本波型(表示数字信号的基本模型) &lt;– 数字信号 码元是数据的载体（一个码元可以携带1bit，多个码元也可以携带1bit，1个码元也可以携带多个bit） 数据上存在上限（受物理介质的限制(数据传输速率)、受码元携带数据的限制(通信:码元 &lt;- 调制解调；计算机:数据–&gt;理想：一个码元带更多的数据)） 波的类型：高电平1、低电平0（2类码元) 一共有7个码元（4个低电平，3个高电平） 芯片：负逻辑(高电平0、低电平1)–&gt;减耗(高电平多费电：功耗) 数据是信息的载体，码元是数据的载体 信道的概念-&gt; 基带调制/带通调制，信道(channel)：一般用来表示向某一个方向传送信息的媒体，与电路并不等同 ​ （一条通信电路包含：一条发送信道和一条接收信道） 通信双方信息交互的三种基本方式 单向通信/单工通信：一个方向的通信，无反向交互（电视广播） 双向交替通信/双工通信：可双方交互，但不能同时发送/接收 （！注意：“单工电台”指的是双向交替通信） 双向同时通信/全双工通信：双方可同时发送和接收 信源的信号常称为基带信号(基本频带信号，高低电平) –&gt; 计算机输出的代表各种文字图像文件的数据信号 ​ 基带信号包含许多的低频分量和直流分量，而许多信道并不能传输这些分量 –&gt; 对基带信号进行调制 调制分类： 基带调制： 由于是把数字信号转换为另一种形式的数字信号，又叫做编码 仅对基带信号的波形进行变换 –&gt; 与信道特征相适应，信号仍为基带信号 带通调制： 使用载波(carrier) 进行调制，把基带信号的频率范围搬移到较高的频段，并转为模拟信号 –&gt; 更好在模拟信道传输 ​ （频带变宽，使用的频带窄） 有没有相位移动 二元调制法：只有两个状态 多元调制法：正交振幅调制QAM（一个码元携带更多的二进制位） ​ 如图，由于4bit编码共有16种不同的组合，因此这16个点中的每一个点可对应于一种4bit的编码 ​ 若每一个码元可表示的比特数越多，则在接收端进行解调时，要正确识别每一种状态就越困难。 信道的极限容量（上界/上限） 寻找提高数据传输速率的途径 只要从失真的波形中能够识别出来原来的信号，那么失真对通信质量可视为无影响。 非理想信道：码元传输的速率越高，信号传输的距离越远，噪声干扰越大或传输媒体质量越差，在接收端的波形的失真就越严重。 限制码元在信道上的传输速率的因素： 信道能够通过的频率范围 码间串扰：具体的信道所能通过的频率范围总是有限的，而信道中存在许多的高频分量不能通过信道。如果信号中的高频分量在传输中衰减，导致不能区分每个码元之间的所占清晰时间界限。–&gt; 一串码元模糊而无法识别 为了避免码间串扰，码元的传输速率存在上限值。–&gt; 奈氏准则 奈氏准则： ​ 理想低通信道的最高码元传输速率 = 2W（Baud） ​ 理想带通信道的最高码元传输速率 = W（Baud） ​ W是带宽，Baud是单位：波特（一秒传x个码元） 如何判断理想低通信道？ ​ 人的说话的信道（300-3400Hz），其他都是理想带通信道 不能单依靠带宽判断，还要看其高低频 ​ 1MHz 带通 ​ 2kHz : 0.001M或0.003M 要分情况（没太懂……） 线限制了带宽，限制其1秒能跑多少码元 人关心的是信息的传输速率（1秒传了多少比特） 信噪比","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"蓝桥云课","slug":"刷题/蓝桥知识点","date":"2022-03-21T15:53:18.427Z","updated":"2022-04-19T01:09:54.211Z","comments":true,"path":"2022/03/21/刷题/蓝桥知识点/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/21/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"STL 中 link 容器 数据结构基础-链表实验介绍我们这门课是算法，这里所讲的数据结构倾向于实战，大家不要拘泥于具体的写法，而重在学习原理，和使用方式，我们所需要的是简洁、实用和快速。我们这节课主要目标学会三种链表的原理与实现，学会灵活地运用，能够不依赖于模板根据题目独立写出各类链表。 我们不是数据结构教程，经典的数据结构采用 C 或 C++ 采用模板类进行编写，但是非常不适合竞赛使用，几行代码硬是能写成十几行，提高了复用性但是浪费了书写时间。所以并不适合竞赛，竞赛追求效率、accept 和简洁。 知识点 单链表实现原理与应用 双向链表实现原理与应用 循环链表实现原理与应用 为什么使用链表相信大家在这之前已经学过数组，无论是 C++,Java,Python 还是其它语言大都会有数组这一概念，好用吗？很好用，所谓数组其实就是线性表的顺序存储形式的原理，我们来看一下链表的定义并对比一下链式存储与顺序存储的存储方式。 什么是链表链表是线性表的链式存取的数据结构，是一种链式存取的数据结构，是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：数据域（数据元素的映象）+ 指针域（指示后继元素存储位置），数据域就是存储数据的存储单元，指针域就是连接每个结点的地址数据。 相比于线性表顺序结构，操作复杂。 似乎定义是有些晦涩难懂，我们用两张图来对比一下数组也就是线性表的顺序存储结构和链表在内存中存储 1-9 号元素的形式： 顺序存储 链式存储 思考一下： 线性表的数据存储方式的内存地址是顺序的，链式存储的数据的内存地址的有什么规律呢？ 事实上链式存储的内存地址的是随机分配的，他们每个节点地址之间是没有任何关联的。而且在每个新的节点在产生之前，我们都是不知道他的地址的。 链表初体验通过上面的介绍，大家可能还是不太能理解为什么要使用链表或者还不懂什么是链表，我们用一个题目来引入。 小王子有一天迷上了排队的游戏，桌子上有标号为 1-10 按顺序摆放的 10 个玩具，现在小王子想将它们按自己的喜好进行摆放。小王子每次从中挑选一个好看的玩具放到所有玩具的最前面。已知他总共挑选了 M 次，每次选取标号为 X 的玩具放到最前面，求摆放完成后的玩具标号。 给出一组输入，M=8 共计排了 8 次，这 8 次的序列为 9，3，2，5，6，8，9，8。 求最终玩具的编号序列。 我们首先梳理一下基本的模拟方法的思路，这个题该怎么去解答： 首先我们要开一个长度为 11 的数组，因为下标要从 1 开始所以 0 — 10 共计 11 个元素。 1a[11]=&#123;0,1,2,3,4,5,6,7,8,9,10&#125; 然后根据题意我们要写一个查找函数： 123456789//伪代码形式int Funciton 查找(X)&#123; range i in(1, 10) //循环从x位置到2号位置 if data[i] == x : //找到X返回 return i end if end range&#125; 我们简单描述一下这个过程: 首先是步进查找比如查找值为 5 元素的下标： 找到元素后返回下标，值为 5。 最后我们找到元素后要进行插入操作。 123456789101112void Function 移动(L)&#123; //移动函数 //拿走了X,X在L位置,所以将L-1向后移动到L,依次向后移动空处最前面的位置 temp = data[L] range i in(L, 2) //循环从L位置到2号位置 data[i] = data[i - 1] //向后移动 end range data[i] = temp&#125; 我们还是以 5 为例，要把 5 移到到首位，肯定不是把 5 放到第一位就行。 讲到这里，大部分同学肯定会写出如下代码： 123456789101112131415161718192021222324252627282930313233//伪代码形式int Funciton 查找(X)&#123; range i in (1,10) //循环从x位置到2号位置 if data[i]==x : //找到X返回 return i end if end range&#125;void Function 移动(L)&#123; //移动函数 //拿走了X,X在L位置,所以将L-1向后移动到L,依次向后移动空处最前面的位置 temp=data[L] range i in (L,2) //循环从L位置到2号位置 data[i]=data[i-1] //向后移动 end range data[i]=temp&#125;void Main()&#123; 输入 M range in (1,M) //循环M次 输入 X L=查找(X) 移动(L) end range&#125; 这样每次调用移动函数即可，M=8 调用 8 次函数，每次传入 X 找到位置后,即可得到正确答案。 如果我们规定每次循环的时间复杂度为 1 的话，这次花费了我们多少时间呢？ X=9 查找 9 循环了 9 次 移动花费了 9 次 此时序列为 9,1,2,3,4,5,6,7,8,10 X=3 查找 3 循环了 4 次 移动花费了 4 次 此时序列为 3,9,1,2,4,5,6,7,8,10 我们看到每次都花费了大量时间去移动。如果我们采用链表去存储呢，会是什么样子呢。 我们来模拟一下过程: 这是初始序列 第一次输入 X=9: 执行查询操作: 执行删除操作 给 9 前面结点的指针赋值为 9 的指针，再将 9 删除。 执行插入操作： 新建一个结点, data 部分为 9 ,将结点插入链表的首部 相比之下后者执行的操作更少，速度更快，那我们给出该题目的一个标准的答案及详细解析。 题目解析我们学了前面那么多的知识点，我们来动手解答一下小王子的问题了。 首先，我们使用链表的话，要先给出结点的定义，上面讲到链表的形式。 结点定义： 12345struct Node&#123; int data; Node *next;&#125; 第二步，我们要先构成一个这样的链表：head-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 123456789101112131415161718192021222324252627282930Node * head=new Node; //先生成头结点void init() &#123; head-&gt;next = nullptr; //形成空链，由上文已知单链表最后一个结点的指针为空。 for (int i = 10; i &gt;= 1; i--) &#123; Node *temp = new Node; temp-&gt;data = i; temp-&gt;next = head-&gt;next; head-&gt;next = temp; &#125; &#125; //由于我们后边会用到插入函数，其实我们可以写成插入函数的形式 void insert(int x) &#123; Node* temp=new Node; temp-&gt;data=x; temp-&gt;next=head-&gt;next; head-&gt;next=temp; &#125; void init()&#123;//为了美观，我们写个初始化函数 head-&gt;next=nullptr; //无论用什么方式，都不能省略该语句，不然无法正常使用。 for(int i=10;i&gt;=1;i--) insert(i);//从10开始插入 &#125; 第三步，我们要写一个插入函数 12345678void insert(int x)&#123; Node *temp = new Node; //新建一个结点 temp-&gt;data = x; //把数据域赋值为x temp-&gt;next = head-&gt;next; head-&gt;next = temp; //将节点加入到链表中&#125; 第四步我们要写一个删除函数，通过遍历链表删掉想要的数字 123456789101112131415161718void del(int x)&#123; Node *Befor = head; //用于存放当前节点的前驱，因为单链表单向遍历，我们不能从下一个找到上一个 for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; if (T-&gt;data == x) //找到要的那个数了 &#123; Node *temp = T; //先临时保存结点 Befor-&gt;next = T-&gt;next; //将节点从链表上摘除 delete temp; //从内存中删除结点。 return; //删除结束后，结束函数。 &#125; Befor = T; //前驱改变 &#125;&#125; 第五步我们写一个遍历输出函数，形式接近于删除函数 123456789void show(int i)&#123; cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 最后一步我们编写主函数 12345678910111213141516int main()&#123; init(); show(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; 我们带入之前的样例进行测试：N=8 X= 9 3 2 5 6 8 9 8。 完整代码如下： C++写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;Node *head = new Node; //先生成头结点void init()&#123; head-&gt;next = nullptr; //形成空链，由上文已知单链表最后一个结点的指针为空。 for (int i = 10; i &gt;= 1; i--) &#123; Node *temp = new Node; temp-&gt;data = i; temp-&gt;next = head-&gt;next; head-&gt;next = temp; &#125;&#125;void del(int x)&#123; Node *Befor = head; //用于存放当前节点的前驱，因为单链表单向遍历，我们不能从下一个找到上一个 for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; if (T-&gt;data == x) //找到要的那个数了 &#123; Node *temp = T; //先临时保存结点 Befor-&gt;next = T-&gt;next; //将节点从链表上摘除 delete temp; //从内存中删除结点。 return; //删除结束后，结束函数。 &#125; Befor = T; //前驱改变 &#125;&#125;void insert(int x)&#123; Node *temp = new Node; temp-&gt;data = x; temp-&gt;next = head-&gt;next; head-&gt;next = temp;&#125;void show(int i)&#123; cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; //提交代码时删掉这一行 for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; init(); show(0);//提交代码时删掉这一行 int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; Python 写法 Java 写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Node: def __init__(self, value, next=None): self.value = value self.next = nextdef createLink(): root = Node(0) tmp = root for i in range(1, 11 ): tmp.next = Node(i) tmp = tmp.next tmp.next = None return rootdef insert(x, linkedroot): tmp = Node(x) tmp.next = root.next root.next = tmpdef delete(x, root): tmp = tmp1 = root while tmp != None: if tmp.value == x: tmp1.next = tmp.next tmp1 = tmp tmp = tmp.nextdef show(root): tmp = root.next while tmp.next != None: print(tmp.value, end=&quot; &quot;) tmp = tmp.next print(&quot;&quot;)if __name__ == &#x27;__main__&#x27;: n = int(input()) root = createLink() # show(root) for i in range(n): x = int(input()) delete(x, root) insert(x, root) show(root) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Scanner;public class Main &#123; static class Node &#123; int data; Node next; Node(int v) &#123; data = v; &#125; &#125;//成员类，代表节点，类似于C++语言中的结构体 static Node head = new Node(1);//头节点单列出来 static void init() &#123; Node x = head; for (int i = 1; i &lt;= 10; i++) x = (x.next = new Node(i));//建立单向链表 x.next = null; &#125; static void del(int x) &#123; Node Befor = head; //用于存放当前节点的前驱，因为单链表单向遍历，我们不能从下一个找到上一个 for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; if (T.data == x) //找到要的那个数了 &#123; Node temp = T; //先临时保存结点 Befor.next = T.next; //将节点从链表上摘除 return; //删除结束后，结束函数。 &#125; Befor = T; //前驱改变 &#125; &#125; static void insert(int x) &#123; Node temp = new Node(x); temp.next = head.next; head.next = temp; &#125; static void show(int i) &#123; // System.out.println(&quot;这是第&quot; + i + &quot;次操作&quot;);//提交代码时删掉这一行 for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; System.out.print(T.data + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; public static void main(String[] args) &#123; int N; Scanner in = new Scanner(System.in); init(); N = in.nextInt(); // show(0);//提交代码时删掉这一行 for (int i = 0; i &lt; N; i++) &#123; int x = in.nextInt(); del(x); insert(x); show(i); &#125; &#125;&#125; 以上为带有头结点的单链表，相应的还有没有头结点的单链表，有兴趣的同学可以自行查阅资料。在比赛中我们常用 STL 中 link 容器而很少会去定义和使用，这一章节我们主要是学会原理和使用，原理学会之后无论是什么样的链表都是可以设计出来的。 头结点： 如果链表有头节点，则链式结构中的第一个节点称为头结点，其数据域可以存储一些附加信息，如链表长度；其指针域指向链表中的第一个节点。 经过上面对小王子这个题的讲解，相信大家都对这个链表的有点有了一个初步的认识，我们看到链表的使用确实很方便，在我们不需要随机访线性表里面的元素时，使用链表确实要方便很多，无论是时间复杂度还是空间复杂度都十分优秀。下面我们对线性表的两种存储方式的对比。 链表与顺序表优缺点对比经过上面的讲解，大家应该都已经对线性表存储数据有了一定的了解，线性表是编写程序中的最常见数据结构，对于顺序和链式两种存储结构我们到底该在何时选择哪一种存储方式? 我们对两种存储方式做一个对比。 顺序表优点: 无需为表示结点间的逻辑关系而增加额外的存储空间（因为逻辑上相邻的元素其存储的物理位置也是相邻的）； 可方便地随机存取表中的任一元素: 由于顺序表每个元素的大小相等，且知道第几个元素就可以通过计算得到任意元素的地址，既可以随机存取任一元素。 缺点: 插入或删除运算不方便： 除表尾的位置外，在表的其它位置上进行插入或删除操作都必须移动大量的结点，其效率较低； 如在 8、9 之 间插入 X 元素，那我们为了保证其顺序性需要把 8 和 9 向后移动一位，再将 X 放到 8 的位置。 这样的存储方式增加了处理器和 IO 资源的消耗代价，这是我们不愿意看到的，至于删除其原理相同，我们不再进行赘述。 难以匹配存储规模： 由于顺序表要求占用连续的存储空间，存储分配只能预先进行静态分配，因此当表长变化较大时，难以确定合适的存储规模。 时间复杂度查找操作为 O(1)，插入和删除操作为 O(n)。 时间复杂度的计算： 时间复杂度不是一个具体的数字，而是一个量级。 常见的时间复杂度量级如下： 常数阶 O(1) &lt; 对数阶 O(log2n) &lt; 线性阶 O(n) &lt; 线性对数阶 O(n log_{2}n)O(nlo**g2n) &lt; 平方阶 O(n^{2})O(n2) &lt; 方阶 O(n^{3})O(n3) &lt; k 次方阶 O(n^{K})O(n**K) &lt; 指数阶 O(2^{n})O(2n) &lt; 阶乘阶O(n!)O(n!) &lt; O(n^{n})O(n**n) 具体的计算方法其他章节会进行讲述，这里大家简单知道时间复杂度量级的大小即可。 链表优点: 插入和删除速度快，保留原有的物理顺序，在插入或者删除一个元素的时候，只需要改变指针指向即可； 没有空间限制, 存储元素无上限, 只与内存空间大小有关； 动态分配内存空间，不用事先开辟内存； 使内存的利用率变高。 缺点: 占用额外的空间以存储指针，比较浪费空间，不连续存储，Malloc 函数开辟空间碎片比较多； 查找速度比较慢，因为在查找时，需要循环遍历链表。 时间复杂度: 查找操作为 O(n), 插入和删除操作为 O(1)。 使用循环链表解决约瑟夫环问题将单链表或者双链表的头尾结点链接起来，就是一个循环链表。不增加额外存储花销，却给不少操作带来了方便从循环表中任一结点出发，都能访问到表中其他结点。 循环链表的组成 特点： 首尾相接的链表。 可以从任一节点出发，访问链表中的所有节点。 判断循环链表中尾结点的特点：q-&gt;next==first 通过观察不难发现，循环链表与单链表的差别就是最后的指针一个为空一个与 First 相等，其他的都没有什么变化，也就是多了一个循环遍历的过程。 约瑟夫环问题设有 n 个人围坐在圆桌周围，现从某个位置 k(1≤k≤n) 上的人开始报数，报数到 m 的人就站出来。下一个人，即原来的第 m+1 个位置上的人，又从 1 开始报数，再报数到 m 的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这 n 个人的出列顺序。 要求一：采用循环链表解决 要求二：可以使用模拟法，模拟循环链表 要求三：可以不使用循环链表类的定义使用方式 大家可以先思考一下如何实验，在 OJ 或者右侧的环境中动手完成。 具体实验步骤思路分析首先要通过循环链表模拟一整个过程，然后再寻找删除位置。 删除位置的计算： 从线性表中起始位置 index 出发开始计数，当计数到 m 时（间隔 m-1 个数据），删除该位置上的元素；同时该位置又是下一次计数的起始位置：index=(index+k-1) 代码编写 C++解法： 第一步：定义循环链表的结点结构体 123456789//头文件与命名空间#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *pNext;&#125;; 第二步：定义主函数直接进行解题： 信息输入，和所续变量的声明 123int n, k, m, i; //n个人从k位置开始报数，数到m出列struct Node *p, *q, *head;cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; 依据题目构造循环链表，可以看出我们直接把插入的函数，拿到了这里来使用。 1234567891011first = (Node *)new Node;p = first;first-&gt;data = 1;for (i = 2; i &lt;= n; i++)&#123; q = new Node; q-&gt;data = i; p-&gt;pNext = q; p = p-&gt;pNext;&#125;p-&gt;pNext = first; 寻找报数的起点 123p = first;for (i = 1; i &lt;= k - 1; i++) p = p-&gt;pNext; 按照顺序依次出链表 123456789101112131415while (p != p-&gt;pNext) //只剩下一个结点的时候停止&#123; for (i = 1; i &lt; m - 1; i++) &#123; p = p-&gt;pNext; &#125; q = p-&gt;pNext; //q为要出队的元素 cout &lt;&lt; q-&gt;data &lt;&lt; endl; p-&gt;pNext = q-&gt;pNext; delete q; p = p-&gt;pNext;&#125;cout &lt;&lt; p-&gt;data &lt;&lt; endl; //输出最后一个元素&#125; 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//头文件与命名空间#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *pNext;&#125;;int main()&#123; int n, k, m, i; //n个人从k位置开始报数，数到m出列 Node *p, *q, *head; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; Node * first = (Node *)new Node; p = first; first-&gt;data = 1; for (i = 2; i &lt;= n; i++) &#123; q = new Node; q-&gt;data = i; p-&gt;pNext = q; p = p-&gt;pNext; &#125; p-&gt;pNext = first; p = first; for (i = 1; i &lt;= k - 1; i++) // p = p-&gt;pNext; while (p != p-&gt;pNext) //只剩下一个结点的时候停止 &#123; for (i = 1; i &lt; m - 1; i++) &#123; p = p-&gt;pNext; &#125; q = p-&gt;pNext; //q为要出队的元素 cout &lt;&lt; q-&gt;data &lt;&lt; endl; p-&gt;pNext = q-&gt;pNext; delete q; p = p-&gt;pNext; &#125; cout &lt;&lt; p-&gt;data &lt;&lt; endl; //输出最后一个元素 return 0;&#125; Java 解法 Python 解法 双向链表再求解小王子问题单链表的主要不足之处是 link 字段仅仅指向后继结点，不能有效地找到前驱。双链表弥补了上述不足之处，增加一个指向前驱的指针 。 由于在双向链表中既有前向链又有后向链，寻找任一个结点的直接前驱结点与直接后继结点变得非常方便。设指针 p 指向双链表中某一结点，则有下式成立： 1p-&gt; llink-&gt;rlink = p = p-&gt;rlink-&gt;llink 双向链表的实现还记得我们在小王子那一题目中所定义前驱变量吗? 因为单链表只能单向遍历所以我们要定义临时变量，如果我们改成双向链表这个题目这里就可以进行优化。 首先，我们使用链表的话，要先给出结点的定义，上面讲到链表的形式。 123456struct Node&#123; int data; Node *next; Node *before;&#125; 第二步，我们要先构成一个这样的链表：head &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 &lt;-&gt; 6 &lt;-&gt; 7 &lt;-&gt; 8 &lt;-&gt; 9 &lt;-&gt; 10 1234567891011121314151617181920void insert(int x)&#123; Node *temp = new Node; temp-&gt;data = x; temp-&gt;next = head-&gt;next; head-&gt;next = temp; temp-&gt;before = head; if (temp-&gt;next) temp-&gt;next-&gt;before = temp;&#125;Node *head = new Node; //先生成头结点void init()&#123; //为了美观，我们写个初始化函数 head-&gt;next = nullptr; //无论用什么方式，都不能省略该语句，不然无法正常使用。 head-&gt;before = nullptr; for (int i = 10; i &gt;= 1; i--) insert(i); //从10开始插入&#125; 第三步我们要写一个删除函数，通过遍历链表删掉想要的数字 12345678910111213void del(int x)&#123; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; if (T-&gt;data == x) &#123; //找到要的那个数了 T-&gt;before-&gt;next = T-&gt;next; //双向链表，就是如此简单方便。 T-&gt;next-&gt;before=T-&gt;before; return; //删除结束后，结束函数。 &#125; &#125;&#125; 第四步我们写一个遍历输出函数，形式接近于删除函数 123456789void show(int i)&#123; cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 最后一步我们编写主函数 12345678910111213141516int main()&#123; init(); show(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; 我们带入之前的样例进行测试：N=8 X= 9 3 2 5 6 8 9 8。 我们可以看到这里的删除非常简单，这么写的话大大简化删除了过程，所以在不同题目下灵活地选取链表能够使得解题变得简单。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next; Node *before;&#125;;Node* head = new Node; //先生成头结点void insert(int x)&#123; Node* temp=new Node; temp-&gt;data=x; temp-&gt;next=head-&gt;next; head-&gt;next=temp; temp-&gt;before=head; if(temp-&gt;next) temp-&gt;next-&gt;before=temp;&#125;void init() //为了美观，我们写个初始化函数&#123; head-&gt;next=nullptr; //无论用什么方式，都不能省略该语句，不然无法正常使用。 head-&gt;before=nullptr; for(int i=10; i&gt;=1; i--) insert(i); //从10开始插入&#125;void del(int x)&#123; for(Node*T=head-&gt;next; T!=nullptr; T=T-&gt;next) //链表的遍历常用写法 &#123; if(T-&gt;data==x) //找到要的那个数了 &#123; T-&gt;before-&gt;next=T-&gt;next;//双向链表，就是如此简单方便。 T-&gt;next-&gt;before=T-&gt;before; return; //删除结束后，结束函数。 &#125; &#125;&#125;void show(int i)&#123; // cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; init(); // show(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; Java 解法： Python 解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485iimport java.util.Scanner;public class Main&#123; static class Node &#123; int data; Node next; Node before; Node(int v) &#123; data = v; &#125; &#125; //成员类，代表节点，类似于C++语言中的结构体 static Node head = new Node(1); //头节点单列出来 static void init() &#123; Node x = head; for (int i = 1; i&lt;= 10; i++) &#123; x.next = new Node(i); //建立双向链表 x.next.before = x; x = x.next; &#125; x.next = null; &#125; static void del(int x) &#123; for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; if (T.data == x) //找到要的那个数了 &#123; T.before.next = T.next; //将节点从链表上摘除 T.next.before=T.before; return; //删除结束后，结束函数。 &#125; &#125; &#125; static void insert(int x) &#123; Node temp = new Node(x); temp.next = head.next; temp.next.before = temp; head.next = temp; &#125; static void show(int i) &#123; // System.out.println(&quot;这是第&quot; + i + &quot;次操作&quot;); for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; System.out.print(T.data + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; public static void main(String[] args) &#123; int N; //n个人从k位置开始报数，数到m出列 Scanner in = new Scanner(System.in); init(); N = in.nextInt(); // show(0); for (int i = 0; i &lt; N; i++) &#123; int x = in.nextInt(); del(x); insert(x); show(i); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Node: def __init__(self, value, next=None): self.value = value self.next = nextdef createLink(): root = Node(0) tmp = root for i in range(10): tmp.next = Node(i+1) tmp = tmp.next tmp.next = None return rootdef insert(x, linkedroot): tmp = Node(x) tmp.next = root.next root.next = tmpdef delete(x, root): tmp = tmp1 = root while tmp != None: if tmp.value == x: tmp1.next = tmp.next tmp1 = tmp tmp = tmp.nextdef show(root): tmp = root.next while tmp != None: print(tmp.value, end=&quot; &quot;) tmp = tmp.next print(&quot;&quot;)if __name__ == &#x27;__main__&#x27;: n = int(input()) root = createLink() # show(root) for i in range(n): x = int(input()) delete(x, root) insert(x, root) show(root) 实验总结关于链表的定义方式，在各种教科书上和网站都有着各个不同版本的定义方式，我们应该学习的实现原理，具体实现都是大同小异，通常在算法中我们只定义结点，在 Main 函数中直接使用结点组成新的链表而不去写链表的结构体，这样可以减少代码量的使用，提高编程的速度，在程序竞赛中的使用的比较多，但是相应的也降低了代码的复用性，不适合用于项目开发中，还需大家理解差异。不要拘泥于写法，注重的是应用和原理，我们学习这门课的目的是为了 accept 题目，而不是写一堆无用的代码浪费时间。 本次实验，我们学习了三种最常见的链表的原理与使用方式，诚然链表的种类是千变万化的，像是循环链表与双向链表的结合形成的双向循环链表，存储图的十字链表等，我们学好这基础的三种链表，以不变应万变才是正确的面对方式。作者在早期学习链表的时侯只会单链表，在比赛的时候临场写出了双向链表，成功 AC 题目，其实链表的类的定义方式也是我在上文写的是最复杂的一种方式，将每种功能封装，诚然这样的代码复用性会很高，当作模板可以，但是在赛场上的时候，我们没有那么多时间去写代码，都是用什么功能再去写什么功能直接在主函数中完成，追求简洁高效。 刷题1「约瑟夫环」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;struct Node&#123; int num; Node *next;&#125;;int main()&#123; int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; Node *first,*tailer=new Node,*temp; Node *p1,*p2; first = tailer; for(int i=1;i&lt;=n;i++) &#123; temp = new Node; temp-&gt;num = i; tailer-&gt;next = temp; tailer = temp; &#125; tailer-&gt;next = first-&gt;next; first = first-&gt;next; while(--k) &#123; first = first-&gt;next; tailer = tailer-&gt;next; &#125; p1 = tailer; p2 = first; k = 1; while(p1!=p2) &#123; if(k%m==0) &#123; temp=p2; p1-&gt;next = temp-&gt;next; cout&lt;&lt;temp-&gt;num&lt;&lt;endl; p2 = p2-&gt;next; delete temp; k++; continue; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; k++; &#125; cout&lt;&lt;p1-&gt;num&lt;&lt;endl; return 0;&#125; 「小王子双链表」1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;struct Node&#123; int num; Node *pfront; Node *pback;&#125;;int main()&#123; int M,X; cin&gt;&gt;M; Node *first,*tailer=new Node,*temp,*p,*p1; first = tailer; for(int i=1;i&lt;=10;i++) &#123; temp=new Node; temp-&gt;num = i; temp-&gt;pfront=tailer; tailer-&gt;pback=temp; tailer=temp; &#125; tailer-&gt;pback=NULL; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;X; p = first-&gt;pback; while(p!=NULL) &#123; if(p-&gt;num==X) &#123; temp=p; temp-&gt;pfront-&gt;pback=temp-&gt;pback; temp-&gt;pback-&gt;pfront=temp-&gt;pfront; temp-&gt;pback = first-&gt;pback; first-&gt;pback-&gt;pfront = temp; first-&gt;pback = temp; temp-&gt;pfront = first; break; &#125; p=p-&gt;pback; &#125; p = first-&gt;pback; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;num&lt;&lt;&quot; &quot;; p = p-&gt;pback; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; STL 中的 queue 容器 数据结构基础-队列实验介绍我们这门课主要是深入算法，这里所讲的数据结构倾向于实战，大家不要拘泥于具体的写法，而重在学习原理和使用方式，我们所需要的是简洁、实用和快速。这节课主要目标学会两种队列的原理与实现，学会灵活地运用，能够不依赖于模板，可以直接据题目独立写出各类队列。 经典的数据结构通常采用 C 或 C++ 模板类进行编写，非常不适合竞赛使用，代码复用性高但是浪费了书写时间。竞赛追求效率、AC 和简洁。本节课程，我们主要讲解基本数据结构的队列这一部分，虽然这一部分相对简单但非常重要。 知识点 普通队列实现原理与应用 循环队列实现原理与应用 为什么使用队列我们之前已经学过数组和链表，相信对数据的存储方式也有了新的认知，但是数据的组织方式远不止一种，我们今天要讲一种数据组织方式，常用于特殊题目的模拟中。在后续相对高级的算法中，队列将是一种不可或缺的工具，单独使用次数可能不多，但是在其他算法的实现中，不借助队列的逻辑可能会导致一些算法的实现变得复杂。 什么是队列如果说链表和顺序表是对数据的存取位置的组织方式，那么队列就是一种对于存取方式限制的组织方式。换一种方式描述的话就是，队列既可以采用链表来表示，也可以采用数组（线性表）来表示，我们限制的是对于存放数据的存取方式。 似乎定义是有些晦涩难懂，我们来用图来介绍一下队列，什么是队列。队列如其名，就是按照队列的方式来存取，什么是队列呢，我们举一张打饭的图作为例子。 很显然我们对数据的组织也是以这种方式进行的。当然数据存储方式还是有两种，一种是顺序存储，一种是链式存储。 顺序存储 链式存储 思考一下： 为什么链式存储的方式的队列首尾指针与链表头尾刚好相反,是什么原因呢？ 其实我们知道链表的表头是用来插入数据的，表尾处的数据才是最先插入的，先入先出原则，所以表尾出的数据最先出列，也就是队列的头啦！听到这里，可能有人迷糊了，什么头什么尾的？链表是数据存储的组织方式，他只是决定了数据在内存中怎么存储，而队列是说我们是按照什么顺序存储。可以理解为一群人排队，队列告诉他们先来的先吃饭，后来的得排队，而链表或顺序表是说，你可以站着排队蹲着排队等等。 我们再复习一下单链表，上一节中我们已经学习过这张图： 我们这节课不讲链式存储的队列，只用掌握顺序存储的队列，后边的课程中会讲解 C++ 的 STL、Java 的实列和 Python 的 Queue 包，大家到时候就不用再自己写这些数据结构了，这节课我们主要理解原理即可。 队列初体验通过上面的介绍，大家已经基本了解了队列的原理，下面我们用一个题目来体验如何使用“队列”。 银行排队问题，CLZ 银行只有两个接待窗口，VIP 窗口和普通窗口，VIP 用户进入 VIP 用户窗口，剩下的进入普通窗口排队。 现在有以下输入： 123456789101112131415161718192021222324252627282930第一行 M 次操作（M&lt;1000）第二行 到 第M+1行 输入操作格式： IN name V OUT V IN name2 N OUT N 即 第一个字符串为操作 是IN进入排队和OUT 出队 IN 排队 跟着两个字符串为姓名和权限V或N OUT 为出队即完成操作，V和N代表那个窗口完成了操作输出：M次操作后V队列和N队列中姓名，先输出V队列后输出N队列。样例：输入：5IN xiaoming NIN Adel VIN laozhao NOUT NIN CLZ V输出：AdelCLZlaozhao 我们先分析一下这道题目的思路： 第一步，创建两个队列，以及两个队列的首尾指针 1234567V队列V队列首指针V队列尾指针N队列N队列首指针N队列尾指针 第二步，我们要写入队函数： 按照队列的定义使用尾指针模拟即可 还要设置 Type 位来表示是哪一个队列 12345in(Name ,type)&#123; Type为V,那么Name进入V队列； Type为N,那么Name进入N队列；&#125; 第三步，我们要写出队函数： 按照队列的定义使用头指针模拟即可 仍需设置 Type 位来表示是哪一个队列 12345out(type)&#123; Type为V,那么V队列出队，如果队列为空则不能出队； Type为N,那么N队列出队，如果队列为空则不能出队；&#125; 第四步，写出获取队头元素的代码，队列我们只关心谁排在第一个 按照队列的定义使用头指针模拟即可 仍需设置 Type 位来表示是哪一个队列 12345getHead(type)&#123; Type为V,那么取V队列首元素； Type为N,那么取N队列首元素；&#125; 第五步：主函数代码 1234567891011121314151617输入M循环M次:// 输入OP OP为IN，则输入name和Type OP为Out，则输入Type 根据执行OP执行in或out操作若队列V不为空，执行以下操作： 输出队首元素，队首出队 直到为空为止若队列N不为空，执行以下操作： 输出队首元素，队首出队 直到为空为止 给大家演示一下样例，大家是不是觉得非常简单。 队列相信大家已经都学会了，开始偷笑这节课比上节课简单多了，那现在我们正式开始讲解相关的定义和知识了。 队列的逻辑结构 队列：只允许在一端进行插入操作，而另一端进行删除操作的线性表。 空队列：不含任何数据元素的队列。 允许插入（也称入队、进队）的一端称为队尾，允许删除（也称出队）的一端称为队头。 队列的操作特性：先进先出(FIFO)，后入后出(LILO)。 时间复杂度 getHead() 查找操作时间复杂度为 O(1) in() 入队操作时间复杂度为 O(1) out() 出队操作时间复杂度为 O(1) 题目解析分析完了基本思路，也了解了相关的知识，下面我们尝试动手解决一下 CLZ 银行的问题，如果已经提前写完代码了，大家可以跟着下面的解题步骤，对一下答案。 第一步 首先我们要先建存放队列数据结构，我们这里采用顺序表，因为主要存放的数据是名字，也就是常说的字符串，我们可以按照如下方式，进行构建： 1234567String Vqueue[1005]; //V队列int Vhead=0; //首指针int Vtail=0; //尾指针String Nqueue[1005]; //N队列int Nhead=0; //首指针int Ntail=0; //尾指针 你会发现，这和数组很像。对，我们确实采用线性表进行存放的，看起来很简单，但是原理是比较复杂的。 第二步 我们要写入队函数： 按照队列的定义使用尾指针模拟即可； 还需要设置 Type 位来表示是哪一个队列。 123456789101112void in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; Vqueue[Vtail]=name; Vtail++; &#125; else &#123; Nqueue[Ntail]=name; Ntail++; &#125;&#125; 第三步 我们要写出队函数： 按照队列的定义使用头指针模拟即可； 仍需设置 Type 位来表示是哪一个队列 123456789101112131415161718192021222324bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if(Vhead==Vtail) &#123; //队伍没有人不能在出队了。 return false ; &#125; else&#123; Vhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125; else &#123; if(Nhead==Ntail) &#123; //队伍没有人不能在出队了。 return false; &#125; else&#123; Nhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125;&#125; 第四步 写出获取队头元素的代码，队列我们只需要关心谁排在第一个： 按照队列的定义使用头指针模拟即可； 仍需设置 Type 位来表示是哪一个队列。 12345678910string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; return Vqueue[head]; &#125; else &#123; return Nqueue[head]; &#125;&#125; 第五步 主函数代码： 123456789101112131415161718192021222324252627282930313233int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; in(name,type); &#125; else &#123; cin&gt;&gt;type; out(type); &#125; &#125; string s=getHead(&quot;V&quot;); while(out(&quot;V&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;V&quot;); &#125; string s=getHead(&quot;N&quot;); while(out(&quot;N&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;N&quot;); &#125;&#125; 完整代码下面我们将会给出本题三种语言实现的完整代码。 C++ 写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;using namespace std;string Vqueue[1005]; //V队列int Vhead=0; //首指针int Vtail=0; //尾指针string Nqueue[1005]; //N队列int Nhead=0; //首指针int Ntail=0; //尾指针void in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; Vqueue[Vtail]=name; Vtail++; &#125; else &#123; Nqueue[Ntail]=name; Ntail++; &#125;&#125;bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if(Vhead==Vtail) &#123; //队伍没有人不能在出队了。 return false ; &#125; else&#123; Vhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125; else &#123; if(Nhead==Ntail) &#123; //队伍没有人不能在出队了。 return false; &#125; else&#123; Nhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125;&#125;string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; return Vqueue[Vhead]; &#125; else &#123; return Nqueue[Nhead]; &#125;&#125;int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; in(name,type); &#125; else &#123; cin&gt;&gt;type; out(type); &#125; &#125; string s=getHead(&quot;V&quot;); while(out(&quot;V&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;V&quot;); &#125; s=getHead(&quot;N&quot;); while(out(&quot;N&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;N&quot;); &#125;&#125; 运行结果如下图所示： Python 写法Vqueue = [] Vhead = 0 Vtail = 0 Nqueue = [] Nhead = 0 Ntail = 0 def inque(name, type): global Vhead, Vtail, Nhead, Ntail,Vqueue ,Nqueue if (type == ‘V’): Vqueue.append(name) Vtail += 1 else: Nqueue.append(name) Ntail += 1 # print(Vqueue) def getHead(type): global Vhead, Vtail, Nhead, Ntail,Vqueue ,Nqueue if (type == ‘V’): # print(Vhead) return Vqueue[Vhead] else: # print(Nhead) return Nqueue[Nhead] def outque(type): global Vhead, Vtail, Nhead, Ntail,Vqueue ,Nqueue if (type == ‘V’): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vhead == Vtail): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: s = getHead(&lt;span class=&quot;hljs-built_in&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;type&lt;/span&gt;) Vhead += &lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; s else: &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Nhead == Ntail): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: s= getHead(&lt;span class=&quot;hljs-built_in&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;type&lt;/span&gt;) Nhead += &lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; s if name == ‘main‘: M = 0 M = int(input()) while M &gt; 0: M -= 1 op = input().split() &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(op[0])&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&#39;IN&#39;&lt;/span&gt;: inque(op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;], op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;2&lt;/span&gt;]) &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(&#39;in&#39;)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: outque(op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(&#39;out&#39;)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(&quot;VVVVV&quot;,Vqueue)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(&quot;NNNN&quot;,Nqueue)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(M)&lt;/span&gt; s = outque(‘V’) while s!=None: print(s) s = outque(‘V’) s = outque(‘N’) while s != None: print(s) s = outque(‘N’)运行结果如下图所示： Java 写法import java.util.Scanner; public class Main &#123; static String Vqueue[] = new String[1000]; // V队列 static int Vhead = 0; // 首指针 static int Vtail = 0; // 尾指针 static String Nqueue[] = new String[1000]; // N队列 static int Nhead = 0; // 首指针 static int Ntail = 0; // 尾指针 static void in(String name, String type) &#123; if (type.contains( “V”)) &#123; Vqueue[Vtail] = name; Vtail++; &#125; else &#123; Nqueue[Ntail] = name; Ntail++; &#125; &#125; static boolean out(String type) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (type.contains( &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vhead == Vtail) &#123; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// 队伍没有人不能在出队了。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Vhead++;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// head前的数据都是无效数据，无需删除，逻辑明确即可。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Nhead == Ntail) &#123; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// 队伍没有人不能在出队了。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Nhead++;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// head前的数据都是无效数据，无需删除，逻辑明确即可。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; } static String getHead(String type) { &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (type.contains( &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Vqueue[Vhead]; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Nqueue[Nhead]; &#125; } public static void main(String[] args) { int M; Scanner in=new Scanner(System.in); M=in.nextInt(); while(M&gt;0) // { M–; String op,name,type; op=in.next(); // System.out.println(“op”+op); if(op.contains(“IN”)) { name=in.next(); type=in.next(); in(name,type); // System.out.println(“name:”+name+”type:”+type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Vqueue);&lt;/span&gt; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; type=in.next(); out(type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(&quot;type&quot;+type);&lt;/span&gt; &#125; &#125; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Nhead);&lt;/span&gt; String s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &#125; s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &#125; } }运行结果如下图所示： 以上是带有顺序表结构的队列，相应的还有链表所对应的序列，有兴趣的同学可以自行查阅资料。在比赛时我们常用 STL 中的 queue 容器，很少会去自己单独定义和使用队列。 这一节我们主要是学习原理和如何使用，在掌握原理之后，其实无论是什么样的队列都是可以自己设计出来的，同学们也可以自己尝试使用上一章链表的知识设计一个队列并完成上面的题目。 使用循环队列解决 CLZ 银行的问题我们上面讲解了队列的定义及使用，会发现一个很大的问题，就是“随着不断地入队出队，我们的队列的容量会不断降低”，如下图所示： 可以看到，队头和队尾是单调向后移动的，因为之前我们的容量足够大所以不需要判定是否队列满，但是当所需入队的数据很大时，我们空间一定时，那么普通队列对空间的低效率利用就显得很蹩脚，所以提出了循环队列的方式。（链式队列就没有这个缺点，所以后续课程中我们讲的容器或者类都采用链式队列的方式实现。 下面我们用一张动图来展示普通队列在不断出队入队时，空间利用效率低这一缺点： 可以看到经过出队后，图中打叉位置的元素已经访问不到，存储单元也浪费掉了，为了很好的解决这个问题，将会使用循环队列。 循环队列的组成逻辑上是首尾相连的数组，可是在数组中其实不存在这样的数组，所以在物理实现上是不存在的，那么我们需要怎么做呢？ 其实对于不存在物理上实现的循环结构，我们可以用软件方法实现（采用求模方式）: tail=（tail＋1）% MAXSIZE head=(head+1) % MAZSIZE 出现了几个关于循环队列所必须解决的问题： 如何判断循环队列队为空？ 队空：head == tail 跟之前一样。 如何判断循环队列队为满 队满：(tail+1) mod QueueSize==head 如何获得队列中的元素数量 1length=(tail-head+QueueSize)%Queuesize 由于顺序存储队列必须预先确定一个固定的长度，所以存在存储元素个数的限制和空间浪费的问题。 现在让我们尝试使用循环队列完成上面 CLZ 银行 的题目。 思路分析 思路跟之前的解法一样，假如现在队列中最多同时存在 10000 个元素，需要我们采用循环队列进行解答。 先要说明的是，我们在 Python 中的是是采用 List 实现的，所以它的空间可以近似的看作无限的。那么 Python 的代码中只需要加一个删除即可达最大利用率，我们利用 C++ 和 Java 完成题目时，采用循环队列去解决，Python 采用优化写法。 第一步，我们先编写队列定义的代码 123456789int QueueSize=10005;string Vqueue[QueueSize];int Vhead;int Vtail;string Nqueue[QueueSize];int Nhead;int Ntail; 第二步，进行编写入队代码 我们先写一个普通循环队列的入队代码。如下所示： 123456789101112131415string queue[QueueSize];int head;int tail;bool in(string s)&#123; if ((tail+1) % QueueSize ==head) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; tail=(tail+1) % QueueSize; queue[tail]=s; return true; //入队成功，返回成功； &#125;&#125; 然后我们结合题目改写我们刚刚写的入队代码，如下所示： 12345678910111213141516171819202122bool in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; if ((Vtail+1) % QueueSize ==Vhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Vtail=(Vtail+1) % QueueSize; Vqueue[Vtail]=name; return true; &#125; &#125; else &#123; if ((Ntail+1) % QueueSize ==Nhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Ntail=(Ntail+1) % QueueSize; Nqueue[Ntail]=name; return true; &#125; &#125;&#125; 第三步，进行出队函数的编写 同样，我们还是先写普通循环队列的代码: 123456789bool out()&#123; if (tail==head) return false; //空队列不能出队列了 else &#123; head=(head+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; 然后结合题目，改写上面的代码: 1234567891011121314151617181920212223242526bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return false; //空队列不能出队列了 else &#123; Vhead=(Vhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125; else &#123; if (Ntail==Nhead) return false; //空队列不能出队列了 else &#123; Nhead=(Nhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125;&#125; 第四步，编写获取队头元素的代码 照例，我们还是先写普通循环队列的代码: 1234567string getHead()&#123; if (tail==head) return &quot;&quot;;//空队列返回空 else &#123; return queue[head]; &#125;&#125; 然后结合题目改写代码: 1234567891011121314151617string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return &quot;&quot;;//空队列返回空 else &#123; return Vqueue[Vhead]; &#125; &#125; else &#123; if (Ntail==Nhead) return &quot;&quot;;//空队列返回空 else &#123; return Nqueue[Nhead]; &#125; &#125;&#125; 好了，基本的代码我们已经完成了，大家试试先不看后面的完整代码答案，尝试自己动手把写好的代码组织起来。 完整代码编写C++解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;using namespace std;const int QueueSize=10005;string Vqueue[QueueSize];int Vhead;int Vtail;string Nqueue[QueueSize];int Nhead;int Ntail;bool in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; if ((Vtail+1) % QueueSize ==Vhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Vtail=(Vtail+1) % QueueSize; Vqueue[Vtail]=name; return true; &#125; &#125; else &#123; if ((Ntail+1) % QueueSize ==Nhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Ntail=(Ntail+1) % QueueSize; Nqueue[Ntail]=name; return true; &#125; &#125;&#125;bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return false; //空队列不能出队列了 else &#123; Vhead=(Vhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125; else &#123; if (Ntail==Nhead) return false; //空队列不能出队列了 else &#123; Nhead=(Nhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125;&#125;string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return &quot;&quot;;//空队列返回空 else &#123; return Vqueue[Vhead+1]; &#125; &#125; else &#123; if (Ntail==Nhead) return &quot;&quot;;//空队列返回空 else &#123; return Nqueue[Nhead+1]; &#125; &#125;&#125;int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; in(name,type); &#125; else &#123; cin&gt;&gt;type; out(type) ; &#125; &#125; while(getHead(&quot;V&quot;)!=&quot;&quot;) &#123; cout&lt;&lt;getHead(&quot;V&quot;)&lt;&lt;endl;; out(&quot;V&quot;); &#125; while(getHead(&quot;N&quot;)!=&quot;&quot;) &#123; cout&lt;&lt;getHead(&quot;N&quot;)&lt;&lt;endl; out(&quot;N&quot;); &#125;&#125; Java 解法import java.util.Scanner; public class Main &#123; static int QueueSize=10005; static String Vqueue[] = new String[QueueSize]; // V队列 static int Vhead = 0; // 首指针 static int Vtail = 0; // 尾指针 static String Nqueue[] = new String[QueueSize]; // N队列 static int Nhead = 0; // 首指针 static int Ntail = 0; // 尾指针 static boolean in(String name, String type) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(type.contains(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;))&#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; ((Vtail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize ==Vhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//队列以达到容量上限满了，所以不能再插入了返回错误；&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;&#123; Vtail=(Vtail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; Vqueue[Vtail]=name; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; ((Ntail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize ==Nhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//队列以达到容量上限满了，所以不能再插入了返回错误；&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;&#123; Ntail=(Ntail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; Nqueue[Ntail]=name; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; } static boolean out(String type) { &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(type.contains(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;))&#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vtail==Vhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列不能出队列了&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Vhead=(Vhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Ntail==Nhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列不能出队列了&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Nhead=(Nhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; } static String getHead(String type) { &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(type.contains(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;))&#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vtail==Vhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列返回空&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Vqueue[Vhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;]; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Ntail==Nhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列返回空&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Nqueue[Nhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;]; &#125; &#125; } public static void main(String[] args) { int M; Scanner in=new Scanner(System.in); M=in.nextInt(); while(M&gt;0) // { M–; String op,name,type; op=in.next(); // System.out.println(“op”+op); if(op.contains(“IN”)) { name=in.next(); type=in.next(); in(name,type); // System.out.println(“name:”+name+”type:”+type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Vqueue);&lt;/span&gt; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; type=in.next(); out(type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(&quot;type&quot;+type);&lt;/span&gt; &#125; &#125; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Nhead);&lt;/span&gt; String s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &#125; s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &#125; } } Python 解法Python 的是在原来基础上进行优化：Vqueue = [] Nqueue = [] def inque(name, type): global Vqueue ,Nqueue if (type == ‘V’): Vqueue.append(name) else: Nqueue.append(name) def outque(type): global Vqueue ,Nqueue if (type == ‘V’): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;len&lt;/span&gt;(Vqueue)==&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: s=Vqueue[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;] Vqueue.remove(Vqueue[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; s else: if (len(Nqueue)==0): return None else: s = Nqueue[0] Nqueue.remove(Nqueue[0]) return s if name == ‘main‘: M = 0 M = int(input()) while M &gt; 0: M -= 1 op = input().split() # print(op[0]) if op[0] == ‘IN’: inque(op[1], op[2]) # print(‘in’) else: outque(op[1]) # print(‘out’) # print(“VVVVV”,Vqueue) # print(“NNNN”,Nqueue) # print(M) s = outque(‘V’) while s!=None: print(s) s = outque(‘V’) s = outque(‘N’) while s != None: print(s) s = outque(‘N’) 关于队列的定义方式，跟链表一样在各种教科书上和网站都有着各个不同版本的定义方式，具体实现都是大同小异。本次课程，我们主要对标大赛，注意把握其中的实现原理，追求更简单高效的解答问题方式。 实验总结本次实验，我们学习了普通队列和循环队列两种队列的实现方式，了解了队列的原理与基本的实现方式。随着我们课程的深入，我们只需要掌握原理即可，这些工具和数据结构，我们都不会再自己定义使用，而是直接使用各类编程语言已经写好的库模板。 另外，大家从我们上面写过的代码可以看出，其中设置了很多输出，用于调试代码，满是代码调试的痕迹。其实每个人写代码都不是一蹴而就的，在后续的学习中，希望大家在觉得复杂困难的部分，要想办法解决，不要因为困难就放弃。 刷题2「CLZ 的银行普通队列」12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;string V[1010];string N[1010];int main()&#123; int M; string behave,name,id; int vfirst=0,vtailer=0,nfirst=0,ntailer=0; cin&gt;&gt;M; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;behave; if(behave==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;id; if(id==&quot;V&quot;) &#123; V[vtailer++]=name; &#125; else &#123; N[ntailer++]=name; &#125; //cout&lt;&lt;&quot;IN&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; else &#123; cin&gt;&gt;id; if(id==&quot;V&quot;) &#123; vfirst++; &#125; else &#123; nfirst++; &#125; //cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; &#125; while(vfirst!=vtailer) &#123; cout&lt;&lt;V[vfirst++]&lt;&lt;endl; &#125; while(nfirst!=ntailer) &#123; cout&lt;&lt;N[nfirst++]&lt;&lt;endl; &#125; return 0;&#125; 「CLZ 的银行循环队列」123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;using namespace std;#define maxsize 1010string V[maxsize];string N[maxsize];int main()&#123; int M; string behave,name,id; int vfirst=0,vtailer=0,nfirst=0,ntailer=0,n; cin&gt;&gt;M; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;behave; if(behave==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;id; if(id==&quot;V&quot;) &#123; n = (vtailer+1)%maxsize; if(n!=vfirst) &#123; V[vtailer]=name; vtailer=(vtailer+1)%maxsize; &#125; else cout&lt;&lt;&quot;队列已满&quot;&lt;&lt;endl; &#125; else &#123; n = (ntailer+1)%maxsize; if(n!=nfirst) &#123; N[ntailer]=name; ntailer=(ntailer+1)%maxsize; &#125; else cout&lt;&lt;&quot;队列已满，不能输入&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;&quot;IN&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; else &#123; cin&gt;&gt;id; if(id==&quot;V&quot;) &#123; if(vfirst!=vtailer) vfirst=(vfirst+1)%maxsize; else cout&lt;&lt;&quot;队列为空，不能输出&quot;&lt;&lt;endl; &#125; else &#123; if(nfirst!=ntailer) nfirst=(nfirst+1)%maxsize; else cout&lt;&lt;&quot;队列为空，不能输出&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; &#125; while(vfirst!=vtailer) &#123; cout&lt;&lt;V[vfirst]&lt;&lt;endl; vfirst=(vfirst+1)%maxsize; //cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; while(nfirst!=ntailer) &#123; cout&lt;&lt;N[nfirst]&lt;&lt;endl; nfirst=(nfirst+1)%maxsize; // cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; return 0;&#125; stack 堆栈 数据结构基础-栈实验介绍我们这门课所讲的数据结构倾向于实战，大家不要拘泥于具体的写法，而重在学习原理，和使用方式，我们所需要的是简洁、实用和快速。本次实验主要目标是学会栈的原理与实现，学会灵活地运用，能够不依赖于模板根据题目独立写出各类栈。 我们本次讲解数据结构栈这一部分，这一部分比队列要少很多，但是会在后面的搜索等算法中使用，即使这一部分简单，但也是同等重要。还是要提及的一点，不管你在你的数据结构课上怎么背的你的代码，在我们这门课，我们不再追求复用性，我们要的是你学会原理，追求效率。 知识点 栈的实现原理与应用 为什么使用栈我们在这之前已经学过了部分数据结构，相信对数据的存储方式也有了新的认知，但是数据的组织方式我们只学习了队列这一种，我们今天要讲另外一种数据组织方式，同样常用于特殊题目的模拟中，诚然在后续相对高级的算法中，栈是一种不可或缺的工具，单独使用可能不会太多次数，当然这一实验会比队列简单，还是希望大家能够好好学习。 什么是栈我们之前学过了队列这一种对于存取方式的限制的组织方式，我们今天要讲另一种，同样栈既可以采用链表来表示，也可以采用数组（顺序表）来表示，我们限制的是对于存放数据的存取方式。 如果觉得看不懂定义，我们来用图来介绍一下栈，什么是栈，栈如其名，就是按照栈的方式来存取，什么是栈呢，我们举一张糖葫芦的图作为例子。 很显然我们对数据的组织也是以这种方式进行的。当然数据存储方式还是有两种，一种是顺序存储，一种是链式存储。而我们常用的存储方式还是顺序表因为方便简单，在语言自带的程序中用的是链式存储，但是实现相对复杂，我们后期课程中会教大家直接使用，所以我们没必要学会去实现，有余力的同学可以自行实现，使用第一次课的知识加上本次可得知识，即可轻松实现，相应的他也有优点就是节省空间。 顺序存储 链式存储 思考一下： 为什么链式存储的方式的栈栈顶指针与队列队头的指针相反,是什么原因呢？ 其实我们知道链表的表头是用来插入数据的，表头处的数据才是最后插入的，先入后出原则，所以表头处的数据最先出栈，也就是栈的顶啦！听到这里，有人迷糊了，什么头什么尾的，队列跟栈傻傻分不清… 链表是数据存储的组织方式，他只是决定了数据在内存中怎么存储，而栈和队列是说我们是按照什么方式存储。栈可以理解为整理衣服，先放进箱子里的，要想拿出来得把后放进箱子里的衣服先拿出来。而链表或顺序表是说，我究竟是放进了箱子还是放进了衣柜还是放进了异度空间。 我们再复习一下单链表，就放个图给你们吧，省的你们回上一讲去翻。 当然大家不会也没有关系，因为我们这节课不讲链式存储的栈，顺序存储的栈足够用，而且后边的课程中会讲 C++ 的 STL、Java 的实列和 Python 的 Stack 包，大家到时候就不用在自己写这些数据结构了，这节课我们主要是理解原理即可。 栈的初体验通过上面的介绍，大家已经基本了解了栈的原理，关于栈的使用我们也要必须学会，我们用一个题目来引入。 小邋遢的衣橱 小邋遢 MS.Jinlin 是个爱打扮的公主，他有很多晚礼服如”LALA” “NIHAOMA”、”WOBUHAO”、”NIHAOBUHAO”等众多衣服，可是由于衣服太多他要把它们装进箱子，但是作为公主，肯定是会突发奇想觉得哪件衣服好看，就把他拿了出来，当然那件衣服上面的衣服也被拿出来了，而且会弄乱了，小邋遢在经过几次的叠衣服和取衣服后，他想知道箱子里最上面的衣服是哪一件，如果箱子为空的话，就告诉她 Empty ，如果有多件一样的衣服，肯定是取走最上面的那一件啦。 输入： 123456789第 1 行，输入N，代表共计进行了几次操作第 2 行至第 N+1 行，进行in out 操作in 为 放入衣服out 为 取出衣服格式： in name1 out name2 现在有以下样例输入： 样例 1： 12345678910111213输入：6in AMDYESin INTELNOin USBADin CNYESout INTELNOin MDICN输出：MDICN 样例 2： 1234567891011输入：5in AMDYESin INTELNOin USBADin CNYESout AMDYES输出：Empty 先说思路，答案在后边公布。 第一步： 创建一个栈，以及一个栈的栈顶指针 12顺序栈 栈 1栈顶指针 指针 1 第二步： 我们要声明并定义入栈函数： 按照栈的定义使用栈顶指针模拟即可 需要传入一个参数来表示放什么数据 12345in(Name)&#123; 栈不满，Name 进入栈； 栈满，返回 False；&#125; 第三步： 我们声明并定义判空函数： 通过栈顶指针大小即可判断。 12345isEmpty()&#123; 1. 如果栈为空返回True 2. 不为空返回False&#125; 第四步： 我们要声明并定义出栈函数： 按照栈的定义使用栈顶指针模拟即可 返回一个数据表示出栈元素。 12345out()&#123; 如果栈为空则不能出栈，返回False； 不为空，则出栈。&#125; 第五步： 我们声明并定义取栈顶函数： 只需要将栈顶元素取出即可 先判断是否为空 12345string getTop()&#123; 如果栈为空则不能取栈顶，返回null； 不为空，则返回栈顶。&#125; 第六步： 主函数代码： 12345678输入N循环N次:// 输入OP，输入name 根据执行OP执行in或out操作 判空，取栈顶输出答案 给大家演示一下样例，大家是不是觉得非常简单。 栈相信大家已经都学会了，开始偷笑这节课比上节课简单多了，那现在我开始给大家讲以下正式的定义和知识了。 栈的逻辑结构 栈：只允许在一端进行插入、删除操作的线性表。 空栈：不含任何数据元素的栈。 允许插入（也称进栈、压栈、入栈）、删除（也称出栈）的一端称为栈顶。 时间复杂度 isEmpty() 查找操作时间复杂度为 O(1) in() 入队操作时间复杂度为 O(1) out() 出队操作时间复杂度为 O(1) 题目解析学完了知识我们要亲自动手解决一下小邋遢的衣橱的问题了，提前写完代码的同学们也要对对答案了。 第一步： 首先我们要先建存放栈数据结构，我们这里采用顺序表。 因为主要存放数据为名字即字符串，我们可以如下构建： 12String stack[1005]; //栈int Top=0; //栈顶指针 你会发现，这好像就是数组，又好像长得像是队列，他就是这么简单，难的是原理！ 第二步： 我们要声明并定义入栈函数： 按照栈的定义使用栈顶指针模拟即可 需要传入一个参数来表示放什么数据 123456789bool in(string name)&#123; if(Top&gt;=maxsize) return 0; else &#123; Mystack[Top++]=name; return 1; &#125;&#125; 第三步： 我们声明并定义判空函数： 通过栈顶指针大小即可判断。 1234bool isEmpty()&#123; if(Top!=0) return 0; else return 1;&#125; 第四步： 我们要声明并定义出栈函数： 按照栈的定义使用栈顶指针模拟即可 返回一个数据表示出栈元素。 12345678bool out()&#123; if(isEmpty()) return 0; else&#123; Top--; return 1; &#125;&#125; 第五步： 我们声明并定义取栈顶函数： 只需要将栈顶元素取出即可 先判断是否为空 12345string getTop()&#123; if(isEmpty()) return &quot;&quot;; else return Mystack[Top];&#125; 第六步： 主函数代码： 12345678910111213141516171819int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) in(name); else &#123; while(getTop()!=name)&#123; out(); &#125; out(); &#125; &#125; if(isEmpty) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;getTop()&lt;&lt;endl;&#125; 完整代码如下： C++写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int maxsize=100005;string Mystack[maxsize]; //栈int Top=0; //栈顶指针bool in(string name)&#123; if(Top&gt;=maxsize) return 0; else &#123; Mystack[++Top]=name; return 1; &#125;&#125;bool isEmpty()&#123; if(Top!=0) return 0; else return 1;&#125;bool out()&#123; if(isEmpty()) return 0; else&#123; Top--; return 1; &#125;&#125;string getTop()&#123; if(isEmpty()) return &quot;&quot;; else return Mystack[Top];&#125;int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) in(name); else &#123; while(getTop()!=name) &#123; out(); &#125; out(); &#125; &#125; if(isEmpty()) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;getTop()&lt;&lt;endl;&#125; 以上为带有顺序表结构的栈，相应的还有链表所对应的栈，但是因为实现复杂，如果在比赛中使用这种解法，会花费更多的时间，失去了我们提高解题效率的初衷，所以我们就不再赘述了，有兴趣的同学可以自行查阅资料。 下面我们就来介绍如何使用 C++、Java、Pyhton 中定义好的内置栈模版进行解答，从而提高解题效率，实现更加快捷方便的解题。 C++ 的内置栈模板我们先看一下 C++ 中栈的定义及相应的函数内容. LIFO stack 堆栈，它是一种容器适配器，专门设计用于在 LIFO 上下文（后进先出）中操作，其中元素仅从容器的一端插入和提取。 stack 被实现为容器适配器 它们是使用特定容器类的封装对象作为其类底层容器的 ，提供一组特定的成员函数来访问其元素。元素推入 / 弹出 从 的 “后面” 特定容器 ，这被称为 的顶部堆栈。 底层容器可以是任何标准容器类模板或一些其他专门设计的容器类。 容器应支持以下操作： 以上引用自 C++的 API，当然现在大家理解起来可能有些困难，不用担心，下面我们将会教大家如何定义，并且如何调用相关的函数。 在 C++ 的 stack 模板定义了如下操作： top()： 返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。 push(const T&amp; obj)： 可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。 push(T&amp;&amp; obj)： 以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop()： 弹出栈顶元素。 size()： 返回栈中元素的个数。 大家看的有点迷糊也没有问题，看名字的话大家也都能猜出是什么意思，在上文中，我也都给大家讲了，所以大家对照着看一下。接下来我们采用 C++ 定义好的模板类给大家改写上面的 C++程序,让大家好好学习一下。 第一步： 引入模板类，并定义声明一个栈类 1234#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;string&gt; myStack; 第二步： 我们要声明并定义入栈函数： 按照栈的定义使用栈顶指针模拟即可 需要传入一个参数来表示放什么数据 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第三步： 我们声明并定义判空函数： 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第四步： 需要要声明并定义出栈函数： 按照栈的定义使用栈顶指针模拟即可 返回一个数据表示出栈元素。 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第五步： 我们声明并定义取栈顶函数： 只需要将栈顶元素取出即可 先判断是否为空 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第六步： 主函数代码： 1234567891011121314151617181920int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) myStack.push(name); else &#123; while(myStack.top()!=name)&#123; myStack.pop(); &#125; myStack.pop(); &#125; &#125; if(myStack.empty()) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;myStack.top()&lt;&lt;endl;&#125; 完整代码如下，你会发现十分简单，就是直接拿来用的，非常方便，但是建议大家也还是要学会自己写，这样使用起来会更加熟练。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;string&gt; myStack;int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) myStack.push(name); else &#123; while(myStack.top()!=name)&#123; myStack.pop(); &#125; myStack.pop(); &#125; &#125; if(myStack.empty()) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;myStack.top()&lt;&lt;endl;&#125; Java 的内置栈类我们先看一下 Java 中栈的定义及相应的函数. 栈是 Vector 的一个子类，它实现了一个标准的后进先出的栈，至于什么是 Vector，大家可以理解为能力超强的数组，在后面的课程中，我们会进行讲解。 堆栈定义了默认构造函数，用来创建一个空栈。 大家可能理解起来有困难，不必担心，咱们现阶段知道如何定义，并且如何调用函数后，之后在不断的实践中，就会慢慢理解了。 在 Java 的 stack 模板定义了如下操作流程： push(): 执行 push 时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 peek(): 执行 peek 时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 pop(): 执行 pop 时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。 empty(): 继承于 Vector，返回是否为空 size(): 继承 Vector,返回元素的个数。 那么若使用 Java 的内置栈类，我们的实现流程会有什么不同呢： 我们只需引入模板类，并定义声明一个栈类： 1234567import java.util.Scanner;import java.util.Stack;public class Main &#123; static Stack Mystack =new Stack();&#125; 主函数代码： 12345678910111213141516171819202122232425public static void main(String[] args)&#123; int N; Scanner in=new Scanner(System.in); N=in.nextInt(); for(int i=0;i&lt;N;i++) &#123; String op,name; op=in.next(); name=in.next(); // System.out.println(op+&quot; &quot;+name); if(op.contains(&quot;in&quot;) ) Mystack.push(name); else &#123; while(!Mystack.peek().equals(name))&#123; // System.out.println(getTop()); Mystack.pop(); &#125; Mystack.pop(); &#125; &#125; if(Mystack.empty()) System.out.println(&quot;Empty&quot;); else System.out.println(Mystack.peek());&#125; 可以看到，使用 Java 的内置栈类，可以帮我们省略以下流程： 声明并定义入栈函数 声明并定义入判空函数 声明并定义出栈函数 声明并定义出取栈顶函数 使用起来非常方便，我们再看一下整体的代码。 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;import java.util.Stack;public class Main &#123; static Stack Mystack =new Stack(); public static void main(String[] args) &#123; int N; Scanner in=new Scanner(System.in); N=in.nextInt(); for(int i=0;i&lt;N;i++) &#123; String op,name; op=in.next(); name=in.next(); // System.out.println(op+&quot; &quot;+name); if(op.contains(&quot;in&quot;) ) Mystack.push(name); else &#123; while(!Mystack.peek().equals(name))&#123; // System.out.println(getTop()); Mystack.pop(); &#125; Mystack.pop(); &#125; &#125; if(Mystack.empty()) System.out.println(&quot;Empty&quot;); else System.out.println(Mystack.peek()); &#125;&#125; Python 的实现由于 Python 没有现成的栈的定义，要想使用，我们只能进行自己模拟，模拟方法大家可以使用我上面使用的方法，也可以看一下我下面讲的高级点的方法，声明并定义一个栈类的方法，推荐使用下面的方法，上面的代码还是主要讲理论使用。 第一步： 声明一个类，并设置一个类型为 list 的元素来保存数据。 123class MyStack: def __init__(self): self._data = [] # 使用list存储栈元素 第二步： 我们要声明并定义入栈函数： 12def push(self, elem): self._data.append(elem) 第三步： 我们声明并定义判空函数： 12def is_empty(self): return self._data == [] 第四步： 我们要声明并定义出栈函数： 123456def pop(self): if self._data == []: raise Warning (&quot;此栈为空，错误操作&quot;); return self._data.pop() 第五步： 我们声明并定义取栈顶函数： 12345def top(self): if self._data == []: raise Warning(&quot;此栈为空，错误操作&quot;); return self._data[-1] 第六步： 主函数代码： 123456789101112131415161718192021222324if __name__==&#x27;__main__&#x27;: N=int (input()) Stack =MyStack() while N&gt;0: N-=1 op=input().split() if(op[0]==&#x27;in&#x27;): Stack.push(op[1]) else : while(Stack.top()!=op[1]): Stack.pop() Stack.pop() if(Stack.is_empty()) : print(&quot;Empty&quot;) else: print(Stack.top()) 完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MyStack: def __init__(self): self._data = [] # 使用list存储栈元素 def is_empty(self): return self._data == [] def push(self, elem): self._data.append(elem) def pop(self): if self._data == []: raise Warning (&quot;此栈为空，错误操作&quot;); return self._data.pop() def top(self): if self._data == []: raise Warning(&quot;此栈为空，错误操作&quot;); return self._data[-1]if __name__==&#x27;__main__&#x27;: N=int (input()) Stack =MyStack() while N&gt;0: N-=1 op=input().split() if(op[0]==&#x27;in&#x27;): Stack.push(op[1]) else : while(Stack.top()!=op[1]): Stack.pop() Stack.pop() if(Stack.is_empty()) : print(&quot;Empty&quot;) else: print(Stack.top()) 实验总结关于栈的定义方式，跟前面两讲一样在各种教科书上和网站都有着各个不同版本的定义方式，我们主要是学习该数据结构的实现原理，虽然实现可能千奇百怪但是我们理解原理就好，对于实现我们还是要追求简单高效即可。 本次实验，我们学习了栈的实现方式，了解了栈的原理与基本的实现方式，学有余力的同学们可以使用链表自己声明并定义链式栈，但是我们后续用不到，可以当作对自己编码能力的提升。随着我们课程的深入这些工具数据结构我们都不会再自己定义使用了，各类编程语言都给了现成的库模板等，我们都可以拿来直接而用，非常方便,这里给大家讲了，使用各语言的特性简化了自己写的代码，非常方便。 刷题3「小邋遢的衣橱」12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int main()&#123; int N; string behave,clothes; string trunk[1010]; int top=0; cin&gt;&gt;N; for(int i=0; i&lt;N; i++) &#123; cin&gt;&gt;behave&gt;&gt;clothes; if(behave==&quot;in&quot;) &#123; trunk[++top]=clothes; &#125; else &#123; while(trunk[top]!=clothes) top--; top--; &#125; &#125; if(top) cout&lt;&lt;trunk[top]&lt;&lt;endl; else cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; return 0;&#125; 选取最接近表长且小于等于表长的最大素数 b 常用 131，h 常用 1e9+7=999983 C++ 中有一个 UnorderedMap，可以方便我们的解题过程； 数据结构基础-散列表(Hash)实验介绍我们本次实验主要目标是学会散列表（hash 算法）的原理与实现，学会灵活的运用，能够不依赖于模板根据题目独立写出各类散列表。数据结构 Hash 属于查找算法中的一部分，在比赛中通常也会占据一定的比例，相对较难也比较重要，大家一定要认真学习哦。 知识点 Hash 的概念 构造方法 冲突处理 为什么使用哈希表我们上面所提到的查找算法，简单来说，就是判断现有数据集合中是否有这个元素，或者是否有满足条件的元素。 其中的 Hash 算法则可以帮助我们判断是否有这个元素，虽然功能简单，但是其 O(1) 时间复杂度是具有高性能的。通过在记录的存储地址和它的关键码之间建立一个确定的对应关系。这样，不经过比较，一次读取就能得到所查元素的查找方法。相比普通的查找算法来说，仅仅在比较的环节，就会大大减少查找或映射所需要的时间。 什么是哈希表（散列表）我们采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间即称为散列表。下面用一张图给大家展示一下散列表的实现过程： 如果还是不太明白的话，我们可以理解为数学函数，Y=F(X)，X 为自变量也就是这里的 Key, F( ) 对应图中的 H( )，也就是一个映射关系，Y 因变量也就是对应的值的 存放位置，此处一定要注意哦。 此处让我们思考一下： 散列技术仅仅是一种查找技术吗？ 应该说，散列既是一种查找技术，也是一种存储技术。 散列是一种完整的存储结构吗？ 散列只是通过记录的关键码定位该记录，没有完整地表达记录之间的逻辑关系，即通过关键码能推出 Key 值，但是通过关键码对应的值（即位置处的值）不能推出关键码，所以散列存储的关键码和值之间并不对称，因此散列主要是面向查找的存储结构。 散列表的初体验通过上面的介绍，大家已经基本了解了散列表的原理。下面我们就来学习一下关于散列表的使用方式，下面我们用一个题目来引入。 弗里的语言 小发明家弗里想创造一种新的语言，众所周知，发明一门语言是非常困难的，首先你就要克服一个困难就是，有大量的单词需要处理，现在弗里求助你帮他写一款程序，判断是否出现重复的两个单词。 要求：有重复的单词，就输出重复单词，没有重复单词，就输出 NO，多个重复单词输出最先出现的。 输入输出如下面示例所示： 首先输入： 12345678第 1 行，输入 N，代表共计创造了多少个单词第 2 行至第 N+1 行，输入 N 个单词格式如下： fjsdfgdfsg fdfsgsdfg bcvxbxfyres 现在有以下样例输入。 样例 1： 12345678910111213输入：61fagas dsafa32jlkiuopybncvhfgdjytrcncxfgsdhrest输出：NO 样例 2： 12345678910111213输入：5sdfggfdsfgsdhsdfdsfhsdhrsdfhdfhsdfggfds输出：sdfggfds 下面我们来分析一下解题思路，请大家跟着下面的思路一步一步实现，然后再对比后面给出的答案。 第一步，首先我们需要创建一个散列表和一个公共溢出区。 12散列表公共溢出区 即使你现在不知道什么是散列表和溢出区，没关系！我们后边会做详细的讲解。 第二步，需要定义插入散列表函数。 按照散列表的映射方式设计即可 需要传入一个参数来表示放什么数据 12345in(Name)&#123; 1. 无冲突 2. 冲突处理&#125; 第三步：定义查询函数。 12345isAt()&#123; 1. 如果散列表查询成功返回 True 2. 不为成功返回 False&#125; 4. 第四步，定义散列表映射函数。 此处我们采用除留余数法即可，不了解这个方法的同学别担心，后面在写解题代码的时候，我会具体为大家介绍。 123456int out(string s)&#123; 处理字符串 s 生成对应的 Key 值&#125; 第五步，编写主函数代码。 12345678910输入 N循环 N 次:// 输入 word； 先查询，有相同的单词有就设置 flag 为 1，ans = word 没有的话，就执行插入操作根据 flag 决定输出什么。 大致的代码逻辑就是这样，相信大家已经都学会了。可能有的小伙伴已经在嘀咕了“这有什么难的”，先别急，咱们继续往下看。 这道题的代码思路其实并不难，但是代码应该如何来写呢，大家是否还摸不着头脑？在比赛中我们为了追求高效率，必须熟知咱们所使用到的每一个函数的优缺点，做到“扬长避短”，所以在写代码前，我们先来聊聊散列表的优缺点。前面咱们已经了解到了，散列表具有高性能，查找效率高等优点，下面就主要了解一下它的缺陷。 散列表的缺陷散列表并不是适用于所有的需求场景，那么哪些情况下不适合使用呢？ 散列技术一般不适合在允许多个记录有同样关键码的情况下使用。 因为这种情况下，通常会有冲突存在，将会降低查找效率，体现不出散列表查找效率高的优点。 并且如果一定要在这个情况下使用的话，还需要想办法消除冲突，这将花费大量时间，那么就失去了 O(1) 时间复杂度的优势，所以在存在大量的冲突情况下，我们就要弃用散列表。 散列方法也不适用于范围查找，比如以下两个情况。 查找最大值或者最小值 因为散列表的值是类似函数的，映射函数一个变量只能对应一个值，不知道其他值，也不能查找最大值、最小值，RMQ(区间最值问题）可以采用 ST 算法、树状数组和线段树解决。 也不可能找到在某一范围内的记录 比如查找小于 N 的数有多少个，是不能实现的，原因也是映射函数一个变量只能对应一个值，不知道其他值。 散列技术的关键问题在使用散列表的时候，我们有两个关键的技术问题需要解决： 散列函数的设计，如何设计一个简单、均匀、存储利用率高的散列函数？ 冲突的处理，如何采取合适的处理冲突方法来解决冲突。 如何设计实现散列函数在构建散列函数时，我们需要秉持两个原则： 简单 散列函数不应该有很大的计算量，否则会降低查找效率。 均匀： 函数值要尽量均匀散布在地址空间，这样才能保证存储空间的有效利用并减少冲突。 散列函数实现三种方法1. 直接定址法。 散列函数是关键码（Key）的映射的线性函数，形如： H(key) = a * key + bH(key)=a∗key+b 来看一个小案例： 如果关键码的集合已知且为 [11,22,33,66,88,44,99] H(key) = \\frac{1}{11} * key + 0H(key)=111∗key+0 如图： 缺点： 我们是看到了这个集合，然后想到他们都是 11 的倍数才想到这 Hash 函数。我们在平常的使用中一般不会提前知道 Key 值集合，所以使用较少。 适用范围： 事先知道关键码，关键码集合不大且较为连续而不离散。 2. 除留余数法。 H(key)=key \\ mod \\ pH(key)=key mod p 来个小例子： H(key)=key \\ mod \\ 21H(key)=key mod 21 会发现产生了很多相同的 H(K)，这就是发生冲突，因为一个位置只能放一个数，有两个值对应这里一个位置，是不可以的。 这种方法是最常用的方法，这个方法的关键在于如何选取 P，使得利用率较高并且冲突率较低，一般情况下，我们会选取最接近表长且小于等于表长的最大素数。 缺点： P 选取不当，会导致冲突率上升。 适用范围： 除留余数法是一种最简单、也是最常用的构造散列函数的方法，并且不要求事先知道关键码的分布。 这个方法非常常用，我们后面题目的展开就是使用的这个方法。在大部分的算法实现中也都是选取的这一种方式。 代码实现： 123456789101112131415161718192021222324C++ const int MOD=P; int Hx(int n) &#123; return n%MOD; &#125;Java final Integer MOD=P; Integer Hx(int n) &#123; return n%MOD; &#125; python MOD=P #由于Python不含常量，我们这里就不做修饰 Hx(n): global MOD return n%MOD 3. 数字分析法。 比如我将我的集合全部转化为 16 进制数，根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址。或者将 N 位 10 进制数，观察各各位的数字分布，选取分布均匀的散列地址。 举个小例子： 首先我们考虑一位作为散列函数，发现都是很多冲突，选取两位时，百位和十位组合最适宜，分布均匀且没有冲突。 当然，我们说的是这一方法的一个具体实列，既然叫做数字分析法，那么只有对于不同数据的不同分析，才能写出更是适配的 H(x)。 另外还有两种平时使用极少的方法，分别是平方取中法和折叠法，我们就不再做过多的讲解，感兴趣的小伙伴可以在网上自行查找相关的资料了解哦。 冲突的处理方法 开散列方法： open hashing 也称为拉链法，separate chaining 称为链地址法，简单来说，就是由关键码得到的散列地址一旦产生了冲突，就去寻找下一个空的散列地址，并将记录存入。 寻找下一个空的散列地址的方法： 线性探测法 当发生冲突时，从冲突位置的下一个位置起，依次寻找空的散列地址。 对于键值 key，设 H(key)=d，闭散列表的长度为 m，则发生冲突时，寻找下一个散列地址的公式为： Hi=(H(key)＋di)\\ MOD \\ m（di=1，2，… ，m-1）H**i=(H(key)＋d**i) MOD m（d**i=1，2，…，m−1） 堆积现象： 在处理冲突的过程中出现的非同义词之间对同一个散列地址争夺的现象。 例子： Key 集合为 47, 7, 29, 11, 27, 92, 22, 8, 3。 P 值为 11，进行 Hash 映射，采用线性探测法处理冲突。 二次探测法 即当发生冲突时，寻找下一个散列地址的公式为： H_i=(H(key)＋d_i)% mH**i=(H(key)＋d**i) 其中（ d_i=1^2，－1^2，2^2，－2^2，… ，q^2，－q^2 且 q≤m/2）其中（d**i=12，－12，22，－22，…，q2，－q2且q≤m/2） 随机探测法 当发生冲突时，下一个散列地址的位移量是一个随机数列，即寻找下一个散列地址的公式为： Hi=(H(key)+round)% mH**i=(H(key)+round) 其中 round 为随机数其中round为随机数 再 hash 法 注意：用开放定址法处理冲突得到的散列表叫闭散列表。 闭散列方法 closed hashing 也称为开地址方法，open addressing 开放地址法，开放地址法中涵盖了以下两种实现方式； 拉链法（链地址法） 将所有散列地址相同的记录即 Key 值相同的项目，坠成一个链表，每个链表的头指针存放位置为 Key 值对应的位置。 举一个小例子： 建立公共溢出区 散列表包含基本表和溢出表两部分（通常溢出表和基本表的大小相同），将发生冲突的记录存储在溢出表中。 查找时，如果在基本表里找的到就返回成功，没找到就在溢出区顺序查找，注意这里不再是映射而是顺序查找，放置时也是按照顺序的方式。 算法流程 假设给定的值为 K，根据所设定的散列函数 h，计算出散列地址 h(K)； 如果将该地址中的值与 K 比较，若相等则检索成功，跳转到第 5 步； 否则，按建表时设定的处理冲突方法查找探查序列的下一个地址,反复执行并检查 如果某个地址空间未被占用（查找不成功，可以插入），跳转到第 5 步； 如果关键码比较相等（有重复记录，不需要插入）为止 ，跳转到第 5 步； 如果探测完整个 hash 表，都没有进行插入或查找失败，跳转到第 5 步； end 算法结束。 虽然在解题过程中，如果依据表长质数 h 设置得当，则很少会出现冲突情况，但是基本的解决方法我们也须得掌握，根据笔者的实战经验来看，公共溢出区的方式更加简洁高效率（在冲突次数远小于元素数量时），所以本节实验中，我们主要掌握如何设置公共溢出区的方法。 至此我们已经学完了散列表的相关知识，下面我们结合建立公共溢出区的方式，亲自动手解决一下“弗里的语言”这个问题。 题目解析第一步，我们需要创建一个散列表和一个公共溢出区： 1234const long long h=1e8+7;string Value[h+5];string UpValue[h+5]; 第二步，我们要定义散列表映射函数： 我们这里介绍一种在算法竞赛中特别常用的字符串映射成数字的方式。 实现原理： 将字符串中的每一个字母都看做是一个数字（例：从 a-z ，视为 1-26 ）； 选取两个合适的互质常数 b 和 h，其中 h 要尽可能的大一点，为了降低冲突的概率。b 常用 131，h 常用 1e9+7，这里我们需要设置公共溢出区所以，我们需要随便找一个 string 数组能开出来的数字，这里选取 999983。 定义哈希函数： 处理方式： C 代表一个字符串，用 C =c1 c2 c3 c4..cm 表示该字符串，其中 ci 表示从前向后数的第 i 个字符； C 当做 b 进制数 来处理，b 是基数； 关于对 h 取模，若 b、h 有公因子，那么不同的字符串取余之后的结果发生冲突的几率将大大大增加（冲突：不同的字符串但会有相同的 hash 值）。 举一个例子： 现在有一字符串 S=s_1s_2s_3s_4s_5s1s2s3s4s5 h a s h[ 1 ] = s 1 has**h[1]=s1 h a s h [ 2 ] = s 1 ∗ p + s 2has**h[2]=s1∗p+s2 h a s h [ 3 ] = s 1 ∗ p 2 + s 2 ∗ p + s 3has**h[3]=s1∗p2+s2∗p+s3 h a s h [ 4 ] = s 1 ∗ p 3 + s 2 ∗ p 2 + s 3 ∗ p + s 4has**h[4]=s1∗p3+s2∗p2+s3∗p+s4 h a s h [ 5 ] = s 1 ∗ p 4 + s 2 ∗ p 3 + s 3 ∗ p 2 + s 4 ∗ p + s 5has**h[5]=s1∗p4+s2∗p3+s3∗p2+s4∗p+s5 所以 S 的哈希值为 Hash[5] 实现123456789101112131415const long long h = 999983;int Hx(string s)&#123; int n = s.size(); int sum1 = 0; for (int i = 0; i &lt; n; i++) &#123; sum1 = sum1 * 131 % h + (s[i] - &#x27;a&#x27; + 1) % h; &#125; return (sum1 + h) % h;&#125; 在比赛按此方法设计 Hash 函数一般不需要设置冲突的公共溢出区，这里我们为了方便讲解，才进行设置，在比赛中我们不用设置溢出区，所以可以设置很大的 h，避免出现冲突。 第三步，我们定义查询函数： 通过散列表顶指针大小即可判断。 123456789101112131415161718bool isAt(string s)&#123; int n=Hx(s); if(Value[n]==&quot;&quot;) return false; else if(Value[n]==s) return true; else &#123; for(int i=0;i&lt;UpValueCount;i++) if(UpValue[n]==s) return true; return false; &#125;&#125; 第四步，定义插入散列表函数： 按照散列表的映射方式设计即可； 需要传入一个参数来表示放什么数据。 12345678910111213141516bool in(string s)&#123; int n=Hx(s); if(Value[n]==&quot;&quot;) &#123; Value[n]=s; return true; &#125; else if(Value[n]==s) return false; else &#123; for(int i=0;i&lt;UpValueCount;i++) if(UpValue[n]==s) return false; UpValue[UpValueCount++]=s; return true; &#125;&#125; 第五步，编写主函数代码： 主函数代码我们有三种定义方式 法一 中规中矩定义法，设置 flag 变量用于跳过找到答案后的输入处理。 1234567891011121314151617181920212223242526int main()&#123; int n; bool flag = 0; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (flag) continue; if (isAt(word)) &#123; flag = 1; ans = word; &#125; else &#123; in(word); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 法二 由于我们设置的插入函数也具有查询功能，插入成功即为没有重复值，插入失败即为有重复值，我们这里不存在单独查询的操作，所以我们可以将查询省略。 12345678910111213141516171819202122int main()&#123; int n; bool flag = 0; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (flag) continue; if (!in(word)) &#123; flag = 1; ans = word; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 法三 在法二的基础上，利用 OJ 的特性，OJ 是判定输出的答案是否与答案相同进行判定，当我们知道答案之后直接输出，结束程序那么就会使得程序运行时间大幅度减少。 12345678910111213141516171819int main()&#123; int n; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (!in(word)) &#123; cout &lt;&lt; word &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 完整解题代码C++实现方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int h = 999983;string Value[h];string UpValue[h];int UpValueCount = 0;int Hx(string s)&#123; int n = s.size(); int sum1 = 0; for (int i = 0; i &lt; n; i++) &#123; sum1 = sum1 * 131 % h + (s[i] - &#x27;a&#x27; + 1) % h; &#125; return (sum1 + h) % h;&#125;bool isAt(string s)&#123; int n = Hx(s); if (Value[n] == &quot;&quot;) return false; else if (Value[n] == s) return true; else &#123; for (int i = 0; i &lt; UpValueCount; i++) if (UpValue[n] == s) return true; return false; &#125;&#125;bool in(string s)&#123; int n = Hx(s); if (Value[n] == &quot;&quot;) &#123; Value[n] = s; return true; &#125; else if (Value[n] == s) return false; else &#123; for (int i = 0; i &lt; UpValueCount; i++) if (UpValue[n] == s) return false; UpValue[UpValueCount++] = s; return true; &#125;&#125;int main()&#123; int n; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (!in(word)) &#123; cout &lt;&lt; word &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 最后总结给大家一个小窍门，在解题过程中可以使用： C++ 中有一个 UnorderedMap，可以方便我们的解题过程； Python 和 Java 中都有提前定义好的 Hash 函数，也可以直接使用。 实验总结本次实验，我们学习了散列表的实现方式，了解了散列表的原理与基本的实现方式，学了各种的冲突处理方式和散列函数的构造方式，我们还讲了一种竞赛常用的字符串 hash 的方式，我们都要多加练习并熟练使用。 刷题4「弗里的的语言」12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int h=999983;const int b=131;struct Node&#123; string word; int flag=1; Node *next;&#125;;Node *Store = new Node [h];int main()&#123; int N,flag0=1; Node *temp,*first,*p; string word; cin&gt;&gt;N; for(int i=0; i&lt;N; i++) &#123; int N,index=0,n; cin&gt;&gt;word; n = word.size(); for(int j=0; j&lt;n; j++) &#123; index=index*b%h+(word[j]-&#x27;a&#x27;+1)%h; &#125; index = (index+h)%h; //cout&lt;&lt;index&lt;&lt;endl; first = &amp;Store[index]; int flag=1; p = first-&gt;next; while(p!=NULL) &#123; //cout&lt;&lt;&quot;ENTER1&quot;&lt;&lt;endl; if(p-&gt;word==word) &#123; if(p-&gt;flag) &#123; cout&lt;&lt;word&lt;&lt;endl; p-&gt;flag=0; flag=0; flag0 = 0; &#125; &#125; p=p-&gt;next; &#125; if(flag) &#123; //cout&lt;&lt;&quot;ENTER1&quot;&lt;&lt;endl; temp=new Node; temp-&gt;word = word; temp-&gt;next = first-&gt;next; first-&gt;next = temp; &#125; &#125; if(flag0) &#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125; 指针数组和数组指针c语言，c++函数返回一个数组，二维数组数据结构之排序算法实验介绍信息获取后通常需要进行处理，处理后的信息其目的是便于人们的应用。信息处理方法有多种，通常有数据的排序、查找、插入、删除等操作。本章主要介绍几种简单的数据排序算法和高效的排序算法. 在比赛中，排序算法是必不可少的。虽然我们可能会直接使用 sort 等函数直接进行排序，但在有些特殊题目中，我们仍需使用到排序算法。 知识点 选择排序的原理以及代码编写 冒泡排序的原理以及代码编写 桶排序的原理以及代码编写 插入排序的原理以及代码编写 理解希尔排序 快速排序 归并排序的原理 时间复杂度分析 我们本节实验先学习所有的排序算法以及他们的实现，再结合做题目实战。 简单排序算法简单排序算法包括选择排序、冒泡排序、桶排序和插入排序，本节重点介绍以上四种简单排序算法。 选择排序 基本思想 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，按照顺序放在待排序的数列的最前，直到全部待排序的数据元素排完。 排序过程 例如: 123456789初始：[5 4 6 8 7 1 2 3]第一趟排序后 1 [4 6 8 7 5 2 3]第二趟排序后 1 2 [6 8 7 5 4 3]第三趟排序后 1 2 3 [8 7 5 4 6]第四趟排序后 1 2 3 4 [7 5 8 6]第五趟排序后 1 2 3 4 5 [7 8 6]第六趟排序后 1 2 3 4 5 6 [8 7]第七趟排序后 1 2 3 4 5 6 7 [8]最后排序结果 1 2 3 4 5 6 7 8 对应代码 C++ 实现 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void select_Sort(int *a,int len)&#123; for (int i=0;i&lt;len;i++) &#123; int k=i; for(int j=i+1;j&lt;len;j++) &#123; if(a[j]&lt;a[k]) k=j; &#125; if(k!=i) swap(a[i],a[k]); &#125;&#125;int main ()&#123; int a[] = &#123;5 ,4 ,6 ,8 ,7, 1, 2 ,3&#125;; select_Sort(a,8); for(auto i: a) cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125; Java 实现 Python 实现 冒泡排序 基本思想 所谓冒泡排序就是依次将两个相邻的数进行比较，大的在前面，小的在后面。 即先比较第一个数和第二个数，大数在前，小数在后，然后比较第 2 个数和第 3 个数，直到比较最后两个数 第一趟排序结束后，最小数的数一定在最后 第二趟排序在第一趟的基础上重复上述操作 由于排序过程中总是大数在前，小数在后，相当于气泡上升，所以叫冒泡排序。 大数在前，小数在后排序后得到的是降序 小数在前，大数在后排序后得到的是升序结果 排序过程(降序) 1234567891011初始数据：4 5 6 1 2 3第一趟：比较前两个数， 4比5小，交换位置 5 4 6 1 2 3比较第2第3个数， 4比6小，交换位置 5 6 4 1 2 3比较第3第4个数， 5比1大，位置不变 5 6 4 1 2 3比较第4第5个数， 1比2小，交换位置 5 6 4 2 1 3比较最后两个数， 1比3小，交换位置 5 6 4 2 3 1第一趟结束第二趟重复第一趟过程得到 6 5 4 3 2 1排序完毕。 可以发现，第二趟排序结束后，所有数据已经排好序了。实际上，我们在对于一组数据进行冒泡排序时，假如需要排列的数据个数为 n 个，那么 n-1 趟一定能排好序，比如因为第 2 趟都会有前 2 个小的数排序好，n-1 趟前 n-1 小的数已排好序，最后一个数自然也排好序了。 对应代码: C++ 实现： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void BubbleSort(int arr[], int n)&#123; for(int i = 0; i &lt; n - 1; i++) &#123; for(int j = 0; j &lt; n - i - 1; j++) &#123; if(arr[j] &gt; arr[j+1]) swap(arr[j],arr[j+1]); &#125; &#125;&#125;int main ()&#123; int a[6] = &#123;4, 5, 6, 1, 2, 3&#125;; BubbleSort(a,6); for(auto i: a) cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125; Java 实现 Python 实现 桶排序 基本思想 桶排序的思想是，若待排序的记录的关键字在一个明显有限范围内时，可设计有限个有序桶，每个桶只能装与之对应的值，顺序输出各桶的值，将得到有序的序列。简单来说，在我们可以确定需要排列的数组的范围时，可以生成该数值范围内有限个桶去对应数组中的数，然后我们将扫描的数值放入匹配的桶里的行为，可以看作是分类，在分类完成后，我们需要依次按照桶的顺序输出桶内存放的数值，这样就完成了桶排序。 例如，要求我们输入 n 个 09 之间的整数，由小到大排序输出，我们可以准备 10 个桶依次编号为 09。那么，输入的数 0 则入 0 号桶，1 入 1 号桶，依次类推。 如图所示 如上图琐事，我们已准备好 10 个空桶并编号。 下面我们依次输入 8 个整数，分别是 2，5，6，8，5，2，9，6，我们每输入一个数值就将其放入对应的桶。 输入完毕后桶内数据如图所示： 桶排序过程： 如上图所示，2 号桶内有两个数字 2，5 号桶内有两个数字 5，6 号桶内有两个数字 6，8 号桶内有一个数字 8，9 号桶内有一个数字 9 然后我们按桶编号从小到大的顺序将桶内数字输出，得到 2，2，5，5，6，6，8，9，至此桶排序完成。 注意，桶排序需要注意适用范围，在已知所需排序数据的范围下可以使用，另外本次课程我们只讨论整型的情况，其他数据类型的情况下如何使用，感兴趣的小伙伴可以当作课外内容，自行了解哦。 实现代码C++ 实现方式： 1234567891011121314151617181920int maxN=10; //题目出现的数据的最大值int a[maxN];int n;cin&gt;&gt;nfor(int i=0;i&lt;n;i++)&#123; int key; cin&gt;&gt;key; a[key]++; &#125;for(int i=0;i&lt;maxN;i++)&#123; for(int j=0;j&lt;a[i];j++) &#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125;&#125; Java 实现方式 Python 实现方式 插入排序基本思想插入排序是一种简单的排序方法，时间复杂度为 O(n*n)，适用于数据已经排好序，插入一个新数据的情况。其算法的基本思想是，假设待排序的数据存放在数组 a[1…n] 中，增加一个节点 x 用于保存当前数据，进行比较，a[1]即作为有序区，a[2…n] 作为无序区。 从 i=2 起直至 i=n 为止，通过循环遍历，将 a[i] 放在恰当的位置，使 a[1…i] 数据序列有序 12345678910111213x=a[i] 将 x 与前 i-1 个数比较j=i-1while(x&lt;a[j]) j-= 1, 将 a 数组的元素从 j 位置开始向后移动：for k in range(j,i+1,-1): a[k]=a[k-1] a[j]=x生成包含 n 个数据的有序区 例如，我们现在有一个数组 a=[3 2 4 1 6 5 2 7]，需要使用插入排序进行排列。 排序过程： 12345678第0步：[3] 2 4 1 6 5 2 7第1步：[2 3] 4 1 6 5 2 7第2步：[2 3 4] 1 6 5 2 7第3步：[1 2 3 4] 6 5 2 7第4步：[1 2 3 4 6] 5 2 7第5步：[1 2 3 4 5 6] 2 7第6步：[1 2 2 3 4 5 6] 7第7步：[1 2 2 3 4 5 6 7] 实现代码C++ 实现 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void insert_Sort(int *a,int len)&#123; for (int i=0; i&lt;len; i++) &#123; int x = a[i]; int j = i - 1; while( j&gt;=0&amp;&amp;x &lt; a[j]) &#123; a[j + 1] = a[j]; j -= 1; &#125; a[j + 1] = x; &#125;&#125;int main ()&#123; int a[9] = &#123;0, 3, 2, 4, 1, 6, 5, 2, 7&#125;; insert_Sort(a,9); for(auto i: a) cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125; Java 实现 Python 实现 高效排序算法前面，我们介绍了简单的排序算法，但在实际应用中，简单的排序算法很难达到效率的要求，所以本节介绍了两种高效的排序算法，使排序时间复杂度大大减少。 快速排序 基本思想 快速排序是一种采用分治法解决问题的一个典型应用，也是冒泡排序的一种改进。它的基本思想是，通过一轮排序将待排记录分割成独立的两部分，其中一部分均比另一部分小，则可分别对这两部分继续进行排序，已达到整个序列有序。排序的时间复杂度为 O(nlogn)，相比于简单排序算法，运算效率大大提高。 算法步骤 从序列中取出一个数作为中轴数； 将比这个数大的数放到它的右边，小于或等于他的数放到它的左边； 再对左右区间重复第二步，直到各区间只有一个数。 例如，对以下 10 个数进行快速排序： 16 1 2 7 9 3 4 5 10 8 以第一个数为基准数，在初始状态下，数字 6 在序列的第 1 位，我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k 。 现在就需要寻找这个 k ，并且以第 k 位为分界点，左边的数都≤6，右边的数都≥6。那么如何找到这个位置 k 呢？ 我们要知道，快速排序其实是冒泡排序的一种改进，冒泡排序每次对相邻的两个数进行比较，这显然是一种比较浪费时间的。 而快速排序是分别从两端开始”探测”的，先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j ，分别指向序列最左边和最右边。 我们为这两个变量起个好听的名字哨兵 i 和哨兵 j。 我们首先让哨兵 i 指向序列的最左边，指向数字 6；让哨兵 j 指向序列的最右边，指向数字 8，如下图所示。 首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要。 哨兵 j 一步一步地向左挪动，直到找到一个小于 6 的数停下来 然后哨兵 i 再一步一步向右挪动，直到找到一个数大于 6 的数停下来 最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前，如下图所示： 现在交换哨兵 i 和哨兵 j 所指向元素的值，交换之后的序列如下： 到此，第一次交换结束。接下来开始哨兵 j 继续向左挪动（再友情提醒，每次必须是哨兵 j 先出发）。他发现了 4&lt;6，停下来。哨兵 i 也继续向右挪动的，他发现了 9&gt;6，停下来。此时再次进行交换，交换之后的序列如下 第二次交换结束。哨兵 j 继续向左挪动，他发现了 3&lt;6，又停下来。 哨兵 i 继续向右移动，此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。 说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。 到此第一轮“探测”真正结束。 现在基准数 6 已经归位，此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。 现在我们将第一轮“探测”结束后的序列，以 6 为分界点拆分成两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列，因为 6 左边和右边的序列目前都还是混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6 左边和右边的序列即可。 实际上快速排序的每一轮处理其实就是将这一轮的基准数归为，直到所有的数都归为为止，排序就结束了。 实现代码C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int tem[10000];void part(int l, int r, int *a);void qSort(int *a, int len)&#123; part(0, len - 1, a);&#125; void part(int l, int r, int *a)&#123; if(l&gt;=r) return ; int r1 = r, l1 = l; while (l1 &lt; r1) &#123; while (a[r1] &gt;= a[l1]&amp;&amp;l1 &lt; r1) r1--; if (l1 &lt; r1) swap(a[l1], a[r1]); else break; while (a[l1] &lt;= a[r1]&amp;&amp;l1 &lt; r1) l1++; if (l1 &lt; r1) swap(a[l1], a[r1]); else break; &#125; part(l,l1-1,a); part(l1+1,r,a);&#125;int main()&#123; int a[1000]; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; qSort(a, n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125; Java 实现 Python 实现 归并排序 基本思想 归并排序是由递归实现的，主要是分而治之的思想，也就是通过将问题分解成多个容易求解的局部性小问题来解开原本的问题的技巧。 归并排序在合并两个已排序数组时，如果遇到了相同的元素，只要保证前半部分数组优先于后半部分数组， 相同元素的顺序就不会颠倒。所以归并排序属于稳定的排序算法。 每次分别排左半边和右半边，不断递归调用自己，直到只有一个元素递归结束，开始回溯，调用 merge 函数，合并两个有序序列，再合并的时候每次给末尾追上一个最大 int 这样就不怕最后一位的数字不会被排序。 排序过程 代码实现 C++ 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #include &lt;iostream&gt;using namespace std;#define MAX 10000int tem[MAX];void merge(int newArray[], int array[], int array_left, int array_right, int end) &#123; /* * array[] 一个待排序数组 * newArray[] 排序后的新数组 * array_left 待排序数组的左半部分的起点的index * array_right 待排序数组的又半部分的起点的index * end 数组的末尾 * * [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] * ↑ ↑ ↑ * array_left array_right end * * */ int l = array_left, r = array_right, p = array_left; /* * 当l &lt;r说明左数组还有没有进排序的数字 * 当r &lt; end说明右数组还有没有进排序的数字 */ while (l &lt; array_right &amp;&amp; r &lt; end) &#123; //左右数组都没排完时情况的处理 if (array[l] &gt; array[r]) newArray[p++] = array[r++]; else newArray[p++] = array[l++]; &#125; while (l &lt; array_right)//右数组还有没有进排序的数字 newArray[p++] = array[l++]; while (r &lt; end) //左数组还有没有进排序的数字 newArray[p++] = array[r++]; for (int i = array_left; i &lt; end; i++) &#123; //将排序生成的新数组写回原来的位置 array[i] = newArray[i]; // cout&lt;&lt;array[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void merge_sort(int l, int r, int a[]) &#123; if (l &gt;= r - 1) return; int mid = (r + l) / 2; merge_sort(l, mid, a); merge_sort(mid, r, a); merge(tem, a, l, mid, r);&#125;int main() &#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; merge_sort(0, n, a); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125; Java 实现 Python 实现 希尔排序 基本思想 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法，同时也突破了之前内排序算法复杂度为 O(n2)的限制。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率. 插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 该方法的基本思想是： 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。 其中增量序列的选择是非常关键的，但通常我们取步长为 n/2（数组长度的一般）然后一直取半直到 1。 实现代码： C++ 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;void ShellSort(int array[], int n) //希尔排序函数&#123; int i, j, step = n / 2; while (step &gt; 0) //这里的step步长是根据10个元素这种情况定义的 &#123; for (i = 0; i &lt; step; i++) //i是子数组的编号 &#123; for (j = i + step; j &lt; n; j = j + step) //数组下标j，数组步长下标j+step &#123; if (array[j] &lt; array[j - step]) &#123; int temp = array[j]; //把数组下标j的值放到temp中 int k = j - step; while (k &gt;= 0 &amp;&amp; temp &lt; array[k]) &#123; array[k + step] = array[k]; //把大的值往后插入 k = k - step; &#125; array[k + step] = temp; //把小的值往前插入 &#125; &#125; &#125; step = step / 2; &#125;&#125;int main(void) //主程序&#123; int array[1000], n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; array[i]; &#125; ShellSort(array, n); for (int i = 0; i &lt; n; i++) cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; return 0;&#125; Java 实现 Python 实现 练习在我们编译语言中，都是预先设置好排序算法的，我们只需要直接调用即可。但是有些情况是不能调用排序算法的，比如特殊的结构体排序而且要求是稳定的这种情况，所以需要我们在上面各种排序算法的原理的基础上进行改写。大部分情况下我们都是可以直接调用的。 下面我们通过一道题目练习一下上面所学到的知识。 排序初步12345678910111213141516题目： 对一组无序的整数用排序算法进行排序，方法不限。输入 第一行为数列的总个数，第二行为待排序的数列输出 排序后的数列样例输入 8 10 4 6 3 8 2 5 7样例输出 2 3 4 5 6 7 8 10 C++ 实现我们将使用 sort 函数解决该问题，由于 sort 在 algorithm 头文件里面，所以使用前先要调入头文件。 用法 sort(首地址，尾地址后面一个位置) 尾地址后面一个位置，即首地址+长度 比如我想排序 a 的第五个元素到第八个元素，共四个元素 那么首地址为 a+5,尾地址后面的一个地址为 a+5+4 尾地址后面一个位置这么描述是为了好理解，其实很多函数都是这么定义的，先这样记住就行,后边就写成 sort(a,a+n)。 或者是 sort(a,a+n,cmp) ,其中 cmp 是比较函数可以根据所比较的数据类型写出比较函数。返回值为 bool 值即可。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 10000 int main()&#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125; 我们自己写一个比较函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 10000 bool cmp(int a,int b) &#123; return a&lt;b;&#125;int main()&#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n,cmp); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125;题目通过代码：#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 500005int main()&#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for (int i = n-1; i &gt;=0; i--) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125;&#125; Java 实现 Python 实现 Python 的cmp对象在Python 3 中已经删除了，所以如果我们需要对类对象排序，不能使用cmp函数，最简单的方式就是重载类对象的lt(selfm,other)函数 123456789101112131415class student(): def __init__(self, index, name): self.index = index self.name = name def __lt__(self, other): if self.index == other.index: return self.name &lt; other.name else: return self.index &lt; other.indexl = [student(9, &quot;A&quot;), student(4, &quot;B&quot;), student(7, &quot;C&quot;), student(1, &quot;D&quot;), student(7, &quot;E&quot;)]l.sort()print([(e.index,e.name) for e in l]) 实验总结本次实验，我们学习了各种排序的实现方式，了解了各种排序方式的原理与基本的实现方法，在最后，我们还讲讲解了一种简单快捷的排序的方式。本次实验中我们提到的排序方式，大家都需要多加练习，并学会熟练使用 刷题5123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; int N,mini; cin&gt;&gt;N; int a[N]; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;N-1;i++) &#123; mini=i; for(int j=i+1;j&lt;N;j++) &#123; if(a[mini]&gt;a[j])mini=j; &#125; if(mini!=i)swap(a[mini],a[i]); &#125; for(int i=0;i&lt;N;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for(int i=N-1;i&gt;-1;i--) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return 0; &#125; 内置模板我们前面讲了很多数据结构相关的知识，本节课程，我们主要讲解怎么不自己定义，而是使用我们所使用的编程语言中，已经定义好的数据结构。 之前我们在栈那一节已经讲过栈的内置数据结构的使用，我们本章就不再进行讲解，我们这节课仍然采用那种方式进行讲解。 知识点 迭代器讲解 线性表的使用 队列的使用 集合（set）的使用 映射（map）的使用 迭代器（Iterator）首先，明确一点迭代器是 C++ 的知识，并不适用于 Java 和 Python 这两种语言，但是下面讲容器就要用到这一点，所以我们必须要提前讲一下。迭代器的知识点很复杂，了解即可，当然有余力可以深究，了解就能做题，实现方式看容器讲解。 对于数组我们可以采用指针进行访问，但是对于其他的存储空间连续的数据结构或者说是存储单元我们就需要找到另一种方式来替代指针的行为作用，从而达到对于非数组的数据结构的访问和遍历，于是我们定义了一种新的变量叫做迭代器。 定义： 迭代器是一种检查容器内元素并遍历元素的数据类型。 迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。 迭代器和指针的区别： 容器和 string 有迭代器类型同时拥有返回迭代器的成员。 如：容器有成员 .begin() 和 .end(),其中 .begin() 成员复制返回指向第一个元素的迭代器，即指向第一个元素的“地址”，而 .end() 成员返回指向容器尾元素的下一个位置的迭代器。 即 .begin() 指向的是第一个合法元素的位置，.end() 指向是容器后第一个不合法元素的地址。 相应的还有容器反向迭代器成员 .rbegin() .rend(), .rbegin() 返回容器的元素前最后一个不合法的地址，rend() 返回容器的最后一个合法地址。 容器迭代器的使用每种容器类型都定义了自己的迭代器类型： 1如 vector：vector&lt; int&gt;:: iterator iter;//定义一个名为iter的变量 数据类型是由 vector&lt; int&gt; 定义的 iterator 类型。简单说就是容器类定义了自己的 iterator 类型，用于访问容器内的元素。每个容器定义了一种名为 iterator 的类型，这种类型支持迭代器的各种行为。 我么们先讲一下各种迭代器的类型，在讲容器所用的迭代器类型，就可以明白怎么操作。 容器写在前面，由于 Python 的语言的特点，所有的数据结构大部分都需要自己实现，但是其 List 功能较强，用起来比较简单，当然我们也会再说一遍怎么实现。 在 Java 中各种数据结构都是继承于 list，所以 Java 的 list 功能也很强，它的功能有很多，由于篇幅原因我们会挑比较重要的讲解，其他的还需要同学们多去使用。 Vector 容器（类）线性表中有 Vector 和 list，两者作用比较相似。 Vector 的主要作用就是可变长度的数组，就把他当成数组使用即可。 至于为甚我们我选择讲 Vector 而不是 List，因为 Vector 可以当作数组使用，用起来非常简单，也非常方便。 我们先讲解一下 c++ 的 Vector 使用： 123456789#include &lt;vector&gt; //头文件vector&lt;int&gt; a; //定义了一个int类型的vector容器avector&lt;int&gt; b[100]; //定义了一个int类型的vector容器b组struct rec&#123; ···&#125;;vector&lt;rec&gt; c; //定义了一个rec类型的vector容器cvector&lt;int&gt;::iterator it; //vector的迭代器，与指针类似 具体操作如下： 123456789a.size() //返回实际长度（元素个数），O(1)复杂度a.empty() //容器为空返回1，否则返回0，O(1)复杂度a.clear() //把vector清空a.begin() //返回指向第一个元素的迭代器，*a.begin()与a[0]作用相同a.end() //越界访问，指向vector尾部，指向第n个元素再往后的边界a.front() //返回第一个元素的值，等价于*a.begin和a[0]a.back() //返回最后一个元素的值，等价于*--a.end()和a[size()-1]a.push_back(x) //把元素x插入vector尾部a.pop_back() //删除vector中最后一个元素 遍历的方式有两种： 迭代器使用与指针类似，可如下遍历整个容器。 12for ( vector&lt;int&gt;::iterator it=a.begin() ; it!=a.end() ; it++ )cout&lt;&lt;*iterator&lt;&lt;endl; 当成数组使用。 1for( int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; 上面我们讲解了 C++ 的实现方式，下面我们了解一下 java 的。 12345678//第一种构造方法创建一个默认的向量，默认大小为 10：Vector()//第二种构造方法创建指定大小的向量。Vector(int size)//第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。Vector(int size,int incr)//第四种构造方法创建一个包含集合 c 元素的向量：Vector(Collection c) 以下为 Java Vector 的 Api。 修饰符和类型 方法和说明 boolean add(E e)将指定的元素附加到此 Vector 的末尾。 void add(int index, E element)在此 Vector 的指定位置插入指定元素。 boolean addAll(Collection&lt;? extends E&gt; c)将指定集合中的所有元素追加到末尾 这个向量，按照它们由指定的返回的顺序 集合的迭代器。 boolean addAll(int index, Collection&lt;? extends E&gt; c)将指定 Collection 中的所有元素插入到此 指定位置的向量。 void addElement(E obj)将指定的组件添加到此向量的末尾， 将其大小增加一。 int capacity()返回此向量的当前容量。 void clear()从此 Vector 中删除所有元素。 Object clone()返回此向量的克隆。 boolean contains(Object o)退货 true 如果此向量包含指定的元素。 boolean containsAll(Collection&lt;?&gt; c)如果此 Vector 包含所有元素，则返回 true 指定的集合。 void copyInto(Object[] anArray)将此向量的分量复制到指定的数组中。 E elementAt(int index)返回指定索引处的组件。 Enumeration elements()返回此向量的组件的枚举。 void ensureCapacity(int minCapacity)如有必要，增加此向量的容量，以确保它至少可以容纳由指定的组件数量最小容量参数。 boolean equals(Object o)比较指定的 Object 与此 Vector 是否相等。 E firstElement()返回第一个组件（索引处的项目 0） 的这个向量。 E get(int index)返回此 Vector 中指定位置的元素。 int hashCode()返回此 Vector 的哈希码值。 int indexOf(Object o)返回指定元素第一次出现的索引 在此向量中，如果此向量不包含该元素，则为 -1。 int indexOf(Object o,int index)返回指定元素第一次出现的索引这个向量，从 index, 或返回 -1 如果 未找到该元素。 void insertElementAt(E obj, int index)将指定对象作为组件插入此向量中的 指定的 index. boolean isEmpty()测试此向量是否没有组件。 Iterator iterator()以适当的顺序返回此列表中元素的迭代器 E lastElement()返回向量的最后一个组件。 int lastIndexOf(Object o)返回指定元素最后一次出现的索引在此向量中，如果此向量不包含该元素，则为 -1。 int lastIndexOf(Object o, int index)返回指定元素最后一次出现的索引这个向量，从 index, 或返回 -1 如果 未找到该元素。 ListIterator listIterator()返回此列表中元素的列表迭代器（在适当的顺序）。 ListIterator listIterator(int index)返回此列表中元素的列表迭代器（在适当的序列），从列表中的指定位置开始。 E remove(int index)移除此 Vector 中指定位置的元素。 boolean remove(Object o)移除此 Vector 中第一次出现的指定元素如果 Vector 不包含该元素，则它保持不变。 boolean removeAll(Collection&lt;?&gt; c)从此 Vector 中删除其包含在指定的集合。 void removeAllElements()从此向量中删除所有组件并将其大小设置为零。 boolean removeElement(Object obj)删除参数的第一个（最低索引）出现从这个向量。 void removeElementAt(int index)删除指定索引处的组件。 protected void removeRange(int fromIndex, int toIndex)从此列表中删除索引介于两者之间的所有元素 fromIndex，包括在内，和 toIndex， 独家的。 boolean retainAll(Collection&lt;?&gt; c)仅保留此 Vector 中包含在指定的集合。 E set(int index, E element)将此 Vector 中指定位置的元素替换为指定的元素。 void setElementAt(E obj,int index)将组件设置在指定的位置 index 这个的向量是指定的对象。 void setSize(int newSize)设置此向量的大小。 int size()返回此向量中的组件数。 List subList(int fromIndex,int toIndex)返回此列表中 fromIndex 之间的部分的视图 Object[] toArray()返回一个包含此 Vector 中所有元素的数组以正确的顺序。 T[] toArray(T[] a)返回一个包含此 Vector 中所有元素的数组正确的顺序; 返回数组的运行时类型指定数组。 String toString()返回此 Vector 的字符串表示形式，包含 每个元素的字符串表示。 void trimToSize()将此向量的容量修剪为向量的电流 尺寸。 遍历 Vector 123Enumeration vEnum = v.elements();while (vEnum.hasMoreElements()) System.out.print(vEnum.nextElement() + &quot; &quot;); Python 中，我们直接使用 list 即可来实现。 题目解析快递员需要对快递进行分拣，现在小李是一名快递员，他想要你帮他设计一个程序用于快递的分拣，按城市分开。 现在有以下输入： 1234567单号 省份请你将单号按照城市分开，并输出。城市按照输入顺序排序单号按照输入顺序排序 样例如下： 12345678910111213141516171819202122232425262728293031323334输入10 10124214 北京12421565 上海sdafasdg213 天津fasdfga124 北京145252 上海235wtdfsg 济南3242356fgdfsg 成都23423 武汉 23423565f 沈阳1245dfwfs 成都输出北京 210124214fasdfga124上海 212421565145252天津 1sdafasdg213济南 1235wtdfsg成都 23242356fgdfsg 1245dfwfs 武汉 123423沈阳 123423565f 下面我们来分析一下解题思路。 首先我们要知道中国城市肯定在 1000 个以内，但是单号我们不确定，我们不可能每个数组开 10000 个，那样内存不够，所以这时候我们就用到了我们的 vector，他的容量是动态申请的，在比赛中我们可以理解为无限制。 第一步：我们创建一个 vector 用于保存地址 1vector&lt;string&gt; city; 第二步：我们创建一个 vector 组用于存放单号 1vector&lt;string&gt; dig[1000]; 第三步：我们定义一个映射函数，因为你的城市可能会再次出现，你需要知道之前有没有。 第四步：我们开始读入操作并按照顺序进行存放 完整代码C++ 解题代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;string&gt; city;vector&lt;string&gt; dig[1000];int Myfind(string s)&#123; for(int i=0;i&lt;city.size();i++) &#123; if(city[i]==s) return i; &#125; return -1;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; string d,c; cin&gt;&gt;d&gt;&gt;c; int flag=Myfind(c); if(flag==-1)&#123; city.push_back(c); dig[city.size()-1].push_back(d); &#125; else dig[flag].push_back(d); &#125; for(int i=0;i&lt;city.size();i++) &#123; cout&lt;&lt;city[i]&lt;&lt;&quot; &quot;&lt;&lt;dig[i].size()&lt;&lt;endl; for(int j=0;j&lt;dig[i].size();j++) cout&lt;&lt;dig[i][j]&lt;&lt;endl; &#125;&#125; Java 解题代码 Python 实现方式 队列 Queue队列的讲解在之前的课程中已经讲过了，忘记的快回去复习。 我们直接开始看操作吧。 C++ 中的队列定义方式：在 C++ 里所有容器的定义方式基本一致。 12queue&lt;string&gt; myqueue;queue&lt;int&gt; myqueue_int; 成员函数: front()：返回 queue 中第一个元素的引用。 back()：返回 queue 中最后一个元素的引用。 push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 Java 中的队列 Python 中的队列 题目回顾 CLZ 的银行。 123456789101112131415161718192021222324252627282930第一行 M 次操作（M&lt;1000）第二行 到 第M+1行 输入操作格式： IN name V OUT V IN name2 N OUT N 即 第一个字符串为操作 是IN进入排队和OUT 出队 IN 排队 跟着两个字符串为姓名和权限V或N OUT 为出队即完成操作，V和N代表那个窗口完成了操作输出：M次操作后V队列和N队列中姓名，先输出V队列后输出N队列。样例：输入：5IN xiaoming NIN Adel VIN laozhao NOUT NIN CLZ V输出：AdelCLZlaozhao 具体的题目讲解，我们之前就已经讲解过了，这里我们主要是来看一下预置代码的方便性。 完整代码C++实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;queue&lt;string&gt; V;queue&lt;string&gt; N;int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; if(type==&quot;V&quot;) V.push(name); else N.push(name); &#125; else &#123; cin&gt;&gt;type; if(type==&quot;V&quot;) V.pop(); else N.pop(); &#125; &#125; while(V.size()) &#123; cout&lt;&lt;V.front()&lt;&lt;endl; V.pop(); &#125; while(N.size()) &#123; cout&lt;&lt;N.front()&lt;&lt;endl; N.pop(); &#125;&#125; Java 实现 Python 实现 Map 映射在之前我们学习散列表的时候我们就接触过了映射，这里我们要讲的是一种类似的数据结构。 map 是一个关联容器，它提供一对一的 hash。 第一个可以称为关键字(key)，每个关键字只能在 map 中出现一次 第二个可能称为该关键字的值(value) map 以模板（泛型）方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map 主要用于资料一对一映射（one-to-one）的情況，map 在 C++ 的內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在 map 内部所有的数据都是有序的。 比如，像是管理班级内的学生，Key 值为学号，Value 放其他信息的结构体或者类。 C++ 中的 map定义方式： 12map&lt;char, int&gt; mymap1;map&lt;string, int&gt; mymap2; 一般用法： 看容量。 12int map.size();//查询map中有多少对元素bool empty();// 查询map是否为空 插入。 12345map.insert(make_pair(key,value));//或者map.insert(pair&lt;char, int&gt;(key, value))//或者map[key]=value 取值。 12345678map&lt;int, string&gt; map;//如果map中没有关键字2233，使用[]取值会导致插入//因此，下面语句不会报错，但会使得输出结果结果为空cout&lt;&lt;map[2233]&lt;&lt;endl;//但是使用使用at会进行关键字检查，因此下面语句会报错map.at(2016) = &quot;Bob&quot;; 遍历操作 123456map&lt;string, string&gt;::iterator it;for (it = mapSet.begin(); it != mapSet.end(); ++it)&#123; cout &lt;&lt; &quot;key&quot; &lt;&lt; it-&gt;first &lt;&lt; endl; cout &lt;&lt; &quot;value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125; 查找操作 12m.count(key)：//由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。m.find(key)：//返回迭代器，判断是否存在。 Java 中的 map Python 字典 题目演练 《弗里石的的语言》 小发明家弗里想创造一种新的语言，众所周知，发明一门语言是非常困难的，首先你就要克服一个困难就是，有大量的单词需要处理，现在弗里求助你帮他写一款程序，判断是否出现重复的两个单词。 有重复就输出重复单词，重复就输出 NO，多个重复输出最先出现的哪一个。 输入： 123456789第 1 行，输入N，代表共计创造了多少个单词第 2 行至第 N+1 行，输入 N 个单词格式： fjsdfgdfsg fdfsgsdfg bcvxbxfyres 现在有以下样例输入： 样例 1 12345678910111213输入：61fagas dsafa32jlkiuopybncvhfgdjytrcncxfgsdhrest输出：NO 样例 2 123456789101112输入：5sdfggfdsfgsdhsdfdsfhsdhrsdfhdfhsdfggfds输出：sdfggfds 这个题的思路在前面我们已经讲过了，这里我们换一种方式解题。 使用映射和字典解题，是的原来的代码减少了超过一半，但是思路还是一样，可以说是非常的巧妙且省力。 C++ 解法12345678910111213141516171819202122232425 #include &lt;iostream&gt; #include &lt;map&gt; using namespace std;map&lt;string,bool&gt; mp;int main ()&#123; int n; string ans=&quot;NO&quot;; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; string word; cin&gt;&gt;word; if(mp.count(word))&#123; ans=word; break; &#125; else mp[word]=1; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Java 解法 Python 解法 打表法和模拟法模拟法是比赛中最常用的方法，使用各种算法大都离不开模拟，而对于一些只是需要结果的题目来说打表法是一个非常好的解决方案，而且对于数论等其他需要找规律的题目来说，打表法是一个非常有用的方法。 模拟法和打表法，经常会同时出现，因为打表就要按照题目的意思去模拟。今天我们就从蓝桥杯的真题出发，给大家讲解一下，打表法和模拟法的应用。 知识点 打表法的使用与简单举例 模拟法的使用与简单举例 算式问题这是 2012 年蓝桥杯国赛 的一道问题。 123456789101112131415161718192021222324252627题目描述：本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。看这个算式：☆☆☆ + ☆☆☆ = ☆☆☆如果每个五角星代表 1 ~ 9 的不同的数字。这个算式有多少种可能的正确填写方法？173 + 286 = 459295 + 173 = 468173 + 295 = 468183 + 492 = 675以上都是正确的填写法！注意：111+222=333 是错误的填写法！因为每个数字必须是不同的！也就是说：1 ~ 9 中的所有数字，每个必须出现且仅出现一次！注意：不包括数字 “0”。注意：满足加法交换率的式子算两种不同的答案。 所以答案肯定是个偶数！运行限制： 1. 最大运行时间：1s 2. 最大运行内存: 128M 题目分析首先我们能了解到这道题只需要答案，那么对于时间要求就等于无限，那我们可以使用模拟方法，因为只需要输出答案即可，只要能够在比赛的时长里跑出来即可。 接下来我们将采用模拟法进行问题的求解，注意既然我们不需要考虑时间问题和代码问题，我们一定要将代码设计的具有较高的逻辑性和准确性。 这个题的正解是搜索算法，但是既然只要答案我们求快、求简单，在这里我们使用另一种方式进行解答。 这里有三个数字 我们称 A + B = C 且各个位上的数字不同。 我们这里借助桶排序的思想来判断 1-9 这些数字有没有占用。 所以我们定义一个判断函数，用于判断 A B C 三个数字是否符合要求。 然后暴力枚举： A 从 123 到 987 开始枚举 有很多同学开始抬杠 111-999 岂不是更简单，因为 123 是最小的符合要求的数字，可以减少枚举的次数，987 是最大的符合要求的数字。 B 从 123 到 987-A 枚举 这时候又会有很多同学来问，为什么不直接枚举与 A 不一样的数字呢，那么又得考虑每一位的问题，这样的模拟已经不是暴力法了，我们要做的就是在不改变完成难度的情况下，减少复杂度。所以要分清注次。 C = A + B 这时候只要检查 A B C 是否符合要求即可。 代码解答C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int flag[11];int check(int a,int b,int c)&#123; for(int i=0;i&lt;10;i++) flag[i]=0; flag[0]=1; while(a!=0) &#123; if(flag[a%10]==1) return 0; else flag[a%10]=1; if(flag[b%10]==1) return 0; else flag[b%10]=1 ; if(flag[c%10]==1) return 0; else flag[c%10]=1 ; a=a/10; b=b/10; c=c/10; &#125; return 1;&#125;int main()&#123; int ans=0; for(int a=123;a&lt;=987;a++) for(int b=123;b&lt;=987-a;b++) &#123; int c=a+b; if(check(a,b,c)) &#123; ans++; cout&lt;&lt;a&lt;&lt;&quot; + &quot;&lt;&lt;b&lt;&lt;&quot; = &quot;&lt;&lt;c&lt;&lt;endl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 运行结果： 1234567891011121314151617181920212223242526272829303132124 + 659 = 783125 + 739 = 864127 + 359 = 486127 + 368 = 495128 + 367 = 495128 + 439 = 567129 + 357 = 486129 + 438 = 567129 + 654 = 783129 + 735 = 864134 + 658 = 792135 + 729 = 864138 + 429 = 567138 + 654 = 792139 + 428 = 567139 + 725 = 864142 + 596 = 738142 + 695 = 837…………………754 + 182 = 936762 + 183 = 945763 + 182 = 945782 + 154 = 936782 + 163 = 945783 + 162 = 945784 + 152 = 936336Process returned 0 (0x0) execution time : 0.360 sPress any key to continue. 注意题目要求是只输出答案，我们讲模拟的代码提交是一分不得的，所以按照题目要求，以下才是正确答案。 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;336&lt;&lt;endl; return 0;&#125; 有的题目是让你输出答案，有的是让你填空，所以务必审清题目，减少不必要的丢分。 Python 解法 Java 解法 求值这是 蓝桥杯 2019 国赛 的一道题目。 1234567891011121314题目描述：本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。学习了约数后，小明对于约数很好奇，他发现，给定一个正整数 t，总是可以找到含有 t 个约数的整数。小明对于含有 t 个约数的最小数非常感兴趣，并把它定义为 St。例如 S1=1,S2=2,S3=4,S4=6，⋅⋅⋅现在小明想知道，当 t=100 时，S100 是多少？运行限制： 1. 最大运行时间：1s 2. 最大运行内存：128M 题目分析这道题乍一看，是一道数论题目，实际上他确实一道数论题目，但是由于是道填空题，所以我们采用模拟法打表做。 题目中的描述是找约数，那我们定义个找约束个数的函数，然后枚举即可。 这样不考虑时间复杂度，我们采取暴力法，尽快完成题目，让程序去跑答案，节省下时间来去做其他的题目。 我们可以这样暴力写约束计数函数。 c++ 与 java 写法相同： 1234567int cnt(int a)&#123; int ans = 0; for (int j = a; j &gt; 0; j--) if (a % j == 0) ans++; return ans;&#125; Python 解决方法 约数函数定义完成之后，就可以开始枚举了，反正是个很大的数，从几开始都无所谓，300、500 都行，当然也可以从 1 开始。 代码解答C++ 解题代码： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int cnt(int a)&#123; int ans = 0; for (int j = 1; j &lt;= a; j++) if (a % j == 0) ans++; return ans;&#125;int main()&#123; for(int i=1;1;i++) &#123; cout&lt;&lt;cnt(i)&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; if(cnt(i)==100) break; &#125;&#125; 运行代码部分： 1234567891011121314151617181920212223242526272829303132333435363738......8 4532710 453282 4532916 453308 4533112 4533216 453338 453344 4533516 453362 453374 4533816 4533912 453402 4534124 453422 4534324 453448 4534516 453464 4534712 453484 4534912 453506 453518 4535216 453538 453548 4535524 453568 453574 453584 45359100 45360Process returned 0 (0x0) execution time : 21.628 sPress any key to continue. 提交代码： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;45360&lt;&lt;endl; return 0;&#125; Java 解题代码 Python 解题代码 在实测中 C++ 跑的最快，其次是 Java，最慢的是 Python 跑了约 30s，大家要耐心等待一下。 既约分数这是 2020 年省赛 的一个题目。 12345题目描述：本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。如果一个分数的分子和分母的最大公约数是 1，这个分数称为既约分数。 例如 \\frac{3}{4} ,\\frac{1}{8} ,\\frac{7}{1}43,81,17， 都是既约分数。 12345请问，有多少个既约分数，分子和分母都是 1 到 2020 之间的整数（包括 1 和 2020）？运行限制 1. 最大运行时间：1s 2.最大运行内存：128M 题目解析我们看到这种题，现在一眼就知道只是到纯暴力的题目，即暴力枚举然后依据题目要求模拟即可。 但是这种简单题在比赛中是来送分的，我们要花很少的时间做完，才有时间做其他的题目，这就要求我们对这种题目的熟练度极高，要做到，看到题目，想到思路手里能直接写出来才可以。 这里有一个巧妙的方法是因为分子与分母是对称的我们可以少枚举一半，不过有些同学可能没想明白，没关系，我们用普通的办法，只要能够快速的编程并找到答案，思路正确性能够保证的话，其他的都是可有可无的。 这题目我们首先要两个数是否互质，即最小公约数为 1，我们就定义一个 GCD() 求最小公约数的算法，这里我们采用的是递归的方法。 一般我们按照如下写法，方便。 1234int GCD(int a,int b)&#123; return a%b?GCD(b,a%b):b;&#125; 也可以同义的替换成一下写法： 1234567891011int GCD(int a,int b)&#123; if(a%b==0) return b; //如果a%b==0 代表可以被整除，那么b就是最大公约数 else return GCD(b,a%b) // 如果不能被整除，那么就先取余数，代码会保证左侧是大的，右侧是小的数字，所以使用时不必进行大小检查，即使a&lt;b也会再一次递归后变成b，a在进行计算。 //这样就能按照辗转相除法求解。（小学五年级的课程吧）&#125; 当让也可以按照算法的字面意思进行编写： 123456789101112int gcd(int a,int b)&#123; int temp; while(b) &#123; /*利用辗除法，直到b为0为止*/ temp = b; b = a % b; a = temp; &#125; return a;&#125; 然后这个题目我们就可以进行枚举了。 外层循环为 a，假设是分母，内层循环是 b 这样就可以进行枚举 a 和 b 都是 1 到 2020 那这个题，就非常简单了 代码解答C++ 实现： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int gcd(int a,int b)&#123; int temp; while(b) &#123; /*利用辗除法，直到b为0为止*/ temp = b; b = a % b; a = temp; &#125; return a;&#125;int main()&#123; int ans=0; for(int a=1;a&lt;=2020;a++) &#123; for( int b=1;b&lt;=2020;b++) &#123; if(gcd(a,b)==1) ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 提交代码： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;2481215&lt;&lt;endl; return 0;&#125; Java 解题代码 Python 解题代码 天干地支这个题目是 2020 国赛的模拟题。 12345678910111213141516171819202122232425262728293031323334353637383940414243题目描述：古代中国使用天干地支来记录当前的年份。天干一共有十个，分别为：甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）。地支一共有十二个，分别为：子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、 亥（hài）。将天干和地支连起来，就组成了一个天干地支的年份，例如：甲子。2020 年是庚子年。每过一年，天干和地支都会移动到下一个。例如 2021 年是辛丑年。每过 60 年，天干会循环 6 轮，地支会循环 5 轮，所以天干地支纪年每 60 年轮回一次。例如 1900 年，1960 年，2020 年都是庚子年。给定一个公元纪年的年份，请输出这一年的天干地支年份。输入描述：输入一行包含一个正整数，表示公元年份。其中有 ，输入的公元年份为不超过 9999 的正整数。输出描述：输入一行包含一个正整数，表示公元年份。输入输出样例：输入2020输出gengzi运行限制 1. 最大运行时间：1s 2. 最大运行内存: 128M 题目解析这个题目是模拟法中最讨厌也最常见的一种，可能还有比这更复杂的，但这道题，已经初具代表性。 他的种类比较多，天干就有 10 种 ，地支有 12 种 现在我们知道了 2020 年是庚子年，我们这里既可以是除留余数来判断 N 年是什么天干和什么地支，我们也可以直接暴力使用循环做，这样的话 9999 的复杂度也跑不了多久。实现起来很简单，我们讲这个比较难的。 我们先判断 0000 年的天干 和地支 。 根据题意 0000 年 距 2020 年 早了 2020 年 。 已知天干 有 10 个， 那么 2020%10=0 剩下的都是整个轮回，即到了 0000 年 是庚 X 年，即天干是 庚 。 再按照这个方法算地支 是 2020%12=4 及还要向前推四年 地支为申。 即 0000 年为庚申年，那么根据模拟法可知。 N%10=0 时 天干为庚 N%10=1 时 天干为辛 … 以此类推 N%12=0 时 地支为申 N%12=1 时 地支为酉 … 以此类推： 那我们很容易就能实现判断代码的编写： 123456string tg(int n)&#123; n=n%10; if(n==0) return &quot;geng&quot;; .....&#125; 这样写谁都会写，但是写起来过于太复杂了。我们换一种优雅的实现方式。 代码解答C++ 方式： 123456789101112#include &lt;iostream&gt;using namespace std;string tg[10] = &#123;&quot;geng&quot;, &quot;xin&quot;, &quot;ren&quot;, &quot;gui&quot;, &quot;jia&quot;, &quot;yi&quot; , &quot;bing&quot;, &quot;ding&quot;, &quot;wu&quot;, &quot;ji&quot;&#125;;string dz[12] = &#123;&quot;shen&quot;, &quot;you&quot;, &quot;xu&quot;, &quot;hai&quot;, &quot;zi&quot;, &quot;chou&quot;, &quot;yin&quot;, &quot;mou&quot;, &quot;chen&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;wei&quot;&#125;;int main()&#123; int year; cin &gt;&gt; year; cout&lt;&lt;tg[year%10]&lt;&lt;dz[year%12]&lt;&lt;endl;&#125; Java 解题代码 Python 解题代码 总结对于这种简单的模拟题，不需要借助算法，只要暴力的题目，我们都可以打表模拟，然后提交答案，在比赛时有的是输出答案，填空，比赛时注意分辨。 这章难度较低，但是对于熟练度要求较高。 多做简单的思维题，进行训练才能为后期的算法学习打下良好的基础，无论你学了多厉害的算法，如果思维训练不够，到了考场也是两眼一黑，手足无措。 而那些思维很好的同学，即使某一道题的算法我不会，但是我会有新的想法能接触这道题，我们现在所接触的所有算法，不都是某一个大牛，在不经意间发现，经过各种优化到我们手里的吗。 算法是工具，思维才是最重要的，我们这门课程不仅讲算法，还希望能够让各位提高思维能力。 递推法与递归法递推法： 递推法是一种非常重要的数学方法，不仅在数学领域有着广泛的运用，在其他领域也有着较高的实用性。在计算机中，递推法是用于数值求解的一个重要算法。 知识点 递推算法 递归算法 递推算法的特点一个问题的求解需要大量重复计算，在已知的条件和所求问题之间总存在着某种相互联系的关系，在计算时，我们需要找到这种关系，进行计算（递推关系式）。 即递推法的关键，就是找到递推关系式，这种处理方式能够将复杂的计算过程，转化为若干步骤的简单重复运送，充分利用计算机运行程序时的时间局部性和空间局部性。 递推算法的思想： 首要问题是先找到各个相邻数据项之间的递推关系； 递推关系避开了求通项公式的麻烦，且有些题目的通项公式很难求，或者不能进行求解； 将复杂问题分解为若干步骤的简单运算； 一般来说递推算法就是一种特殊的迭代算法。 递推算法解题的基本思路： 将复杂计算转换为简单重复运算； 通过找到递推关系式进行简化运算； 利用计算机的特性，减少运行时间。 递推算法的一般步骤： 根据题目确定数据项，并找到符合要求的递推关系式； 根据递推关系式设计递推程序； 根据题目找到递推的终点； 单次查询可以不进行存储，多次查询都要进行存储； 按要求输出答案即可。 递归算法： 递归算法是一种从自顶向下的算法，实际上是通过不停的直接调用或者间接的调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。 与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。 递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。 递归算法的思想： 将复杂计算过程转换为简单重复子过程； 找到递归公式，即能够将大问题转化为小问题的公式； 自上而下计算，在返回完成递归过程。 递归算法设计的一般步骤： 根据题目设计递归函数中的运算部分； 根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导； 找到递归出口，即递归的终止条件。 递归法的和递推法的思路也给大家讲的差不多了，我们结合真实大赛题目给大家进行讲解。 斐波纳契数列 fibonacci 问题在一定情况下，同一个问题可以使用用递归也可以使用递推解答。一般一个问题的递推关系和递归关系都好求的话就都可以解题。 当然如果题目只有一个关系好求，那就最好采用关系好求的办法。 题目描述: 1234567斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）请求出该数列中第n个数字（n从1开始计数）是多少。 样例: 123456789101112131415输入样例样例1输入6样例2输入4输出样例样例1输出8样例2输出3 对于上面的样例我们进行了如下计算； 12345678910111213[0]=0[1]=1[2]=0+1[3]=1+1=2[4]=1+2=3[5]=2+3=5[6]=5+3=8 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 这个题给出递推式 F(n) = F(n-1) + F(n-2) 转化为可用的递推关系，即 F(n) + F(n+1) = F(n+2) 这一通过从 n=1 开始循环即可完成递推，当然也可以使用递归法。 首先我们写找出递归式，F(n)= F(n-1) + F(n-2)。 1234F(n)= F(n-1) + F(n-2) = F(n-2)+F(n-3)+F(n-3)+F(n-4)//重复调用 这样我们找到了递归式，然后我们应该找到递归出口。 我们可以知道 F(n)=0 n=0 ,F(n)=1 n=1 这就是递归出口，能让递归停止的条件。 递归算法的通用框架如下： 1234567891011121314151617181920212223do(a,b,c...)&#123; //递归终止条件，即出口 if(a==? ,b==? ,....) return //递归条件 if(条件1) do(参数1) else(条件2) do(参数2)&#125;如本题，各子式间存在计算关系，可以化为：do(a)&#123; if(a==0) return 0; if(a==1) return 1; return do(a-1)+do(a-2);&#125; 这道题不是多次询问问题，不需要存储直接计算的复杂度是最低的。 答案解析C++ 代码： 递推算法代码 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int n; //第几个数 int x=0; //F(n) int y=1; //F(n+1) int ans; //F(n+2） cin&gt;&gt;n; if(n==0) ans=0; else if(n==1) ans=1; else &#123; for(int i=2;i&lt;=n;i++) &#123; ans=x+y; x=y; y=ans; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 递归算法代码 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int fn(int n)&#123; //递归出口1 if(n==0) return 0; //递归出口2 else if(n==1 ) return 1; else return fn(n-1)+fn(n-2); //递归关系式&#125;int main()&#123; int n; //第几个数 int ans; cin&gt;&gt;n; ans=fn(n); cout&lt;&lt;ans&lt;&lt;endl;&#125; Python 解题代码 Java 解题代码 存储型的递推与递归我们在开始就讲过题目十分存储和非存储的，上面那个题目就是此询问，如果改为多次询问我们该怎么办，我们会采用存储的方式，存储的方式适用于大部分的的多次查询问题。 我们看一下修改后的题目。 题目描述： 123456789斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）。我们将进行M次查询，每次输入一个N，其中n小于30。请求出该数列中第n个数字（n从1开始计数）是多少? 样例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445输入样例样例1输入：64278810样例2输入：81323141724161011输出样例样例1输出：3113212155样例2输出：233286573771597463689875589 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 这道题跟上面一道题的算法原理相同，只是增加了多次查询的复杂度，所以仅需修改这一点即可。 再有的是有的同学担心自己的输入输出是在一个屏幕上的，评测的时候会不会出现问题。 类似这样的情况，这一点是不用担心的，只要不是交互题，评测机的输入与输出是分开的，只有你的输出会用来跟答案比较，所以我们只用关心我们的输出即可。 比如有一道题让你计算 x+y 的值，如果你知道每答案，就可以直接输出，都不用进行读入。 然后我们来看一下需要多次询问的题目该怎么解决。 答案解析C++ 代码： 递推算法代码 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int F[35];void init()&#123; F[0]=0; F[1]=1; for(int i=2;i&lt;=30;i++) &#123; F[i]=F[i-1]+F[i-2]; &#125;&#125;int main()&#123; int m; //m次查询 int n; //第几个数 init(); cin&gt;&gt;m; while(m&gt;0)&#123; m-=1; cin&gt;&gt;n; cout&lt;&lt;F[n]&lt;&lt;endl; &#125;&#125; 存储答案的递推法，才是最常使用的递推法。 递归算法代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int F[35];int fn(int n)&#123; //递归出口1 if(n==0) &#123; F[0]=0; return 0; &#125; //递归出口2 else if(n==1 ) &#123; F[1]=1; return 1; &#125; else &#123; F[n]=fn(n-1)+fn(n-2); return F[n]; //递归关系式 &#125;&#125;int main()&#123; int m; //m次查询 int n; //第几个数 fn(30); cin&gt;&gt;m; while(m&gt;0)&#123; m-=1; cin&gt;&gt;n; cout&lt;&lt;F[n]&lt;&lt;endl; &#125;&#125; Python 解题代码 Java 解题代码 数字三角形问题题目描述: 123456789如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。 1. 一步可沿左斜线向下或右斜线向下走；2. 三角形行数小于等于 100；3. 三角形中的数字为 0，1，…，99； 测试数据通过键盘逐行输入。如上例数据应以样例所示格式输入： 样例: 1234567891011输入：573 88 1 02 7 4 44 5 2 6 5输出：30 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目分析: 解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。 我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第 i 层，正向着 i+1 层前进， 两条可行路径中我们肯定会选择最大的方向前进，为此我们可以采用递推中的反向递推，即逆推的方式解决，设 a[i][j] 存放从 i,j 出发到达第 n 层的最大值。 我们可以写出递推式： 1a[i][j] = max&#123;a[i][j]+a[i+1][j]，a[i][j]+a[i+1][j+1]&#125; 则 逆推到出发点 a[1][1] 为题目所求答案，即第一层到第 N 层的最大值。 答案解析C++ 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int main()&#123; int n; //n层 int a[101][101]; //路径矩阵 cin&gt;&gt;n; //输入数字三角形的值 for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=i; j++) &#123; cin&gt;&gt;a[i][j]; //输入原始数据 &#125; &#125; //递推开始 for (int i=n-1; i&gt;=1; i--)//从最后一层逆推 &#123; for (int j=1; j&lt;=i; j++) &#123; if (a[i+1][j]&gt;=a[i+1][j+1]) a[i][j]+=a[i+1][j]; //路径选择 else a[i][j]+=a[i+1][j+1]; &#125; &#125; cout&lt;&lt;a[1][1]&lt;&lt;endl;&#125; Python 解题代码 Java 解题代码 总结我们这节课讲了递推与递归的知识点，并且也讲了何时采用递归设计程序，何时采用递推设计程序。对于多次询问的题目，也为大家展示了一种解决方法。 对于递推算法，我们覆盖了正推和逆推两种方式。无论是递推和递归的关键在于找到关系式。 希望同学能够独立完成题目进行练习。并且在后面的学习中会多次用到递归与递推设计其他算法。 枚举法之前的课，给大家讲解过打表法与模拟法的暴力方式，说到暴力，我们大家最先想到一定是枚举，但是枚举真的是一门技术，怎么样把所有情况一个不落下的枚举出来是比较难的，所以我们这节课给大家讲解一下枚举法。 知识点 简单型枚举 组合型枚举 排列型枚举 指数型枚举 枚举法枚举算法的思想： 将问题的所有可能成为答案的解一一列举，然后根据问题所给出的条件判断此解是否合适，如果合适就保留，反之则舍弃。 枚举算法解题的基本思路： 确定枚举解的范围，以及判断条件 选取合适枚举方法，进行逐一枚举，此时应注意能否覆盖所有的可能的解 在枚举时使用判断条件检验，留下所有符合要求的解。 枚举算法的一般步骤： 根据题目确定枚举的范围，并选取合适的枚举方式，不能遗漏任何一个真正解，同时避免重复。 为了提高解决问题的效率，看题目是否存在优化，将可能成为解的答案范围尽可能的缩小。 根据问题找到合理并、准确好描述并且好编码的验证条件。 枚举并判断是否符合第三步确定的的条件，并保存符合条件的解。 按要求输出枚举过程中留下的符合条件的解。 枚举法也是有很多技巧和方法的，这节课我们将从如下几种方法为大家进行讲解。 简单型枚举简单型枚举就是可以通过简单的 for 循环嵌套就可以解决的问题。我们之前的课讲的题目都算是简单型枚举的范畴，所以简单型枚举是比较简单，也是大家接触最多的一种枚举方式。 这种枚举方式没有特定的固定枚举方式，而且都比较简单，按照题目的要求进行设计代码即可完成解题。 我们用一个题复习一下。 42 点问题题目描述: 123456789众所周知在扑克牌中，有一个老掉牙的游戏叫做24点，选取4张牌进行加减乘除，看是否能得出24这个答案。现在小蓝同学发明了一个新游戏，他从扑克牌中依次抽出6张牌，注意不是一次抽出，进行计算，看是否能够组成 42 点，满足输出YES，反之输出 NO。最先抽出来的牌作为第一个操作数，抽出牌做第二个操作数，运算结果在当作第一个操作数，继续进行操作。除不尽的情况保留整数。请设计一个程序对该问题进行解答。 样例: 1234567输入：K A Q 6 2 3 输出：YES 对于上面的样例我们进行了如下计算； 123451. K*A=K 即 13*1=132. 13/12=1 保留整数3. 1+6=74. 7*2=145. 14*3=42 运行限制: 12最大运行时间：1s最大运行内存: 128M 题目解析： 这个题目我们可以依次枚举数字，然后在枚举数字间的符号即可。由于到结果之间进行了三步计算，所以我们这里需要进行一个递归操作，利用了上节课讲解的知识。 两重循环即可解决问题，伪代码如下： 1234567891011121314op1 赋值为 第一个数op(op[1] op[2])&#123; for op in [+ - * /] ans = 第一个操作数op1 操作 第二个操作数op2 如果是第六个操作数，就检验是否符合要要求 ==42？ 如果是就返回True 如果op(ans , op[3]) 返回 True，就返回True 因为找到了答案，否则就继续进行 没有找到答案返回False&#125; 但是这样写，思路感觉很清晰，写起来却非常的复杂，我们使用我们讲过的 Vector 来优化这个枚举方式。 我们创建 5 个 Vector ，分别用来存放 1-5 次的运算结果，非常简单。我们答案就采用这种方式。 答案解析C++ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int a[10];vector &lt;int&gt; ans[10];int main()&#123; for(int i=0; i&lt;6; i++) &#123; char c; cin&gt;&gt;c; if(c==&#x27;A&#x27;) a[i]=1; else if(c==&#x27;J&#x27;) a[i]=11; else if(c==&#x27;Q&#x27;) a[i]=12; else if(c==&#x27;K&#x27;) a[i]=13; else a[i]=(c-&#x27;0&#x27;); //cout&lt;&lt;a[i]&lt;&lt;endl; &#125; ans[0].push_back(a[0]); for(int i=1; i&lt;=5; i++) &#123; for(int j=0; j&lt;ans[i-1].size(); j++) &#123; ans[i].push_back(ans[i-1][j]+a[i]); ans[i].push_back(ans[i-1][j]-a[i]); ans[i].push_back(ans[i-1][j]*a[i]); ans[i].push_back(ans[i-1][j]/a[i]); &#125; &#125; //cout&lt;&lt;ans[5].size()&lt;&lt;endl; int flag=0; for(int i=0; i&lt;ans[5].size(); i++) &#123; if(ans[5][i]==42) &#123; flag=1; break; &#125; &#125; if(flag==1) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; Python 解题代码 Java 解题代码 组合型枚举排列组合相信大家都学习过，组合型枚举就是让你在 n 个中，随机选出 m 个，问你有多少种方案，而且每一种方案选择了哪 m 个，这就是组合型枚举。 即组合型枚举就是寻找 cnmc_{n}^mcnm 问题。 组合型枚举有固定的流程，即有着固定的算法模板，这个需要大家去记忆一下。 1234567891011121314151617181920212223int n;//共计N个数int m;//选m个数vector&lt;int&gt; chosen;void calc(int x) &#123; if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝 return; if (x == n + 1) &#123; //选够了m个数输出 for (int i = 0; i &lt; chosen.size(); i++) printf(&quot;%d &quot;, chosen[i]); //也可以不输出，存放起来也是可以的，主要是看题目。 puts(&quot;&quot;); return; &#125; calc(x + 1); chosen.push_back(x); calc(x + 1); chosen.pop_back();//消除痕迹&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; calc(1);&#125; Python 写法 Java 写法 大家有个疑虑，我这里全是数字而且是从 1 开始的能好用吗，我题目要是字母怎么办，那么请看下面的题目。 公平抽签题目描述: 1234567891011小A的学校，蓝桥杯的参赛名额非常有限，只有m个名额，但是共有n个人报名，其中m&lt;=n。作为老师非常苦恼，他不知道该让谁去，他在寻求一个绝对公平的方式。于是他准备让大家抽签决定，即m个签是去，剩下的是不去。小A非常想弄明白最后的抽签结果是什么样子的，到底有多少种结果。请设计一个程序帮助小A。最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。第一行 输入 N M第二行 到 第 N+1 行 共输入 N 个人名每种情况输出 M 个人名，空格隔开。 样例: 1234567891011输入：3 2xiaowangxiaoAxiaoli输出：xiaowang xiaoAxiaowang xiaolixiaoA xiaoli 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 实际上还是组合型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，直接输出即可。 答案解析C++ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; //共计N个数int m; //选m个数vector&lt;string&gt; name;vector&lt;string&gt; ans;vector&lt;int&gt; chosen;void calc(int x)&#123; if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝 return; if (x == n + 1) &#123; //选够了m个数输出 string ansTem = &quot;&quot;; for (int i = 0; i &lt; chosen.size(); i++) ansTem += name[chosen[i] - 1] + &quot; &quot;; ans.push_back(ansTem); return; &#125; calc(x + 1); chosen.push_back(x); calc(x + 1); chosen.pop_back(); //消除痕迹&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; name.push_back(s); &#125; calc(1); for (int i = ans.size() - 1; i &gt;= 0; i--) cout &lt;&lt; ans[i] &lt;&lt; endl;&#125; Python 解题代码 Java 解题代码 排列型枚举上面说过，组合型枚举就是让你在 n 个中，随机选出 m 个 ，问你有多少种方案，而且每一种方案选择了哪 m 个，这就是组合型枚举。 而排列型枚举相对组合型枚举就简单了一点，就是 n 个的全排列，即从 n 个中选取 n 个但是关心内部的顺序。 相比较组合只关心有多少个集合，而排列是关心集合内的排列方式。即排列型枚举就是寻找 A_{n}^nAnn 问题。 而且排列型枚举也是有着比较成熟的模板需要大家进行记忆。 123456789101112131415161718192021222324252627282930int n; //共计N个数int order[20];bool chosen[20];void calc(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; order[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (chosen[i]) continue; order[k] = i; chosen[i] = 1; calc(k + 1); chosen[i] = 0; order[k] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; calc(1);&#125; Python 写法 Java 写法 不少同学问我 20 够不够，排列问题是阶乘阶的时间复杂度，如果超过这个复杂度，那么这个题也就不用做了，算不出来。 所以肯定够用。 1234567891011121314151617181920212223242541 2 3 41 2 4 31 3 2 41 3 4 21 4 2 31 4 3 22 1 3 42 1 4 32 3 1 42 3 4 12 4 1 32 4 3 13 1 2 43 1 4 23 2 1 43 2 4 13 4 1 23 4 2 14 1 2 34 1 3 24 2 1 34 2 3 14 3 1 24 3 2 1 4 的排列就已经这么多了，大家可以尝试跑一下 10。 同样，我们再来看一个的问题来进行加深理解。 座次问题题目描述: 12345678910小 A 的学校，老师好不容易解决了蓝桥杯的报名问题，现在老师又犯愁了。现在有 N 位同学参加比赛，但是老师想给他们排座位，但是排列方式太多了。老师非常想弄明白最后的排座次的结果是什么样子的，到底有多少种结果。请设计一个程序帮助老师。最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。第一行 输入 N；第二行 到 第N+1 行 共输入 N 个人名。由于小 A 学校承办能力实在有限，所以其中 N 小于等于 10 人。 样例: 1234567891011121314输入：3xiaowangxiaoAxiaoli输出：xiaowang xiaoA xiaolixiaowang xiaoli xiaoAxiaoA xiaowang xiaolixiaoA xiaoli xiaowangxiaoli xiaowang xiaoAxiaoli xiaoA xiaowang 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 实际上还是排列型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，就是按照上一道题的方式处理即可。 答案解析C++ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; //共计N个数vector&lt;string&gt; name;int order[20];bool chosen[20];void calc(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; name[order[i] - 1] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (chosen[i]) continue; order[k] = i; chosen[i] = 1; calc(k + 1); chosen[i] = 0; order[k] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; name.push_back(s); &#125; calc(1);&#125; Python 解题代码 Java 解题代码 实验总结我们讲了三种的枚举方式，普通枚举和排列组合枚举，其实还是有其他的枚举方式，可以借助我们排列组合进行组合实现，并且在后面的课程中我们将进行搜索的讲解，搜索算法能够作为补充进行其他的枚举。 基本所有的枚举情况我们都涵盖到了，希望大家多加练习，熟练运用。 差分与前缀和差分与前缀和是一对互逆的操作，常常用于处理区间问题，差分法是解决区间加减问题，前缀和是解决区间求和问题的常用办法。 知识点 差分算法 前缀和算法 差分法差分法的应用主要是用于处理区间问题。当某一个数组要在很多不确定的区间，加上相同的一个数。我们如果每个都进行加法操作的话，那么复杂度 O(nm) 是平方阶的，非常消耗时间。 如果我们采用差分法，将数组拆分，构造出一个新的拆分数组，通过对数组区间的端点进行加减操作，最后将数组和并就能完成原来的操作。 这样处理后，时间复杂度降低为 O(N)，虽然感觉操作变得更加复杂了，但是只用对边界操作确实比操作一整个区间的方法要优秀的多。 听到这里也是吊足了胃口，那到底怎么对区间操作呢，请大家跟随我的讲解，慢慢理解。 差分法的特点： 将对于区间的加减操作转化为对于端点的操作； 时间复杂度为 O(n)； 用于维护区间的增减但不能维护乘除； 差分后的序列比原来的数组序列多一个数。 差分算法解题的基本思路： b[1]=a[1]； 从第 2 项到 n 项，利用 b[i]=a[i]-a[i-1]b[i]=a[i]−a[i−1] 差分式； 对于区间端点操作加减； 差分还原(前缀和)。 注意是从1开始，从0开始还有讨论i=0 的情况，使用1的话 b[1]=a[1]-a[0]=a[1]-0; 递推算法的一般步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102首先假设有一个数组：a[]=&#123;1 2 3 4 5 7 2&#125;差分后：b[]=&#123;1 1 1 1 1 2 -5&#125;一般应用场景：让你对区间 [l,r] 加减操作 N 次如：从第二个元素到第五个元素每个+3从第二个元素到第四个元素每个-2从第一个元素到第三个元素每个+1....这里我们先演示前三个：对于每个 [l,r] 区间的加减操作都转化为对端点 l,r+1 的操作从第二个元素到第五个元素每个+3：转化为：[l]+3 并且 [r+1]-3那么原序列变成了：1 1 1 1 1 2 -51 4 1 1 1 -1 -5然后我们按照 b[i]=b[i]+b[i-1] 复原：1 5 6 7 8 7 2去掉最后一项，跟原序列对比：1 2 3 4 5 7 21 5 6 7 8 7 2确实是都加上了 3。我们继续操作：从第二个元素到第四个元素每个-2转化为：[l]-2 并且 [r+1]+2那么序列变成了： 1 4 1 1 1 -1 -51 2 1 1 3 -1 -5然后我们按照b[i]=b[i]+b[i-1] 复原1 3 4 5 8 7 2与上次复原后对比：1 5 6 7 8 7 21 3 4 5 8 7 2 确实是按照操作执行了。注意 Warning：不用每次都复原，只用最后一次复原即可，这里我是演示给大家看。我们最后直接做三次，最后还原：从第二个元素到第五个元素每个+3从第二个元素到第四个元素每个-2从第一个元素到第三个元素每个+1a[]=&#123;1 2 3 4 5 7 2&#125;原序列差分后：b[]=&#123;1 1 1 1 1 2 -5&#125;2 号元素 + 3 6 号元素 - 32 号元素 - 25 号元素 + 21 号元素 + 1 4 号元素 - 1差分序列变成：2 2 1 0 3 -1 -5复原后：2 4 5 5 8 7 5与原序列对比：1 2 3 4 5 7 22 4 5 5 8 7 5所以还是非常方便快捷的。 差分与前缀和是逆操作，常在一起出现，但是先做差分还是先做前缀和就是两种不同的算法，做不做另一种操作也决定了算法不同，所以大家要根据题目分析，具体学会使用。 大学里的树木要打药题目描述: 1234567891011教室外有 N 棵树，根据不同的位置和树种，学校要对其上不同的药。因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。树的编号从 0-N-1 且 N&lt;1e6。对于树的药是成区间分布，比如 3 - 5 号的树靠近下水道，所以他们要用驱蚊虫的药， 20 - 26 号的树，他们排水不好，容易涝所以要给他们用点促进根系的药。诸如此类，每种不同的药要花不同的钱。现在已知共有 M 个这样的区间，并且给你每个区间花的钱，请问最后，这些树木花了多少药费。 输入: 123456789101112131415161718192021输入描述:每组输入的第一行有两个整数 N（1 &lt;= N&lt;= 1000000）和 M（1 &lt;= M &lt;= 100000）。N 代表马路的共计多少棵树，M代表区间的数目，N 和 M 之间用一个空格隔开。接下来的 M 行每行包含三个不同的整数，用一个空格隔开，表示一个区域的起始点 L 和终止点 R 的坐标，以及花费。输入样例:500 3150 300 4100 200 20470 471 19输出描述:输出包括一行，这一行只包含一个整数，所有的花费。输出样例:2662 样例: 123456789101112131415输入样例3000 8150 1130 21020 1200 3 470 2071 11123 211 612 222 213 23 2 1 213 41232 2523 6输出样例2662 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 利用b[i]=a[i]-a[i-1]b[i]=a[i]−a[i−1] 差分式。 这里由于开始时都是 0，可以用，但是用完都还是 0，所以没有意义，所以直接跳过即可。 依次读入区间的值，然后将对于区间的操作转化为对于区间端点操作加减。 由于我们从1开始，所以数目整体区间要右移1位。 对于每个 [l,r] 区间的加减操作都转化为对端点 l,r+1 的操作。 差分还原(前缀和)。 123for (int i = 1; i &lt; n; i++)b[i] = a[i] - a[i - 1] 差分算法解决区间加减问题通用框架如下： 1234567891011121314151617181920212223242526//读入原始数据 n,m,a输入n,mfor(int i=1;i&lt;=n;i++)&#123; 输入a[i]&#125;//差分for(int i=1;i&lt;=n;i++) b[i]=a[i]-a[i-1] //区间操作while(m--)&#123; 输入l,r,value b[l]+value b[r+1]-value&#125;//前缀和还原for(int i=1;i&lt;n;i++) b[i]=b[i]+b[i-1] 答案解析C++ 代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int b[100005];int main()&#123; int n; //n层 int m; // m个区间 cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int l, r, value; cin &gt;&gt; l &gt;&gt; r &gt;&gt; value; b[l+1] += value; b[r + 1+1] -= value; &#125; for (int i = 1; i &lt;= n; i++) b[i] = b[i] + b[i - 1]; int sum = 0; for (int i = 1; i &lt;= n; i++) sum += b[i]; /* 也可以一次性搞定 int sum=b[1]; for(int i=1; i&lt;=n; i++)&#123; b[i]=b[i]+b[i-1]; sum+=b[i] &#125; */ cout &lt;&lt; sum &lt;&lt; endl;&#125; Python 解题代码 Java 解题代码 前缀和前缀和法的应用主要也是用于处理区间问题。 前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和。当对于某一数组区间进行多次询问，[L,r] 的和时，如果正常处理，那么我们每次都要 [l,r]。查询 N 次，那么时间复杂度也是 O(nm) 也是平方阶的。 如果我们采用前缀和，构造出一个前缀和数组，通过对于端点的值的减法操作就能 O(1) 的求出 [l,r] 的和。然后 N 次查询的,就将复杂度降低为 O(n) 同差分一样，感觉操作变得更加复杂了，但是只用对端点值的操作确实比一整个区间相加的方法要优秀的多。听到这里大家很期待了，我们接着进行讲解。 前缀和的特点： 将对于区间的求和操作转化为对于端点值的减法的操作； 区间求和操作的时间复杂度为 O(1)； 数组存放时要从 1 开始； 前缀和数组比原来的数组序列多一个数，第 0 个 前缀和算法解题的基本思路： 利用 sum[i]=a[i]+sum[i-1]sum[i]=a[i]+sum[i−1] 差分式； 从第 1 项到 n 项，且第 0 项无数据默认为 0； 对于区间求和的操作转化为端点值相减。 前缀和的一般解题过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556首先假设有一个数组：1 2 3 4 5 7 2前缀和后：0 1 3 6 10 15 22 24一般应用场景：让你对区间 [l,r] 求和操作N次如：从第二个元素到第五个元素的和从第二个元素到第四个元素的和从第一个元素到第三个元素的和....这里我们先演示前三个：对于每个 [l,r] 区间的求和操作转化为区间端点的加减操作sum[l,r] =[r]-[l-1]从第二个元素到第五个元素的和：转化为：[5]-[1]那么Sum[2,5]=[5]-[1]=14且 2+3+4+5=14确实是相等的，就是这么神奇。我们继续操作：从第二个元素到第四个元素的和转化为：[4]-[1]那么Sum[2,4]=[4]-[1]=9且 2+3+4=9我们继续操作：从第一个元素到第三个元素的和转化为：[3]-[0]那么Sum[1,3]=[3]-[0]=6且 1+2+3=6符合题意，验证结束，咱么做个题目看一看 大学里的树木要维护题目描述: 12345678910111213141516171819202122232425262728293031教室外有 N 棵树，根据不同的位置和树种，学校已经对其进行了多年的维护。因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。树的编号从 1-N 且 N&lt;1e6。由于已经维护了多年，每一个树都由学校的园艺人员进行了维护费用的统计。每棵树的前期维护费用各不相同，但是由于未来需要要打药，所以有些树木的维护费用太高的话，就要重新种植。由于维护费用也称区间分布，所以常常需要统一个区间里的树木的维护开销。现在园艺人员想知道，某个区间内的树木维护开销是多少。共计 M 个区间需要查询。输入描述:每组输入的第一行有两个整数 N（1 &lt;= N&lt;= 1000000）和 M（1 &lt;= M &lt;= 100000）。N 代表马路的共计多少棵树，M 代表区间的数目，N 和 M 之间用一个空格隔开。接下来的一行，包含 N 个数，每个数之间用空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点L和终止点R的坐标。输入样例:10 37 5 6 4 2 5 0 8 5 31 52 63 7输出描述: 输出包括M行，每一行只包含一个整数，所有的花费。输出样例:242217 样例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263输入样例30 28172 723 580 822 718 798 941 625 450 716 540 252 16 666 115 679 274 323 875 233 99 538 881 486 610 462 319 878 930 7356 227 213 167 209 170 2113 277 1910 232 1421 2215 176 1316 2321 2111 155 129 118 2210 163 815 275 164 80 274 87 2120 21输出样例81406804791867053708106176576647262077847637106843383902991589504017066401298444845894651639041391339046804332 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 利用sum[i]=a[i]+sum[i-1]sum[i]=a[i]+sum[i−1] 前缀和式在输入时求出前缀和； 依次读入区间的值，然后将对于区间的求和操作转化为对于区间端点操作加减，对于每个 [l,r] 区间的求和操作都转化为对端点[r]-[l-1]的操作。 输出答案。 前缀和一般解题过程： 12345678910111213输 入 N 和 M 输入 N 个值 并计算前缀和for( int i=1;i&lt;=N;i++) 输入a[i] 并计算sum[i]=sum[i-1]+a[i]输入 M 个区间，计算结果while(M) M-=1 输入 L , R 计算 [r]-[l-1]，并输出 答案解析C++ 代码： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int a[100005];int sum[100005];int main()&#123; int n; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; sum[i] = a[i] + sum[i - 1]; &#125; while (m &gt; 0) &#123; m -= 1; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; endl; &#125;&#125; 这个代码有个问题，虽然是能通过的，但是他是一个输入对应一个输出的，我们之前讲过，这对大部分的测评机是没问题。 终端输出： 123456789101110 37 5 6 4 2 5 0 8 5 31 5242 6223 717Process returned 0 (0x0) execution time : 1.741 sPress any key to continue. 但是如果有想要规规矩矩的处理，或者说题目要求必须全部读入后输出。我们可这样操作。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int sum[100005];vector&lt;int&gt;ss;int main()&#123; int n ; int m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; sum[i]=a[i]+sum[i-1]; &#125; while(m&gt;0) &#123; m-=1; int l,r; cin&gt;&gt;l&gt;&gt;r; ss.push_back(sum[r]-sum[l-1]); &#125; for(auto sss:ss) cout&lt;&lt;sss&lt;&lt;endl;&#125; 终端输出： 123456789101110 37 5 6 4 2 5 0 8 5 31 52 63 7242217Process returned 0 (0x0) execution time : 6.235 sPress any key to continue. 都可以，大家看自己需求和心情选择即可。 Python 解题代码 Java 解题代码 实验总结我们这节课讲了差分和前缀和的知识点，并且也讲了怎样使用差分，怎样使前缀和，也讲了差分和前缀和最常见的两种情况。 差分和前缀和是很多思维题的解题技巧，必须要掌握熟练才能拿到简单题目的全部分数。 二分查找算法知识点 二分查找原理讲解 在单调递增序列 a 中查找 x 或 x 的后继 在单调递增序列 a 中查找 x 或 x 的前驱 二分查找算法讲解枚举查找也就是顺序查找。 实现原理就是逐个比较 a[0:n-1] 中的元素，直到找出元素 x 或搜索遍整个数组后确定 x 不在其中，或者说符合要求的元素在不在数组中。 最坏的情况下需要比较 N 次，时间复杂度是 O(n) 线性阶。 二分查找也就是折半查找。折半查找是将 N 个元素分成大致相同的两部分。选取中间元素与查找的的元素比较，或者与查找条件相比较，找到或者说找到下一次查找的半区。每次都将范围缩小至\\frac{1}{2}21 所以时间复杂度是 O(log2n），但是二分查找的前提是有序的，一般是从小到排列。 折半查找的基本思想： 在有序表中（low,high,low&lt;=high），取中间记录即 [(high+low)/2] 作为比较对象。 若给定值与中间记录的关键码相等，则查找成功 若给定值小于中间记录的关键码，则在中间记录的左半区继续查找 若给定值大于中间记录的关键码，则在中间记录的右半区继续查找 不断重复上述过程，直到查找成功，或所查找的区域无记录，查找失败。 二分查找的特征： 答案具有单调性； 二分答案的问题往往有固定的问法，比如：令最大值最小（最小值最大），求满足条件的最大（小）值等。 折半查找一般过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Step 1:假设存在一有序数组：下标[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ]数据[ 7 14 18 21 23 29 31 35 38 42 46 49 52 ] ↑ ↑ low=0 high=12 mid=(low+high)/2 mid=(0+12)/2 mid=6 [mid]=31&gt;14 所以选择左半部分操作： 此时令low不变，high=mid-1=5Step 2:下标[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ]数据[ 7 14 18 21 23 29 31 35 38 42 46 49 52 ] ↑ ↑ low=0 high=5 mid=(low+high)/2 mid=(0+6)/2 mid=3 [mid]=21&gt;14 所以选择左半部分操作： 此时令low不变，high=mid-1=2Step 3:下标[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ]数据[ 7 14 18 21 23 29 31 35 38 42 46 49 52 ] ↑ ↑ low=0 high=2 mid=(low+high)/2 mid=(0+2)/2 mid=1 [mid]=14=14 找到答案操作： 返回下标 整数二分法常用算法模板C++ 语言描述12345678910111213141516171819202122// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high)&#123; int mid = (low + high) / 2; if (a[mid] &gt;= x) high = mid; else low = mid + 1;&#125;// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high)&#123; int mid = (low + high + 1) / 2; if (a[mid] &lt;= x) low = mid; else high = mid - 1;&#125; Python 语言描述 Java 语言描述 此处我们先分整数的二分查找法的常用模版，关于实数的部分，我们后面再讲。 下面可能会有同学会疑问道：为什么采用这一套代码的而不是采用查找等于的 X？ 是因为这样的适用范围更广，当有 X 时这套代码就返回 X 的位置。如果没有 X，就返回 &lt;=x 的数中最大的一个或者 &gt;=x 的数中最小的一个。 分巧克力2017 年省赛真题链接。 题目描述: 12345678儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：1. 形状是正方形，边长是整数;2. 大小相同;例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 要求输入: 1234567输入描述:第一行包含两个整数 N,K (1≤N,K≤1e5）。以下 N 行每行包含两个整数 Hi Wi (1≤Hi,Wi≤1e5)。输入保证每位小朋友至少能获得一块 1x1 的巧克力。 要求输出： 123输出描述:输出切出的正方形巧克力最大可能的边长。 样例: 123456789输入样例2 106 55 6输出样例2 运行限制: 12345678最大运行时间：1s最大运行内存：256M注意：1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”的多余内容。2. 不要调用依赖于编译环境或操作系统的特殊函数。3. 所有依赖的函数必须明确地在源文件中4. 不能通过工程设置而省略常用头文件。 题目分析简单思路，边长的最大规模为 100000；我们可以枚举出所有的情况。按从大到小的顺序进行切割，直到找到满足要求的巧克力边长。 在判断边长是否满足条件时：求一块长方形（h * w）最多被分成的正方形（len * len）巧克力个数为： 1cnt = (h / len) \\* (w / len) 但是使用朴素算法枚举时间复杂度 O(n)*O(n) =O(n2) 会超时，所以改用 2 分查找法，这找到符合要求的最大的一个。 即用在单调递增序列 a 中查找 &lt;=x 的数中最大的一个（即 x 或 x 的前驱）即可，原本这里的条件是 &lt;=x ，我们将其换成验证即可。 代码解答C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100010;int n,k;int h[MAXN],w[MAXN];bool pd(int l)&#123; int sum=0; for(int i=0; i&lt;n; i++) &#123; sum+=(h[i]/l)*(w[i]/l); if(sum&gt;=k) &#123; return true; &#125; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) cin&gt;&gt;h[i]&gt;&gt;w[i]; //找到二分查找的上界 int high=0; for(int i=0; i&lt;n; i++) &#123; high=max(high,h[i]); high=max(high,w[i]); &#125; // 二分下届由题意可得至少为1 int low=1; // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边 int mid=0; while(low&lt;high) &#123; mid = (low + high+1) / 2; if(pd(mid)) low=mid; else high = mid - 1;// cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl; &#125; //因为low=high所以输出哪一个都一样 cout&lt;&lt;low; return 0;&#125; 查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。 Python 实现 Java 实现 M 次方根题目描述: 123456789101112131415小A最近在学高等数学，他发现了一道题，求三次根号下27。现在已知，小 A 开始计算，1 的三次方得1，2 的三次方得 8，3 的三次方得 27，然后他很高兴的填上了 3。接着他要求 5 次根号下 164。然后他开始 1 的三次方得 1，2 的三次方得 8，3 的三次方得27...直到他算到了秃头，也没有找到答案。这时一旁的小 B 看不下去了，说这题答案又不是个整数。小 A 震惊，原来如此。作为程序高手的小 A，打算设计一个程序用于求解 M 次跟下N的值。但是由于要考虑精度范围，答案必须要保留 7 位小数，连三次根号下 27 都要掰手指的小 A 又怎么会设计呢。请你帮小 A 设计一个程序用于求解 M 次根号 N。数据范围：1&lt;= N &lt;= 1e5 1&lt;= M &lt;= 100且 M&lt;N 要求输入: 123输入描述:第一行输入整数 N 和 M，数据间用空格隔开。 要求输出： 123输出描述:输出一个整数，并保留 7 位小数。 样例: 1234567输入样例：27 3输出样例：3.000000 运行限制: 12345678最大运行时间：1s最大运行内存: 256M注意：1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。2. 不要调用依赖于编译环境或操作系统的特殊函数。3. 所有依赖的函数必须明确地在源文件中。4. 不能通过工程设置而省略常用头文件。 题目分析前面讲的都是整数二分，其实二分法还是可以用于实数。这个题目比较难，很多同学可能想不明白，想不明白就多读题，写写画画理解一下。这个题还有很多解法，现在告诉你了这道理用二分可以解答，请设计一个二分程序。 首先是这道题我们怎么下手： 根据前面的知识，我们要找到一个具有单调性的数列，去二分。这个题的关键是我们要去二分什么，这里可以二分的是 a^M 中的 a，所以我们要先想办法设计出用于处理实数二分的代码。 这里给大家两个模板，都可以大家选择一个使用即可： C++ 模版： 1234567891011121314151617181920212223242526272829//模版一：实数域二分，设置eps法//令 eps 为小于题目精度一个数即可。比如题目说保留4位小数，0.0001 这种的。那么 eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。//一般为了保证精度我们选取精度/100 的那个小数，即设置 eps= 0.0001/100 =1e-6while (l + eps &lt; r)&#123; double mid = (l + r) / 2; if (pd(mid)) r = mid; else l = mid;&#125;//模版二：实数域二分，规定循环次数法//通过循环一定次数达到精度要求，这个一般 log2N &lt; 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给 N 乘一个系数使得精度更高。 for (int i = 0; i &lt; 100; i++)&#123; double mid = (l + r) / 2; if (pd(mid)) r = mid; else l = mid;&#125; Python 模版 Java 模版 模板讲完了，然后我们就要考虑判定条件了，怎样判定是否存在满足大于平均值的区间。当然这个题你可以使用语言中自带开方软件，但是我们还是联系一下实数的二分代码。 关于判定条件，我们应该设计一个代码用于比较 a^m 和 N 的大小关系。 在我们代码中： 1234if (pd(mid)) r = mid;else l = mid; pd 成功的情况，一定是 pd 的 mid 符合条件，且小于 mid 的一定符合条件。因此我们要在大于 mid 中继续查找，找到更大的 mid。 所以我们可以设计出如下判定条件: 12345678910111213double pd(double a,int m)&#123; double c=1; while(m&gt;0) &#123; c=c*a; m--; &#125; if(c&gt;=n) return true; else return false;&#125; 代码解答C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;iomanip&gt; //用于浮点数输出using namespace std;double n,l,r,mid;double eps=1e-8;bool pd(double a,int m)&#123; double c=1; while(m&gt;0) &#123; c=c*a; m--; &#125; if(c&gt;=n) return true; else return false;&#125;int main()&#123; int m; cin&gt;&gt;n&gt;&gt;m;//设置二分边界 l=0,r=n;//实数二分 while (l + eps &lt; r) &#123; double mid = (l + r) / 2; if (pd(mid,m)) r = mid; else l = mid; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l; //一般使用print //printf(&quot;%x.yf&quot;,n) //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0 //y是保留小数位数，不够补零 //printf(&quot;%.7f&quot;,l); return 0;&#125; 查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。 Python 实现 Java 实现 实验总结二分的题目主要是必须要求是单调的，一般会有条件等字眼。做这种题目主要还是找到递增或者递减的序列，然后关于序列的判定条件。或者通过观察时间复杂度来看是否可以使用二分，二分法的题目相对来说比较明显，设计起来也比较简单，模板不用死记硬背，理解一下，很快就可以独立写出来。 贪心算法贪心算法（Greedy algorithm），又称贪婪算法。是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而使得问题得到全局最优解。 贪心的算法的设计就是要遵循某种规则，不断地选取当前最优解的算法设计方法。这节实验将会通过多个问题的来讲解贪心算法。 知识点 贪心算法的基本概念 贪心算法的适用范围 贪心算法的设计步骤 贪心算法的题目讲解 贪心算法基本概念贪心算法与枚举法的不同之处在于每个子问题都选择最优的情况，然后向下继续进行，且不能回溯，枚举法是将所有情况都考虑然后选出最优的情况。 贪心算法，在对问题求解时，不从整体考虑，而是采用一叶障目的选择方式，只选择某种意义上的局部最优解。并且，贪心算法是没有固定的模板可以遵循的，每个题目都有不同的贪心策略，所以算法设计的关键就是贪心策略的选择。 贪心算法有一个必须要注意的事情。贪心算法对于问题的要求是，所有的选择必须是无后效性的，即当前的选择，不能影响后续选择对于结果的影响。 贪心算法主要适用于最优化问题，如：MST 问题。有时候贪心算法并不能得到最优答案，但是能得到精确答案的近似答案。有时可以辅助其他算法得到不是那么精确的结果。 适用范围符合贪心策略： 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。 所谓的贪心选择性质就是，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。 或者说是无后效性，如果该问题的每一步选择都对后续的选择没有影响，就可以是应用贪心算法。 贪心算法的设计步骤按照定义设计： 证明原问题的最优解之一可以由贪心选择得到。 将最优化问题转化为这样一个问题，即先做出选择，再解决剩下的一个子问题。 对每一子问题一一求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解 伪代码： 关于 Question Q： 1234567while(Q.hasNextStep)&#123; Select(Q.nowBestSelect); Q.NextStep&#125;Select(Q.nowBestSelect); 贪心相关题目讲解我们在正式将题目前，聊一个大家都懂的常见的知识，也是一个常见的题目。 找零问题题目如下： 12345假设商店老板需要找零 n 元钱。钱币的面额有：100 元、50 元、20 元、5 元、1 元、如何找零使得所需钱币的数量最少？注意：n 可能为 0，也能为几百元（别问，问就是来着里微信提现来了） 输入: 123456789输入解法:在第一行给出测试例个数 N。代表需要找零的钱数。输入样例：365 输出： 1234567891011输出解法 有 5 行输出数据，每一行输出数据输出找零的金额与数量，详情看样例。输出样例：100:350:120:05:31:0 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 关于这个题，如果是正常人都知道从大的钱开始找钱。这就是一种贪心的思想，将大问题转化为一个个小的子问题，每次选择最大的钱数使得总量最小。 其实再生活中贪心思想的例子还有很多，像是“自助餐“这种的都是贪心算法的印证。贪心算法其实离我们很近，掌握不会很困难的。 我们先看一下上一道题目的代码题解是什么。 答案解析： C++ 解法： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;//面值int t[5]=&#123;100, 50, 20, 5, 1&#125;;//张数int m[5];void change(int n)&#123; for(int i=0;i&lt;5;i++) &#123; m[i]=n/t[i]; n=n%t[i]; //print(&quot;%d&quot;,n); &#125;&#125;int main()&#123; int N; cin&gt;&gt;N; change(N); for(int i=0;i&lt;5;i++) &#123; printf(&quot;%d:%d\\n&quot;,t[i],m[i]); &#125;&#125; Python 解法 Java 解法 活动选择型问题之小 B 的宿舍题目如下: 123456789101112131415161718192021小 B 的宿舍楼沿着走廊南北向的两边各有 200 个房间。如图所示：[房间1][房间3][房间5][房间7][房间9 ]...[房间399]---------------------------------------------- 走廊----------------------------------------------[房间2][房间4][房间6][房间8][房间10]...[房间400]最近，由于转专业和专业分流的原因，宿舍将迎来新的调整，以便组成新的班级后方便管理。但是由于走廊狭窄，走廊里只能通过两个搬运的物品（可以同向也可以反向），因此必须指定高效的搬运计划。老师给了每位同学下达了以下要求，让同学们体现收拾好行李，然后给每位同学 10 分钟的时间搬运。当房间 i 搬运行李到 j 时，i 与 j 之间的走廊都会被占用，但是可以容纳两个不同同学同时搬运。所以，10 分钟之内同一段走廊最多两个人同时搬运，不重叠的走廊也可以同时搬运。小 B 的老师是个数学老师，经过运筹学一通计算他得到了最优的搬运计划。虽然计划不唯一，但是最优值唯一，请问这个最短时间是多少？ 输入: 123456789101112131415161718192021输入解法:输入数据有 T 组测试例，在第一行给出测试例个数 T。每个测试例的第一行是一个整数 N（1≤N≤200)，表示要搬运行李的人数。接下来 N 行，每行两个正整数 s 和 t，表示一个人，将行李是从房间号码 s 移到到房间号码 t。输入样例:3410 2030 4050 6070 8021 32 200310 10020 8030 50 输出： 123456789输出解法 每组输入都有一行输出数据，为一整数 T，表示完成任务所花费的最小时间。输出样例:101020 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 该题属于贪心算法，因为它尽可能使搬运行李同时进行，以便使单独安排的搬运次数最少。这样用的时间最少，即所用最少时间为不能同时搬运行李的次数，进而转化为寻找某一段走廊使用次数最多（贪心标准），由于走廊可以同行 2 人，所以除 2，有余数再加 1 即可，即使最多的搬运次数，再乘以 10，即为最少搬运时间。 首先将二维问题转化成一维问题。 不难发现，相对应的两个房间其实是占用一段走廊的，我们可以将将房间号映射为走廊号，然后再考虑上面的解析。 答案解析： C++ 解法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int move[200];//搬运次数 int N;//每次搬运的起点和终点 int from, to; int maxAns=0; int T; cin&gt;&gt;T; while(T--) &#123; scanf(&quot;%d&quot;, &amp;N); memset(move, 0, sizeof(move)); for(int i = 0; i &lt; N; i++) &#123; scanf(&quot;%d%d&quot;, &amp;from, &amp;to);//将房间号映射为走廊号 from = (from - 1)/2; to = (to - 1)/2;//确保from&lt;to，C++使用：swap(from, to) if(from &gt; to) &#123; int temp = from; from = to; to = temp; &#125;//统计占用走廊情况，并统计最大值 for(int j = from; j &lt;= to; j++) &#123; move[j]++; maxAns=max(maxAns,move[j]); &#125; &#125; if(maxAns%2==1) maxAns=maxAns/2+1; else maxAns&gt;&gt;=1; //等价于/2 cout&lt;&lt;maxAns*10&lt;&lt;endl; &#125;&#125; Python 解法 Java 解法 可拆分背包问题之贪心的自助餐题目如下: 123456789101112131415161718192021222324小 B 同学呢，想去吃自助餐，但是他是那种比较节俭的的人，既不想浪费食物，又想尽可能吃的贵一点，他于是私下里做了调查。小蓝餐厅的自助餐有 n 种食材，每种食材都有它的价格。而且也能估计出每一份的重量，所以他列了一个表格。红烧牛肉 30元 300g油闷大虾 8元 5g四喜丸子 4元 8g三文鱼 5元 3g排骨 18元 200g麻辣兔头 20元 120g高汤海参 40元 70g扇贝粉丝 8元 32g牛排 79元 240g...现在小 B 想知道在他到底最多吃多少钱的菜品。假设自助餐厅的菜品供应同样的菜品每个人只能取一份。小B的饭量假设为 C，单位为 g。现在请你设计一个程序帮助小 B 计算他的最多吃了多少钱。 输入: 1234567891011121314151617181920212223242526272829303132333435输入解法第一行输入 n C（0&lt;=n&lt;=1000）（0&lt;=C&lt;=10000）其中 n 为菜品数量，C 为小 B 的肚子容量。第二行输入两个数 V，W 第一个数 V[i] 是第 i 个菜品的价值（0&lt;=v[i]&lt;=10000） 第二个数 V[i] 是第 i 个菜品的质量（0&lt;=w[i]&lt;=10000）输入样例:20 10001 222 43123 21412 2123 43221 22322 1677 4934 7834 943 67721 3423 2312 56332 5621 99123 545389 3312 99923 88 输出： 1234567输出解法 输出一行数据，表示最大的价值，保留三位小数。输出样例：1204.114 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 可拆分背包的一般解法为： 这里有 n 种不同值 v[i] 和权重 w[i] 的对象（如果选择该对象的 w[i] 可以获得值 v[i]）。 你有一个容器来挑选它们。你可以根据自己的需要把它们分成任意大小的碎片。可以拾取的对象的最大重量给定为 w。请计算您能得到的最大值。 就像是这个题目，要想吃回本就要捡着贵的吃，但是贵只是一方面，人会饱，所以用价格除以质量所获的价格商才是贪心准则，应按照价格商优先进行选取。 于是这个题，就要用的我们之前学的知识了。这里因为要整体排序，所以要先创建一个类，然后自定义 cmp 函数，在使用 sort 排序。 答案解析： C++ 解法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;//需要一个结构体，通过性价比，能够查找到重量和价值。//做一个排序，需要将性价比由高到底排序，排序的过程中重量和（价值）要对应上struct Food&#123; double w; double v; double aver;&#125;;//C++一般用 struct，因为默认都是public的bool cmp(Food a, Food b)&#123; return a.aver &gt; b.aver; //助记大于号就是从大到小排序，小于号就是从小到大排序&#125;int main()&#123; Food foods[1009]; int n; double C; double Value = 0; cin &gt;&gt; n &gt;&gt; C; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; foods[i].v&gt;&gt;foods[i].w; //求性价比 foods[i].aver = foods[i].v / foods[i].w; //cout &lt;&lt; foods[i].aver &lt;&lt; endl; &#125; //性价比排序 sort(foods, foods + n, cmp); //当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和 // int sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += foods[i].w; &#125; if (sum &lt;= C) &#123; for (int j = 0; j &lt; n; j++) Value += foods[j].v; //V = floor(V * 1000.0) / 1000.0; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt;Value &lt;&lt; endl; return 0; &#125; //当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品 for (int i = 0; i &lt; n; i++) &#123; if (foods[i].w &lt;= C) &#123; Value =Value + foods[i].v; C = C - foods[i].w; &#125; else &#123; //直接将剩余的C加入即可 Value =Value + C * foods[i].aver; C = 0; &#125; if (C == 0) break; &#125; //V = floor(V * 1000.0) / 1000.0; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt;Value &lt;&lt; endl; return 0;&#125; Python 解法 Java 解法 实验总结贪心算法的最主要的特征就是无后效性，就像是自助餐那个题目，如果说吃了某一样食物，就不能吃另一个食物了，那么这就有了后效性，那就不能使用贪心算法进行解决问题了。 本节课举了三个贪心算法的例子进行讲解，贪心算法是算法竞赛中最入门的算法。没接触过感觉很深奥，接触过了也就那样，简单的贪心伸伸手就可以写出来，其实非常简单，大家也不要过分的担心。 蓝桥杯真题精讲之一在前面实验中，我们为了快速提高对每一个实验的知识点快速理解，所做的实战题目都是使用对应知识点解答的题目，导致题目知识点或者说用到的算法比较单一，实战意义还不充足。 本节实验主要是融汇贯穿前面我们学习过的知识点，通过 4 道蓝桥杯真题进行实战讲解，带领大家学以致用。 知识点 2020 年蓝桥杯国赛真题–答疑 2012 年蓝桥杯省赛真题–鲁卡斯队列 2015 年蓝桥杯模拟真题–金币 最大化股票交易的利润 答疑本题出自于 2020 年蓝桥杯国赛真题。 题目链接 题目描述123456789101112有 n 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。 一位同学答疑的过程如下： 首先进入办公室，编号为 i的同学需要 si 毫秒的时间。 然后同学问问题老师解答，编号为 i 的同学需要 ai 毫秒的时间。 答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可 以忽略。 最后同学收拾东西离开办公室，需要 ei 毫秒的时间。一般需要 10 秒、20 秒或 30 秒，即 ei 取值为 1000，20000 或 30000。一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群 里面发消息的时刻之和最小。 输入1234567891011121314输入描述:输入第一行包含一个整数 n，表示同学的数量。接下来 n 行，描述每位同学的时间。其中第 i 行包含三个整数 si, ai, ei，意义如上所述。其中有 ，1≤n≤1000，1≤si≤60000，1≤ai≤106，ei∈10000,20000,30000。即 ei 一定是 10000、20000、30000之一。输入样例:310000 10000 1000020000 50000 2000030000 20000 30000 输出1234567输出描述:输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。输出样例:280000 运行限制12最大运行时间：1s最大运行内存: 128M 题目解析本题是一个贪心问题，要想使得所有的时刻之和最小，就要使得每一个时刻尽可能少，根据题目我们可以得到每位同学的时刻=每位同学的等待时间+进门时间+答疑时间。 由于答疑时间是已知的，要使得每位同学的时刻最小，那么就要使得每位同学的等待时间最小。如何使得等待时间最小的呢？ 如果这么考虑这道题是做不出来的，我们应该考虑的是使得每位同学等待的时间和最小。 123每位同学的时刻 = 每位同学的等待时间 + 进门时间 + 答疑时间 = 前一位同学的等待时间 + 前一位同学的进门时间 + 前一位同学的答疑时间 + 前一位同学的收拾东西的时间 + 进门时间 + 答疑时间 设第 i 位同学的等待时间为 Ti，则有： 第一位同学等待时间 S1=T1=0 —–（1） 第二位同学等待时间 S2=T1+T2=T2 —–（2） 第三位同学等待时间 S3=T1+T2+T3=T2+T3 —–（3） … 那么第 N 位同学等待时间 Sn=T1+T2+T3+T4+T5+…+Tn-1 —–（n） 将 1 到 n-1 式带入 n 式得， 1Sn=T1*n+T2\\*(n-1)+T3\\*(n-1)+....+Tn 由此可知前面的系数是最大的，所以要使前面的时间最小，于是得出了贪心策略进而解决问题。 使用贪心算法后，我们可以得出结论是，每位同学的等待时间（前一位同学的等待时间 + 前一位同学的进门时间 + 答疑时间 + 前一位同学的收拾东西的时间）最小。 但是如果相同的时候，两者前后关系是什么？ 因为是答疑结束后就发消息，而不是出门之后发消息，所以两者存在前后关系，谁先答疑结束谁就先执行。 我们还要进一步考虑，如果进门时间+答疑时间相同，即答疑同时结束，既然答疑同时结束，那么谁先谁后结果是相同的，所以不用继续考虑，到此，贪心策略完整的生成。 即：我们选取最小的进门时间+答疑时间+收拾东西时间之和最小的人在前，且当进门时间 + 答疑时间 + 收拾东西时间的和相同时，选择最小的进门时间 + 答疑时间。 答案解析C++ 描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;struct Stu&#123; int inD; //进门所需时间 int answQ; //答疑所需时间 int outD; //收拾东西所需时间 int sum1; //贪心准则1=进门时间+答疑时间+收拾东西时间 int sum2; //贪心准则2=进门时间+答疑时间+收拾东西时间&#125; stu[N];//贪心准则bool cmp(Stu st1, Stu st2)&#123; if(st1.sum1 != st2.sum1) return st1.sum1 &lt; st2.sum1; else return st1.sum2 &lt; st2.sum2;&#125;int main()&#123; //输入数据 scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i ++ ) &#123; scanf(&quot;%d%d%d&quot;, &amp;stu[i].inD, &amp;stu[i].answQ, &amp;stu[i].outD); //标准生成 stu[i].sum1= stu[i].inD + stu[i].answQ+stu[i].outD; stu[i].sum2 = stu[i].inD + stu[i].answQ; &#125; //贪心过程及结果计算 sort(stu, stu + n, cmp); long long res = 0, t = 0; for(int i = 0; i &lt; n; i ++ ) &#123; t += stu[i].sum2; res += t; t += stu[i].outD; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; Python 描述 Java 描述 鲁卡斯队列本题出自 2012 年蓝桥杯省赛真题。 题目链接 题目描述: 123456789101112131415本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。黄金分割数 0.618 与美学有重要的关系。舞台上报幕员所站的位置大约就是舞台宽度的 0.618 处，墙上的画像一般也挂在房间高度的 0.618 处，甚至股票的波动据说也能找到 0.618 的影子....黄金分割数是个无理数，也就是无法表示为两个整数的比值。0.618 只是它的近似值，其真值可以通过对 5 开方减去 1 再除以 2 来获得，我们取它的一个较精确的近似值：0.618034 。有趣的是，一些简单的数列中也会包含这个无理数，这很令数学家震惊！1 3 4 7 11 18 29 47.... 称为“鲁卡斯队列”。它后面的每一个项都是前边两项的和。如果观察前后两项的比值，即：1\\3 3\\4 4\\7 7\\11 11\\18...会发现它越来越接近于黄金分割数！你的任务就是计算出从哪一项开始，这个比值四舍五入后已经达到了与 0.618034 一致的精度。请写出该比值。格式是：分子/分母。比如：29/47。 输入: 1234567输入描述:无输入样例:无 输出： 1234567输出描述:输出一个整数，表示该比值。格式是：分子/分母。比如：29/4729/4729/47。输出样例:无 运行限制: 12最大运行时间：1s最大运行内存: 128M 题目解析： 这道题是基于前缀和的模拟题，我们按照要求进行模拟即可。 答案解析： C++ 描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;double a[51] = &#123; 1,3 &#125;;void init()&#123; for (int i = 2; i &lt; 50; i++) &#123; a[i] = a[i - 1] + a[i - 2]; &#125;&#125;string comp()&#123; for (int i = 0; i &lt; 50; i++) &#123; double b = a[i] / a[i + 1]; if (abs(b - 0.618034) &lt;= 0.000001) &#123; stringstream s1; s1 &lt;&lt; a[i] &lt;&lt; &quot;/&quot; &lt;&lt; a[i + 1]; string s; s1&gt;&gt;s; return s; &#125; &#125;&#125;int main()&#123; init(); string ans=comp(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; stringstream 类： 这里给出的 C++ 代码描述，会写的相对繁琐一些，目的是为了给大家讲一种新的字符串使用技巧。C++ stringstream 类是一种十分有用的类，特别是当我们需要在程序中使用字符串和数字数据互相转换的时候。 要想在程序中使用 stringstream 类，我们需要在源程序文件中包含头文件include&lt;sstream&gt;。 stringstream 对象的使用方法与 cout 对象和 cin 的使用方法基本相同。&gt;&gt; 这个符号就很形象，比如： cin&gt;&gt;a 可以理解为将数据流流入到 a 中 cout&lt;&lt;a 则是将数据流流入到 cout 中，归根结底还是数据流 可能对于底层的描述不太恰当，但是大家记住 &gt;&gt; 指向谁，则是将数据给到谁，stringstream 当成 cin cout 用即可。在我上面给出的代码中，大家可以看到我还将数据还进行了转化处理，在 C++ 中数据类型的转化使用 stringstream 也是不错的选择。 Python 描述 Java 描述 金币本题出自 2015 年蓝桥杯模拟真题。 题目链接 题目描述: 12345678910111213国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币......；这种工资发放模式会一直这样延续下去：当连续 N 天每天收到 N 枚金币后，骑士会在之后的连续 N+1 天里，每天收到 N+1 枚金币。请计算在前 K 天里，骑士一共获得了多少金币。 输入: 1234567输入描述:输入只有 1 行，包含一个正整数 K （1≤K≤104），表示发放金币的天数。输入样例:6 输出： 1234567输出描述:输出只有 1 行，包含一个正整数，即骑士收到的金币数。输出样例:1000 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 这道题是前缀和的变种，变种的方式可以通过模拟解决，时间复杂度为 O(N2)，但是题目的范围为 1e4，不超时方法可行。 答案解析C++ 描述： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int comp(int n)&#123; int sum = 0; int day = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; sum += i; day += 1; if (day == n) return sum; &#125; &#125; return sum;&#125;int main()&#123; int n; cin&gt;&gt;n; int ans=comp(n); cout&lt;&lt;ans;&#125; Python 描述 Java 描述 最大化股票交易的利润本题是来自蓝桥云课题库中的模拟题。 -题目链接 题目描述: 1234567实现一个算法寻找最大化股票交易利润的策略。介绍如下：- 股票价格每天都在变化，以数组的索引表示交易日，以数组的元素表示每天的股票价格。- 可以通过买入和卖出获得利润。一天只能进行一次买入或卖出操作，一次买入加卖出操作称为一次交易次数。- 你只能交易一次，求使得利润最大的交易策略。 输入: 123456789101112输入描述:第一行为数字 N，表示共有 N 天。第二行为 N 个数字 Ai，表示每天的股票价格。其中，1≤N,Ai≤1e4。输入样例:82 5 6 1 4 3 1 3 输出： 1234567输出描述:输出一行，为交易一次的最大利润（有可能利润为负）。输出样例:4 运行限制: 12最大运行时间：1s最大运行内存: 128M 题目解析： 这个题目是个模拟题目，按照题目要求即可。 这个题目获得最大利润的方式，就是存在 A，B 两天，A 在 B 前一天，使得 B—A 的值最大。 答案解析： C++ 描述 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int a[100005]; int n; cin&gt;&gt;n; int mini=-0x3f3f3f3f;//一个常用的极小值 for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0; i&lt;n-1; i++) &#123; for(int j=i+1; j&lt;n; j++) &#123; int t=a[j]-a[i]; if(mini&lt;t) &#123; mini=t; &#125; &#125; &#125; cout&lt;&lt;mini; return 0;&#125; Python 描述 Java 描述 实验总结我们复习了之前的讲的几个知识点，然后我们又讲了几道题目，希望大家能够发散思维，不要局限方式方法，能做出来即可。 蓝桥杯真题精讲之二实验介绍本节实验，我们将延续上一节实验的真题精讲，继续继续分析蓝桥杯真题，通过精讲，让大家对学过的知识点达到学以致用。 知识点 2021 年蓝桥杯模拟赛真题-谈判 优先队列 2008 年 NOIP 普及组真题-排座椅 谈判题目链接 题目描述: 1234567题目描述在很久很久以前，有 n 个部落居住在平原上，依次编号为 1 到 n。第 i 个部落的人数为 ti。有一年发生了灾荒。年轻的政治家小蓝想要说服所有部落一同应对灾荒，他能通过谈判来说服部落进行联合。每次谈判，小蓝只能邀请两个部落参加，花费的金币数量为两个部落的人数之和，谈判的效果是两个部落联合成一个部落（人数为原来两个部落的人数之和）。 输入: 12345输入的第一行包含一个整数 nnn，表示部落的数量。第二行包含 nnn 个正整数，依次表示每个部落的人数。其中，1≤n≤1000，1≤ti≤1e4。 输出： 1输出一个整数，表示最小花费。 输入输出样例 123456789示例 1输入49 1 3 5输出31 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 这题是一个贪心问题，要想使得花费金额之和最小，就要使得每一次的花费尽可能少。 根据题目我们可以得到，合成的新部落的花费=人数为原来两个部落的人数之和。 如何使得等待时间最小的呢？ 如果这么考虑这道题是做不出来的，应该考虑的是使得每位同学等待的时间和最小。我们回忆一下答疑拿到题目： 12345678910111213141516171819第一位同学等待时间 S1=T1=0 -----（1）第二位同学等待时间 S2=T1+T2=T2 -----（2）第三位同学等待时间 S3=T1+T2+T3=T2+T3 -----（3）......第 N 位同学等待时间 Sn=T1+T2+T3+T4+T5+...+Tn-1 -----（n）将 1 到 n-1 式带入 n 式得Sn=T1*n+T2\\*(n-1)+T3\\*(n-1)+....+Tn由此可知前面的系数是最大的，所以要使前面的时间最小。于是得出了贪心策略进而解决问题。此时贪心的除了结论是每位同学的等待时间(前一位同学的等待时间+前一位同学的进门时间+答疑时间+前一位同学的收拾东西的时间)最小。 这道题目还是按照人数排序吗，然而不是这样的，我们看一组样例： 1234567891011121314151617181920212223242526272829303132333435363743 4 5 6如果按照顺序组合的话：3+4=77 5 67+5=1414 614+6=20最终花费：7+14+20=41其实答案应该是：3 4 5 63+4=77 5 6再次排序5 6 75+6=1111 711+7=18最终花费为 7+11+18=36 所以这里贪心原则是维护最小的值，但是每次都会进行更新，每次更新后就要重新排序，时间复杂度是 Nlog(n) 的复杂度，这里是可以通过的，当然我们也可以使用优先队列解题。 优先队列的使用方式跟队列是一模一样的，优先队列会自动进行排序而已。 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出（first in, largest out）的行为特征。通常采用堆数据结构来实现。 C++中的优先队列： 首先要包含头文件 #include&lt;queue&gt;，他和 queue 不同的就在于我们可以自定义其中数据的优先级，让优先级高的排在队列前面，优先出队。 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 常用的成员函数: top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 队列的定义有两种： 1234//升序队列，小顶堆priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列，大顶堆priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q; Python 优先队列 Java 优先队列 简单排序答案这个题我们会采取两种解题策略，一种是简单的多次排序，另一种就是上面讲的优先队列。 C++ 描述： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int cnt=0,k; vector&lt;int&gt; t; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;k; t.push_back(k); &#125; while(t.size()&gt;1) &#123; //排序 sort(t.begin(),t.end()); //取出前两个值 int k=t[0]+t[1]; //答案求和 cnt+=k; //删除前两个利用过的值 t.erase(t.begin()); t.erase(t.begin()); //将产生的新值加入集合 t.push_back(k); &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; Python 描述 Java 描述 优先队列答案C++ 描述： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int n,cnt=0; priority_queue&lt;int&gt;pq; //默认是大顶堆，从大到小排序 cin&gt;&gt;n; for(int i=0; i&lt;n; ++i) &#123; int a; cin&gt;&gt;a; pq.push(-a); //存入负值，从小大排序 &#125; if(pq.size()==1) &#123; cout&lt;&lt;-pq.top(); &#125; else &#123; while(pq.size()!=1) &#123; int x=pq.top(); pq.pop(); int y=pq.top(); pq.pop(); pq.push(x+y); cnt+=-x-y; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125; Python 描述 Java 描述 这道题的做法，变成了一种数据结构叫做哈夫曼树，后面的课程我们会讲到。 排座椅题目链接 题目描述: 123456789上课的时候总有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 D 对同学上课时会交头接耳。同学们在教室中坐成了 M 行 N 列，坐在第 i 行第 j 列的同学的位置是（i，j），为了方便同学们进出，在教室中设置了 K 条横向的通道，L 条纵向的通道。于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了两个会交头接耳的同学，那么他们就不会交头接耳了。请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生对数最少。 输入: 12345输入第一行，有 5 各用空格隔开的整数，分别是 M，N，K，L，D（2≤N，M≤1000，0≤K&lt;M，0≤L&lt;N，D≤2000）。接下来 D 行，每行有 4 个用空格隔开的整数，第 i 行的 4 个整数 Xi，Yi，Pi，Qi，表示坐在位置 (Xi,Yi)与 (Pi,Qi) 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。输入数据保证最优方案的唯一性。 输出： 12345输出共两行。第一行包含 K 个整数，a1,a2,⋯aK，表示第 a1a_1a1 行和 a1+1a_1+1a1+1 行之间、第 a2 行和第 a2+1行之间、…、第 aK 行和第 aK+1 行之间要开辟通道，其中 ai&lt;ai+1，每两个整数之间用空格隔开（行尾没有空格）。第二行包含 L 个整数，b1,b2,⋯bk，表示第 b1 列和 b1+1 列之间、第 b2 列和第 b2+1 列之间、…、第 bL 列和第 bL+1 列之间要开辟通道，其中 bi&lt;bi+1，每两个整数之间用空格隔开（行尾没有空格）。 输入输出样例： 12345678910111213示例 1输入4 5 1 2 34 2 4 32 3 3 32 5 2 4 输出22 4 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 样例说明： 上图中用符号 *、※、+ 标出了 3 对会交头接耳的学生的位置，图中条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。 首先这道题是说前后左右有交头接耳的同学，我们通过设置设置了 K 条横向的通道，L 条纵向的通道使得交头接耳的同学组数最少。 本题的主要算法为贪心，要使上课时交头接耳的学生对数最少，每条通道的划分应该使得分开的交头接耳同学的对数最多。 因此我们可以使用桶排序解决这个问题，通过定义一系列的桶来记录每条通道的交头接耳的学生对数。 关于桶排序的过程： 我们先定义两个数组 x,y。 x[1] 表示如果在第一列与第二列中间划分过道能够分开几组说话的同学，x[2] 则是第二列与第三列… 直到 x[n-1]。 同理，y[1] 表示第一行与第二行，y[2] 表示第二行与第三行，直到 y[m-1]。 如果纵坐标相同，即这两个同学在一列，那么设两个同学横坐标分别为 a,b。 a 和 b 之间一定存在着大小关系，如果 a\\&lt;b 那么根据题目可以知道 a+1=b，那么 a 与 b 之间通道的编号就是 a。 同理,如果横坐标相同，即这两个同学在一行，那么设两个同学纵坐标分别为 a,b。 那么，a 和 b 之间一定存在着大小关系，如果 a\\&lt;b 那么根据题目可以知道 a+1=b，那么 a 与 b 之间通道的编号就是 a。 这样我们就能进行桶排序，并且经过排序过后，就可以在横向通道和纵向通道中找到前 K 和前 L 个即可，最后输出答案。 需要注意的是， 123第一行包含 K 个整数，a1,a2,⋯aK，表示第 a1a_1a1 行和 a1+1a_1+1a1+1 行之间、第 a2 行和第 a2+1 行之间、…、第 aK 行和第 aK+1 行之间要开辟通道，其中 ai&lt;ai+1，每两个整数之间用空格隔开（行尾没有空格）。第二行包含 L 个整数，b1,b2,⋯bk，表示第 b1 列和 b1+1 列之间、第 b2 列和第 b2+1 列之间、…、第 bL 列和第 bL+1 列之间要开辟通道，其中 bi&lt;bi+1，每两个整数之间用空格隔开（行尾没有空格）。 所以输出需划分的通道时，要先将通道按编号由小到大排序后再输出 。 答案解析： C++ 描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;const int MAXN= 1001;int x[MAXN]; //横坐标桶int y[MAXN]; //纵坐标桶int c[MAXN];int o[MAXN]; int main()&#123; int M, N, K, L, D; cin &gt;&gt; M &gt;&gt; N &gt;&gt; K &gt;&gt; L &gt;&gt; D; int xi, yi, pi, qi; while (D--) &#123; cin &gt;&gt; xi &gt;&gt; yi &gt;&gt; pi &gt;&gt; qi; if (xi == pi) //横坐标相同 &#123; y[min(yi, qi)]++; &#125; else //纵坐标相同 &#123; x[min(xi, pi)]++; &#125; &#125; //两重循环找出前K大的横坐标值 for (int i = 1; i &lt;= K; i++) &#123; int maxn = -1; int p; for (int j = 1; j &lt; M; j++) &#123; if (x[j]&gt;maxn) &#123; maxn = x[j]; p = j; &#125; &#125; x[p] = 0; c[p]++; &#125; //两重循环找出前L大的横坐标值 for (int i = 1; i &lt;= L; i++) &#123; int maxn = -1; int p; for (int j = 1; j &lt; N; j++) &#123; if (y[j]&gt;maxn) &#123; maxn = y[j]; p = j; &#125; &#125; y[p] = 0; o[p]++; &#125; for (int i = 0; i&lt;MAXN; i++) &#123; if (c[i]) printf(&quot;%d &quot;, i); &#125; printf(&quot;\\n&quot;); for (int i = 0; i&lt;MAXN; i++) &#123; if (o[i]) printf(&quot;%d &quot;, i); &#125; return 0;&#125; Python 描述 Java 描述 实验总结这节课我们围绕着贪心展开，讲了排序，用到了 Vector、桶排序，可见在真正的竞赛中，像这样各种知识的混着出题，才是常见的。单一知识点出题，我们称作签到题，就是所有人都会做的。当然在蓝桥杯省赛中，能够将前面的知识学会学好，省二是没有问题，想要冲击更高的奖项，基础篇只是打好了基础，后面的课程会带你认识更多的算法，体验算法之美。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zhang0224gz.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"模块一 教育基础知识和基本原理——第一章 教育与教育学","slug":"教资/模块一 教育基础知识和基本原理/第一章 教育与教育学","date":"2022-03-20T12:36:20.872Z","updated":"2022-03-28T15:59:54.830Z","comments":true,"path":"2022/03/20/教资/模块一 教育基础知识和基本原理/第一章 教育与教育学/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/20/%E6%95%99%E8%B5%84/%E6%A8%A1%E5%9D%97%E4%B8%80%20%E6%95%99%E8%82%B2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%99%E8%82%B2%E4%B8%8E%E6%95%99%E8%82%B2%E5%AD%A6/","excerpt":"","text":"教育的含义广义的教育指：凡是增进人们的知识和技能，影响人们的思想和品德的活动，广义的教育包括学校教育、家庭教育和社会教育 狭义的教育指：教育者根据一定的社会或阶级要求，遵循受教育者身心发展的规律，有目的、有计划、有组织地对受教育者身心施加影响，把他们培养成一定社会或阶级需要的人的活动，狭义的教育指“学校教育” 辨析题步骤 1.判断对错 2.分析题干中关键词的含义 3.分析关键词中的逻辑关系（冲突点）并加以分析解释 教育的属性教育的本质属性教育是有目的地培养人的社会活动，是教育区别于其他事物现象的根本特征，是教育的质的规定性 教育的社会属性历史性：古今不同 ； 继承性：古今相同 永恒性：与人类社会共始终； 长期性：十年树木，百年树人 生产性：教育与生产劳动相结合 阶级性：教育要反应社会阶级的内容 教育的相对独立性 教育具有自身的继承关系（独立） 教育要受其他社会意识形态的影响（相对） 教育与政治经济发展不平衡（百家争鸣、文革） 教育的功能教育的个体功能 促进功能：个体社会化和个体化 个体谋生和享用功能 个体发展的负向功能（应试教育） 教育的社会功能 社会流动功能：社会成员通过教育能够在不同的社会区域、层次、岗位、组织之间调动，以充分发挥特长，展现才能，实现抱负 文化传递功能：教育作为培养人的活动，以文化为中介，通过教育者和受教育者的共同活动实现文化传承 社会改造功能：教育是改造社会和推进社会进步的重要手段 人口控制功能：教育对社会人口数量和质量的提高所具有的作用 教育的起源神话起源说 —— 不老神话朱熹（不正确最古老；神话起源说；朱熹） 生物起源说 —— 本能生利息(西)（生存竞争的本能就是教育的基础；生物起源说；利托尔诺和沛西·能） 心理起源说 —— 心理仿孟禄（心理起源说；儿童对成人无意识的模仿；孟禄） 劳动起源说 —— 米凯爱劳动（米丁斯基和凯洛夫；中国认为最科学合理；劳动起源说） 学校产生的条件 社会生产力水平的提高 脑力劳动和体力劳动的分离 国家机器的产生 文字的产生和发展 古代教育发展中国古代教育的发展夏学校，周六艺 战国兴百家，仲舒兴儒术 隋科举，宋理学 四书五经成经典，明代迂腐八股文 科举清末已废除 原始社会：教育和劳动相结合（打猎、生火……） 奴隶社会：夏学校 封建社会：春秋战国开始–&gt;秦大一统 世界古代教育发展古埃及：宫廷学校、职官学校、文士学校 —— 以僧为师、以吏为师 印度：寺院学府 希腊：雅典 —— 政治家和商人；斯巴达 —— 军人和武士 西欧中世纪：教会学校(七艺)、骑士教育和宫廷学校 七艺：文法、修辞、辩证法、算数、几何、天文、音乐 古代的教学思想中国古代教育思想《论语》 孔子及其弟子的言论记录 教育对象：有教无类 教育目的：学而优则仕 教育方法：启发诱导（“不愤不启，不悱不发”，“学而不思则罔，思而不学则殆”） 教育内容：六艺六经 师生关系：尊师爱生 因材施教 《学记》 世界上最早的教育学专著 “教学相长”的教学原则 “启发诱导”的教学原则（“道而弗牵，强而弗抑，开而弗达”） 循序渐进（“学不躐lie等”，”不陵节而施“）–&gt; 遵循学生心理发展水平 长善救失（优点弥补缺点） 藏息相辅（不能死记硬背，要将课堂上老师讲的和自己的理解相结合） 师生关系：师严而道尊 西方古代教育思想 苏格拉底：问答法（产婆术） 柏拉图：“知识即回忆”，《理想国》 亚里士多德：“教育要遵循自然”，《政治学理论》 昆体良：《论演说家的教育》(《雄辩术原理》) –&gt; 西方第一部最早的教育学专著 教育学的产生和发展教育学的独立培根首提出，纽斯来实现，康德首讲授，巴特去规范，杜威来改变 培根首次提出将教育学作为独立的学科 夸的独立大班泛，教学直系巩自力 夸美纽斯认为“教师是太阳底下最光辉的职业”，教育学之父 《大教学论》是教育学走上独立发展道路的标志 《大教学论》 泛智主义、班级授课制 教学原则：直观性、系统性、量力性、巩固性 教育要适应自然 洛克：《教育漫话》，“白板说”，绅士教育 –&gt; 绅士洛克话白板 卢梭：《爱弥儿》，倡导自然教育和儿童本位的教育 康德：教育学作为课程在大学中讲授 斐斯泰洛奇：“教育心理学化” 规范教育学的形成与发展赫的普教传规范，一原则二基础三中心四阶段 赫尔巴特：传统教育学派代表人(应试教育)，现代教育学之父 《普通教育学》 《普通教育学》标志着规范教育学的建立 一原则二基础三中心四阶段 教育性教学原则 建立在心理学和伦理学基础上 以教师、教材、课堂三中心 明了、联想、系统、方法(巩固) 杜威： 《民主主义与教育》(素质教育) 新三中心：学生/儿童、经验、活动 教育的本质：教育即生活…… 教育原则：在做中学（实践出真知） 教育学在当代的新发展姆有掌握目标，纳来发现结构，瓦根找范例，高度赞发展，巴班最优化，全面和谐是斯基 苏联 赞可夫 “高难度，高速度”教学 赞可夫 《教育与发展》以一般发展为出发点 美国 布卢姆 掌握学习理论 《教育目标分类学》 教学目标：认识、情感和动作机能 布鲁纳 发现学习理论(心理学) 结构主义教学理论 《教育过程》 苏霍姆林 全面和谐的教育思想 著作被称为活的教育学 瓦根·舍因 范例教学理论 巴班斯基 《教学过程最优化》 马克思主义教育学 克鲁普斯卡娅：《国民教育和民主主义》是世界上第一位运用马克思主义观点探讨教育问题的教育家 加里宁：《论共产主义教育和教学》“教师是人类灵魂的工程师” 马卡连柯：《论共产主义教育》、《教育诗》(集体主义教育思想) 凯洛夫：《教育学》世界公认的第一部马克思主义的教育专著，也是我国首次采用的教育学用书；劳动起源说 中国近代教育家的思想 蔡元培：提倡美育(“以美育代宗教”) 陶行知：教学做合一 杨贤江：《新教育大纲》我国第一部用马克思主义观点分析教育问题的著作 《国民教育和民主主义》是世界；《新教育大纲》是中国","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"教育知识与能力","slug":"教育知识与能力","permalink":"https://zhang0224gz.github.io/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/"}]},{"title":"《计算机网络》——第一章 概述","slug":"笔记/计算机网络/第一章 概述","date":"2022-03-07T14:44:31.675Z","updated":"2022-04-03T06:15:11.501Z","comments":true,"path":"2022/03/07/笔记/计算机网络/第一章 概述/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/07/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/","excerpt":"","text":"21世纪的重要特征：数字化、网络化、信息化；21世纪是一个以网络为核心的信息时代。 三大类网络：电信网络、有线电视网络、计算机网络 Internet中文译名：因特网、互联网(Internet是由数量极大的各种计算机网络互联起来的) 互联网的基本特点：连通性和共享 “互联网+”是一种新的经济形态：互联网+各个传统行业 负面影响：计算机病毒、恶意攻击 互联网概述-&gt; 计算机网络、互联网、主机计算机网络(简称网络)是由若干**节点(node)和连接这些节点的链路(link)**组成 把分布在不同地理位置的独立自主的计算机系统用通信线路连接起来。在通行协议控制下实现资源共享的新型计算机系统 组成：若干主机、一个通信子网、一系列协议 互联网(网络的网络network of network)有多个网络通过一些路由器相互连接起来，构成一个覆盖范围更大的计算机网络，即将原本孤立的网络联结起来 主机(host)是与网络相连的计算机 –&gt; 边缘部分，给用户提供服务(终端：使用服务，像手机) 网络把许多计算机连接在一起，而互联网则把许多网络通过一些路由器(路由器是特殊的计算机，但它不是主机)连接在一起。 主机在边缘部分是为用户进行信息处理的，和其他主机通过网络交换信息；路由器是用来转发分组，即进行分组交换的 互联网基础结构三个发展阶段-&gt; internet/Internet、ISP 单个网络ARPANET(美国DOD国防部)同互联网发展的过程 internet互连网是一个通用名词，泛指由多个计算机网络互联而成的计算机网络。通行协议是任意的。 Internet互联网/因特网是一个专用名词，指当前全球最大、最开放的、由众多网络相互连接而成的特定互连网。通行协议是TCP/IP协议族，其前身是美国ARPANET 建成三级结构的互联网：主干网、地区网、校园网/企业网 全球范围的多层次ISP结构的互联网 ISP互联网服务提供商(Internet Service Provider)，如中国电信、联通、移动，从互联网管理机构申请到许多IP地址，且拥有通信线路以及路由器等连网设备。用户需向ISP缴纳费用租用IP地址进行上网。 IXP互联网交换点(Internet eXchange Point)，为更快的转发分组和高效利用网络资源 WWW万维网(World Wide Web)，方便广大非网络专业人员对网络的使用 互联网的标准化工作互联网在指定其标准的最大特点是面向公众，所有标准都是以RFC的形式在互联网上发表 RFC请求评论(Request For Comments) 工程部和学术部通过收集对协议的评论 –&gt; 标准 -&gt; RFC互联网的组成-&gt; 边缘部分(客户-服务器方式、P2P) 边缘部分 ：由所有连接在互联网上的主机组成，用户直接使用/接触的(向用户提供服务的)，用来进行通信和资源共享 计算机通信是计算机中的进程(即运行着的程序)之间的通信。计算机网络采用的通信方式是客户-服务器方式、P2P （1）客户-服务器方式 服务器被动等待，客户主动发出任务(正常) 客户是服务器请求方，服务器是服务提供方。服务器请求方和服务提供方都要使用网络核心部分所提供的服务。 例子：发邮件、网上查资料 以上所说的客户和服务器本来都指的是计算机进程(软件) 使用计算机的人是计算机的“用户”(user) 运行客户程序的机器称为client(客户机/客户端)，运行服务器程序的机器称为server(服务器/服务器端) （2）对等连接方式peer-to-peer 两台主机在通信时，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件(P2P软件)，就可以进行平等的对等连接通信，双方都可以下载对方已经存储在硬盘中的共享文档。 P2P引起的版权问题：P2P服务器并不会储存和提供资源，它只会保存一个索引index用来找到拥有该资源的人。用户通过下载P2P软件，在服务器的指引下找到真正拥有资源的人来获取资料 -&gt; 核心部分(电路交换、报文交换、分组交换) 核心部分 ：由大量网络和连接这些网络的路由器组成，是为边缘部分提供服务服务的(提供连通性和交换) 网络核心部分起特殊作用的是路由器，它是一种专用计算机(不叫主机)，是实现分组交换的关键构件，其任务是转发收到的分组(核心部分重要功能)。 (1)电路交换 双方接通形成一条专用的物理通路，不使用挂断归还给予他人使用。 电路交换：建立连接(占用通信资源) –&gt; 通话(一直占用通信资源) –&gt; 释放连接(归还通信资源) 特点：独占性、语音服务、线路使用效率较低(2人一说&lt;50%) (2)报文交换 按序 (3)分组交换 分组独立发，先发不一定先到 以观看电影为例，我们发出看电影的请求，服务器会将电影的数据(很大)切割成一小块一小块块(分组)再放进链路中，数据被路由器接受并选择合适的路再继续发送下去，最终将数据全部放送到用户手机(终端)中。 所以有一个现象：加载中的转圈(等待序号)，既是分发数据的延时，也是数据在路上开了小差(只有按先后序排列回原本的大数据才能看电影，且各小块数据送达的时间是随机的)。 开了小差：乱丢错 计算机网络的类别-&gt; WAN,MAN,LAN,PAN 按照网络的作用范围分类 广域网WAN 几十到几千公里(跨国) 城域网MAN 5~50km(城市) 局域网LAN 1km(学校、企业) 个人区域网PAN 10m 微微网 蓝牙 按照网络的使用者分类 公共网 电信公司建造的大型网络，日常使用的网络 专用网 部门 用来把用户接入到互联网的网络 接入网AN(Access Network)本地接入网/居民接入网 计算机网络的性能-&gt; 性能指标(速率、带宽、吞吐量、时延)性能指标 速率(数据率、比特率) –&gt; 网络技术中指数据的传输速率 比特：信息论中使用的信息量的单位(二进制数字的0或1) 速率单位：bit/s(bps) , B/s k = 1000 (k千, M兆, G吉, T太, P拍, E艾, Z泽, Y尧) 现实生活中提到网络的速率，往往指的是额定速率或标称速率，并不是网络上实际运行的速率 带宽 –&gt; 计算机网络中表示网络中某通道传送数据的能力(时域称谓) 网络带宽指单位时间内数字信道所能传送的“最高数据率” 带宽单位：bit/s 某个信号具有的频带宽度(例广播)，即该信号所包含的各种不同频率成分所占据的频率范围(带宽=高频-低频)，单位是赫(频域称谓) 吞吐量 –&gt; 单位时间内通过某个网络的实际数据量 吞吐量受网络的带宽或网络的额定速率的限制，且取决于实际情况 例一：额定速率为100 Gbit/s，是吞吐量的绝对上限值，实际吞吐量可能&lt;=100 Mbit/s 例二：主机A和服务器B接入互联网的链路速率为100Mbit/s和 1Gbit/s，但主机A只能从服务器A那最大接收自己的速率100Mbit/s。若100个用户连接到服务器B，则服务器B的链路容量将被用户平分成每人10Mbit/s的带宽。这是主机A连接到服务器B的吞吐量只有10Mbit/s。 当互联网某处发生严重堵塞，主机A接收不到服务器B发来的数据，吞吐量降为0。 故日常交的宽带费用只保证某个路由器之间的数据传输速率，进入互联网之后就取决于互联网的流量分布(用户无法控制) 时延 latency （1）发送时延/传输时延 –&gt;机器内部的发送器(网络适配器) 数据块长度：观看电影1GB ； 发送速率：每次传多少数据 （2）传播时延 –&gt;机器外部 从一个节点到另一个节点 信道长度：数据传输的距离 ； 电磁波在信道上的传播速率：定值，依所用介质而定 （3）处理时延 –&gt; 主机/路由器收到分组要分析首部、提取数据部分、进行差错检验或查找转发表 （4）排队时延 –&gt; 路由器内部分组排队等待处理和在接口等待转发 利用率(信道利用率和网络利用率) 非性能指标费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护 计算机网络的体系结构计算机网络的体系结构定义：计算机网络的各层及其协议的集合 –&gt; 只讲层与层逻辑关系(面)，不讲一层一层实现的细节(点) 实现：计算网络的体系结构就是这个计算机网络及其构件所完成的功能的精确定义。强调的是，这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的实现(implementation)的问题 体系结构是抽象的，而是现实是具体的，是真正在运行的计算机的软件和硬件 ISO和OSI/RMISO：国际标准化组织 International Standard Organization OSI/RM：开放系统互联基本参考模型 Open Systems Interconnection Reference Model 网络协议的组成要素为进行网络中的数据交换而建立的规则、标准或约定成为网络协议，简称协议 语法：结构、格式问题 –&gt; 数据结构 语义：功能问题 –&gt; 实现什么功能 同步：事件发生的先后次序 具有五层协议的体系结构(从下到上) TCP/IP 四层结构 –&gt; 商业标准(真正应用) Application:7,6,5 ; Transport: 4 ; Network: 3 ; Network Access: 2,1 该体系只关心网络的互相连接，并不关心局域网的构建(2,1) OSI模型 –&gt; 学术/国际标准 （1）Physical：规定信号和介质 （2）Data Link：帧、介质的访问控制 （3）Network：路径的选择 （4）Transport：流控，保证可靠性 （5）Session：控制会话 （6）Presentation：通用的数据格式，语法 （7）Application：0,1转化用户可使用的 功能冗余，复杂 具有五层协议的体系结构 –&gt;教科书标准(不存在) 为了能网络的相互连接，并关心局域网(小网)的构建。将TCP/IP 四层结构Application，Transport，Network和OSI模型Data Link，Physical合并成了教科版的五层协议结构。 主机1向主机2发送数据 主机1接收到”今天吃面的消息”从应用层开始从上到下在上一层的基础上进行逐层加密，通过介质传输到另一端再从下到上逐层进行解密将”今天吃面“显示给主机2 一些概念-&gt; 实体、协议 实体：可发送或接受的硬件或软件进程(任务管理器中的皆是软件进程) 协议：控制两个对等实体进行通信的规则的集合 两个对等实体：网络层1-&gt; 网络层2，网络层1 &lt;- 网络层2 ！注意：这只是逻辑通信(水平)，真正的通信是垂直通信(上文) 协议是水平的(对等实体之间的通信规则)，服务是垂直的(能被上一层看见) 在协议的控制下，两个对等实体间的通信使得本层能够为上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。(只看见服务，看不见协议) IP协议支持最强 应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互规则。此进程指主机中正在运行的程序。报文是应用层交互的数据单元。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《应用密码学》——第一章 概述","slug":"笔记/密码学/第一章 概述","date":"2022-03-01T08:50:06.823Z","updated":"2022-03-28T15:52:58.523Z","comments":true,"path":"2022/03/01/笔记/密码学/第一章 概述/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/01/%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1.1 信息安全与密码技术信息安全是目的，密码技术是解决方法 1.2 密码技术发展简介古典密码时期时间：古代–19世纪末 人工，未形成学科，仅能称其为密码术 近代密码时期时间：20世纪初–20世纪50年代左右 自动编码的转轮密码机：德国“艾尼格玛”ENIGMA密码机 现代密码时期时间：1949年–现在 香农的奠基性论文“保密系统的通信理论” 1.3 密码学基本概念密码学的主要任务 机密性：非授权用户不得访问 数据完整性：不允许添加，删除，篡改等 鉴别：消息的来源和本身的真实性 抗抵赖性：已发（先前的通信行为及其相关内容）不可以否认 密码学两方面：密码编码学和密码分析学 密码体制的五大部分 消息空间M，即明文空间 密文空间C 密钥空间K：加密秘钥和解密秘钥 加密算法E 解密算法D 啥啥空间：一个非常大的数据集合 熵：衡量信息的不确定性 max：等概率 例子：算法 Y=aX+b, 秘钥 a,b E(m)=c -&gt; 秘钥,即 f 密码系统的安全性密码攻击者常用方法 穷举（暴力攻击） 统计分析 –&gt; 规律 数学分析攻击 –&gt; 数学模型 攻击类型 攻击者拥有的资源 惟密文攻击 加密算法截获的部分密文 已知明文攻击 加密算法截获的部分密文，和相应的明文 选择明文攻击 加密算法截获的部分密文；加密黑盒子，可加密任意明文得到相应的密文 选择密文攻击 加密算法截获的部分密文；解密黑盒子，可解密任意密文得到相应的明文 当前密码算法只要抵抗住穷举攻击状态下，惟密文攻击的攻击就是成功的 密码算法要求 数据复杂性：计算量 处理复杂性：花费时间 存储复杂性：空间大小 密码算法安全性的因素 密码算法的保密程度 之外的不安全因素（管理程度） 密码算法的保密强度并不等价于密码系统整体的安全性。一个密码系统必须同时具备完善的技术和管理要求，才能保证整个密码系统的安全。 密码系统的安全性 无条件安全性 一次一密，秘钥不能重复使用 –&gt; 存储管理花费巨大，不采取 可证明安全性 数学难题：大整数素因子分解，计算离散对数(log n = b%m，模前可能b无穷等于余数) –&gt; 解决耗费时间过大 计算安全性性 当密码系统的秘钥空间足够大时，由于攻击者受计算条件、资源限制，而且有其特定目的，若不能在希望的时间内或实际可能的条件下破译成功，则称计算上不可破译 达到实际安全性要满足的准则 实际计算量十分巨大 计算时间超过被加密信息有用的生命周期 破译该密码系统的费用超过被加密信息本身的价值 1.4 密码系统设计的基本原则科克霍夫斯(Kerckhoffs)原则数据安全基于秘钥而不是算法的保密性 密码设计公开原则并不等于所有的密码在应用时都一定要公开密码算法 1.5 密码体制的分类按秘钥数量 对称密码体制 非对称密码体制 也称单钥、秘密密钥…… 也称双钥、公开密钥…… c=Ek(m), m=Dk(c) c=Epk(m), m=Dsk(c) DES(56 bits) –&gt; AES(128 bits) RSA –&gt; ECC O(n2) : C(2,n) = n(n-1)/2 O(2n): 每人分配一个公钥一个密钥 加/解密使用一样，效率高密钥管理成本高，麻烦(比如分发) 加/解密使用不一样，效率低密钥管理简单 公钥不可解出密钥，密钥可以推出公钥 根据对明文信息的处理方式可将对称密码体制再分为分组密码和序列密码(流密码) 分组密码 序列密码(字符流) 一个字符/1 bit处理k足够长，不重复使用密钥非常重要（异或） 根据是否能进行可逆的加密变换 单向函数密码体制 双向变换密码体制 例子： b%m=c 对称密码体制的优缺点 优点 加密、解密的处理速度快、效率高、算法安全性高 缺点 密钥分发过程复杂，说花代价高 密钥管理量的困难 非对称密码体制的优缺点 优点 密钥分配简单 系统密钥量少 系统开放性好(随便加入正负) 可以实现数字签名(私钥不可伪造性；不可否认性：因偷了或丢了造成的损失都要负责) 缺点 加密、解密的运算复杂、处理速度较慢，同等安全强度下，非对称密码体制的密钥位数较多 对称密码体制是每个人都有其他人的密钥，一旦加了一个人就要通知所有人人手增加一把新人的密钥。 对称密码体制每人一把公钥和私钥，用收件人的公钥加密信件，收件人只需要用自己的私钥解密即可。若增加一人只需给新人配两把公私密钥就行，不需要通知所有人","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"蓝桥杯题目","slug":"刷题/蓝桥","date":"2022-02-23T10:00:54.461Z","updated":"2022-04-19T01:12:38.186Z","comments":true,"path":"2022/02/23/刷题/蓝桥/","link":"","permalink":"https://zhang0224gz.github.io/2022/02/23/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5/","excerpt":"","text":"背包问题01背包问题1max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int n=1010;int N,V;int v[n],w[n];int f[n][n];int main()&#123; cin&gt;&gt;N&gt;&gt;V; for(int i=1;i&lt;=N;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1;i&lt;=N;i++) &#123; for(int j=0;j&lt;=V;j++) &#123; f[i][j]=f[i-1][j]; if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); &#125; &#125; int res=0; for(int i=0;i&lt;=V;i++)res=max(res,f[N][i]); cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 报错： [[Error] array bound is not an integer constant before ‘]’ token](https://alanhere.com/2021/01/11/array-size-constant/) 报错地方：全局变量 int n=1010;未加const 报错原因：一般而言，C/C++ 的编译器在编译时，一个数组的长度往往要求是静态已知的。因此，如果数组 array[n] 长度是借助一个变量 n 来确定，那么可以加上 const 限定符。const 关键字是 用于限定一个变量为只读。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int n=1010;int N,V;int v[n],w[n];int f[n];int main()&#123; cin&gt;&gt;N&gt;&gt;V; for(int i=1;i&lt;=N;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1;i&lt;=N;i++) &#123; for(int j=V;j&gt;=v[i];j--) &#123; f[j]=max(f[j],f[j-v[i]]+w[i]); &#125; &#125; cout&lt;&lt;f[V]&lt;&lt;endl; return 0;&#125; 完全背包问题1max(f[i-1][j],f[i][j-v[i]]+w[i])","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zhang0224gz.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}]},{"title":"三天","slug":"数学建模/三天计划","date":"2022-02-17T10:39:42.831Z","updated":"2022-03-06T07:31:30.912Z","comments":true,"path":"2022/02/17/数学建模/三天计划/","link":"","permalink":"https://zhang0224gz.github.io/2022/02/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%B8%89%E5%A4%A9%E8%AE%A1%E5%88%92/","excerpt":"","text":"相关问题Q：队伍在微信群里打字交流算作弊吗？ A：不算。 Q：论文控制号就是赛克的队伍编号吗？ A：不是，论文控制号在美赛官网。mcm参赛编号为赛氪系统生成的编号，不是美赛官网的队伍号！！！ Q：翻译软件 A：谷歌翻译 Q：WPSPDF还是不如AdobePDF保险，对吗？ A：当然，它的准则说只接受Adobe PDF。个人建议还是用office别用WPS，会LaTeX最好 Q：新赛题的中文版 A：关注 数学建模比赛 公众号，8点左右 Q：论文里可以不放程序吗？ A：可，代码之类放附件 Q：可以不用官网给的摘要吗？ A：写控制号就行（22+五位数），需要使用官方给定的模板 美赛官网登录网址：https://www.comap.com/undergraduate/contests/mcm/login.php 辅助报名完成后2小时左右会给队长的赛氪账号发送站内消息，消息内通知美赛控制号。或登录美赛官网查看控制号。 ![img](file:///C:\\Users\\zhangguozhi\\Documents\\Tencent Files\\2251787923\\Image\\Group2\\F\\89\\F89BQ$`3}N4}BJOJ_0IR3O.jpg) A:比赛结束之前都可以选的对吧，到时候写完了再选题提交没问题吧 Q:选题开始比赛后才能选，选定了就先选上再写，以防意外。文件，即论文，插到邮箱附件（交官方邮箱） A:今年 目录，参考文献列表（或书目）、注释页和任何附录”是不是全都计入25页数限制？ Q:是的 2022年美赛选题步骤+论文提交步骤指导：https://www.saikr.com/c/nd/8549 美赛官方最新发布丨MCM-ICM_Tips（中英文对照版）：https://www.saikr.com/c/nd/8552 22年美赛常见问题及解答:22年美赛常见问题及解答 (qq.com) 2022.2.18 6:00 – 2022.2.21 20:00 – 2022.2.21 21:00 赛题分析，哪种问题+算法 模型假设 参数 模型建立 顺序步骤 求解 模型结果分析-&gt;图表分析 模型检验（是否正确）利用已知数据 模型应用 数据处理（算法：差值，拟合，组成和分析，层次分析法），关联与分析，分析与判别，评价与决策，预测与预报，优化和控制 聚类分析：诊断数据异常值 神经网络评价 小样本灰色预测 公式类评价模型（正比反比并拟合），模糊数学评价体系，因子分析法，主成分分析法，神经网络类的算法，层次分析法，灰色关联分析 预测模型：线性回归，非线性回归，灰色预测，时间序列分析，小波分析，神经网络预测 有效性评价，当出现某个指标变动之后，就需要对未来的数据进行重新预测，简易的方法是通过百分比的方式，或者参数方法，对原预测结果进行直接的提升，也可以使用马尔科夫模型，针对新的政策对未来进行预测，再将预测之后的结果，带入到之前建立的模型，评价结果上升，才会说明政策的有效性 最后我们之前的变动是直接针对指标进行变动 国家做出调整各个方面为这个指标努力，努力就会牵动更多的内容，需要细致分析和自由发挥，需要说明国家推行新政策时可能遇到的困难 灵敏度分析，当有些政策无法迅速做出变动时，或出现其他状况时，公平出现的趋势 方差分析：单因素和多因素 标准差，极差，方差，偏度，峰度 正态分布 1.如何数据处理，如何实现降维过程 第一个要素：评价指标 如何选择 花篇幅为什么选择这个指标 如何建模量化得出结论 详细说明指标含义，指什么东西，和论文有什么关系，为什么选她做指标 谈怎么量化 不可忽视数据来源 评价模型 相对重要，权重大 我们选择TOPSIS(基于理想解相似度的排序偏好技术)来建立我们的评价模型。考虑到层次分析法在确定权重时过于依赖管理者判断的缺点，我们决定采用信息熵权法(view)确定各指标的权重。 我们输入来自21个经合组织国家(包括发展中国家)的数据，并对其健康状况进行排名 使用GM(灰色模型)来说明改善智利高等教育现状的强有力政策的必要性，并通过问题6的评估模型来评估政策的有效性。 三个维度:输入、输出和效率。投入是指国民经济对高等教育系统的教育支出。产出是指高等教育系统回报社会的经济价值和社会价值。而效率则是指资源的输入要素的利用程度 三个维度，即覆盖率、公平性和绩效作为主要指标。覆盖率由三个二级指标来衡量:大学生在青年群体中的比例、研究生与本科生的比例和近30年来高等教育覆盖率的增长速度。公平是由学生家庭在高等教育支出中所占的比例和大学的宣传程度来衡量的。成绩由四个能力分布指标和博士毕业率来衡量。 公平侧重于获得资源的机会","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[]},{"title":"基础知识","slug":"智能车/基础知识1","date":"2022-02-07T14:39:13.103Z","updated":"2022-04-16T04:46:29.709Z","comments":true,"path":"2022/02/07/智能车/基础知识1/","link":"","permalink":"https://zhang0224gz.github.io/2022/02/07/%E6%99%BA%E8%83%BD%E8%BD%A6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/","excerpt":"","text":"一些报错 Warning[Pe223]: function “Speed_Control” declared implicitly 出现原因1该函数没有在本文件包含的头文件中定义，而只在其他c文件的头文件中有定义，也就是间接地有定义。这样是不规范的。 解决办法1把出现问题的函数所在头文件包含进来。且如果包含进来还未解决，可能是头文件包含的先后顺序有关。 出现原因2头文件和C文件中的函数声明不完全相同，可能出现函数名有细微差别，比如字母大小写不一致等情况。 解决办法2回去仔细看一下出现问题的函数是否在声明和调用时使用了完全一致的函数名称和变量 Error[Pe028]: expression must have a constant value 报错内容：float Output=angle_duty; 报错原因：Output和angle_duty都是变量不能在定义时赋值，可以先定义在函数中赋值。 123456意思是.表达式必须是常量推论---------------1.数组在声明时初始化必须是常量！2.unsigned char const Tab[]。Tab是变量3.const unsigned char const Tab[]。Tab也是是变量！尽管程序整个过程它都不能被改变. Error[Pe028]: expression must have a constant value 常见原件电阻和电容贴片电容(不分+,-)，钽电容(分+,-) 固态电解电容(用于主板) 电阻、电容的标号： 电容：1μF = 1,000nF = 1,000,000pF 【103】，即10 x 10^3皮法 = 10纳法； 计算方法：前两位数字代表有效数字，第三位代表10的n次幂（也可以理解为在有效数字后面有几个0），单位是皮法。 前3位数字是容量代码，字母是额定电压代码(耐压值) 字母C表示额定电压为16V(C型耐压16V),字母A表示额定电压为10V(A型耐压10V) 107C是 100UF 16V，107A是100UF 10F 电阻：1MΩ=1,000KΩ=1,000,000Ω 数字索位标称法（一般矩形片状电阻采用这种标称法） 数字索位标称法就是在电阻体上用三位数字来标明其阻值。它的第一位和第二位为有效数字，第三位表示在有效数字后面所加“0”的个数。这一位不会出现字母。 例如：【472】表示“4700Ω”；【151】表示“150Ω”。 如果是小数。则用“R”表示“小数点”。并占用一位有效数字，其余两位是有效数字。例如：【2R4】表示“2.4Ω”；【R15】表示“0.15Ω”。 色环标称法（一般圆柱形固定电阻采用这种标称法） 色环电阻大多采用三环、四环（有时五环、六环）标明其阻值，原理都一样。 ​ 颜色表示：从左到右，前三列为有效数字，第四列为倍数，第五列为误差，第六列为温度系数。 例如：【蓝灰橙银】表示“68kΩ”，误差±10% 二极管LED有正有负，有线的一边为负极 蜂鸣器调车使用，有问题可以响 排母、排针焊接工具焊箱松香焊芯片，自动分开防止短路 细丝吸锡器排针孔堵了 IAR安装和使用Ctrl+Shift+F 快捷键唤出查找功能-&gt;查找之后再go to defination Ctrl+T 格式化 C语言基础知识内存和地址内存是以字节为单位的存储空间 有底到顶：机械码、代码-&gt;静态变量-&gt;全局变量-&gt;堆区(指针）-&gt;栈区(main函数中的) 数据类型1234567typedef char int8; // 8 bitstypedef short int int16; // 16bitstypedef long int int32; //32 bitstypedef unsigned char uint8; //8 bitstypedef unsigned short int uint8;// 16 bitstypedef unsigned long int uint8;// 32 bitstypedef unsigned long long uint8;// 64 bits 外部变量和外部函数文件之间调用 关键字extern: 当extern不与“C”在一起修饰变量和函数时，如在头文件中：extern int g_Int : 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或者其他模块中使用。！！！它是一个声明不是一个定义。 栗子：B模块（编译单元）要是引用模块（编译单元）A中定义的全局变量或函数时，它只要包含A模块的头文件即可，在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。 12345678//include.cpp#include&quot;include.h&quot;int a=10;int b=5;int sum(int a,int b)&#123; return a+b;&#125; 123456789//include.h#ifndef _INCLUDE_H_ //防止嵌套，造成资源浪费#define _INCLUDE_H_extern int a;extern int b;int sum(int a,int b);#endif 123456//主函数异步编译多个不同代码，使用关键词#if 0#elif 1#elif 0#endif //想编译的写1，不想编译的写0 123456789//main.cpp#include&lt;iostream&gt;#include&quot;include.h&quot;using namespace std;int main()&#123; cout&lt;&lt;a&lt;&lt;&quot;+&quot;&lt;&lt;b&lt;&lt;&quot;=&quot;&lt;&lt;sum(a,b)&lt;&lt;endl; return 0;&#125; 中断原理及应用中断服务程序 中断服务程序，处理器处理“急件”，可理解为是一种服务，是通过执行事先编好的某个特定的程序来完成的，这种处理“急件”的程序被称为——中断服务程序。 与每类I/O设备相关的进程都有一个靠近内存底部的地址，称作中断向量。 它包括中断服务程序的入口地址。当中央处理器正在处理内部数据时，外界发生了紧急情况，要求CPU暂停当前的工作转去处理这个紧急事件。处理完毕后，再回到原来被中断的地址，继续原来的工作，这样的过程称为中断。实现这一功能的部件称为中断系统，申请CPU中断的请求源称为中断源，单片机的中断系统一般允许多个中断源，当多个中断源同时向CPU请求中断时，就存在一个中断优先权的问题。通常根据中断源的优先级别，优先处理最紧急事件的中断请求源，即最先响应级别最高的中断请求。 1、中断标识码（中断类型号）：由硬件（通常是中断控制器）产生，以标识不同的中断源。 2、中断向量：早期的微机系统中将由硬件产生的中断标识码（中断源的识别标志，可用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址）称为中断向量。在某些计算机中，中断向量的位置存放一条跳转到中断服务程序入口地址的跳转指令。 3、中断向量地址：存储中断向量的存储单元地址。 4、中断：在计算机执行程序的过程中，当出现异常情况或者特殊请求时，计算机停止现行的程序的运行，转而对这些异常处理或者特殊请求的处理，处理结束后再返回到现行程序的中断处，继续执行原程序。 存放：存放中断服务程序的入口地址，来存放中断向量（共256个），称这一片内存区为中断向量表。 跳转：跳转到中断服务程序的入口地址，在AVR或ARM微处理器中，中断向量的大小也是4个字节，但其中存放的不是中断程服务程序的入口地址，而是可执行的代码。当响应中断时，硬件自动执行相应中断向量处的跳转代码，然后跳转到具体的中断服务程序的入口地址。 综上所述：中断向量的地址一定是 中断服务程序的入口地址的地址，但中断向量不一定就是中断服务程序的入口地址。 单片机中重要中断PID定时中断： 对于时间进行精准的控制，定时进入中断服务程序完成某个任务 123456789main()&#123; 1.关总中断 2.中断初始化(中断开启): PID中断初始化(4个PID定时器用哪个:一般只使用一个，定时的时间:10ms进入一次) 3.开启中断 4.使能(使其能工作) 5.&#125; 串口接收中断： 由单片机通过蓝牙串口接收到信息时，做出对应的反应(调车使用) 中断一多就有中断优先级问题…… https://www.bilibili.com/video/BV1fJ411K7bk?spm_id_from=333.999.0.0 怎样烧录程序硬件准备：1.主板 2.核心板 3.下载器 软件准备：IAR 不要插反 GPIO通用输入输出接口概念：通用型之输入输出的简称，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入GPI或通用输出GPO或通用输入输出GPIO。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它 输入模式：通过读取某个寄存器来确定引脚电位的高低输出模式：写入某个寄存器来让这个引脚输出高电位或低电位 通用串行异步数据总线：异步通信：通信中两个字符（8位）之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。波特率：每秒钟传送的二进制位 PC–&gt;USB原则单片机–&gt;TTL原则（USB转TTL模块转Kea板） 主要：引脚（即排针） 1234GPIO初始化 gpio_init(port,dir,state) port/ptxn端口号，dir引脚方向(0=输入,1=输出)，state引脚初始状态(0=低电平,1=高电平)设置引脚状态 gpio_set(ptxn,state)获取引脚状态 gpio_get(ptxn) UART串口(输入输出信息)概念：串行接口(Serial Interface)是指数据一位一位地顺序传送 ​ 有线串口：usb转ttl的模块； ​ 蓝牙串口更适用于调试； 硬件：1.USB to TTL模块 2.KEA板 3.下载器 !！注意：硬件连接时，下载器拔掉3.3V跳线帽 12345UART初始化 uart_init(uartn,band_rate) UARTn通道(实际是两个引脚)，band_rate波特率(数据传输的速度：9600 11400……)UART串口打印 uartPrintf(UARTn uartn,char *pcFmt....)虚拟示波器 uart_sendware(UARTn uartn,void *wareaddr,uint32 waresize)串口接收中断 uart_rx_irq_en AD采集(电磁组)概念：模拟信号(Analog signal) -&gt; 数字信号(Digital signal) 1234567初始化 ADC_Init(ch,bit) ch采集通道，bit采集位数单次采集 adc_once(adcn_ch) adcn_ch ADC通道均值滤波 adc_ave(adcn_ch,N) adcn_ch ADC通道,N均值滤波次数(范围:0~255) 其他滤波算法：中位值平均滤波算法、卡尔曼滤波算法…… PIT定时中断软件上执行时间一致，但在硬件上(电容、电阻跑久了温度会升高，时间发生变化会导致周期变化)时间不一致 概念：定时器实际上是计数器，它通过累计已知时间间隔的个数来计算时间。被累积的时间间隔若是系统时钟，计数器就变成了定时器。（周期性地做某一件事……） 1234初始化 PIT_Init(uSChannel_No,freq) uSChannel_No PIT通道端口号0、1,freq定时器频率中断服务函数 PIT0_ISR(uSChannel_No)中断使能 pit_irq_en(uSChannel_No) 关于中断内核 约等于 操作系统 单片机上的程序，始终获得CPU的控制权 用户程序并发处理的时候，是轮番处理的且交换很快 所以单片机要明确知道IO什么时候做这些输入输出和这些中断，要自己亲自过问 摄像头的获取，摄像头输入：首先摄像头分传感器和集成本地缓存，传感器会把光的信号转换为数字信号，数值放在缓存里。若是写成请求一次程序，完全收集好一次数据交给CPU处理会非常难慢。先初始摄像头给摄像头配置寄存器写好时然后告诉摄像头以什么频率和分辨率、彩色还是干风暴的画面，按行采集完一次告诉CPU一次，使用的是外部中断，CPU给传感器一个地址，就是DMA传送方式（DMA直接内存访问：在传的过程中不需要CPU一条一条把缓存里的东西取到内存里，而是传感器的缓存是直接向内存传数据，CPU只要直接告诉缓存往哪存数据缓存往哪存数据） FTM多功能定时器PWM波驱使电机转动和舵机打角 编码器测速（轮胎转的速度） 占空比（高电平的时间占总时间的比例） FTM模块的核心是一个16位计数器。主要功能：PWM输出、输入捕捉、正交解码 PWM输出： PWM的周期=(MOD-CNTIN) 123456FTM模块初始化 FTM_PWM_init(ftm,ch,freq,duty) ftm PWM模块，ch通道，freq频率，duty占空比(0-1000 可以调节FTM_PRECISON这个系数)设置占空比 FTM_PWM_Duty计数模块初始化 ftm_count_init获取计数值 ftm_count_get清空计数值 ftm_count_clean 初始化以及其他一些功能函数写在.c文件，服务函数统一写在Isr.c ！注意：串口打印和虚拟示波器不能同时使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#if 1//GPIOvoid main()&#123; DisableInterrupts; gpio_init(GPI0,1,0); gpio_init(GPI1,0,0); if(gpio_get(PIG1)==0)gpio_set(GPI1,1); EnableInterrupts;&#125;#elif 0//串口void main()&#123; DisableInterrupts; uart_init(UARTR0,9600); int pulse[2]; pulse[0]=0; pulse[1]=100; uartPrintf(UARTR0,&quot;ok\\n&quot;); EnableInterrupts; while(1) &#123; //串口打印时需注释掉虚拟示波器 //uart_sendware(UARTR0,&amp;pulse,sizeof(pulse)); &#125;&#125;#elif 0//串口接收中断void main()&#123; DisableInterrupts; uart_init(UARTR0,9600); gpio_init(PIG0,1,0); gpio_init(PIG1,1,0); gpio_init(PIG2,1,0); gpio_init(PIG3,1,0); uart_rx_irq_en(UARTR0);//rx接收，tx发放-&gt;isr.c EnableInterrupts;&#125;#elif 0//AD采集void main()&#123; DisableInterrupts; uart_init(UARTR0,9600); int val; ADC_Init(ADC_CHANNEL_AD6,ADC_12BIT); EnableInterrupts; while(1) &#123; val=adc_once(ADC_CHANNEL_AD6); //val=adc_ave(ADC_CHANNEL_AD6);//均值滤波 uart_sendware(UARTR0,&amp;val,sizeof(val)); &#125;&#125;#elif 0//PIT定时中断void main()&#123; DisableInterrupts; PIT_Init(PIT_CHANNEL0,1); uart_init(UARTR0,9600); PIT_IRQ_EN(PIT_CHANNEL0); EnableInterrupts;&#125;#elif 0//FTMvoid main()&#123; DisableInterrupts; PIT_Init(PIT_CHANNEL0,1); uart_init(UARTR0,9600); FTM_PWM_init(CFTM0,FTM_CH1,50,10); ftm_count_init(CFTM1); PIT_IRQ_EN(PIT_CNANNEL0); EnableInterrupts;&#125; #endif #if 0//FTMvoid PIT0_ISR(void)&#123; //清除中断标志位 PIT-&gt;CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK; uartPrintf(UARTR0,&quot;%d\\n&quot;,ftm_count_get(CFTM1)); ftm_count_clean(CFTM1);&#125;#elif 1//PIT定时中断void PIT0_isr(void)&#123; //清除中断标志位 PIT-&gt;CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK; uartPrintf(UARTR0,&quot;%d\\n&quot;,1);&#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"Python 数据获取与可视化分析综合练习题","slug":"Python/实验课代码","date":"2022-01-15T10:33:10.359Z","updated":"2022-03-21T09:25:24.308Z","comments":true,"path":"2022/01/15/Python/实验课代码/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/15/Python/%E5%AE%9E%E9%AA%8C%E8%AF%BE%E4%BB%A3%E7%A0%81/","excerpt":"","text":"Python 数据获取与可视化分析综合练习题实验内容：(1) 用自己的姓名或学号新建一个文件夹，在文件夹中新建一个文本文件 “111.txt”。(2) 从网上复制“当好学生成长的引路人——习近平总书记给全国高校黄大 年 式 教 师 团 队 代 表 的 回 信 引 发 强 烈 反 响 （ 网 址 ： http://www.xinhuanet.com/2021-09/13/c_1127858064.htm）”中的文本内容 保存到“111.txt”中。(3) 将“111.txt”文件中的内容的中文提取到“222.txt”文档中（使用 re 方法）。(4) 使用 jieba 对提取的中文文档（222.txt）进行分词处理，并统计出现频 率最高的前 100 个。(5) 使用 wordcloud 和 matplotlib.pyplot 方法对“222.txt”中的分词制作 分词云图，并保存为“分词云图 1.png”。(6) 使用“222.txt”中出现频率最高的前 10 个词语，制作条形图，X 轴对应 10 个词语，y 轴对应每个词语的频率值，保存成“条形图 2.png”。（附：有余力的同学可以将实验内容的第(1)(2)步换成爬取网页内容的操作。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#原始版本import osimport requestsimport reimport jiebaimport matplotlib.pyplot as pltfrom wordcloud import WordCloudimport numpy as npfrom PIL import Imageimport matplotliburl = r&#x27;http://www.xinhuanet.com/2021-09/13/c_1127858064.htm&#x27;response = requests.get(url)response.encoding = &#x27;utf-8&#x27;path = r&#x27;C:\\Users\\zhangguozhi\\Desktop\\2020416177&#x27;isExists = os.path.exists(path)if not isExists: os.makedirs(path) print(&#x27;创建成功&#x27;)else: print(&#x27;目录已存在&#x27;)path1 = path + &#x27;\\\\&#x27; + &#x27;111.txt&#x27;file = open(path1, &#x27;w&#x27;, encoding=&#x27;utf&#x27;)file.write(response.text)file.close()file = open(path1, &#x27;r&#x27;,encoding=&#x27;utf&#x27;) #r表示是文本文件，rb是二进制文件content = file.read()file.close()pattern1 = &#x27;[\\u4e00-\\u9fa5]+&#x27; #形成字符串列表（提取中文(默认一个)，+(至少匹配一个))#pattern2 = &#x27;[A-Za-z0-9\\!\\%\\&lt;\\&gt;\\，\\。]&#x27;re1 = re.compile(pattern1) #正则表达式对象：匹配或替换方式res1 = re1.findall(content) #指定字符串进行匹配#res2 = re1.sub(pattern2, &#x27;&#x27;,content) #过滤path2 = path + &#x27;\\\\&#x27; + &#x27;222.txt&#x27;file = open(path2, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)n = len(res1)for i in range(n): file.write(res1[i])file.close()file = open(path2, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)content = file.read()jb_li = list(jieba.cut(content, cut_all=False))#print(jb_li)file.close()list1 = []list4 = []dict1 = &#123;&#125;n = len(jb_li)for i in range(n): if len(jb_li[i])&gt;1: num = jb_li.count(jb_li[i]) dict1[jb_li[i]] = num list4.append(jb_li[i])for i in dict1: tup = (dict1[i],i) list1.append(tup)list1.sort(key=lambda x:x[0],reverse=True)list2 = list1[0:99]list3 = [i[1] for i in list2]fcl = &#x27; &#x27;.join(list4)bgl = np.array(Image.open(r&#x27;C:\\Users\\zhangguozhi\\Pictures\\Saved Pictures\\QQ截图20210529160439.png&#x27;) ) #功能:将数据转化为矩阵cyl = WordCloud( font_path = &#x27;C:\\WINDOWS\\Fonts\\STFANGSO.TTF&#x27;, background_color = &#x27;white&#x27;, width = 500, height = 400, max_font_size = 100, min_font_size = 10, mask = bgl )cyl.generate(fcl)plt.figure(&#x27;词云图&#x27;)plt.imshow(cyl) #?plt.axis(&#x27;off&#x27;) #关闭坐标轴plt.savefig(r&#x27;C:\\Users\\zhangguozhi\\Desktop\\2020416177\\分词云图1.png&#x27;,dpi=300)#plt.show()matplotlib.rcParams[&#x27;font.family&#x27;]=&#x27;SimHei&#x27;x = [list1[0][1],list1[1][1],list1[2][1],list1[3][1],list1[4][1],list1[5][1],list1[6][1],list1[7][1],list1[8][1],list1[9][1]]y = [list1[0][0],list1[1][0],list1[2][0],list1[3][0],list1[4][0],list1[5][0],list1[6][0],list1[7][0],list1[8][0],list1[9][0]]figure = plt.figure()plt.bar(x,y)plt.savefig(r&#x27;C:\\Users\\zhangguozhi\\Desktop\\2020416177\\条形图2.png&#x27;,dpi=300) 实验2在已有网络拓扑基础上，给每个节点随机生成剩余能量（取值范围：1～10） 骨干节点： 随机性 成为骨干节点的要求：剩余能量&gt;=4.2 骨干节点之间是连通的 普通节点表示、普通节点之间连线 骨干节点表示、骨干节点之间连线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import matplotlib.pyplot as pltimport numpy as npfrom matplotlib.patches import Circlen = 80rl = 0rr = 100r = 20energy = np.random.randint(1,10,size=[n])a = np.random.randint(rl,rr,size=[n])b = np.random.randint(rl,rr,size=[n])fig = plt.figure()ax = fig.add_subplot(111)plt.scatter(a,b,c=&#x27;r&#x27;,marker=&#x27;o&#x27;,s=5)pre = &#123;&#125;for i in range(n): pre[(a[i],b[i])]=[0,0,0] for i in range(n): for j in range(i+1,n): if (a[i]-a[j])*(a[i]-a[j])+(b[i]-b[j])*(b[i]-b[j])&lt;r*r: if energy[i]&gt;=4.2 and energy[j]&gt;=4.2: aa = [a[i],a[j]] bb = [b[i],b[j]] plt.plot(aa,bb,color=&#x27;gold&#x27;,linewidth=1) pre[(a[i],b[i])][1] += 1 pre[(a[j],b[j])][1] += 1 else: aa = [a[i],a[j]] bb = [b[i],b[j]] plt.plot(aa,bb,color=&#x27;skyblue&#x27;,linewidth=1) pre[(a[i],b[i])][2] += 1 pre[(a[j],b[j])][2] += 1 pre[(a[i],b[i])][0] += 1 pre[(a[j],b[j])][0] += 1mini0 = 0;mini1 = 0;mini2 = 0; for j in range(n): if pre[(a[j],b[j])][0]&lt;mini0:mini0=j if pre[(a[j],b[j])][1]&lt;mini1:mini1=j if pre[(a[j],b[j])][2]&lt;mini2:mini2=jprint(pre[(a[mini0],b[mini0])][0],pre[(a[mini1],b[mini1])][1],pre[(a[mini2],b[mini2])][2])#print(pre)for i in range(n): circle = plt.Circle(xy=(a[i],b[i]),radius=20,alpha=0.05,color=&#x27;lightseagreen&#x27;) ax.add_patch(circle) plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"}],"tags":[]},{"title":"最优化方法","slug":"数学建模/线性规划","date":"2022-01-11T14:14:05.578Z","updated":"2022-02-09T14:06:57.519Z","comments":true,"path":"2022/01/11/数学建模/线性规划/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/","excerpt":"","text":"最优化方法广泛应用于工农业、交通运输业、商业、国防、建筑、通信与政府机关及管理各部门各领域，旨在解决最优计划、最优分配、最优决策、最佳管理等最优化问题。最优化方法是一门应用科学，它以量化为基础，融合多学科交叉特点，强调做出最优决策 内容包括线性规划、运输问题、整数规划、非线性规划的基本概念与基本原理、无约束问题的最优化方法和约束问题的最优化方法 线性规划问题 我们将一个问题抽象为在满足一组约束条件下，寻求变量x1,x2…xn使目标函数达到最大值的一个数学问题 线性规划数学模型 -&gt;可行域：满足约束条件和非负条件的点组成的交集-&gt;最优解： 线性规划标准形式目标函数一律改为最大化 约束条件一律改为等式（非负约束条件除外） 等式右端项大于等于零 -&gt; 两种形式：一般形式、矩阵形式和向量形式 -&gt; 将非标准形式化为标准形式 例子：","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[]},{"title":"评价类模型","slug":"数学建模/层次分析法","date":"2022-01-07T11:08:39.548Z","updated":"2022-03-21T09:23:40.851Z","comments":true,"path":"2022/01/07/数学建模/层次分析法/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/","excerpt":"","text":"层次分析法 层次分析法（The Analytic Hierarchy Process即 AHP) 最基础的模型之一，最主要用于解决评价类问题（例如：选择哪种方案最好、哪位运动员或者员工表现的更优秀） 评价类问题关键字：确定评价指标，形成评价体系 解决评价类问题，首先想到的三个问题： （1）我们评价的目标是什么？ （2）我们为了达到这个目标有哪几种可选的方案？ （3）评价的准则或者指标是什么？（我们根据什么东西来评价好坏） 优先选择知网（或者万方，百度学术，谷歌学术等平台）搜索相关文件 和小组成员来场头脑风暴+在平台上搜索别人或者专家的看法 虫部落-快搜：https://search.chongbuluo.com/ 搜索优先级：谷歌&gt;微信&gt;知乎 第一步：建立层次结构图​ -&gt; 通过题目找出目标、方案和准则 第二步：建立权重表格 -&gt; 求出指标权重和方案权重法一：直接打分法法二：分而治之法-&gt; 一次性考虑不周，两个两个指标进行比较，最终根据两两比较的结果来推算出权重 第一步：使用程度打分表，填写判断矩阵 计算指标权重的 计算同一指标下方案间权重的 出现问题：几个方案会出现逻辑矛盾（不一致现象：A&gt;B,A=C,B&gt;C） 第二步：一致性检验-&gt; 判断矩阵和一致矩阵对比 -&gt; 一致矩阵引理1：一致矩阵A各行成比例，所以矩阵的秩为1，故一致矩阵有一个特征值为n（tr(A)=a11+……+ann)，其余特征值为0；对应特征向量为第一行各元素取反，即第一列 引理2：n阶正互反矩阵A为一致矩阵时，最大特征值为n 当不是一致矩阵时，最大特征值&gt;n -&gt; 矩阵之间关系 -&gt; 一致性检验 CR &gt; 0.1 如何修正？往一致矩阵上调整~~~ 第三步：计算权重 PS:选一列进行计算 -&gt; 算术平均法 -&gt;几何平均法 -&gt; 特征值法求判断矩阵最大特征值和其特征向量，将其归一化处理 第三步：计算各方案得分 局限性（1）评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大。 （2）如果决策层中指标的数据是已知的，那么我们如何利用这些数据来使得评价的更加准确呢？ TOPSIS法 第一步：原始矩阵正向化 第二步：正向化矩阵标准化 第三步：计算得分并归一化","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[]},{"title":"PID三环","slug":"智能车/PID","date":"2022-01-05T08:13:52.956Z","updated":"2022-04-13T16:16:07.052Z","comments":true,"path":"2022/01/05/智能车/PID/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/05/%E6%99%BA%E8%83%BD%E8%BD%A6/PID/","excerpt":"","text":".直立环pd：d参数的引入是为了抑制震荡 p，比例参数，它的作用是反应了控制的响应速度，过小的话平衡车表现是pwm明显不够直立不起来，过大的话小车过于震荡，震荡的时候就要加微分参数抑制震荡· d，微分参数，它的作用是反应了对震荡的抑制。过小的话和没加微分参数只有比例参数一样的现象，过大的话会低频迅速抖动 控制时序：角度5ms采集一次 直立环和角度环10ms控制一次 下面是程序分析： /************************************************************************/ 直立环 ： int balance(float Angle,float Gyro) { float Bias; int balance; Bias=Angle-ZHONGZHI; //===求出平衡的角度中值 和机械相关 balance=BkpBias+GyroBkd; //===计算平衡控制的电机PWM PD控制 kp是P系数 kd是D系数 return balance; } 角度环pid分析：这里使用的是 位置pid控制器的PD控制器，这里 微分D乘的参数是角速度是因为：这里的角速度已经转变为弧度/s单位，当在单位时间内，车子由一个角度猛然的转到另一个角度的时候，角速度先变大后变为0，这里的角速度就可以理解为在这段时间内的此时的角度差值和上次角度差值的差值(因为角度差值除以单位时间就是角速度)，这就很符合位置pid的微分乘的参数的要求了。所以这里的微分乘的是角速度（这里的角速度单位已经从°/s转为弧度/s） 角度环是根据平衡角度的变化给出的pwm值 kp：是比例参数 他决定平衡小车响应速度的快还是慢 太小响应速度慢太大会发生低频抖动 kd：是微分参数 对于干扰要进行迅速响应的的要加入微分参数 太小的话没什么作用太大会高频抖动 只有直立环调试比较好的现象是：平衡车可以直立几秒钟然后像一个方向加速 直立环调试指南： 在调试直立环的时候，我们要把速度环和转向环屏蔽掉，只打开直立环。 （1）先确定平衡车机械平衡位置角度。 （2）确定kp值得极性和大小: 首先我们估计kp的取值范围。我们的PWM设置的是7200代表占空比100%，假如我们设定 kp 值为 720，那么平衡小车在±10°的时候就会满转。根据我们的感性认识，这显然太大了，那我们就可以估计 kp 值在 0~720 之间，首先大概我们给一个值 kp=-200,我们可以观察到，小车往哪边倒，电机会往那边加速让小车到下，就是一个我们不愿看到的正反馈的效果。说明 kp 值的极性反了，接下来我们设定 kp=200,这个时候可以看到平衡小车有直立的趋势，虽然响应太慢，但是，我们可以确定 kp 值极性是正的。具体的数据接下来再仔细调试。 确定 kp 值的大小（令 kd=0，请结合本小节开头的直立控制函数理解）确定参数的原则是： kp 一直增加，直到出现大幅度的低频抖动。 设定 kp=200,这个时候我们可以看到，小车虽然有平衡的趋势，但是显然响 应太慢了。 设定 kp=350,这个时候我们可以看到，小车虽然有平衡的趋势，而且响应有 所加快，但是响应还是不足以让小车保持平衡。 设定 kp=500,这个时候我们可以看到，小车的响应明显加快，而且来回推动 小车的时候，会有大幅度的低频抖动。说明这个时候 kp 值已经足够大了，需要 增加微分D控制削弱 p 控制，抑制低频抖动(也就是抑制超调)。 （3）确定kd值得极性和大小： 我们得到的 MPU6050 输出的陀螺仪的原始数据，通过观察数据，我们发现最大值不会超过 4 位数（9999），再根据 7200 代表占空比 100%，所以我们估算 kd 值应该在 0~2 之间，我们先设定 kd=-0.5，当我们拿起小车旋转的时候，车轮会反向转动，并没有能够实现 跟随效果。这说明了 kd的极性反了。接下来，我们设定 kd=0.5,这个时候我们可以看到，当我们旋转小车的时候，车轮会同向以相同的速度跟随转动，这说明我们实现了角速度闭环，至此，我们可以确定 kd 的极性是正的。具体的数据接下来再仔细调试。 确定 kd 值的大小（令 kp=500，请结合本小节开头的直立控制函数理解） 确定参数的原则是： kd 一直增加，直到出现高频抖动。 设定 kd=0.5,这个时候我们可以看到，低频大幅度频抖动已经基本消除。 设定 kd=1,这个时候我们可以看到，整体性能已经非常棒。 设定 kd=1.7,这个时候我们可以看到，小车开始出现高频剧烈抖动(调试过程 遇到这种情况请马上关闭小车，长时间高频抖动会导致驱动被烧坏的) 至此，我们可以确定得到 kp=500,kd=1.7 是 P、D 参数的最大值。然后我们进行最关键的一步，对每个系数乘以 0.6,取整得到 kp=300,kd=1，这就是最终我们需要的参数，这样做的原因是，我们之前得到的参数是 kp、kd 最大值，理想值是根据我们的工程经验，对每个数据乘以 0.6 得到。这个时候我们可以看到，小车没有任何的抖动，非常平稳，但是依然无法保持长时间的直立，直立很短一段时间后会往一个方向加速倒下。这个等我们下面加上速度环才能得到更好的性能。只有直立环是很难让小车达到很好的直立效果的。至此，直立调试部分就告一段落了。 感谢平衡小车之家在技术上的帮助 如果觉得有用的话 请关注我哦 也可以和我一起交流，或者评论，我会一一回复。————————————————版权声明：本文为CSDN博主「假如明天没有太阳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/zhaoyuaiweide/article/details/54572483 1.占空比 就是输出的PWM中，高电平保持的时间与该PWM的时钟周期的时间之比。 如，一个PWM的频率是1000Hz，那么它的时钟周期就是1ms，就是1000us，如果高电平出现的时间是200us，那么低电平的时间肯定是800us，那么占空比就是200：1000，也就是说PWM的占空比就是1:5。 2.分辨率 也就是占空比最小能达到多少，如8位的PWM，理论的分辨率就是1：255(单斜率)，16位的的PWM理论就是1:65535(单斜率)。 频率就是这样的，如16位的PWM，它的分辨率达到了1:65535，要达到这个分辨率，T/C就必须从0计数到65535才能达到，如果计数从0计到80之后又从0开始计到80…….，那么它的分辨率最小就是1:80了，但是，它也快了，也就是说PWM的输出频率高了。 3.双斜率 / 单斜率 假设一个PWM从0计数到80，之后又从0计数到80……. 这个就是单斜率 假设一个PWM从0计数到80，之后是从80计数到0……. 这个就是双斜率 可见，双斜率的计数时间多了一倍，所以输出的PWM频率就慢了一半，但是分辨率却是1：(80+80)=1:160，就是提高了一倍。 假设PWM是单斜率，设定最高计数是80，我们再设定一个比较值是10，那么T/C从0计数到10时(这时计数器还是一直往上计数，直到计数到设定值80)，单片机就会根据你的设定，控制某个IO口在这个时候是输出1还是输出0还是端口取反，这样，就是PWM的最基本的原理了。 传感器（陀螺仪和加速度计）(4条消息) 陀螺仪原理–转载_jaczen的博客-CSDN博客_陀螺仪原理 - 加速度计（accelerometer）检测什么 - 陀螺仪（gyroscope，也称作 gyro）检测什么 - 如何将传感器ADC读取的数据转换为物理单位（加速度传感器的单位是g，陀螺仪的单位是 度/秒） - 如何结合加速度传感器和陀螺仪的数据以得到设备和地平面之间的倾角的准确信息 加速度计检测到得力的方向与它本身加速度的方向是相反的。这种力量通常被称为 惯性力或假想力 R ^ 2 = RX ^ 2 + RY ^ 2 + RZ ^ 2（ 公式1），此公式等价于 三维空间勾股定理。 直立车，PID部分角度环(4条消息) 【平衡小车制作】（五）位置式PID、直立环与速度环概念（超详解）_鲁乎乎的博客-CSDN博客_直立环 这个信息挺全的 直立平衡角度环PID控制 · 给新手的两轮自平衡小车开发实战指南 (miaowlabs.com) PID(4条消息) PID应用时要注意的一些点_maitd的博客-CSDN博客_pid限幅 位置式连续式 位置式离散式(注意此时Kp=Kp, Ki=Kp*T/Ti, Kd=Kp*Td/T) 增量式离散式： 12345678910参数整定找最佳，从小到大顺序查 先是比例后积分，最后再把微分加 曲线振荡很频繁，比例度盘要放大(Kp减小) 曲线漂浮绕大湾，比例度盘往小扳(Kp增大)曲线偏离回复慢，积分时间往下降(Ki增大)曲线波动周期长，积分时间再加长(Ki减小)曲线振荡频率快，先把微分降下来(Kd增大) 动差大来波动慢。微分时间应加长(Kd减小) 理想曲线两个波，前高后低4比1 一看二调多分析，调节质量不会低 二.控制PID的执行周期(T)虽然在离散化的公式里这个地方这个参数隐藏了,但注意它只是被隐藏了,但还是还会发生作用,看一下离散位置PID公式里那几个参数的公式,是不是它会影响参数的大小啊.所以在应用第二个第三个PID公式时执行周期一定是要确定的,不能变更的,一T变更那么参数就得跟着变了,注意是T变了,参数就得相应的去变化,而不是一直不变,但如果此时你的参数维持不变的话,显然这组参数已经不是当前的最优参数了.举个例子,有一个取样周期为1的PID和一个取样周期为10的PID控制同一个的执行元件,若此时参数还采取一样,它的控制效果显而易见是不会一样的.所以要控制执行周期,最好能将Ki=KpT/Ti, Kd=KpTd/T,这个公式直接应用,公式变为: 我推荐用这个公式,在控制好T,或者获取T的实际值,代入,调节Ti和Td.许多开源四轴的控制一般是用这个公式的. 三.积分环节的限幅我不推荐做智能车啥的用增量式PID,说是简化了运算,但现在的单片机啥的运算能力和频率都挺强的,又不是51那个时代了,所以减那一点实在没什么作用.此外用增量式PID,不好去做积分限幅的,只能对每次的输出做限制,但对积分的限幅没什么作用.有时候当误差量e(k)比较大,而e(k)-e(k-1)要小的多的时候,系统有较大的迟滞的时候(感觉是)要防止积分的饱和.就是当系统的输出一直摇摆,不会收敛,而且摇摆的频率比较缓慢,那么我感觉可能是饱和,得限制下积分了.也就是 这个环节的累积值大小做限幅.我感觉用的时候可以最后加积分环节,看一下系统的稳态误差,如果没稳态误差,我就直接不加了,如果有的话,那么看一下稳态误差的大小在什么范围,积分限幅也就大致限制在那个范围了. 四.微分环节的滤波当系统容易收到高频信号的干扰时,微分作用会将高频信号的扰动放大(自控课本上说的),高频信号变化的较快,而微分是去求误差的变化率,所以有高频扰动信号,就会被微分作用给放大,建议对微分环节做低通滤波,通常是一阶低通滤波,讲低通滤波的帖子文章挺多的,我就不写了. 五.关于各种自适应PID包括什么神经网络PID,模糊PID,遗传算法优化PID等等,本质上都是对参数的统计和优化,但通常这些算法运算量时挺大的,写肯定可以写出来,但这个在一些嵌入式设备上运行的效率速度不是很好,会占很大的运行速度,而且要搞清楚各种自适应PID的使用范围,比如模糊PID适用于过程控制,控制个温度什么的,它不适合用来做运动控制,控制电机什么的,因为计算量较大,在单片机上还有可能会参数迟滞什么的.做个智能车类的小东西,还是用不上这些方法的,单纯PID就够了,论文里的一些自适应PID方法,不一定都是经过实际检验的,可能只是在MATLAB里做了个仿真.所以我感觉不能全信. 先把单片机，驱动芯片，陀螺仪，加速度计，电机准备好。 然后搭车，质量尽可能集中在两个车轮轴心线，陀螺仪和加速度计也要尽可能放在轴心线。 我这个是个错误的示范，质量比较分散了，但是又无可奈何，又想要零点，又想把传感器伸的远一点。。。 然后调试代码，1读取三轴加速度和角速度2姿态结算，互补滤波，四元数，卡尔曼估计器都可以。 直立控制，找出你的车的机械零点，也就是质量平衡点。最简单的方法：电机输出=p（当前角度-期望角度）＋d（角速度） 参数整定参考一下csdn的一些文吧。 你的车就立起来了。 直立控制不止这一种，也有各种双pi，双pd的串级控制等等。 然后再搞速度和方向。 可以去智能车论坛找个代码研究一下。 https://www.its203.com/article/Mark197/119486864?2022-03-13T1?2022-03-20T0 机械结构的设计决定了整个系统的极 限，硬件电路提供实现极限的方法与条件，而软件算法则是决定了整体系统能 否达到极限 https://www.its203.com/article/Mark197/119486864?2022-03-13T1 直立车模控制中三种滤波算法简单分析 https://www.eefocus.com/sensor/467379?_ga=2.136496885.490729479.1647172634-1494707267.1647172610&amp;pk_vid=3f99cf4edfd158d71647182427d8fba1 参数调试的话可以参照平衡小车之家的平衡车调试指南来进行相应的调试，里边写的还是比较好的哦https://wenku.baidu.com/view/3e5fc765bb4cf7ec4bfed00b.html 这里说一下机械结构对控制的影响。机械结构对直立控制的影响还是比较巨大的，特别是车速越快对结构的要求就越高，如果只是单纯的想立起来的话对结构的要求则没那么高。 主要遵循的原则就是机械重心越集中、越靠近两车轮轴线越好。车子除去底盘的话基本就电池和电路板了。电池是比较重的，所以可以优先考虑电池的放置，其次就是考虑电路板的放置了。重心越低越靠近车轮轴线相应的PID参数的调试就会更加的简单。反之的话则会更难。 https://www.cxy80.com/article/qq_36240874/100026227 https://its401.com/article/qq_46336588/119916341 关于直立环 https://www.guyuehome.com/24372 详细介绍如何从0开始写一个数据通信，将数据从单片机发送到上位机（或者虚拟示波器）进行数据或图像显示，以及常见问题或注意事项解答 https://www.guyuehome.com/19990 卡尔曼滤波（非矩阵）在平衡直立车直立角度测量中的应用（MATLAB模拟仿真），简单易懂，详细注释，附卡尔曼滤波(矩阵) https://blog.csdn.net/qq_44339029/article/details/105597930 直立车的控制可分为直立环、转向环、和速度环，首先要写的肯定是直立环，直立环根据姿态传感器的数据，进行直立环PID控制，输出直立环PWM，使车保持直立状态，直立车直立是基础，当然直立环也不是越硬越好，这个看个人的需要吧，关于直立的角度，经过我的多次实验，一定不要太低，过低后会带来很多不必要的麻烦（比如上坡道时车不稳，贴地，电感值异常等），一般直立环调节到原地站立在机械零点，给予下压或者上挑干扰后可以在短距离的前后移动后恢复稳定状态，这时候就可以加转向环了，之前刚开始调完直立环后，我直接加的速度环，发现虽然给两个电机相同的PWM值，但是我的车就是不跑直线，后来经过数据采集后发现，两者的转速也没有什么规律可言，通过差值PWM来使其走直线也是不可行的，索性就直接先加转向环，通过转向环的作用来纠正其偏离中心赛道的偏差，发现效果很好，调完转向环后再调速度环（同时调也行），转向环和速度环都可以看做是对直立环的干扰，推荐使用串级PID的方法 直立环：在周期性中断中采集姿态传感器的数据，比如10ms采集一次，在主函数中初始化相应的外设，比如姿态传感器MPU6050的初始化、IIC的初始化、电机PWM的初始化，然后在直立控制函数中，先调用写好的由陀螺仪和加速计计算角度的函数，分别计算出当前小车距离地面的夹角，然后采用滤波算法，获取其融合后真正使用的角度值，然后将该角度值与设定的机械零点值相减，获取偏差通过PID算法对其进行控制，调试参数使其保持直立 转向环和速度环：在周期性中断中采集电感值ADC的数据，比如10ms采集一次，在主函数中初始化相应的外设，比如编码器所用的定时器的初始化、电感值ADC通道的初始化等，然后在控制函数里，读取编码器的值，并对其进行异常数据检查及处理，适当的滤波处理，然后由左右编码器的值得到车中心的速度值与设定值做差来获取速度偏差进行控制，在输出速度环和转向环PWM时建议采用平滑输出的方式，来减小短时间内对直立环的干扰，此外关于转向环，根据在不同的赛道元素采用不同的转向环系数的方式来增强控制效果，当然这种方法虽然使得控制效果更优化，但是需要检测和判断赛道元素，调试的参数也变多了，大家根据实际情况选择是否使用，还有非常重要的一点各环PWM的输出一定要限幅，限幅值的大小也是很重要的调节参数，尤其是直立环的 MCU（Microcontroller Unit）微控制单元，核心板上的芯片 USB转TTL是可以直接转换，插头同时插在塑料壳上的 编码器分正交编码器和角度编码器(不用了)，一个是带方向的(数字显示正负表示正反)，一个不带方向 512 速度环、直立环、转向环 电子设计竞赛(4)-常用的两种PID算法 (qq.com) 基于TC264的两种电机驱动使用教程及PID算法浅析–逐飞科技 (qq.com) 陀螺仪：灵敏度高，调整舵机角度偏转 (33条消息) 平衡车直立PID调节总结_a568713197的博客-CSDN博客_平衡车pid 这个有代码参考 (33条消息) PID实践笔记-PID浅解及两轮直立车参数调试经验_尔过留香的博客-CSDN博客_方向环pid 这个很不错 (33条消息) PID实践笔记-两轮直立车的速度控制_尔过留香的博客-CSDN博客_直立车速度环 拒绝瞎调，用matlab，自动调节PID参数 - 知乎 (zhihu.com) 好方法！！ [平衡小车PID，就该这么调！！！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/119160742#:~:text=在直立环中，PID的入口参数为：平衡小车的姿态角和姿态角对应的角速度。,值得说明，MPU6050得出来的姿态角有三种：PITCH（俯仰角）、ROLL（翻滚角）、YAW（航向角） 一般来说，MPU6050都是平方且平行装在平衡小车上，总不会有人垂直装吧。)","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"计算机组成原理","slug":"笔记/计算机组成","date":"2022-01-02T08:37:04.897Z","updated":"2022-03-21T09:21:54.410Z","comments":true,"path":"2022/01/02/笔记/计算机组成/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/02/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/","excerpt":"","text":"翻译程序-&gt; 编译程序（C）和解释程序（Python）冯·诺依曼计算机的特点 计算机由五大部件组成 指令和数据以同等地位存于存储器， 可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 指令在存储器内按顺序存放 以运算器为中心 机器指令格式-&gt; 操作码+地址码PC 存放当前欲执行指令的地址， 具有计数功能（PC）+ 1 -&gt; PC PC Program Counter IR 存放当前欲执行的指令 IR Instruction Register 机器字长 CPU 一次能处理数据的位数, 与 CPU 中的 寄存器位数 有关，一般字长越长，表示范围就越大，精度也越高。 机器字长也会影响机器运算速度 存储容量存放二进制信息的总位数 主存容量： 存储单元个数MAR × 存储字长MDR ​ C = 2**MAR + MDR bit B KB MB GB 运算速度（1）与主频、执行的操作和主存本身的速度等有关（2）衡量方法&lt;1&gt; 完成一次加法或乘法所需要的时间（不合理）&lt;2&gt; TM=fi*ti（连加） 其中TM 为平均指令执行时间，fi为第i条指令占全部操作的比例，ti为第i条指令的执行时间。&lt;3&gt; 单位时间内完成的平均指令条数MIPS (million instruction per second)百万指令每秒&lt;4&gt; 执行一条指令所需要的平均时钟周期数 CPI (cycle per instruction)&lt;5&gt; 每秒执行的浮点操作数目 FLOPS（floating point operation per second）或 MFLOPS (million FLOPS)百万浮点操作每秒&lt;6&gt; 每个时钟周期数执行的指令数目 IPC（instruction per cycle）补充：GFLOPS（Giga FLOPS）每秒10亿次 109TFLOPS（Tera FLOPS）每秒万亿次 1012PFLOPS（Peta FLOPS）每秒千万亿次 1015 总线 1.片内总线 芯片内部 的总线 2.系统总线 计算机各部件之间 的信息传输线 数据总线（双向），地址总线（单向），控制总线（有出有入） 3.通信总线 用于 计算机系统之间 或 计算机系统与其他系统（如控制仪表、移动通信等）之间的通信 串行通信和并行通信 总线的性能指标 总线宽度 数据线 的根数 总线带宽 数据传输率，每秒传字节数（MBps） -&gt; 总线宽度和总线带宽总线通信控制四个阶段申请分配阶段 主模块提出申请，总线仲裁决定 寻址阶段 主模块向从模块 给出地址 和 命令 传数阶段 主模块和从模块 交换数据 结束阶段 主模块 撤消有关信息 -&gt;申请分配阶段，寻址阶段，传数阶段，结束阶段1秒=1000毫秒，1秒=1000000微妙 求总线的数据传输率 例3.1 假设总线的时钟频率为100MHz，总线的传输周期是4个时钟周期，总线的宽度为32位，求总线的数据传输率。若想把数据的传输率提高一倍，可采取什么措施？ 解：法一：1个时钟周期=1/100MHz=0.01μs总线传输周期=0.01 μs*4=0.04 μs因为总线宽度为32位（4B）所以数据传输率v=x/t=4B/(0.04 μs)=100 MBps法二：f = 100MHz -&gt; 1s有100M个时钟周期100/4 = 25 个总线周期25 * (32/8)B = 100MBps提高数据传输率方法： ① 数据宽度改为64位②总线频率变为200MHz | 比特率和波特率波特率：单位时间内传送的二进制数据的位数，单位用bps表示。比特率：单位时间内传送的二进制有效数据的位数，单位用bps表示。 例3.2 在异步串行传输系统中，假设每秒传输120个数据帧，字符格式包含1个起始位，7个数据位，1个奇校验位，1个终止位，计算波特率和比特率。解：一帧包含1+7+1+1=10位故波特率为10120=1200bps=1200波特比特率为7120=840bps=840比特 | 存储器按存取方式分类 (1) 存取时间与物理地址无关（随机访问） 随机存储器：在程序的执行过程中 可 读 可 写 RAM：Random Access Memory（一旦停电，信息丢失） 只读存储器：在程序的执行过程中 只 读 ROM：Read Only memory（存放固定不变的程序、常数、汉字库等） (2) 存取时间与物理地址有关（串行访问） 顺序存取存储器 磁带 直接存取存储器 磁盘 存储器：主存储器（RAM，ROM），Flash Memory，高速缓冲存储器（Cache)，辅助存储器 主存中存储单元地址的分配​ 小端：低地址存低字节 ​ 大端：低地址存高字节 -&gt; 大端和小端 动态 RAM 刷新 刷新（再生）：由于漏电阻的存在，电容上的电荷一般只能维持1~2ms，即使电源不掉电，信息也会自动消失，因此，必须在2ms内对所有存储单元恢复一次原状态 刷新过程实质上是先将原信息读出，再由刷新放大器形成原信息并重新写入的再生过程。 刷新周期：在规定时间内，对DRAM全部基本单元电路全部刷新一遍，通常取2ms 刷新是一行行进行的，一次刷新一行 对于 128 ×128 的存储芯片（存取周期为 0.5 gs ） ① 集中刷新（存取周期为0.5 微妙 ） 将所有行进行读写，再整体刷新128行 “死区” 为 0.5 gs ×128 = 64 gs (gs暂代微秒) “死时间率” 为 128/4 000 ×100% = 3.2% ② 分散刷新（存取周期为1 gs ） 读/写一个，同时刷新该数据 tC = tM + tR (无 “死区”) (存取周期为 0.5 gs + 0.5 gs ) ③ 分散刷新与集中刷新相结合（异步刷新） 读/写一行后，同时将该行刷新 每行每隔 2 ms 刷新一次 “死区” 为 0.5 gs 将刷新安排在指令译码阶段，不会出现 “死区” 动态 RAM 和静态 RAM 的比较 DRAM SRAM 存储原理 电容 触发器 集成度 高 低 芯片引脚 少 多 功耗 小 大 价格 低 高 速度 慢 快 刷新 有 无 主存 触发器 只读存储器（ROM） 行列选择线交叉处有 MOS 管为“1” 行列选择线交叉处无 MOS 管为“0” -&gt; PD/Progr功率下降 / 编程输入端 读出时 为 低电平 存储器与 CPU 的连接 存储器容量的扩展 (1) 位扩展（增加存储字长）-&gt; DBUS (2) 字扩展（增加存储字的数量）-&gt; ABUS -&gt; 位扩展和字扩展汉明码 2**k ≥ n + k + 1 1 :无错误发生n :错误发生在n个数据位k : 错误发生在k个校验位 高速缓冲存储器 -&gt; 命中率命中率：h = Nc/(Nc+Nm) 平均访问时间：ta = h*tc+(1-h)tm 效率：e = 访问cache的时间/平均访问时间 * 100% -&gt; Cache – 主存的地址映射​ -&gt; 直接映射 软盘硬盘区别 硬盘 软盘 速度 高 低 磁头 固定，活动，浮动 活动，接触盘片 盘片 固定盘、盘组，大部分不可换 可换盘片 价格 高 低 环境 苛刻 I/O设备与主机信息传送的控制方式程序查询方式 程序中断方式 DMA方式 I/O通道方式 I/O处理机方式 I/O 接 口接口 两个系统或者两个部件之间的交接部分为什么要设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串—并格式转换 实现电平转换 传送控制命令 反映设备的状态（“忙”、“就绪”、 “中断请求”） 接口 Interface端口 Port 端口：接口电路中的一些寄存器，用来存放数据信息、控制信息和状态信息 数据端口控制端口状态端口 若干个端口加上相应的控制逻辑才组成接口。 总线连接方式的 I/O 接口电路 (1) 设备选择线 (2) 数据线 (3) 命令线 (4) 状态线","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"数据结构的小知识点","slug":"笔记/数据结构/数据结构的一些小知识点","date":"2021-12-28T12:36:46.476Z","updated":"2022-03-20T15:45:57.456Z","comments":true,"path":"2021/12/28/笔记/数据结构/数据结构的一些小知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/28/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"随机存取、顺序存取、随机存储和顺序存储的区别1.存取结构:随机存取和顺序存取随机存取（直接存取，Random Access）指当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关微观栗子：编程语言中的数组宏观栗子：随机存取存储器（RAM：Random Access Memory,内存条）（因为RAM利用电容存储电荷的原理保存信息，所以RAM可以高速存取，且与物理地址无关。）顺序存取（Sequential Access）一种按记录的逻辑顺序进行读、写操作的存取方法，所需要的时间与该数据所在的物理地址有关。顺序存取表现为:在存取第N个数据时，必须先访问前（N-1）个数据。微观栗子：数据结构中的链表宏观栗子：录音磁带、光盘、机械硬盘里面的磁盘（磁带、光盘、磁盘上的数据分别存储在不同扇区、不同磁道上，磁盘的读写磁头通过切换不同扇区和磁道来读取物理地址不连续的数据时，该过程中要经过不同扇区和不同磁道上的无关数据，磁盘的读写磁头在切换不同扇区和磁道所需时间也不同，故为顺序存取。）2.存储结构:顺序存储、随机存储按ctrl+D键将本页面保存为书签，下次可直接打开网页；按F11(或Fn+F11)键把网页设置成全屏，学习效率更高。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"新核心知识点","slug":"英语/CET4/新核心知识点","date":"2021-12-27T06:29:35.146Z","updated":"2021-12-27T07:21:28.288Z","comments":true,"path":"2021/12/27/英语/CET4/新核心知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/27/%E8%8B%B1%E8%AF%AD/CET4/%E6%96%B0%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.When she realized most of China’s top causes of death could be tied to smoking, she began pushing officials to tackle the problem. tackle/solve/resolve/address/handle/tackle/deal with 2.Its population rises and falls unpredictably, destroying clumps of pinewood as it peaks which then regenerate/grow again as the bug recedes/die away. 树皮甲虫的繁殖不可预测，或暴增，或减弱，当树皮甲虫繁殖高峰时会杀害大量松树，只有甲虫消退后松树才能再生。 recede: to move back from a previous point 自原处后退 3.… says that the current outbreak is “unprecedented in history”: a natural background-noise disturbance has become a major outbreak. adj. 前所未有的，史无前例的；（大小、数量、程度等）前所未知的，空前的 n. 干扰，扰乱；骚乱，动乱；失调，紊乱 4.Other parts of North America have also been affected, but the damage in British Columbia is particularly severe and particularly troubling in a province whose economy is dominated by timber. dominated /ˈdɒmɪneɪtɪd/adj. 占主导地位的；强势的；受控的v. 控制，支配；处于支配地位（dominate 的过去式和过去分词 ） n.林木 北美的其他地方也受到了影响，但是英属哥伦比亚的损失是相当严重的，尤其对一个依赖木材产业的省伤害更甚。 5.It could be caused by the higher temperatures that now prevail in northern areas, … V-I If a proposal, principle, or opinion prevails, it gains influence or is accepted, often after a struggle or argument. 占上风 V-I If a situation, attitude, or custom prevails in a particular place at a particular time, it is normal or most common in that place at that time. 盛行; 普遍存在 V-I If one side in a battle, contest, or dispute prevails, it wins. 获胜 6.Its aim was to “achieve stabilization of greenhouse-gas concentrations in the atmosphere at a level that would prevent dangerous anthropogenic interference with the climate system”. 《联合国气候变化框架公约》的目标是“为全面控制二氧化碳等温室气体排放，阻止人类对气候系统的危险干预。” n. 稳定；稳定化 adj. 人为的；[人类] 人类起源的 interference with 干涉；妨碍，打扰 7.According to the Intergovernmental Panel on Climate Change(政府间气候变化专门委员会), the body set up to establish a scientific consensus on what is happening, heat waves, droughts, floods and serious hurricanes have increased in frequency over the past few decades. consensus n. a general agreement; the opinion of most of the people in a group （意见等的）一致,一致同意 build a consensus 达成一致 reach a consensus 取得一致 unspoken consensus 默契 Extreme weather/natural disaster heat wave, drought, flood, hurricane 热浪，干旱，洪水，飓风 earthquake, mudslide, typhoon, cyclone, blizzard/snow storm暴风雪, storm, hail冰雹，landslide, sandstorm, tsunami, volcanic eruption 地震,泥石流,台风,飓风,暴风雪/暴风雪暴风雪,风暴,雹冰雹,山体滑坡,沙尘暴,海啸,火山喷发 snowslide,avalanche,acid rain 雪崩,雪崩,酸雨","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[]},{"title":"Python小知识点","slug":"Python/细小知识点","date":"2021-12-22T03:03:46.564Z","updated":"2022-04-03T06:17:03.112Z","comments":true,"path":"2021/12/22/Python/细小知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/22/Python/%E7%BB%86%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.复数我们把形如z=a+bj（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，j称为虚数单位。 一个复数时一对有序浮点数 (x,y)，其中 x 是实数部分，y 是虚数部分。 Python 语言中有关复数的概念： 1、虚数不能单独存在，它们总是和一个值为 0.0 的实数部分一起构成一个复数 2、复数由实数部分和虚数部分构成 3、表示复数的语法：real+imagej 4、实数部分和虚数部分都是浮点数 5、虚数部分必须有后缀j或J 2.and,or(有0,逻辑数据时进行c/c++中的&amp;&amp;与运算(1,0)，or取前and取后) 10 and 20 -&gt; 20 10 or 20 -&gt; 10 10 &amp; 20 -&gt; 0 （01010&amp;10100=00000）每位进行与运算 10 | 20 -&gt;30 逻辑数据，是一种操作数类型。是用来表示二值逻辑中的 “是”与 “否” 、或称 “真”与 “假” 两个状态的数据。 3.Python浮点数占4个字节4.pass 表示空语句5.encode异常报错-&gt; AttributeError: module ‘sys’ has no attribute ‘setdefaultencoding Python3字符串默认编码unicode, 所以sys.setdefaultencoding也不存在了,所以去掉，sys.setdefaultencoding -&gt; UnicodeDecodeError: ‘ascii’ codec can’t decode byte …… 默认执行的decode(‘ascii’)执行为decode(‘utf-8’) #python3不能使用 12345import sysreload(sys)sys.setdefaultencoding(&#x27;utf8&#x27;) #python3的话reload函数被移到了importlib库 使用需要使用from importlib import reload 一下或者import importlib 然后使用 importlib.reload() -&gt; ‘gb18030’ codec can’t decode byte 0x80 in position 10: incomplete multibyte sequence（解决方法） 出现这种报错的问题原因是：我们要解码的数据不符合我们期望的类型，所以有时候我们知道数据的编码格式，但是其中有一些其他格式的数据，这样我们就要将其他的格式数据进行忽略，否则解码会报错，程序运行不下去,在decode 中添加’ignore’参数即可data_str = ** data.decode(‘gb18030’,’ignore’).encode(‘utf8’) 读取文件的时候也可以使用ignore 1file = open(path, encoding=’gb18030’, errors=’ignore’) -&gt; 真正解决Windows下UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte 0xff in position 0错误的方法 在open函数encoding参数中设置正确的文件编码。 123456789101112# coding=utf-8def check_charset(file_path): import chardet with open(file_path, &quot;rb&quot;) as f: data = f.read(4) charset = chardet.detect(data)[&#x27;encoding&#x27;] return charset your_path = 你的文件路径with open(your_path, encoding=check_charset(your_path)) as f: data = f.read() print(data) 6.CSV读取大文件报错-&gt; _csv.Error: field larger than field limit 该问题出现在用csv读取文件的时候，出现大字段，导致超过字段默认限制，而无法读取。因此，需要在使用csv读取文件前，先设置下csv字段显示大小。 1234csv.field_size_limit(500 * 1024 * 1024)for i in range(1, 5): # 21 print(&#x27;开始读取第%d个&#x27; % i) csv_reader = csv.reader(open(&quot;E:\\\\数据备份\\\\处理\\\\zc (%d).csv&quot; % i,encoding=&#x27;utf-8&#x27;)) 7.判断key是否存在方法一：使用自带函数实现 print(dict.contains(“b”)) 方法二：使用in方法 ‘a’ in d /d.key() 方法三：dict.get(‘a’,’没有该key‘)避免了dict[‘a’]没有就报错 判断字典key的个数: len(dict) 8.列表越界报错-&gt; IndexError: list index out of range 错误原理及解决方法（python） 报错原因：（1）下标超出范围，(2)list是空的，没有一个元素 源文档末尾存在一行空行可以用try…except模块跳过该错误，或删除末尾的空行 9.plt.figure()的使用1figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True) num:图像编号或名称，数字为编号 ，字符串为名称 figsize:指定figure的宽和高，单位为英寸； dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80 1英寸等于2.5cm,A4纸是 21*30cm的纸张 facecolor:背景颜色 edgecolor:边框颜色 frameon:是否显示边框 10.Python 读写 tsvTSV文件和CSV的文件的区别是：前者使用\\t作为分隔符，后者使用,作为分隔符tsv和csv都是以纯文本文件存储的电子表格格式，两者都可以用文本编辑器、Sublime等程序打开，同时他们又是电子表格形式，可以用Excel等电子表格程序打开。tsv和csv被广泛用于计算机存储简单的电子表格数据（貌似csv用的更频繁些~但是有些老外喜欢用tsv格式……嗯……坑货！） 12345678#TSV：tab separated values；即“制表符分隔值”，用制表符分隔数据name,agename age张三 20李四 30#CSV： comma separated values；即“逗号分隔值”，用逗号分隔数据张三,20李四,30 1.python库 2.用csv包读取tsv文件 1234567891011121314#第一步：修改csv包的解析文件模式import csvcsv.register_dialect(&#x27;mydialect&#x27;,delimiter=&#x27;\\t&#x27;,quoting=csv.QUOTE_ALL)#csv中register_dialect()方法是创建自己的解析模式，第一个参数是模式名称（自己取名），第二个参数用于配置分隔符（这里我们把分隔符改成制表符，这样便可以解析tsv格式）#第二步：用自己的解析模式读入tsv文件with open(&#x27;myFile.tsv&#x27;,) as csvfile: file_list = csv.reader(csvfile,&#x27;mydialect&#x27;) for line in file_list: print line #通过csv中的reader()方法解析tsv文件便可，第一个参数是要解析的文件，第二个参数是要使用的解析模式（这里用刚刚配置好的mydialect解析文件）#第三步：注销自己的解析模式csv.unregister_dialect(mydialect) 3.使用pandas： 123456#使用pandas读取tsv文件train=pd.read_csv(&#x27;test.tsv&#x27;, sep=&#x27;\\t&#x27;)#如果已有表头，则可使用header参数train=pd.read_csv(&#x27;test.tsv&#x27;, sep=&#x27;\\t&#x27;, header=0)#如果已有主键列train=pd.read_csv(&#x27;test.tsv&#x27;, sep=&#x27;\\t&#x27;, header=0, index_col=&#x27;id&#x27;) 11.pyplot绘制的图中中文不会正常显示-&gt; RuntimeWarning: Glyph 22270 missing from current font. font.set_text(s, 0, flags=flags) 1234解决办法：添加一句：plt.rcParams[“font.sans-serif”] = [“SimHei”]再添加一句：plt.rcParams[‘axes.unicode_minus’] = False之后便可以正常显示中文以及负号 12.1e6 = 100000013.深浅拷贝 14.缓存机制 15.切片的原理16.Python取整 17.可视化图简介 子图等 直方图 箱线图 小提琴图 条形图 折线图 1,2 堆叠柱状图 散点图 气泡图 饼状图 热力图 地图等(pyecharts库使用) 18.os.path.exists()os即operating system（操作系统），Python 的 os 模块封装了常见的文件和目录操作。 os.path模块主要用于文件的属性获取,exists是“存在”的意思，所以顾名思义，os.path.exists()就是判断括号里的文件是否存在的意思，括号内的可以是文件路径。 存在返回True；如果不存在，返回的则是FALSE。 19.os.mkdir()与os.makedirs()的区别os.mkdir(path)，他的功能是一级一级的创建目录，前提是前面的目录已存在，如果不存在会报异常。当你的目录是根据文件名动态创建的时候，你会发现他虽然繁琐但是很有保障，不会因为你的一时手抖，创建而创建了双层或者多层错误路径 os.makedirs(path),可以一次创建多级目录，哪怕中间目录不存在也能正常的（替你）创建，想想都可怕，万一你中间目录写错一个单词……… 20.创建文件和文件夹-&gt; import os1234567891011121314151617def mkdir(path): path = path.strip()# 去除首位空格 path = path.rstrip(&#x27;\\\\&#x27;) # 去除尾部 \\ 符号 isExists = os.path.exists(path)#判断一个目录是否存在:存在True/不存在False if not isExists: print(&#x27;文件夹不存在！&#x27;) os.makedirs(path)#创建多级目录，不存在会自动创建（有些缺陷，不太严谨） print(&#x27;创建成功！&#x27;) return True else: print(&#x27;文件已存在！&#x27;) return False path = os.getcwd() #可以查看py文件所在路径dictname = &#x27;Dict&#x27;dictpath = path + &#x27;\\\\&#x27; + dictnamemkdir(dictpath) 1234567891011121314#&quot;x&quot; - 创建 - 不存在将创建一个文件，如果文件存在则返回错误#&quot;a&quot; - 追加 - 会追加到文件的末尾#&quot;w&quot; - 写入 - 会覆盖任何已有的内容with open(filepath,&#x27;w&#x27;) as file: file.write(info)file = open(filepath,&#x27;w&#x27;)file.write(info)file.fiutterfile.close()file = open(filepath,&#x27;r&#x27;)print(file.read())file.close() -&gt; import csv12345with open(filepath,&#x27;w&#x27;) as file: writer = csv.writer(file) writer.writerow(item[itemkind_name[i]])with open(filepath) as fp: reader = csv.reader(fp) 21.Matplotlib设置坐标轴 xlim():设置x坐标轴范围 ylim():设置y坐标轴范围 xlabel():设置x坐标轴名称 ylabel():设置y坐标轴名称 xticks():设置x轴刻度 yticks():设置y轴刻度 22.plt.scatter()的使用 1,21scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, , data=None, *kwargs) x, y : 相同长度的数组，数组大小(n，)，也就是绘制散点图的数据； s：绘制点的大小，可以是实数或大小为(n，)的数组， 可选的参数 ； c：绘制点颜色， 默认是蓝色’b’ ， 可选的参数 ； marker：表示的是标记的样式，默认的是’o’ ， 可选的参数 ； cmap：当c是一个浮点数数组的时候才使用， 可选的参数 ； norm：将数据亮度转化到0-1之间，只有c是一个浮点数的数组的时候才使用， 可选的参数 ； vmin , vmax：实数，当norm存在的时候忽略。用来进行亮度数据的归一化 ， 可选的参数 ； alpha：散点的透明度，实数，0-1之间， 可选的参数 ； linewidths：散点的边缘线宽 ； edgecolors：散点的边缘颜色； 23.生成1到100的列表并打印的方法12345678910111213#使用list生成list1 = list(range(1,100+1))print(list1)#使用列表生成式list2 = [i for i in range(1,100+1)]print(list2)#使用for循环list3 = []for i in range(1,100+1): list3.append(i)print(list3) 24.numpy.random.randn()的使用numpy.random.rand(d0,d1,…,dn) rand函数根据给定维度生成[0,1)之间的数据，包含0，不包含1 dn表格每个维度 返回值为指定维度的array 25.plt作图时出现横坐标或者纵坐标乱序的解决方法 可以看到Y轴坐标已经乱掉了。出现这种情况的主要原因在于：Y轴的值不是int或float这种数据，而是 string这种类型，导致转换成数据的时候出错。 123456789fig =plt.figure(100)x=SDFfile[&#x27;ID&#x27;] #元素类型：&lt;class &#x27;numpy.int64&#x27;&gt;y=SDFfile[&#x27;logBB&#x27;] #元素类型：&lt;class &#x27;str&#x27;&gt; 会导致y轴顺序发生变化#改成下面这种代码，把元素类型改一下就好y=[np.float64(i) for i in SDFfile[&#x27;logBB&#x27;]]plt.scatter(x, y)fig.show() 12#我使用的list(map(float, mylist)) 26.plt.plot()的使用123#不显示y轴,x轴plt.xticks([]) # 不显示x轴plt.yticks([]) # 不显示y轴 27.在文本中寻找关键词(已知)1 2 3 28.字符串是否为关键字1 2 29.创建关键词1 2 3 4 30.502 Bad Gateway出现502的原因是：对用户访问请求的响应超时造成的 解决办法： 1.提高 Web 服务器的响应速度，也即减少内部的调用关系，可以把需要的页面、素材或数据，缓存在内存中，可以是专门的缓存服务器 ，也可以Web服务器自身的缓存，提高响应速度； 2.网络带宽的问题，则对传输的数据包进行压缩处理，或者向IDC申请增加带宽； 3.属于内部网络的故障或设置问题，也即内部网络拥塞，可能内部存在大量的数据调用或交互造成的，则需要优化内部网络传输或协议； 4.数据库的数据读取造成前端服务器 ，响应用户的请求变慢，那么必须提高数据库的处理能力，若是只读业务可以增加数据缓存的模式 或者增加数据库备机，分散读压力； 若是写的压力，则可以考虑延迟写的模式，想这个时候做数据写分散肯定来不及","categories":[{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"}],"tags":[]},{"title":"数据结构笔记","slug":"笔记/数据结构/数据结构","date":"2021-12-09T05:52:57.914Z","updated":"2022-03-27T15:50:18.870Z","comments":true,"path":"2021/12/09/笔记/数据结构/数据结构/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"第二、三、四章 线性表字符串：线性表特例 多维数组：线性表推广（严格不是） 线性表（表）：具有相同类型的数据元素的有限序列 -&gt; 将元素类型限制为字符：字符串（串）：零个或多个字符组成的有限序列 串长：串中所包含的字符个数 空串：长度为 0 的串 子串：串中任意个连续的字符组成的子序列(包含空串)主串：包含子串的串子串的位置：子串的第一个字符在主串中的序号 串的存储结构 字符串通常采用顺序存储，即用数组存储 模式匹配-&gt; BF算法模式匹配：在主串 S 中寻找子串 T 的过程，T 也称为模式 如果匹配成功，返回 T 在 S 中的位置；否则返回 0 模式匹配问题有什么特点？ （1） 算法的一次执行时间：问题规模通常很大，常常在大量信息中进行匹配 （2） 算法改进所取得的积累效益：模式匹配操作经常被调用，执行频率高 数组的存储结构 如何存储（多维）数组呢？ 数组没有插入和删除操作，所以，不用预留空间，适合采用顺序存储 按行优先：先存储行号较小的元素，行号相同者先存储列号较小的元素 按列优先：先存储列号较小的元素，列号相同者先存储行号较小的元素 -&gt; KMP算法 i 0 1 2 3 4 5 6 char[i] a b a b a b c next -1 0 0 1 2 3 4 nextval -1 0 -1 0 -1 0 4 一、过程： 求next值： 1.两个固定值：char[0]_next=-1; char[1]_next=0（一个，没有匹配的，长度为0） 2.开始求：char[2]匹配出错，前面a!=b（两组字符不同），故next=0(重头开始） char[3]匹配出错，前面有aba, a(char[3]前面的a)和a（匹配必从第一个开始）相同，字符a长度为1，故next=1 char[4]匹配出错，前面有abab,ab和ab相同，长度为2，故next=2 char[5]匹配出错，前面有ababa，aba和aba(123和345)相同，长度为3，故next=3 char[6]匹配出错，前面有ababab,abab和abab(1234和3456)相同,长度为4，故next=4 求nextval值： 1.一个固定值：char[0]_nextval=-1 2.开始求：char[1]_next=0(char[0]=a), a!=b,所以nextval=char[1]_next char[2]_next=0(char[0]=a),a==a,所以nextval=char[0]_nextval 同理可得…… 二、总结： 求next的值： 看当前字符的前面的一组字符是否有相似的一组字符（开头开始）与之相同，取其最大长度作为next的值 求nextval值（修正值）： 当前字符的next值(索引值)所指向的字符是否和当前字符相同：相同则修正值为当前字符的next值所指向的字符的修正值；不同则去当前字符的next值 三、例子再来一个： 0 1 2 3 4 5 6 7 8 9 a b c a b c a b a a next -1 0 0 0 1 2 3 4 5 1 nextval -1 0 0 -1 0 0 -1 0 5 1 求next值：next0=-1,next1=0 a!=b,next2=0; abc不可能(ab!=bc),next3=0; 0==3,next4=1; 01==34,next5=2;012==345,next6=3; abca==abca(1234==3456),next7=4; 01234==34567,next8=5 1==8,next9=1 求nextval值：nextval0=-1 b!=char[next1]=a, nextval=next1=0 c!=char[next2]=a, nextval=next2=0 a==char[next3]=a,nextval=nextval0=-1 同理可得…… 这个思路也可以： [(7条消息) KMP算法中计算next值和nextval的值_threecat.up的博客-CSDN博客_kmp算法next修正值计算方法https://blog.csdn.net/qq_43919400/article/details/103736457]( 特殊矩阵的压缩存储什么是特殊矩阵？ 特殊矩阵：矩阵中很多值相同的元素并且它们的分布有一定的规律 特殊矩阵如何压缩存储？ 为值相同的元素分配一个存储空间 特殊矩阵压缩存储后有什么要求吗？ 保证随机存取，即在O(1)时间内寻址 -&gt; 对称矩阵的压缩存储如何压缩存储对称矩阵呢？ 只存储下三角部分的元素 aij 在一维数组中的下标 k = i×(i-1)/2+ j-1 对称矩阵压缩存储后的寻址方法 对于下三角中的元素aij（i ≥ j）：k＝i×(i-1)/2＋j -1 对于上三角中的元素aij（i＜j），因为aij＝aji，则 k＝j×(j-1)/2＋i -1 -&gt; 三角矩阵的压缩存储如何压缩存储三角矩阵呢？ 下（上）三角部分的元素；相同的常数只存储一个 下三角矩阵压缩存储后的寻址方法 对于下三角中的元素aij（i ≥ j）：k＝i×(i -1)/2 + j-1 对于上三角中的元素aij（i＜j）：k＝n×(n + 1)/2 -&gt; 对角矩阵的压缩存储对角矩阵：所有非零元素都集中在以主对角线为中心的带状区域中，所有其他元素都为零 稀疏矩阵的压缩存储什么是稀疏矩阵？ 稀疏矩阵：矩阵中有很多零元素，并且分布没有规律 稀疏矩阵如何压缩存储？ 只存储非零元素，零元素不分配存储空间 如何只存储非零元素？ 三元组：（行号，列号，非零元素值） -&gt; 三元组顺序表 三元组表：将稀疏矩阵的非零元素对应的三元组所构成的集合，按行优先的顺序排列成一个线性表 -&gt; 十字链表第五章 树和二叉树树的前序遍历等价于二叉树的前序遍历！树的后序遍历等价于二叉树的中序遍历！ 先访问该结点打标记，再孩子入队列-&gt;图结构时，不会造成重复入队先访问左右孩子入队列，再打标记 -&gt;图结构时会造成重复入队 逻辑关系线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继； 树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子 图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接 树树：n个结点(数据元素)的有限集合 ，当 n＝0 时，称为空树；任意一棵非空树 T 满足以下条件：（1）有且仅有一个特定的称为根的结点；（2）当 n＞1 时，除根结点之外的其余结点被分成 m（m &gt; 0）个互不相交的有限集合 T1,T2,… , Tm，其中每个集合又是一棵树，并称为这个根结点的子树。 ​ *树的定义是采用递归方法 互不相交的具体含义是什么？结点：结点不能属于多个子树边：子树之间不能有关系 *互不相交-&gt;没有回路-&gt;树结构具有层次性 结点的度：结点所拥有的子树的个数树的度：树中各结点度的最大值叶子结点：度为 0 的结点，也称为终端结点分支结点：度不为 0 的结点，也称为非终端结点 *在树结构中，逻辑关系表现为双亲——孩子 路径：结点序列 n1, n2, …, nk 称为一条由 n1 至 nk 的路径，当且仅当满足如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k） 路径长度：路径上经过的边的个数在树结构中，路径是唯一的祖先、子孙：如果有一条路径从结点 x 到结点 y，则 x 称为 y 的祖先，而 y 称为 x 的子孙 结点所在层数：根结点的层数为 1；对其余结点，若某结点在第 k 层，则其孩子结点在第 k+1 层 树的深度（高度）：树中所有结点的最大层数树的宽度：树中每一层结点个数的最大值树的遍历-&gt;前序，中序，后序和层序树的遍历：从根结点出发，按照某种次序访问树中所有结点，并且每个结点仅被访问一次 树的存储结构-&gt;双亲，孩子，孩子兄弟表示法实现树的存储结构，关键是什么? 如何表示树中结点之间的逻辑关系 什么是存储结构? 数据元素及其逻辑关系在存储器中的表示 树中结点之间的逻辑关系是什么? 思考问题的出发点：如何表示结点的双亲和孩子 二叉树-&gt;斜树，满二叉树，完全二叉树二叉树： n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树是度为 2 的树吗？ 二叉树是度小于等于 2 的树吗？ 二叉树有什么特点？（1）每个结点最多有两棵子树（2）二叉树是有序的，其次序不能任意颠倒 左斜树：所有结点都只有左子树的二叉树右斜树：所有结点都只有右子树的二叉树斜树：左斜树和右斜树的统称 斜树有什么特点呢？（1）每一层只有一个结点（2）结点个数与其深度相同 斜树是树结构的特例，是从树结构*退化成了线性结构 满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上的二叉树 满二叉树有什么特点呢？（1）叶子只能出现在最下一层（2）只有度为 0 和度为 2 的结点（3）在同样深度的二叉树中结点个数最多（4）在同样深度的二叉树中叶子结点个数最多 满二叉树是树结构的特例，是最丰满的二叉树 完全二叉树：在满二叉树中，从最后一个结点开始，连续去掉任意个结点得到的二叉树 完全二叉树有什么特点呢？ （1）叶子结点只能出现在最下两层且最下层的叶子结点都集中在二叉树的左面（2）完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子（3）深度为 k 的完全二叉树在 k-1 层上一定是满二叉树（4）在同样结点个数的二叉树中，完全二叉树的深度最小 二叉树性质-&gt; n0＝n2＋1性质 5-1：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2＋1 n＝n0＋n1＋n2 ;n＝n1＋2n2＋1;n0＝n2＋1 -&gt; 第i层：2**(i-1)个结点性质 5-2：二叉树的第 i 层上最多有2i-1个结点（i≥1） -&gt;最多有2**(k-1)个结点性质 5-3：一棵深度为 k 的二叉树中，最多有 2k-1个结点 深度为 k 且具有 2k-1个结点的二叉树一定是满二叉树 -&gt;深度：log n下取整+1性质 5-4：具有 n 个结点的完全二叉树的深度为[ logn] +1/log(n+1)上取整 -&gt;双亲i/2，左孩子2i，右孩子2i+1性质 5-5：对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，对于任意的序号为 i（1≤i≤n）的结点（简称结点 i），有：（1）如果 i＞1，则结点 i 的双亲结点的序号为 i/2，否则结点 i 无双亲结点（2）如果 2i≤n，则结点 i 的左孩子的序号为 2i，否则结点 i 无左孩子（3）如果 2i+1≤n，则结点 i 的右孩子的序号为2i+1，否则结点 i 无右孩子 二叉树的遍历-&gt;前序，中序，后序和层序O(n)123456789101112131415161718192021222324252627282930313233343536373839404142434445template &lt;typename DataType&gt;class BiTree&#123;public: BiTree( )&#123;root = Creat(root);&#125; ~BiTree( )&#123;Release(root);&#125; void PreOrder( )&#123;PreOrder(root);&#125; void InOrder( )&#123;InOrder(root);&#125; void PostOrder( )&#123;PostOrder(root);&#125; void LeverOrder( ); private: BiNode&lt;DataType&gt; *Creat(BiNode&lt;DataType&gt; *bt); void Release(BiNode&lt;DataType&gt; *bt); void PreOrder(BiNode&lt;DataType&gt; *bt); void InOrder(BiNode&lt;DataType&gt; *bt); void PostOrder(BiNode&lt;DataType&gt; *bt); BiNode&lt;DataType&gt; *root; &#125;;template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; :: PreOrder(BiNode&lt;DataType&gt; *bt) &#123; if (bt == nullptr) return; //递归调用的结束条件 else &#123; cout &lt;&lt; bt-&gt;data; //访问根结点bt的数据域 PreOrder(bt-&gt;lchild); //前序递归遍历bt的左子树 PreOrder(bt-&gt;rchild); //前序递归遍历bt的右子树 &#125;&#125;template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; :: LeverOrder( )&#123; BiNode&lt;DataType&gt; *Q[100], *q = nullptr; int front = -1, rear = -1; if (root == nullptr) return; Q[++rear] = root; while (front != rear) &#123; q = Q[++front]; cout &lt;&lt; q-&gt;data; if (q-&gt;lchild != nullptr) Q[++rear] = q-&gt;lchild; if (q-&gt;rchild != nullptr) Q[++rear] = q-&gt;rchild; &#125;&#125; 二叉树的存储结构-&gt;顺序存储结构顺序存储结构的要求是什么？用一组连续的存储单元依次存储数据元素，由存储位置表示元素之间的逻辑关系 二叉树的顺序存储结构是用一维数组存储二叉树的结点，结点的存储位置（下标）应能体现结点之间的逻辑关系——父子关系 缺点：浪费存储空间二叉树的顺序存储结构一般仅存储完全二叉树 1234567void PreOrder(char a[],int i,int n)&#123; if(i&gt;=n)return; cout&lt;&lt;a[i]&lt;&lt;endl; PreOrder(a,2*i,n); PreOrder(a,2*i+1,n);&#125; -&gt;二叉链表二叉链表：二叉树的每个结点对应一个链表结点，链表结点存放结点的数据信息和指示左右孩子的指针 叶子结点的标志？ 左右孩子指针均为空 n 个结点的二叉链表有多少个空指针？ 2n-(n-1) = n+1 个空指针 如何由一种遍历序列生成该二叉树？ 扩展二叉树：将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值如 ‘#’ -&gt;扩展二叉树123456789101112131415template &lt;typename DataType&gt;BiNode&lt;DataType&gt; *BiTree&lt;DataType&gt; :: Creat(BiNode&lt;DataType&gt; *bt)&#123; char ch; cin &gt;&gt; ch; //输入结点的数据信息，假设为字符 if (ch == ‘#’) bt = nullptr; //建立一棵空树 else &#123; bt = new BiNode&lt;DataType&gt;; bt-&gt;data = ch; bt-&gt;lchild = Creat(bt-&gt;lchild); //递归建立左子树 bt-&gt;rchild = Creat(bt-&gt;rchild); //递归建立右子树 &#125; return bt;&#125;扩展二叉树的前序遍历序列：A B # D # # C # # 森林森林：m（m≥0）棵互不相交的树的集合 森林的遍历：按照某种次序(前序（根）、后序（根）)依次遍历构成森林的 m（m≥0）棵树 最优二叉树叶子结点的权值：对叶子结点赋予的一个有意义的数值量 二叉树的带权路径长度：从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和 最优二叉树（哈夫曼树）：给定一组具有确定权值的叶子结点，带权路径长度最小的二叉树 最优二叉树有什么特点?（1）权值越大的叶子结点越靠近根结点（2）只有度为 0 和度为 2 的结点，不存在度为 1 的结点 -&gt;哈夫曼算法1选取权值最小的两棵二叉树进行合并，重新排序，再选权值最小的两棵二叉树进行合并 -&gt;哈夫曼编码编码：给每一个对象标记一个二进制位串来表示一组对象 等长编码：用长度相等的二进制位串表示一组对象 编码的目的是什么? 数字化（编码效率取决于编码长度） 不等长编码：表示一组对象的二进制位串的长度不相等 设计不等长编码时，必须考虑解码的唯一性 前缀编码：在一组编码中，任一编码都不是其它任何编码的前缀 ​ *前缀（无歧义）编码保证了在解码时不会有多种可能 线索二叉树 线索：指向前驱和和后继结点的指针 线索二叉树：加入线索的二叉树 缺点：指针和线索无法区分-&gt;加标记 0孩子,1前驱后继 以一定规则将二叉树中的结点排列成一个线性序列，使每个结点(除第一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继 优点：如果右链中中序后继，左链中中序前趋，则中序遍历的效率高 第六章 图单链表的逆置，寻找叶子结点，树的遍历，折半查找，哈夫曼树 逻辑关系线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继； 树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子 图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接 连通图（无向图）连通顶点：在无向图中，如果顶点vi和顶点vj(i≠j)之间有路径，则称顶点vi和vj是连通的 连通图：在无向图中，如果任意两个顶点都是连通的，则称该无向图是连通图 连通分量：非连通图的极大连通子图：含有极大顶点数，依附于这些顶点的所有边 强连通图、强连通分量（有向图）强连通顶点：在有向图中，如果从顶点vi到顶点vj和从顶点vj到顶点vi均有路径，则称顶点vi和vj是强连通的 强连通图：在有向图中，如果任意两个顶点都是强连通的，则称该有向图是强连通图 强连通分量：非强连通图的极大连通子图 图的遍历图的遍历：从图中某一顶点出发访问图中所有顶，并且每个结点仅被访问一次 在图中，如何选取遍历的起始顶点？解决方案：将图中的顶点按任意顺序排列起来， 从编号最小的顶点开始 从某顶点出发能访问其他所有顶点吗？解决方案：多次调用图遍历算法 如何避免遍历不会因回路而陷入死循环？解决方案：附设访问标志数组visited[n] 采用什么次序依次访问图中所有顶点？ -&gt; 深度优先遍历和广度优先遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061深度优先遍历DFTraverse（类似树的前序遍历）广度优先遍历BFTraverse（类似树的层序遍历） template &lt;typename DataType&gt;void MGraph&lt;DataType&gt; :: DFTraverse(int v) &#123; cout &lt;&lt; vertex[v]; visited[v] = 1; for (int j = 0; j &lt; vertexNum; j++) if (edge[v][j] == 1 &amp;&amp; visited[j] == 0) DFTraverse( j );&#125;template &lt;typename DataType&gt;void MGraph&lt;DataType&gt; :: BFTraverse(int v) &#123; int w, j, Q[MaxSize]; //采用顺序队列 int front = -1, rear = -1; //初始化队列 cout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v; //被访问顶点入队 while (front != rear) //当队列非空时 &#123; w = Q[++front]; //将队头元素出队并送到v中 for (j = 0; j &lt; vertexNum; j++) if (edge[w][j] == 1 &amp;&amp; visited[j] == 0 ) &#123; cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j; &#125; &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: DFTraverse(int v)&#123; int j; EdgeNode *p = nullptr; cout &lt;&lt; adjlist[v].vertex; visited[v] = 1; p = adjlist[v].firstEdge; while (p != nullptr) &#123; j = p-&gt;adjvex; if (visited[j] == 0) DFTraverse(j); p = p-&gt;next; &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: BFTraverse(int v) &#123; int w, j, Q[MaxSize]; int front = -1, rear = -1; EdgeNode *p = nullptr; cout &lt;&lt; adjlist[v].vertex; visited[v] = 1; Q[++rear] = v; while (front != rear) &#123; w = Q[++front]; p = adjlist[w].firstEdge; while (p != nullptr) &#123; j = p-&gt;adjvex; if (visited[j] == 0) &#123; cout &lt;&lt; adjlist[j].vertex; visited[j] = 1; Q[++rear] = j; &#125; p = p-&gt;next; &#125;&#125; 存储结构-&gt; 邻接矩阵和邻接表 1234567891011struct EdgeNode&#123; int adjvex; EdgeNode *next;&#125; ;template &lt;typename DataType&gt; struct VertexNode&#123; DataType vertex; EdgeNode *firstEdge;&#125;; 边表中的结点表示什么？对应图中的一条边 设图有n个顶点e条边，邻接表的空间复杂度是多少？O(n+e) 如何求顶点 v 的度？顶点 v 的边表中结点的个数 12345p = adjlist[v].firstEdge; count = 0;while (p != nullptr)&#123; count++; p = p-&gt;next;&#125; 如何求顶点 v 的所有邻接点?顶点 i 的边表中的所有结点 123456p = adjlist[v].firstEdge; while (p != nullptr)&#123; j = p-&gt;adjvex; //j是v的邻接点 p = p-&gt;next;&#125; 最小生成树（无向图）-&gt; Prim算法O(n2)生成树：连通图的生成树是包含全部顶点的一个极小连通子图（含有n-1条边） 生成树的代价：在无向连通网中，生成树上各边的权值之和 最小生成树(Minimum Spanning Tree) ：在无向连通网中，代价最小的生成树 贪心算法的应用：Prim算法，Kruskal算法和Boruvka算法 Prim算法：先构造满足条件的候选最短边集，再查找最短边 Kruskal算法：先查找最短边，再判断是否满足条件 123456Prim算法 O(n2)*每步添加一条边及其相连的顶点(min)到一棵树，从而逐步生成最小生成树(可能不唯一，但代价唯一)通过第一个顶点，将第一个顶点和其他顶点的权值进行比较，找到最小边邻接的顶点该邻接顶点和剩余顶点比较，比第一个顶点和其权值小就替换进数组，找到更新后的最小边的邻接顶点……（创建一个数组存放当前顶点和邻接顶点的边，当邻接顶点和当前顶点的边权值更小就更新。每次找出更新的最小边，并将选择出的顶点从数组中标除去） -&gt; Kruskal算法O(elog2e)12345678910？Kruskal算法 O(elog2e)*将所有的点放入，每次选最小的边，但不能形成回路图采用什么存储结构呢？ 边集数组表示法Kruskal算法在图中存在相同权值的边时也有效如何存储连通分量呢？ 并查集（并查集：集合中的元素组织成树的形式：（1）查找两个元素是否属于同一集合：所在树的根结点是否相同（2）合并两个集合——将一个集合的根结点作为另一个集合根结点的孩子）*如何判断两个顶点是否位于同一个连通分量呢？*如何合并两个连通分量呢？ 最短路径（有向图）-&gt; Dijkstra算法O(n2)最短路径：非带权图——边数最少的路径 最短路径：带权图——边上的权值之和最少的路径 路径上第一个顶点称为源点；最后一个顶点称为终点 对于非带权图，如何求最短路径？ 广度优先遍历 对于带权图，如何求最短路径？ 123Dijkstra算法 O(n2)针对一个源点，求出中转（mini)；将中转和剩下点连接，比剩下点与上一个点的路径短就替换，再在整合好的表中找到最短的当前最短路径中最小路为最终最短路（路径长度递增） (dist,path) v1 v2 v3 v4 {v0} (10,’v0v1’) (**,’ ‘) (30,’v0v3’) (100,’v0v4’) {v0v1} (60，‘v0v1v2’) (30,’v0v3’) (100,’v0v4’) {v0v1v3} (50,’v0v3v2’) (60,’v0v3v4’) {v0v1v3v2} (60,’v0v3v2v4’) {v0v1v3v2v4} 疑惑性很大，如何当点&gt;2时，进行判断不同可能性（类似Prim但必须包含源点得出的路径？） -&gt; Floyd算法O(n3)123456Floyd算法 O(n3)*可有权值为负，但不能有负的回路(*)-&gt; 使用邻接矩阵初始化path0（两点相连的所有可能性9种，以a/b/c为源点），在两点间插入a(保持源点不变，以a为源点的一行可忽视,6种；如果值比原来小就替换)形成path1,在path1中插入b……同理……dist保存路径权值，path保存路径中的点-&gt;该算法将所有的可能性都计算出来，只有最后一步有效 有向无环图-&gt; AOV网和拓扑排序 O(n+e)什么是工程？工程有什么共性？几乎所有的工程都可以分为若干个称作活动的子工程某些活动之间通常存在一定的约束条件 AOV网（顶点表示活动的网）：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系 AOV网（activity on vertex network） AOV网中出现回路意味着什么？活动之间的优先关系是矛盾的 拓扑序列:v2必须满足v0和v1才能成立（栗子：排课系统），可能不唯一 拓扑排序：对一个有向图构造拓扑序列的过程 12345678图采用什么存储结构呢？ 邻接表在邻接表中，如何求顶点的入度？ 顶点表中增加入度域如何查找没有前驱的顶点？ 设置栈或队列成功标志：排完后，所有点都排序（NULL），不剩余点 1.重复下述操作，直到输出全部顶点，或AOV网中不存在没有前驱的顶点 1.1从AOV网中选择一个没有前驱的顶点并且输出； 1.2从AOV网中删去该顶点，并且删去所有以该顶点为尾的弧； -&gt;AOE网和关键路径什么是工程？工程有什么共性？几乎所有的工程都可以分为若干个称作活动的子工程活动之间存在某些制约关系每个活动通常需要一个持续的时间 源点：整个工程的开始点，其入度为0终点：整个工程的结束点，其出度为0 AOE网（边表示活动的网）：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间 AOE网（activity on edge network） AOE网的性质：（1）只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生（2）只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始 AOE网能够解决什么问题？（1） 完成整个工程至少需要多少时间?（2）为缩短完成工程所需的时间， 应当加快哪些活动? 关键路径：AOE网中从源点到终点的最长路径关键活动：关键路径上的活动 不按期完成关键活动就会影响整个工程的进度；换言之，要缩短整个工期，必须加快关键活动的进度 1234567891011121314151617如何求关键路径呢？ 求关键活动如何求关键活动呢？关键活动为什么是关键的？关键活动的开始时间不能推迟-&gt;关键活动的最早开始时间和最晚开始时间相等 1. 计算各个活动的最早开始时间和最晚开始时间 2. 计算各个活动的时间余量，时间余量为 0 即为关键活动设带权有向图 G=(V，E)含有 n 个顶点 e 条边，设置 4 个一维数组：（1）事件的最早发生时间 ve[n] -&gt; 从v0=0开始到该顶点的相加ai和取最大（正序计算）（2）事件的最迟发生时间 vl[n] -&gt; 从v3=10开始到该点减去ai被减差取最小（倒序计算）（3）活动的最早开始时间 ae[e] -&gt; 等于ve[以ai为出度的事件] （4）活动的最晚开始时间 al[e] -&gt; vl[以ai为入度的事件]-ai-&gt; al[i]-ae[i]=0 取为0的相连作为关键路径书P205 表格 一个关键活动的延期，会影响延误工期；一个关键活动的提前，不一定提前工期 第七章 查找技术基本概念关键码：可以标识一个**记录(数据元素、结点、顶点)**的某个数据项 键值：关键码的值 主关键码：可以唯一标识一个记录的关键码 次关键码：不能唯一标识一个记录的关键码 什么是查找？查找：在相同类型的记录构成的集合中找出满足给定条件的记录 静态查找 ：不涉及插入和删除操作的查找 静态查找只注重查找效率，适用于： （1）查找集合一经生成，便只对其进行查找，而不进行插入和删除操作 （2）经过一段时间的查找之后，集中地进行插入和删除等修改操作 动态查找 ：涉及插入和删除操作的查找 动态查找要求插入、删除、查找均有较好的效率，适用于：查找与插入和删除操作在同一个阶段进行 例如：当查找成功时，要删除查找到的记录 当查找不成功时，要插入被查找的记录 查找结构 ：面向查找操作的数据结构 ，即查找基于的数据结构 查找基于的数据模型是什么？集合 集合 ：线性表：适用于静态查找，顺序查找、折半查找等技术 树 表：适用于动态查找，二叉排序树的查找技术 散列表：静态查找和动态查找均适用，采用散列技术 查找算法的性能如何评价查找算法的效率呢？和关键码的比较次数 关键码的比较次数与哪些因素有关呢？ 平均查找长度ASL：查找算法进行的关键码比较次数的数学期望值 查找算法线性表1234567891011121314151617/*顺序查找（线性查找）O(n)改进：设置“哨兵”，就是待查值，放在查找方向的尽头处，免去了每一次比较后都要判断查找位置是否越界不要求元素的有序性，插入、删除的性能是O(1)查找性能是O(n)*/ int LineSearch :: SeqSearch2(int k) &#123; int i = n; data[0] = k; while (data[i] != k) i--; return i;&#125; 12345678910111213141516171819202122232425262728293031323334353637/*折半查找（对半查找、二分查找）在有序表（假设为递增）中，取中间记录作为比较对象，若给定值与中间记录相等，则查找成功；若给定值小于中间记录，则在有序表的左半区继续查找；若给定值大于中间记录，则在有序表的右半区继续查找。不断重复上述过程，直到查找成功，或查找区域无记录，查找失败查找性能是O(log2n)为保证元素的有序性，插入、删除要移动元素，性能是O(n)*///非递归算法：int LineSearch :: BinSearch1(int k) /*查找集合存储在r[1]~r[n]*/&#123; int mid, low = 1, high = n; /*初始查找区间是[1, n]*/ while (low &lt;= high) /*当区间存在时*/ &#123; mid = (low + high) / 2; if (k &lt; data[mid]) high = mid - 1; else if (k &gt; data[mid]) low = mid + 1; else return mid; /*查找成功，返回元素序号*/ &#125; return 0; /*查找失败，返回0*/&#125;//递归算法：int LineSearch :: BinSearch2(int low, int high, int k) &#123; int mid; if (low &gt; high) return 0; /*递归的边界条件*/ else &#123; mid = (low + high) / 2; if (k &lt; data[mid]) return BinSearch2(low, mid-1, k); else if (k &gt; data[mid]) return BinSearch2(mid+1, high, k); else return mid; /*查找成功，返回序号*/ &#125;&#125; 判定树（折半查找判定树）：描述折半查找判定过程的二叉树 查找成功的平均比较次数 = (1×1+2×2+3×4+4×4)/11 = 3查找不成功的平均比较次数 = (3×4+4×8)/12 = 11/3 树表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*二叉排序树（二叉查找树）：或者是一棵空的二叉树，或者是具有下列性质的二叉树：（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值（3）它的左右子树也都是二叉排序树中序序列是元素升序排序存储：二叉链表*/class BiSortTree &#123;public: BiSortTree(int a[ ], int n); ~ BiSortTree( ) &#123;Release(root);&#125; BiNode&lt;int&gt; *InsertBST(int x) &#123;return InsertBST(root, x);&#125; void DeleteBST(BiNode&lt;int&gt; *p, BiNode&lt;int&gt; *f ); BiNode&lt;int&gt; *SearchBST(int k) &#123;return SearchBST(root, k);&#125;private: BiNode&lt;int&gt; *InsertBST(BiNode&lt;int&gt; *bt , int x); BiNode&lt;int&gt; *SearchBST(BiNode&lt;int&gt; *bt, int k); void Release(BiNode&lt;DataType&gt; *bt); BiNode&lt;int&gt; *root; &#125;;BiSortTree::BiSortTree(int a[ ], int n)//构造函数&#123; root = nullptr; for (int i = 0; i &lt; n; i++) root = InsertBST(root, a[i]);&#125;BiNode&lt;int&gt; * BiSortTree :: SearchBST(BiNode&lt;int&gt; *bt, int k)//查找函数&#123; if (bt == nullptr) return nullptr; if (bt-&gt;data == k) return bt; else if (bt-&gt;data &gt; k) return SearchBST(bt-&gt;lchild, k); else return SearchBST(bt-&gt;rchild, k);&#125;BiNode&lt;int&gt; * BiSortTree::InsertBST(BiNode&lt;int&gt; *bt, int x)//插入函数&#123; if (bt == nullptr) &#123; BiNode&lt;int&gt; *s = new BiNode&lt;int&gt;; s-&gt;data = x; s-&gt;lchild = s-&gt;rchild = nullptr; bt = s; return bt; &#125; else if (bt-&gt;data &gt; x) bt-&gt;lchild = InsertBST(bt-&gt;lchild, x); else bt-&gt;rchild = InsertBST(bt-&gt;rchild, x);&#125;二叉排序树的性能分析最坏情况：退化为线性查找最好情况：相当于折半查找平均情况：O(n) ~ O(logn) 123456789101112/*平衡二叉树（二叉排序树优化-&gt;深度尽可能小的二叉排序树）二叉排序树的深度取决于给定查找集合的排列，即结点的插入顺序平衡因子：该结点的左子树的深度减去右子树的深度平衡二叉树：或者是一棵空的二叉排序树，或者是具有下列性质的二叉排序树：（1）根结点的左子树和右子树的深度最多相差 1;（2）根结点的左子树和右子树也都是平衡二叉树在平衡二叉树中，结点的平衡因子是1、0 或 -1平衡调整扁担原理：将根结点看成是扁担中肩膀的位置*/ 123456/*B树：一棵m阶的B树或者为空树，或者为满足下列特性的m叉树：（1）每个结点至多有 m 棵子树；（2）根结点至少有两棵子树；（3）除根结点和叶子结点外，所有结点至少有[m/2]棵子树；*/ 散列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*散列的基本思想：在记录的关键码和存储地址之间建立一个确定的对应关系，通过计算得到待查记录的地址。散列表：采用散列技术存储查找集合的连续存储空间。散列函数：将关键码映射为散列表中适当存储位置的函数。散列地址：由散列函数所得的存储地址。冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj)。同义词：ki 和 kj 相对于H 称做同义词。 散列是一种完整的存储结构吗？散列只是通过记录的关键码定位该记录，没有完整地表达记录之间的逻辑关系，所以，散列主要是面向查找的存储结构散列技术能进行范围查找吗？适合于哪种类型的查找？散列技术最适合回答的问题是：如果有的话，哪个记录的关键码等于待查值除留余数法 H(key)=key mod p 处理冲突的方法——开放定址法（数组）对于给定的关键码key执行下述操作：（1）计算散列地址：j = H(key)（2）如果地址 j 的存储单元没有存储记录，则存储key对应的记录；（3）如果在地址 j 发生冲突，则寻找一个空的散列地址，存储key对应的记录；闭散列表：用开放定址法处理冲突得到的散列表线性探测法：从冲突位置的下一个位置起，依次寻找空的散列地址。堆积：非同义词对同一个散列地址争夺的现象二次探测法：以冲突位置为中心，跳跃式寻找空的散列地址。Hi=(H(key)＋di) % m （di = 12,-12,22,-22,… , q2,-q2(q≤m/2)）处理冲突的方法——拉链法（链表）对于给定的关键码key执行下述操作：（1）计算散列地址：j = H(key)（2）将key对应的记录插入到同义词子表 j 中；（头插）同义词子表：所有散列地址相同的记录构成的单链表。开散列表：用拉链法处理冲突得到的散列表。开散列表中存储同义词子表的头指针，开散列表不会出现堆积现象散列查找的性能分析散列技术的查找性能取决于什么？产生冲突后，仍然是给定值与关键码进行比较影响冲突产生的因素有什么？（1）散列函数是否均匀（2）处理冲突的方法 （3）散列表的装填因子α= 表中填入的记录数/散列表的长度*/ 堆积：非同义词对同一个散列地址争夺的现象冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj) 第8章 排序技术基本概念1.排序：给定一组记录（数据元素，结点，顶点）的集合{r1,r2,…,rn}，其相应的关键码分别为{k1,k2,…,kn},将这些记录排列为{s1,s2,…,sn}的序列，使得相应关键码满足升序或降序。 （排序是对线性结构(数据模型)的一种操作） 2.排序码(关键码)：排序的依据 3.趟：在排序过程中，将待排序的记录序列扫描一遍称为一趟 4.排序算法的稳定性：相同关键码的相对次序经过排序保持不变 （只是算法的一种属性，且有具体算法决定） 排序算法的性能（1）时间性能：排序算法在各种情况（最好、最坏、平均）下的时间复杂度。 例如，基于比较的内排序在排序过程中的基本操作： ① 比较：关键码之间的比较； ② 移动：记录从一个位置移动到另一个位置。 （2）空间性能：排序过程中占用的辅助存储空间。 辅助存储空间是除了存放待排序记录占用的存储空间之外，执行算法所需要的其他存储空间。 直接插入排序 希尔排序 起泡排序 快速排序 简单选择排序 堆排序 归并排序 最好情况 正序 O(n) O(n**1.3) 正序 O(n) 都是中值O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 最坏情况 逆序 O(n**2) 逆序 O(n**2) 正序逆序O(n**2) O(n2) O(nlog2n) O(nlog2n) 平均情况 O(n**2) O(n**2) O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 稳定性 稳定 不稳定 稳定 不稳定 不稳定 不稳定 稳定 时间性能 O(n**2) 取决于增量序列O(n**2) ~ O(nlogn) O(n**2) O(nlog2n) O(n**2) O(nlog2n) O(nlog2n) 空间性能 O(1) O(1) O(1) O(log2n)~O(n) O(1) O(1) O(n) 稳定性：直接插入排序，起泡排序，归并排序不稳定：希尔排序，快速排序，简单选择排序，堆排序 直接插入排序、简单选择排序和起泡排序 O(n2)堆排序、快速排序和归并排序 O(nlogn)希尔排序的时间性能取决于增量序列，介于O(n2)和O(nlog2n)之间 缓冲区应该是一个（队列 ）结构。最快的速度挑选出前10个最大的，采用（ 堆排序）方法最好。（插入排序）可能会出现下面情况：在最后一趟开始之前，所有元素都不在最终位置上 基于比较的内排序-&gt; 比较排序-&gt; 直接插入排序直接插入排序：（正序）循环第k个元素开始，向前进行比较，大于就交换，小于就结束，进行下一趟-&gt;排序过程：前面k-1个有序，后面无序 -&gt; 希尔排序希尔排序：步数为n，序列中索引值为(i += n)的作为一个子序列进行排序，再全部进行直接插入排序 -&gt; 交换排序-&gt; 起泡排序起泡排序：两两比较，如果反序则交换-&gt;排序过程：后面k+1个有序，前面无序 -&gt; 快速排序快速排序：将第一个作为中间值mid，从后向前找比mid小的，找到就交换位置，i++；从前向后开始找比mid大的，找到就交换位置,j–；重复，直到i&gt;=j,一趟结束。i==j的位置作为下一趟的mid值。 -&gt; 选择排序-&gt; 简单选择排序简单选择排序：将前n-1个值和和该值后面的进行比较，找到最小的和该值交换-&gt;排序过程：前面k-1个有序，后面无序 -&gt; 堆排序堆排序：（大根堆）原顺序作为层序形成完全二叉树，从大到小的根节点和孩子比较，小就交换，然后向下继续比较小就交换直到底。形成大根堆，将第一个0和最后一个n-1交换，剩下n-1个进行堆调整。 -&gt; 归并排序归并排序：将序列划分为2*n个子序列进行单独排序，两两合并为2n-1个子序列进行单独排序,一直到合并为一个排序 -&gt; 基数排序基数排序：栗子三位数排序(有明显界限的个位，十位，百位)创建10个链表09,先后按个位按09连进属于的表头（尾插），结束将其串成整表，再按照十位做相同的行为","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SET4-翻译","slug":"英语/CET4/CET4--翻译","date":"2021-12-06T08:36:53.397Z","updated":"2021-12-17T15:19:39.748Z","comments":true,"path":"2021/12/06/英语/CET4/CET4--翻译/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4/CET4--%E7%BF%BB%E8%AF%91/","excerpt":"","text":"Hot pot has a history of over 2000 years in China.Initially,it was only popular in the coldest places,and subsequentlg became widely accepted in many other areas,where distinct regional variations developed.When eating a hot pot,family and friends sit around the table with a steaming hot pot at the center of it.People can put their preferred meal,seafood,vegetables and ingredients into the pot to cook their own food,and chat to their hearts’ content over a good meal.","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"SET4-作文","slug":"英语/CET4/CET4--作文","date":"2021-12-06T02:20:39.278Z","updated":"2021-12-17T15:19:33.154Z","comments":true,"path":"2021/12/06/英语/CET4/CET4--作文/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4/CET4--%E4%BD%9C%E6%96%87/","excerpt":"","text":"“use”类栗子：the use of translation apps is becoming increasingly popular 开篇可概述翻译应用程序在生活中的应用越发广泛的趋势 主体部分应详述其应用情况：多种应用场景 + 积极影响/受欢迎的原因 结尾部分可总结其带来的益处，适当提及不足之处和未来的应用或发展趋势 The use of translation apps is becoming increasely popular.They play a critical role in removing the language barrier in this globalized era(全球化的时代). These technology tools are especially helpful for both leisure(闲暇，业余时间；休闲活动) and business travelers. With the ever-increasing input of linguistic data,these apps will be smarter and thus applied in broader fields.As a result,more people will enjoy the fruits of this technological advance. 123456789101112131415词汇：machine translation 机器翻译convert speech to text 将语音转换为文字voice/speech recognition 语音识别voice translator apps 语音翻译应用程序photo/camera translator apps 拍照翻译应用程序an offline multilingual dictionary 可离线使用的多语种词典translate text into multiplelanguages 将文本翻译为多种语言offer instant speech-to-speech translation 提供即使语音翻译foreign/overseas/international travel 出国游have a short conversation with locals 与当地人进行简短的交流bridge the information and communication gap 架起信息与沟通的桥梁keep in contact with clients/customers worldwide 与世界各地的客户保持联系conduct trade negotiations with foreign companies 与外国公司进行贸易洽谈 “changes of ways”类栗子：Changes in the way of education 开篇可铺陈背景，引入对“教育方式发生改变”的探讨，或开门见山，直接概述教育领域发生的变化 主体部分应详细阐述具体变化（今昔对比/当下变化）+ 这些变化的成因/影响 结尾部分可对这些变化简要作评，或展望未来的发展趋势并呼吁人们做好准备 The past decades have witnessed a surge of technological innovations.Irresistibly useful and convenient,tools resulting from these innovations have prompted(促使，导致) radical changes in our lifestyle.Among them,changes in the way of education are some of the most noticeable ones. Nowadays,the computer and projector(投影仪) have become indispensable(不可或缺的) in every classroom.Compared with old-fashioned chalk and talk(板书口授),multimedia-based teaching enables teachers to demonstrate what they found hard or even impossible in the past,such as abstract geometric(几何的) concepts and bizarre lanscapes. The trend of distance learning is another significant change.With a wide array of(大量各式各样的) online courses to choose from,teaching and learning are no longer confined(局限) to the classroom or school day.Students now can attend lectures by prominent(著名的，卓越的) professors in far-away locations in their own bedroom anytime they want.And all this happens just within a few clicks. Although these changes are by and large(大体上) constructive,they do have a couple of unintended(无意地的，意想不到的) negative consequences.For instance,distance learning is likely to lead to a detached(冷淡的，疏远的) relationship between the student and the teacher. 其他作文： the changes of communication:At one time,people communicated primarily face to face and via letters.Nowadays,however,the advancement of network technology offers us more options such as text messaging,voice calling and video chatting.These changes bring a great deal of benefits.Perhaps the most obvious one is convenience.Irrespective of (不考虑，不管)the geographical locations and time zones,we can now keep in touch with each other through the Internet at a previously unimaginable speed. This increased efficiency,in turn,leads to reduced costs.For instance,the advent of video conferencing(视频会议) allows people to meet each other without having to worry about travel expenses. More excitingly,changes in the way of communication make possible remote “importance of quality”类栗子：Self-confidence:an importance factor for success 开篇可概述没有自信的危害来强调自信的重要性 主体部分：自信的定义+例子论证自信是成功的必要因素 结尾部分总结其带来的益处 If we don’t feel self-confident about our ability,we will not be able to take up a task and get it done.If we dont’t have confidence in our competence,we won’t be courageous enough to face up to a challenge.Only when we think we are capable of doing something,will we be able to succeed in doing that. Self-confidence is different from complacency(自满).It is solidly(坚固地，坚硬地) based on our knowledge,judgement,abilities and skills.To develop it takes years of learning and to consolidate(巩固) it takes years of practicing.Self-confidence means more than mental preparedness(准备就绪).It serves as an indication(象征，暗示，迹象) of professional readiness(敏捷；准备就绪).It is also an expression of intellectual maturity. With self-confidence,we are able to firmly take each step in our journey of life(坚定地迈出人生旅途中的每一步) and it is self-confidencet that has been paving the way to the ultimate(最终的，最后的) goal of our professional career(为我们职业生涯的终极目标铺路). 新闻写作：记叙类报道栗子：a news report to your campus newspaper (on a volunteer activity organized by Student Union to assist elderly people in the neighbor hood) 开篇应为导语，介绍活动的时间、地点及参与者（基本事实+抓人眼球） 主体部分应介绍活动目的及具体内容/流程 结语部分应总结活动的意义、影响或收获，也可简要提及活动举办的大背景 ​ 记叙方式：时间循序（暖场-&gt;活动主体-&gt;结束）​ 空间顺序（不同区域举办的活动依次参观）​ 组别顺序（一人负责一件事，另一组人负责另一件事）​ 记叙类新闻写作五个基本要素5W（when,where,what,why,who）+ 1H:how The students,organized by the Student Union,visited a senior center close to our school on Wednesday,June 12th,for the purpose of providing help for the elderly there. Our volunteer were warmly welcomed when they arrived there at about 1 p.m.They presented the elderly with fresh fruits before dividing themselves into two groups,one responsible for cleaning and the other for chatting.It took nearly an hour for half a dozen volunteers to sweep and mop the floor and then wash all the windows.The rest were,meanwhile,listening attentively to the elderly who looked back on their good old days(过去美好时光) with a certain amount of nostalgia(n.怀旧，念旧).The activity ended with a certain lecture on how to send voice messages and make video calls on WeChat. “I’m impressed with their vigor(n.活力，精力) and optimism(n.乐观),”says one of the volunteers.”And I’m glad that the entire afternoon we spent together means something to them.They expressed their gratitude for our company,which may be,in my opinion,what they need most.” “whether正反观点观点”类栗子：Whether technology will make people lazy With the continus progress of science and technology,great changes have taken place in the way people live.This progress has brought great convenience to people.Nonetheless,it has also made many people lazy.First,the widespread use of Internet technology,especially smart phones ,allows people to know what is happening outside without going out.People just need to pick up a mobile phone,connect to the Internet,and open the corresponding software,then the major events of the world will be caught in their eyes.They no longer have to open books and newspapers or go out to get information.Second,the appearance of takeaways has also made people lazier.People can get whatever they want to eat without cooking for themselves or even getting up to go to a restaurant…To sum up ,the ever-changing technology brings convenience to people,but it also make people laxy.Consequently,while improving the quality of life,people should learn to use science and technology correctly instead of relying on it blindly. 栗子：Whether violent video games online will cause students violent behaviors With the progress of the times, the use of smart phones, computers and other electronic products is becoming more and more common among students. And many students like violent video games online. This raises a question, whether violent online games will lead to students’ violent tendency? From my point of view, the answer is no.First of all, through online games, students can relieve the pressure in real life and find like-minded people to communicate with, which will reduce students’ irritable tendency in real life. In this way, these video games will not increase students’ violent tendency. On the contrary, to a certain extent they will reduce students’irritable behaviors. Moreover, online video games are virtual and the violent elements in the games are unrealistic, and these violent scenes can hardly be implemented in real life. So the violence in online games has little impact on real life.To sum up, from my point of view, violent online games will not lead to students’ violent tendency. The development of science and technology is bound to change people’s way of life, which will bring about a lot of influence on people’s life. It is only necessary for us to learn to use it properly. 栗子：Are People Becoming Addicted to Technology? Numerous studies claim that addiction to technology is real and it has the same effect on the brain as drug addiction. First, no one can deny the fact that technology is of great importance to our daily life. However, as a matter of fact, its adverse effect should not be ignored by the public.Confronted with such phenomenon, we should take a series of effective measures to cope with the situation. For one thing, it is obvious that the universitiesand mass media should increase publicity and educationto encourage people to apply technology more appropriately. For another, we should bear in mind that we are supposed to take a reasonable attitude toward modern technology, andmake its advantages over-weigh disadvantages.Personally, I believe that only by doing so can we better ourselves in every aspect of our life. Consequently, I’m confident that a bright future is awaiting us because technology makes our life rich and colorful. 高级替换：1234end/finish with sth;end/finish by doing sth(do sth at last) 以某事收尾mean something/a lot to sb;matter to sb(be important to sb) 对某人来说很重要show/express one&#x27;s gratitude/appreciation for (doing) sth(thanks for (doing) sth) 对某事表示感谢 单词12345678副词应用：solidly(坚固地，坚硬地)/firmlymore than + n./no longer/by and largeincreaselyespeciallyAs a result/For instanceIrresistibly 12345同义转换：feel self-confident about our ability/have confidence in our competencetake up a task/face up to a challengeare capable of doing/be able to take/be courageous enough to facemean/ an indication(象征，暗示，迹象) of/an expression of","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"SET4-词汇","slug":"英语/CET4/CET4--词汇","date":"2021-12-06T01:41:11.803Z","updated":"2021-12-17T13:18:51.349Z","comments":true,"path":"2021/12/06/英语/CET4/CET4--词汇/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4/CET4--%E8%AF%8D%E6%B1%87/","excerpt":"","text":"2021/12/13 生词 翻译 airline,carrier,aviation,aircraft,cabin seat n.航空公司，航线；客运航空公司；航空；飞机；机舱座位 definitely，alternatively，incredibly,possibly adv.肯定，当然，确实；确切地，明确地，清楚地 adv.或者，要么 adv.极端的，及其；难以置信地 adv.可能，或许；尽可能，尽量 budget adj.廉价的 v.安排开支，编制预算 across the globe 全球 integrate various shades/tones of blue 融合(v.合并,成为一体;加入,融入群体)各种色调(n.)的蓝 aircraft interior n.内部，室内设计 reinforce v.加固，强化 induce/endure v.引起，诱导/忍耐，忍受 bold adj.大胆的 the principal aim adj.最重要的，主要的 n.大学校长，学院院长；本金，资本；主角 domestic，earthy adj.家庭的；朴实的 become the color of choice 首选的，广受欢迎的 to the point of complete inaction 达到完全不作为的程度 imitate v.模仿，效仿 rebell v.反叛；叛逆；反对（rebell against） indication n.表明，显示；象征 be unable and unprepared to endure the long haul 无法或不愿意忍受长期的煎熬 adj.不愿意的，不甘心的，未准备好的 长期艰巨的任务。 inaction n.不行动，不采取措施；无作为 destructive adj.破坏性的，毁灭性的 proposition n.提议；主张，观点；（美国）法律修正议案；事情，问题，任务 熟词 翻译 coincidence n.（令人吃惊的）巧合，巧事；同时存在；（意见）相同，一致 credit card,debt,loan,mortgage,financial difficulty,financial stress n.信用卡；债务；贷款；按揭贷款，房屋抵押贷款；经济困难 trust,efficiency,quietness,coolness,reflection,calm n.信任；高效；平静；冷静；沉思；沉着 domestic,natural,earthy adj.居家，自然，质朴 conservative,agreeable,corporate adj.保守的；令人愉快的；公司的 trustworthy adj.可靠的，值得信赖的 natural adj.天然的，自然地；正常的，意料之中的；天生的，本能的 n.有天赋的人，擅长做某事的人 associated v.-ed 联想，联系；交往；表明支持，表示同意 adj.相关的；有联系的；联合的 psychology n.心理学，心理课堂 leading adj.杰出的 brand n.品牌 recognizable adj.易于识别的，可承认的 primary concern maximize v.使增加到最大限度；充分利用 softened adj.柔和的 traditional adj.传统的，习俗的，惯例地；守旧地 simply stick 就这么沿用下来 adv.仅仅，不过；确实，简直；简单地，简朴地；不过，只是 v.经久驻留 symbolize v.象征，代表 encounter v.遭遇，遇到 convince v.坚信，深信，确信 argue v.争吵，争辩（argue with sb about/over sth)；论证，说理（argue for/against sth) the normal ups and downs of investment markets 投资市场正常的涨涨跌跌 adj.正常的，一般的；精神正常的，意识健全的 n.常态，通常标准，一般水平 起伏，涨跌，兴衰 gateway，household，pattern n.大门入口，途径;家庭，一家人;模式 statement n.声明，陈述；结算单，报表（financial statement财务报表） era n.souvenir n.stall n.fruit n.advance n.phrase bookintroduce v.indispensable adj.adequate adj.casual adj.lingual,linguistic adj.when it comes to …find the right way to deal with sthmake a big effort to do sthbe not as good as sb accessible adj.account v.adaptation n.appropriately adv.considerable adj.effective adj.ladder n.miseread v.nomination n.overlook v.promote v.senior n.submission n.suggest v.thankfullg adv.separate v.utter v.pioneering adj.pursuit n.in one’s lifetimeplay an importannt part/role in …higher educationadvance and promote gender equalityundergraduate n./adj.postgraduate n./adj.make upacademic staffat senior levelsstark adj.median adj. knit(knitting,knitter) v.(crocheter)stitch v.handiwork n.crafts n.throughout college prep.thereafter adv.hook v.on one’s way to doing sthrestore v./ renewal n.council n.swell the ranksin honer ofpioneer n.repetitive adj.induce a relaxed statebe associated withinitial learning curveheart ratetangible adj.self-esteem/self-respect n.singular adj.boost my spiritshundreds of thousands of …routinely adv.fulfillment n.a prematurely born babyintensive care unit(ICU)stick withcope withprompte v.go well adv.replace A with Bconduct v.heal for v.autoimmune adj.mindless adj.stiff agj.disorder n.significant improvementslessen their fearswellness n.therapeutic adi.respondent n.clinically adv.persistent adj.redirect their focus/ divert their attention from their painprocessat onceregister pain signalssample n.be engaged in …diminished adj.speculate v.nerve pathwaysintellectually adv.sustained adj.maximize v.like-minded adj.for onestay away from tobaccoenhance v.prolong one’s lifekeenly adv.relieve stresssuffer mild cognitive damage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869vanish v.prospect n.there is almost no hard evidence for ... other than ...pilot adj.autopilot n.the bulk ofa shifting of gearsterrifying adj.a rebirth n.choose purpose over happinessgive priority tofar from gloomyphase v.identity n.built up your resourcesprecisely adv.foundation n.secure adj.sowing n.reap v.the runleap v.venture n.measured adj.haste n.energetic adj.presidential candidatelifespan n.narrativedescent cn.a turning pointtake full advantage ofmisrepresent real liferosy adj.burdensome adj.undergo(undergoes) v.turn offdone adj.science fictionincreasingly adv.absorb v.fragmented adj.bizarre adj.popular notionretain v.replay v.a neural virtual realityvivid adj.sleep disorderssleepwalk v.physical movementvideotape the subjectsdraw v.integrate ... into10-fold adj.respondent,candidate,subject,participantbedtime n.a napa study sessionodd n.intensified adj.systematize v.substitute ... with","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"数据结构 PTA","slug":"刷题/PTA","date":"2021-12-04T15:24:25.366Z","updated":"2022-03-21T09:24:12.339Z","comments":true,"path":"2021/12/04/刷题/PTA/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E5%88%B7%E9%A2%98/PTA/","excerpt":"","text":"第一章 绪论判断题1-1 数据元素是数据的最小单位。F(数据项) 1-2 数据的逻辑结构是指数据的各数据项之间的逻辑关系。F（数据元素之间） 1-3 数据结构概念包括数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三个方面。T 1-4 数据结构的抽象操作的定义与具体实现有关。F 1-5 算法和程序没有区别，在数据结构中二者是通用的。F 1-6 数据结构包括数据对象集以及它们的逻辑结构和物理结构，还包括与数据对象相关联的操作集，以及实现这些操作的高效的算法。T 选择题（错题：2-9,2-13）2-1 在 Data_Structure = (D，R)中，D 是（ ）的有限集合。 A.数据元素 2-2 以下关于数据结构的说法中错误的是（ ）。 A.数据结构相同，对应的存储结构也相同 2-4 算法分析的目的是( ) C.分析算法的效率以求改进 2-5 算法分析的两个主要方面是( ) A.空间复杂度和时间复杂度 2-6 采用链结构存储线性表时，其地址（ ）。 B.连续不连续都可以 2-7 一个正确的算法应该具有 5 个特性，除输入、输出特性外，另外 3 个特性是（ ）。 A.确定性、可行性、有穷性 2-8 算法的时间复杂度取决于（ ） C.问题的规模和待处理数据的初态 2-9 以下数据结构中，哪一个是线性结构（ ） D.串 2-10 以下数据结构中，（ ）是非线性数据结构 B.字符串 2-11 算法的时间复杂度与（ ）有关。 A.问题规模 2-12 以下程序段的空间复杂度为 12345int a = 1, b = 1, i;for (i=0; i&lt;=10; i++) &#123; b += a; a = b - a;&#125; B.O(1) 2-13 下列程序段的时间复杂度是（ ）。 1234count=0;for(k=1;k&lt;=n;k*=2) for(j=1;j&lt;=n;j++) count++; C.O*(nlog2*n) 2-14 下面说法中，错误的是（ ）。 ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间 ⅱ.在相同规模n下，复杂度为O(n)的算法在时间上总是优于复杂度为O(2n)的算法 ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界 ⅳ.同一个算法，实现语言的级别越高，执行效率越低 C.ⅰ,ⅳ 2-15 算法的计算量的大小称为算法的____。 B.复杂度 2-16 在下面的程序段中，对x的赋值语句的频度为（ ） 123for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++) x=x+1; C.O(n2) 2-17 下面程序段的时间复杂度是 ( ) 123i ＝ 0；while（i&lt;=n） i = i * 3； D.O(log3n) 填空题（错题：4-1, 4-4, 4-6，4-7，4-10）4-1 算法效率的比较 假设为解决某问题而设计的若干算法的时间复杂度分别为： A) O(n)B) O(n2)C) O(log2​n)D) O(nlog2​n)E) O(2n)F) O(n​)G) O(n!)H) O(1)I) O(n**n​)J) O(n**n) 这些算法按效率由高到低的顺序是 HCFADIBEGJ 4-2 基本术语 数据 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。 4-3 数据结构的数学定义 数据结构的数学定义为一个二元组： D**S=(D,R) 其中：D 是数据元素的有限集，R 是 D 上的关系 的有限集。 4-4 存储结构存储结构包括数据元素的表示和关系的表示。 4-5 基本术语 抽象数据类型 一般指由用户定义的、表示应用问题的数学模型，以及定义在该模型上的一组操作。 4-6 在数据结构中，数据的逻辑结构分为线性结构和非线性结构 。 4-7 数据结构由数据的逻辑结构、存储结构 和运算|操作三部分组成。 4-8 算法的特性 一个算法必须满足以下五个重要特性： (1) 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都可以有穷有时间内完成。 (2) 确定性 一个算法中每一条指令必须有确切的含义。 (3) 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 (4) 输入一个算法有零个或多个输入。 (5) 输出一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果。 4-9 基本术语 数据元素是数据的基本单位，数据项是数据的不可分割最小单位。其中：前者在计算机中通常作为一个整体进行考虑和处理，它可以由一个或多个后者组成。 4-10 数据的实例 观察下面的表格： 学号 姓名 性别 语文 数学 物理 化学 英语 总分 15160101 王克强 男 87 95 93 76 84 435 15160102 刘铭志 男 77 82 80 97 95 431 15160103 孙勇 男 78 85 87 86 65 401 15160104 李瀚东 男 93 82 72 75 95 417 15160105 赵敏 女 95 90 88 82 96 451 15160106 张毅 男 78 76 65 81 80 380 15160107 柳青 女 82 91 82 84 85 424 15160108 蔡文婷 女 85 78 80 86 95 424 整张表格称为一个 数据对象，其中每一行称为一个 数据元素，任意一行中的每一个栏目称为一个数据项。 4-11 沃斯的名言 瑞士科学家尼古拉斯·沃斯(Niklaus Wirth)有一句在计算机领域里人尽皆知的名言： 算法 + 数据结构 = 程序 编程题7-1 求最小值和次小值 (25 分)123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int main()&#123; int n,x; cin&gt;&gt;n; cin&gt;&gt;x; if(n&gt;1)&#123; int mini = x; int mini2 = x; int a[n]=&#123;x&#125;; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; if(mini&gt;a[i])mini=a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; if(a[i]==mini)continue; if(mini2==mini)mini2=a[i]; if(mini2&gt;a[i])mini2=a[i]; &#125; if(mini==mini2) cout&lt;&lt;&quot;There is no second smallest element&quot;&lt;&lt;endl; else cout&lt;&lt;mini&lt;&lt;&quot; &quot;&lt;&lt;mini2; &#125; else &#123; cout&lt;&lt;&quot;Invalid Input&quot;&lt;&lt;endl; &#125; return 0;&#125; 7-2 求素数个数 (30 分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=0; cin&gt;&gt;n; int *a=new int[n+1]; for(int i=2;i&lt;=n;i++) a[i]=1; a[0]=a[1]=0; for(int i=2;i*i&lt;=n;i++) &#123; if(a[i]) &#123; for(int j=2*i;j&lt;=n;j+=i) a[j]=0; &#125; &#125; for(int i=2;i&lt;=n;i++) &#123; if(a[i])num++; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125;/*#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=1,flag=1; cin&gt;&gt;n; if(n==1)cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else if(n==2)cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; else &#123; for(int i=3;i&lt;=n;i+=2) &#123; for(int j=3;j*j&lt;=i;j+=2) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag) num++; flag=1; &#125; cout&lt;&lt;num&lt;&lt;endl; &#125; return 0;&#125;*//*#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=0,flag=1; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; for(int j=2;j*j&lt;=i;j++) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag) &#123; num++; &#125; flag=1; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125;*/ 第二章 线性表判断题（错题：1-2,1-4,1-15,1-17）1-1 顺序存储方式只能用于存储线性结构。F 1-2在顺序表中取出第i个元素所花费的时间与i成正比。F 1-3 线性表的顺序存储表示优于链式存储表示。F 1-4带头结点的单循环链表中，任一结点的后继结点的指针域均不空。T 1-5 顺序表 - 存储结构 顺序表中逻辑上相邻的元素，其物理位置也一定相邻。T 1-6 链式存储的优点是插入、删除元素时不会引起后续元素的移动，缺点是只能顺序访问各元素。T 1-7 线性表若采用链式存储结构时，要求内存中可用存储单元的地址一定不连续。F 1-8 链表是采用链式存储结构的线性表,进行插入、删除操作时，在链表中比在顺序存储结构中效率高。T 1-9 若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。T 1-10 对于顺序存储的长度为N的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为O(1)和O(N)。F 1-11 在线性表的顺序存储结构中，插入和删除元素时，移动元素的个数与该元素的位置有关。T 1-12 顺序存储方式的优点是存储密度大，且插入、删除运算效率高。F 1-13 在具有N个结点的单链表中，访问结点和增加结点的时间复杂度分别对应为O(1)和O(N)。F 1-14 线性表采用链式存储表示时，所有结点之间的存储单元地址可以连续也可以不连续。T 1-15在单链表中，要访问某个结点，只要知道该结点的指针即可。因此，单链表是一种随机存取结构。F 1-16 在具有头结点的链式存储结构中，头指针指向链表中的第一个元素结点。F 1-17在一个设有头指针和尾指针的单链表中，执行删除该单链表中最后一个元素的操作与链表的长度无关。F 1-18 循环链表可以做到从任一结点出发，访问到链表的全部结点。T 1-19 在单链表中，逻辑上相邻的元素，其物理位置必定相邻。F 1-20 在双向链表中，可以从当前结点出发访问到任何一个结点。T 选择题(错题：2-10,2-13,2-16,2-20)2-1 在一个长度为n的顺序表中，向第i个元素(1≤i≤n+1)位置插入一个新元素时需要从后向前移动多少个元素。 B.n-i+1 2-2 对于线性表，在顺序存储结构和链式存储结构中查找第k个元素，其时间复杂性分别是多少？ D.O(1)和O(k) 2-3 在顺序结构表示的线性表中，删除第i个元素（数组下标为i-1)，需要把后面的所有元素都往前挪一位，相应的语句是： 12for (___________ ) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; 其中空缺部分的内容应该是 A.j = i; j&lt; = PtrL-&gt;Last; j++ 2-4 向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（ ） B.63.5 2-5 顺序表是线性表的( ) B.顺序存储结构 2-6 以下说法错误的是 ( )。 C.在链表上实现读表元运算的平均时间复杂度为O（1） 2-7 哪个选项不是线性表的链式存储结构（ ） B.顺序表 2-8 在向表中第i个元素（1≤i≤n+1）位置插入一个新元素时，为保持插入后表中原有元素的相对次序不变，需要从后向前依次后移（ ）个元素。 B.n-i+1 2-9 在删除表中第i个元素时，同样地，为保持删除后表中原有元素的相对次序不变，需要从前向后依次前移（ ）个元素。 A.n-i 2-10与单链表相比，双链表的优点之一是（）。 D.顺序访问相邻结点更加灵活 2-11 在单链表中，要删除某一指定结点，必须先找到该结点的（）。 A.直接前驱 2-12 循环链表的主要优点是（）。 D.从表中的任意结点出发都能扫描到整个链表 2-13若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点，则采用（）存储方式最节省运算时间。 D.带表头附加结点的双循环链表 2-14 单链表又称为线性链表，在单链表上实施插入和删除操作（ ）。 B.不需移动结点，只需改变结点指针 2-15 链表不具有的特点是( )。 A.可随机访问任一个元素 2-16下面关于线性表的叙述中，错误的是____。 B.线性表采用顺序存储，便于进行插入和删除操作。 2-17 单链表L（带头结点）为空的判断条件是____。 B.L-&gt;next==NULL 2-18 在单链表指针为p的结点之后插入指针为s的结点，正确的操作是：（ ）。 B.s-&gt;next=p-&gt;next;p-&gt;next=s 2-19 对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（ ） B.head→next==NULL 2-20设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用( )最节省时间。 D.带头结点的双循环链表 填空题4-1 顺序表 - 地址计算 假设顺序表第 1 个元素的内存地址是 100，每个元素占用 2 字节内存空间，则第 5 个元素的内存地址是 108 4-2 在有n个元素的顺序表中删除任意一个元素所需移动元素的平均次数为 （n-1)/2 4-3 在有n个元素的顺序表中的任意位置插入一个元素所需移动元素的平均次数为 n/2 4-4 在长度为n的顺序表L中将所有值为x的元素替换成y，该算法的时间复杂度为 O(n) 4-5 在顺序表中，逻辑上相邻的元素，其物理位置 一定 相邻。在单链表中，逻辑上相邻的元素，其物理位置 不一定 相邻。 4-6 对于顺序表的插入算法insert_sqlist来说，若以结点移动为标准操作，则插入算法的在最坏情况下的移动次数为 n ，时间复杂度是 **O(n)**。在平均情况下的移动次数为 n/2 ，时间复杂度是 **O(n)**。 4-7 线性表L=(a1, a2, … , an)用数组表示，假定删除表中任一元素的概率相同，则删除一个元素平均需要移动元素的个数是 (n-1)/2 程序填空题5-1 顺序表删除操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0#define MAXSIZE 100typedef int datatype;typedef struct &#123; datatype *elem; int length;&#125; SqList;int ListDelete_Sq(SqList &amp;L, int i) &#123; if ((i &lt; 1) || (i &gt; L.length)) return ERROR; for (int j = i; j &lt;= L.length; j++) ; (2&#x27;) --L.length; return OK;&#125;int main() &#123; SqList L; int i = 0, n,a; datatype e; L.elem = new datatype[MAXSIZE]; L.length = 0; cin &gt;&gt; n; for (i=0;i&lt;n;i++) cin &gt;&gt; L.elem[i]; L.length = i; cin &gt;&gt; a; if (ListDelete_Sq(L, a)) &#123; for (i = 0; i &lt; L.length; i++) if(i==0) cout &lt;&lt; L.elem[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; L.elem[i]; &#125; else cout &lt;&lt; &quot;ERROR&quot;; return 0;&#125; 5-2单链表删除操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0typedef int ElemType;typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; void CreateList(LinkList &amp;L, int n) ;//该函数未显示细节 int ListDelete_L(LinkList &amp;L, int i) &#123; LinkList p, q; int j; p = L; j = 0; while((p-&gt;next) &amp;&amp; (j &lt;i)) (2&#x27;) &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || (j &gt; i - 1)) return ERROR; q = p-&gt;next; p-&gt;next=q-&gt;next;(2&#x27;) delete q; return OK;&#125; void print(LinkList &amp;L)&#123; LinkList p; int flag=1; p = L-&gt;next; while (p) &#123; if(flag) cout &lt;&lt; p-&gt;data; else cout &lt;&lt; &quot; &quot;&lt;&lt; p-&gt;data; flag=0; p = p-&gt;next; &#125;&#125;int main() &#123; LinkList L; ElemType e; int length; int i; cin &gt;&gt; length; CreateList(L, length); cin &gt;&gt; i; ListDelete_L(L,i); print(L); return 0;&#125; 函数题6-1 求顺序表最大值 (10 分) 123456789int GetMax(SqList L)&#123; int maxi=0; for(int i=0;i&lt;L.length;i++) &#123; if(maxi&lt;L.elem[i])maxi=L.elem[i]; &#125; return maxi;&#125; 6-2 单链表逆置* (10 分)1234567891011121314void Reverse(NODE *head)&#123; NODE *p,*p1,*p2,*p3; p = head-&gt;next; p1 = head; p1-&gt;next = NULL; while(p!=NULL) &#123; p2 = p; p = p-&gt;next; p2-&gt;next = p1-&gt;next; p1-&gt;next = p2; &#125;&#125; 6-3 单链表统计正数个数 (6 分) 123456789101112int PositiveInt(LinkList L)&#123; LNode *p; int n=0; p = L-&gt;next; while(p!=NULL) &#123; if(p-&gt;data&gt;0)n++; p = p-&gt;next; &#125; return n;&#125; 编程题7-1 学生顺序表的建立 (10 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576法一：#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;using namespace std;struct Node&#123; int id; string name; float s1,s2,s3; Node *next;&#125;;int main()&#123; int n; int id; string name; float s1,s2,s3; Node *p,*first,*last=NULL; last = new Node; first = last; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;id&gt;&gt;name&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; p = new Node; p-&gt;id = id; p-&gt;name = name; p-&gt;s1 = s1; p-&gt;s2 = s2; p-&gt;s3 = s3; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; p = first-&gt;next; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;p-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s1&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s2&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s3&lt;&lt;endl; p = p-&gt;next; &#125; return 0;&#125;法二：#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct Students&#123; int ID; string name; double score1; double score2; double score3; &#125;students[5];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;students[i].ID&gt;&gt;students[i].name&gt;&gt;students[i].score1&gt;&gt;students[i].score2&gt;&gt;students[i].score3; &#125; cout.precision(1); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;students[i].ID&lt;&lt;&quot; &quot;&lt;&lt;students[i].name&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score1&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score2&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score3; if(i!=n-1) cout&lt;&lt;endl; &#125; return 0;&#125; 7-2 求两个一元多项式的和 (20 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129法一：链表#include&lt;iostream&gt;using namespace std;struct Node&#123; int coef,exp; Node *next;&#125;;int main()&#123; int n,coef,exp; Node *p,*p1,*q,*q1,*temp; Node *first1,*first2,*last; last = new Node; first1=last; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; p=new Node; p-&gt;coef = coef; p-&gt;exp = exp; last-&gt;next=p; last = p; &#125; last-&gt;next = NULL; last = new Node; first2=last; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; p=new Node; p-&gt;coef = coef; p-&gt;exp = exp; last-&gt;next=p; last = p; &#125; last-&gt;next = NULL; p=first1-&gt;next; p1=first1; q=first2-&gt;next; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;exp&gt;q-&gt;exp) &#123; p=p-&gt;next; p1=p1-&gt;next; &#125; else if(p-&gt;exp&lt;q-&gt;exp) &#123; temp=q-&gt;next; p1-&gt;next=q; q-&gt;next=p; q = temp; &#125; else &#123; p-&gt;coef+=q-&gt;coef; if(p-&gt;coef==0) &#123; p1-&gt;next=p-&gt;next; delete p; p=p1-&gt;next; &#125; else &#123; p=p-&gt;next; p1=p1-&gt;next; &#125; q = q-&gt;next; &#125; &#125; if(q!=NULL)p1-&gt;next=q; p=first1-&gt;next; if(p!=NULL) &#123; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;coef&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;exp&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; cout&lt;&lt;p-&gt;coef&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;exp&lt;&lt;endl; &#125; else cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; return 0;&#125;法二：数组#include&lt;iostream&gt;using namespace std;int a[1001]=&#123;0&#125;;int main()&#123; int n,coef,exp; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; a[exp]=coef; &#125; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; a[exp]+=coef; &#125; n=0; for(int i=1000;i&gt;-1;i--) &#123; if(n==0&amp;&amp;a[i]) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;i; n=1; &#125; else if(a[i]) cout&lt;&lt;&quot; &quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;i; &#125; if(n)cout&lt;&lt;endl; else cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl;&#125; 7-3 两个有序链表合并（新表不含重复元素） (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242法一：刘俊兄弟的代码……emm……#include&lt;iostream&gt;using namespace std;int main()&#123; int a[1000], b[1000]; int flog = 1; int lengtha = 0, lengthb = 0; while (flog) &#123; int c; cin &gt;&gt; c; if (c == -1) flog = 0; else &#123; a[lengtha++] = c; &#125; &#125; flog = 1; while (flog) &#123; int c; cin &gt;&gt; c; if (c == -1) flog = 0; else &#123; b[lengthb++] = c; &#125; &#125; int j = 0; for (int i = lengtha ; i &lt; lengtha + lengthb; i++) &#123; a[i] = b[j++]; &#125; if (lengtha + lengthb == 0) &#123; cout &lt;&lt; &quot;NULL&quot;; &#125; int n = lengtha + lengthb; for (int i = 0; i &lt; n-1; i++) //冒泡循环 &#123; for (int j = i + 1; j &lt; n; j++)//从i后的一个元素一直往len-1位置寻找 &#123; if (a[j] == a[i]) //如果发现重复 &#123; for (int k = j + 1; k &lt; n; k++)//j+1的位置到len-1的位置 &#123; a[k - 1] = a[k]; //将后面的数依次赋值给前一个位置 &#125; n--; //数组长度-1 j--; //重复点再次进行查重 &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++) &#123; for (int j = 0; j &lt; n - i-1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; n-1; i++) &#123; cout &lt;&lt; a[i]&lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; a[n - 1]&lt;&lt;endl; return 0;&#125;法二：数组#include&lt;iostream&gt;using namespace std;int a1[10000];int a2[10000];int main()&#123; int x,n=0; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; a1[n++] = x; &#125; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; a1[n++] = x; &#125; for(int i=0;i&lt;n-1;i++) &#123; int mini=i; for(int j=i+1;j&lt;n;j++) &#123; if(a1[mini]&gt;a1[j])mini=j; &#125; if(mini!=i)swap(a1[mini],a1[i]); &#125; int flag=0; for(int i=0;i&lt;n;i++) &#123; if(a1[i]==flag)a1[i]=0; else flag = a1[i];//? &#125; int n1=0; for(int i=0;i&lt;n;i++) &#123; if(a1[i]) a2[n1++]=a1[i]; &#125; for (int i = 0; i &lt; n1-1; i++) &#123; cout &lt;&lt; a2[i]&lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; a2[n1 - 1]&lt;&lt;endl; return 0;&#125;法三：链表#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;int main()&#123; int x,flag=-1; Node *first1,*first2,*first3,*p,*p1,*p2,*last; last=new Node; first1 = last; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; if(x == flag)continue; p = new Node; p-&gt;data = x; flag = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; last=new Node; first2 = last; flag = -1; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; if(x == flag)continue; p = new Node; p-&gt;data = x; flag = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; last = new Node; first3 = last; p1 = first1-&gt;next; p2 = first2-&gt;next; while(p1!=NULL||p2!=NULL) &#123; if(p1!=NULL&amp;&amp;p2!=NULL) &#123; if(p2-&gt;data&gt;p1-&gt;data) &#123; p= new Node; p-&gt;data = p1-&gt;data; last-&gt;next = p; last = p; p1=p1-&gt;next; &#125; else if(p2-&gt;data&lt;p1-&gt;data) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; &#125; else if(p2-&gt;data==p1-&gt;data) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; p1=p1-&gt;next; &#125; &#125; else if(p2==NULL) &#123; p= new Node; p-&gt;data = p1-&gt;data; last-&gt;next = p; last = p; p1=p1-&gt;next; &#125; else if(p1==NULL) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; &#125; &#125; last-&gt;next = NULL; p= first3-&gt;next; if(p!=NULL) &#123; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl; return 0;&#125; 7-4 在有序链表中插入数据 (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;int main()&#123; int n,x; Node *p,*p2,*p1,*first,*last=new Node; first=last; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; p = new Node; p-&gt;data = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; cin&gt;&gt;x; p1 = first-&gt;next; p2 = first; while(p1!=NULL) &#123; if(x == p1-&gt;data)break; if(x&lt;p1-&gt;data) &#123; p = new Node; p-&gt;data = x; p-&gt;next = p1; p2-&gt;next = p; break; &#125; else if(x&gt;p1-&gt;data&amp;&amp;(p1-&gt;next==NULL||x&lt;p1-&gt;next-&gt;data)) &#123; p = new Node; p-&gt;data = x; p-&gt;next = p1-&gt;next; p1-&gt;next = p; break; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; if(first-&gt;next == NULL) &#123; p = new Node; p-&gt;data = x; p-&gt;next = NULL; first-&gt;next = p; &#125; p = first-&gt;next; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return 0;&#125; 第三章 栈和列表判断题（错题：1-10）1-1 若一个栈的输入序列为1，2，3，…，N，输出序列的第一个元素是i，则第j个输出元素是j−i−1。F 1-2 所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。F 1-3 在对不带头结点的链队列作出队操作时，不会改变头指针的值。F 1-4 不论是入队列操作还是入栈操作,在顺序存储结构上都需要考虑”溢出”情况。T 1-5 队列和栈都是运算受限的线性表，只允许在表的两端进行运算。F 1-6 栈和队列的存储方式，既可以是顺序方式，也可以是链式方式。T 1-7 循环队列也存在着空间溢出问题。T 1-8 循环队列执行出队操作时会引起大量元素的移动。F 1-9 栈是插入和删除只能在一端进行的线性表；队列是插入在一端进行，删除在另一端进行的线性表。T 1-10 在n个元素连续进栈以后，它们的出栈顺序和进栈顺序一定正好相反。T 1-11 环形队列中有多少个元素可以根据队首指针和队尾指针的值来计算。T 1-12 栈和队列的插入和删除操作特殊，所以，栈和队列是非线性结构。F 1-13 序列{1,2,3,4,5}依次入栈，则不可能得到{3,4,1,2,5}的出栈序列。 T 1-14 队列中允许插入的一端叫队头，允许删除的一端叫队尾。F 单选题（错题：2-2、2-18）2-1 若用大小为6的数组来实现循环队列，且当前front和rear的值分别为0和4。当从队列中删除两个元素，再加入两个元素后，front和rear的值分别为多少？ A.2和0 2-2如果循环队列用大小为m的数组表示，且用队头指针front和队列元素个数size代替一般循环队列中的front和rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数最多为： B.m 2-3 以下数据结构中，（ ）是非线性数据结构。 A.树 2-4 设栈S和队列Q的初始状态均为空，元素{1, 2, 3, 4, 5, 6, 7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2, 5, 6, 4, 7, 3, 1}，则栈S的容量至少是： D.4 2-5 线性表、堆栈、队列的主要区别是什么？ B.堆栈和队列都是插入、删除受到约束的线性表 2-6 栈和队列的共同点( )。 C.只允许在端点处插入和删除元素 2-7 下列关于线性表,栈和队列叙述,错误的是( )。 A.线性表是给定的n(n必须大于零)个元素组成的序列 2-8 设用一个数组A[1……N]来存储一个栈，令A[N]为栈底，用整型变量T指示当前栈顶位置，A[T]为栈顶元素。当从栈中弹出一个元素时，变量T的变化为（ ）。 A.T=T+1 2-9 链式栈与顺序栈相比，一个比较明显的优点是（ ）。 B.通常不会出现栈满的情况 2-10 (neuDS)在循环顺序队列中，假设以少用一个存储单元的方法来区分队列判满和判空的条件，front和rear分别为队首和队尾指针，它们分别指向队首元素和队尾元素的下一个存储单元，队列的最大存储容量为maxSize，则队列的长度是（ ）。 C.(rear-front+maxSize)%maxSize 2-11 (nueDS_C++)设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5、e6依次通过栈S，一个元素出栈后即进入队列Q，若6个元素出队的顺序是e2、e4、e3、e6、e5、e1，则栈S的容量至少应该是（ ）。提示：对于栈，可以全进再依次出；也可以进一个出一个；也可以进一部分，出一个，再进一部分；但是出栈之后，不能再入栈。 A.3 2-12 关于栈和队列的下列说法正确的是（） B.栈是后进先出的结构，出栈时除了栈顶元素，其余元素无需移动； 2-13 一个栈的入栈序列是a,b,c,d,e，则栈的出栈序列不可能的是（ ）。 C.dceab 2-14 在一个链表表示的队列中， f和r分别指向队列的头和尾。下列哪个操作能正确地将s结点插入到队列中： B.r-&gt;next=s; r=s; 2-15 栈和队列具有相同的。 B.逻辑结构 2-16 假定利用数组a[n]顺序存储一个栈，用top表示栈顶指针，用top==-1表示栈空，并已知栈未满，当元素x进栈时所执行的操作为（ ）。 C.a[++top]=x 2-17 队列的“先进先出”特性是指（ ）。 Ⅰ.最后插入队列中的元素总是最后被删除Ⅱ.当同时进行插入、删除操作时，总是插入操作优先Ⅲ.每当有删除操作时，总要先做一次插入操作Ⅳ.每次从队列中删除的总是最早插入的元素 B.Ⅰ、Ⅳ 2-18已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。 B.0,n-1（原因：……） 2-19 执行函数时，其局部变量一般采用（ ）进行存储。 C.栈结构 2-20 对空栈 S 进行 Push 和 Pop 操作，入栈序列为 a, b, c, d, e，经过 Push, Push, Pop, Push, Pop, Push, Push, Pop 操作后，得到的出栈序列是： D.b, c, e 2-21 用S表示入栈操作，X表示出栈操作，若元素入栈的顺序为1234，为了得到1342出栈顺序，相应的S和X的操作串为( )。 D.SXSSXSXX 填空题（错题：4-3）4-1 栈的运算遵循 后进先出|先进后出 的原则。 4-2 以下运算实现在链队上的入队列，请在空白处用适当句子予以填充。 12345678void EnQueue(QueptrTp *lq,DataType x)&#123; LqueueTp *p; p=(LqueueTp *)malloc(sizeof(LqueueTp)); p-&gt;data=x;(1&#x27;) p-&gt;next=NULL; (lq-&gt;rear)-&gt;next=p;(1&#x27;) lq-&gt;rear=p;(1&#x27;) &#125; 4-3 以下运算实现在链栈上的初始化，请在空白处用请适当句子予以填充。 12345typedef struct Node&#123; DataType data; struct Node *next;&#125;StackNode,*LStackTp;void InitStack(LStackTp &amp;ls)&#123; ls=NULL;&#125;。(1&#x27;) 函数题6-3 jmu-ds-舞伴问题 (20 分)12345678910111213141516171819202122232425262728293031323334353637383940int QueueLen(SqQueue Q)&#123; return (Q-&gt;rear-Q-&gt;front+MAXQSIZE)%MAXQSIZE;&#125;int EnQueue(SqQueue &amp;Q, Person e)&#123; Q-&gt;rear = (Q-&gt;rear+1)%MAXQSIZE; Q-&gt;data[Q-&gt;rear] = e; return 0;&#125;int QueueEmpty(SqQueue &amp;Q)&#123; if(Q-&gt;rear==Q-&gt;front)return 1; else return 0;&#125;int DeQueue(SqQueue &amp;Q, Person &amp;e)&#123; Q-&gt;front = (Q-&gt;front+1)%MAXQSIZE; e = Q-&gt;data[Q-&gt;front]; return 0;&#125;void DancePartner(Person dancer[], int num)&#123; for(int i=0;i&lt;num;i++) &#123; if(dancer[i].sex==&#x27;M&#x27;) EnQueue(Mdancers,dancer[i]); else EnQueue(Fdancers,dancer[i]); &#125; while(!QueueEmpty(Mdancers)&amp;&amp;!QueueEmpty(Fdancers)) &#123; Person x,y; DeQueue(Mdancers,x); DeQueue(Fdancers,y); cout&lt;&lt;y.name&lt;&lt;&quot; &quot;&lt;&lt;x.name&lt;&lt;endl; &#125;&#125; 6-4 十进制转二进制（顺序栈设计和应用） (10 分) 12345678910111213141516171819202122232425bool isEmpty()&#123; if(top==-1)return 1; else return 0;&#125;/* 元素x入栈 */void Push(int x)&#123; //if(x==MaxSize)cout&lt;&lt;&quot;上溢&quot;&lt;&lt;endl; //else mystack[++top]=x;&#125;/* 取栈顶元素 */int getTop()&#123; return mystack[top];&#125;/* 删除栈顶元素 */void Pop()&#123; top--;&#125; 编程题7-1 银行业务队列简单模拟 (25 分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int arr[1000];int main()&#123; int n; int flag1=0,flag2=0; int top1=0,top2=0,top=0; cin&gt;&gt;n; int a1[n+1],a2[n+1],a[n+1]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; if(arr[i]%2!=0)a1[top1++]=arr[i]; else a2[top2++]=arr[i]; &#125; int t1=0,t2=0; for(int i=0;i&lt;n;i++) &#123; if(arr[i]%2==0)flag2++; else flag1++; if(flag2%2==0&amp;&amp;flag1%4==0) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; a[top++]=a2[t2++]; &#125;else&#123; if(t1!=top1&amp;&amp;(flag1%2==0||t2==top2)) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; &#125; if(t2!=top2&amp;&amp;(flag2%2==0||t1==top1||flag1%2==0)) &#123; a[top++]=a2[t2++]; &#125; &#125; if(top==n)break; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;a[n-1]&lt;&lt;endl; return 0;&#125; 7-2 堆栈操作合法性 (20 分) 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N,M; string str; int n,x=0; cin&gt;&gt;N&gt;&gt;M; for(int i=0; i&lt;N; i++) &#123; cin&gt;&gt;str; n = str.size(); for(int j=0; j&lt;n; j++) &#123; if(str[j]==&#x27;S&#x27;) &#123; x++; if(x&gt;M)break; &#125; else if(str[j]==&#x27;X&#x27;) &#123; x--; if(x&lt;0)break; &#125; &#125; if(x==0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; x=0; &#125; return 0;&#125; 第四章 串和数组判断题1-1 假设模式串是abababaab，则KMP模式匹配算法中的next[j] = 0 1 1 2 3 4 5 6 2。T 选择题(错题：2-3,2-6,2-9,2-13)2-1 KMP算法下，长为n的字符串匹配长度为m的字串的时间复杂度为 B.O（M+N） 2-2 串的长度是指 B.串中所含字符的个数 2-3设主串 T = abaabaabcabaabc，模式串 S = abaabc，采用 KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是： B.10（6+4） 2-4 串“ababaaababaa”的next数组为（ ）。 C.011234223456 2-5 已知字符串S为“abaabaabacacaabaabcc”，模式串t为“abaabc”。采用KMP算法进行匹配，第一次出现“失配”(s[i]≠t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是()。 C.i=5,j=2 2-62 符号串abcde的子串共有： C.16（1+2+3+4+5+1(空串)） [^长度为n的字符串]: 1、有n(n+1)/2 +1个子串；2、非空子串：n（n+1）/2；3、非空真子串：n（n+1）/2– 1 2-7 适用于压缩存储稀疏矩阵的两种存储结构是： A.三元组表和十字链表 2-8 (neuDS)以下( )是稀疏矩阵的一种存储方法。 A.十字链表 2-9一个稀疏矩阵采用压缩后，和直接采用二维数组存储相比会失去（ ） 特性。 B.随机存取 2-10 对特殊矩阵采用压缩存储的主要目的是（ ）。 D.减少不必要的存储空间 2-11 对n阶对称矩阵压缩存储时，需要表长为（ ）的顺序表。 C.n(n+1)/2 2-12 顺序查找法适合于存储结构为（ ）的线性表。 B.顺序存储或链式存储 2-13（SWPU-DS）设有一个 10 阶的对称矩阵 A，采用压缩存储方式，以行序为主存储，a[1, 1] 为第一元素，其存储地址为 1，每个元素占一个地址空间，则 a[8, 5] 的地址为（ ）。 *C.33（对称矩阵：(7+1)7/2+5)） 第五章 树和二叉树选择题2-1 设一棵非空完全二叉树 T 的所有叶节点均位于同一层，且每个非叶结点都有 2 个子结点。若 T 有 k 个叶结点，则 T 的结点总数是： A.2k−1 2-2 已知字符集{ a, b, c, d, e, f }，若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是： A.00, 1011, 01, 1010, 11, 100 2-3 已知二叉树的先序遍历序列为ABCDEFGH，中序遍历序列为CBEDFAGH，则该二叉树形态中，父节点的右子节点为（）。 C.G 2-4若将一棵树 T 转化为对应的二叉树 BT，则下列对 BT 的遍历中，其遍历序列与 T 的后根遍历序列相同的是： B.中序遍历 2-5对 n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有 115 个结点，则 n 的值是： C.58 2-6 设 T 是非空二叉树，若 T 的先序遍历和中序遍历序列相同，则 T 的形态是 __ D.所有结点只有右孩子 2-7以二叉链表作为二叉树的存储结构，在具有 n 个结点的二叉链表中（n&gt;0），空链域的个数为 __ A.n+1 2-8 已知二叉树的前序遍历序列为 ABDCEFG，中序遍历序列为 DBCAFEG，则后序遍历序列为 __ B.DCBFGEA 2-9 对于任意一棵高度为 5 且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占 1 个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元的数量至少是： A.31 2-10已知森林 F 及与之对应的二叉树 T，若 F 的先根遍历序列是 a, b, c, d, e, f，后根遍历序列是 b, a, d, f, e, c，则 T 的后序遍历序列是： C.b, f, e, d, c, a 填空题4-1 已知一棵完全二叉树的第5层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是：47 4-2 一棵二叉树的前序遍历序列是ABDFECGHK，中序遍历序列是DBEFAGHCK，则它的后序遍历序列是 DEFBHGKCA 4-3具有n个结点的二叉树中,一共有 2n 个指针域,其中只有 n-1 个用来指向结点的左右孩子，其余的 n+1 个指针域为NULL。 4-4 若以{4，5，6，7，8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是 69 程序填空题5-2 下列代码的功能是将二叉树T中的结点按照层序遍历的顺序输出。 123456789101112131415161718192021222324typedef struct TreeNode *Tree;struct TreeNode&#123; int Key; Tree Left; Tree Right;&#125;;void Level_order ( Tree T )&#123; Queue Q; if ( !T ) return; Q = CreateQueue( MaxElements ); Enqueue( T, Q ); while ( !IsEmpty( Q ) )&#123; T = Front_Dequeue ( Q ); /* return the front element and delete it from Q */ printf(&quot;%d &quot;, T-&gt;Key); if ( T-&gt;Left ) Enqueue( T-&gt;Left)3分; if (T-&gt;Right 3分 ) Enqueue( T-&gt;Right)3分; &#125;&#125; 5-3 下列代码的功能是计算给定二叉树T的宽度。二叉树的宽度是指各层结点数的最大值。函数Queue_rear和Queue_front分别返回当前队列Q中队尾和队首元素的位置。 12345678910111213141516171819202122232425262728293031323334typedef struct TreeNode *BinTree;struct TreeNode&#123; int Key; BinTree Left; BinTree Right;&#125;;int Width( BinTree T )&#123; BinTree p; Queue Q; int Last, temp_width, max_width; temp_width = max_width = 0; Q = CreateQueue(MaxElements); Last = Queue_rear(Q); if ( T == NULL) return 0; else &#123; Enqueue(T, Q); while (!IsEmpty(Q)) &#123; p = Front_Dequeue(Q); temp_width++3分; if ( p-&gt;Left != NULL ) Enqueue(p-&gt;Left, Q); if ( p-&gt;Right != NULL ) Enqueue (p-&gt;Right)3分; if ( Queue_front(Q) &gt; Last ) &#123; Last = Queue_rear(Q); if ( temp_width &gt; max_width ) max_width = temp_width; temp_width=0 3分; &#125; /* end-if */ &#125; /* end-while */ return max_width; &#125; /* end-else */&#125; 函数题6-1 求二叉树高度 (20 分)1234567891011int GetHeight( BinTree BT )&#123; int LH,RH; if(!BT)return 0; else &#123; LH = GetHeight(BT-&gt;Left); RH = GetHeight(BT-&gt;Right); return LH&gt;RH?++LH:++RH; &#125;&#125; 6-2 二叉树的遍历 (25 分)123456789101112131415161718192021222324252627282930313233343536void InorderTraversal( BinTree BT )&#123; if(!BT)return; InorderTraversal(BT-&gt;Left); printf(&quot; %c&quot;,BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;void PreorderTraversal( BinTree BT )&#123; if(!BT)return; printf(&quot; %c&quot;,BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void PostorderTraversal( BinTree BT )&#123; if(!BT)return; PostorderTraversal(BT-&gt;Left); PostorderTraversal(BT-&gt;Right); printf(&quot; %c&quot;,BT-&gt;Data);&#125;void LevelorderTraversal( BinTree BT )&#123; if(!BT)return; BinTree que[101],t; int first=0,rear=0; que[rear++]=BT; while(first!=rear) &#123; t=que[first++]; printf(&quot; %c&quot;,t-&gt;Data); if(t-&gt;Left)que[rear++]=t-&gt;Left; if(t-&gt;Right)que[rear++]=t-&gt;Right; &#125;&#125; 6-3 先序输出叶结点 (15 分)123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT) &#123; if(!BT-&gt;Left&amp;&amp;!BT-&gt;Right) printf(&quot; %c&quot;,BT-&gt;Data); PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right); &#125;&#125; 6-4 二叉树的非递归遍历 (25 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void InorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); T = T-&gt;Left; &#125; T = Pop(S); printf(&quot; %c&quot;,T-&gt;Data); T=T-&gt;Right; &#125;&#125;void PreorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); printf(&quot; %c&quot;,T-&gt;Data); T = T-&gt;Left; &#125; T = Pop(S); T = T-&gt;Right; &#125;&#125;void PostorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); T-&gt;flag=0; T = T-&gt;Left; &#125; T = Peek(S); if(T-&gt;flag==0) &#123; T-&gt;flag++; T=T-&gt;Right; &#125; else&#123; T = Pop(S); printf(&quot; %c&quot;,T-&gt;Data); T = NULL; &#125; &#125;&#125; 编程题7-1 根据后序和中序遍历输出先序遍历 (25 分)1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* Creat(int *Post,int *In,int n)&#123; if(n&lt;=0)return NULL; int len=0; Node *p=new Node; p-&gt;data = *(Post+n-1); while(*(In+len)!=p-&gt;data)len++; p-&gt;left=Creat(Post,In,len); p-&gt;right=Creat(Post+len,In+len+1,n-len-1);//右子树……emmm……记住吧…… return p;&#125;void Preorder(Node *t)&#123; if(!t)return; cout&lt;&lt;&quot; &quot;&lt;&lt;t-&gt;data; Preorder(t-&gt;left); Preorder(t-&gt;right);&#125;int main()&#123; int n; cin&gt;&gt;n; int a[n],b[n]; Node *t; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; t=Creat(a,b,n); cout&lt;&lt;&quot;Preorder:&quot;; Preorder(t); return 0;&#125; 7-2 玩转二叉树 (25 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* creat(int *In,int *Pre,int n)&#123; if(n&lt;=0)return NULL; int len=0; while(*(In+len)!=*Pre)len++; Node *p=new Node; p-&gt;data=*(In+len); p-&gt;left=creat(In,Pre+1,len); p-&gt;right=creat(In+len+1,Pre+len+1,n-len-1);//n-len-1我也不清楚…… return p;&#125;void Level(Node *t,int n)&#123; if(!t)return; int first=0,last=0,i; Node* Q[n],*w; Q[last++]=t; while(last!=first) &#123; w=Q[first++]; //镜面也可以看做先右子树再左子树 if(w-&gt;right)Q[last++]=w-&gt;right; if(w-&gt;left)Q[last++]=w-&gt;left; &#125; for(i=0;i&lt;n-1;i++) cout&lt;&lt;Q[i]-&gt;data&lt;&lt;&quot; &quot;; cout&lt;&lt;Q[i]-&gt;data&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; int In[n],Pre[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;In[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;Pre[i]; Node* t=creat(In,Pre,n); Level(t,n); return 0;&#125; 7-3 树的遍历 (25 分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* creat(int* In,int* Post,int n)&#123; if(n&lt;=0)return NULL; int len=0; while(*(In+len)!= *(Post+n-1))len++; Node *p=new Node; p-&gt;data=In[len]; p-&gt;left=creat(In,Post,len); p-&gt;right=creat(In+len+1,Post+len,n-len-1); return p;&#125;void Level(Node* t,int n)&#123; int last=0,first=0,i; Node* Q[n],*w; Q[last++]=t; while(last!=first) &#123; w=Q[first++]; if(w-&gt;left)Q[last++]=w-&gt;left; if(w-&gt;right)Q[last++]=w-&gt;right; &#125; for(i=0;i&lt;n-1;i++) cout&lt;&lt;Q[i]-&gt;data&lt;&lt;&quot; &quot;; cout&lt;&lt;Q[i]-&gt;data&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; int In[n],Post[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;Post[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;In[i]; Node* t=creat(In,Post,n); Level(t,n); return 0;&#125; 7-4 哈夫曼编码 (30 分) 1 7-5 二叉搜索树的最近公共祖先 (30 分) 1 第六章 图判断题1-1 无向连通图所有顶点的度之和为偶数。T 1-2无向连通图至少有一个顶点的度为1。F 1-3 用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。T 1-4 在一个有向图中，所有顶点的入度与出度之和等于所有边之和的2倍。T 1-5如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。F 1-6在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。T 1-7 用一维数组G[]存储有4个顶点的无向图如下： 1G[] = &#123; 0, 1, 0, 1, 1, 0, 0, 0, 1, 0 &#125; 则顶点2和顶点0之间是有边的。T 1-8 Kruskal 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。F 1-9 Prim 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。T 1-10 若图G有环，则G不存在拓扑排序序列。T 1-11 若图G为连通图且不存在拓扑排序序列，则图G必有环。T 1-12 P 是顶点 S 到 T 的最短路径，如果该图中的所有路径的权值都加 1，P 仍然是 S 到 T 的最短路径。F 1-13 对于带权无向图 G = (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。F 1-14如果从有向图 G 的每一点均能通过深度优先搜索遍历到所有其它顶点，那么该图一定不存在拓扑序列。T 1-15 如果 e 是有权无向图 G 唯一的一条最短边，那么边 e 一定会在该图的最小生成树上。T 选择题2-1在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？ (1分) A. 是的肯定不同 B. 肯定是相同的 C. 有可能会不同 D. 以上全不对 2-2若要检查有向图中有无回路，除了可以利用拓扑排序算法外，下列哪种算法也可以用？ A. Dijkstra算法 B. Prim算法 C. 广度优先搜索 D. 深度优先搜索 2-3下图为一个AOV网，其可能的拓扑有序序列为： (2分) A. ABCDFEG B. ADFCEBG C. ACDFBEG D. ABDCEFG 2-4下列选项中，不是下图深度优先搜索序列的是： (2分) A. V1, V5, V4, V3, V2 B. V1, V3, V2, V5, V4 C. V1, V2, V5, V4, V3 D. V1, V2, V3, V4, V5 2-5 若将n个顶点e条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是： (1分) A. O(n) B. O(n+e) C. O(n2) D. O(n×e) 2-6 使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是： (2分) A. 5, 2, 3, 4, 6 B. 5, 2, 3, 6, 4 C. 5, 2, 4, 3, 6 D. 5, 2, 6, 3, 4 2-7 使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是： (2分) A. 6, 7, 5, 3, 2, 4 B. 6, 2, 5, 7, 3, 4 C. 2, 3, 4, 5, 6, 7 D. 2, 4, 3, 6, 5, 7 2-8设无向图为 G=(V，E)，其中 V={v1,v2,v3,v4}，E={(v1,v2)，(v3,v4)，(v4,v1)，(v2,v3)，(v1,v3)}。则每个顶点的度依次为： (2分) A. 2, 1, 1, 1 B. 1, 1, 2, 1 C. 3, 2, 3, 2 D. 2, 3, 2, 3 2-9 对于给定的有向图如下，其逆邻接表为： (2分) A. B. C. D. 2-10 已知一个无向图的顶点集为 {V0,V1,⋯,V7}，其邻接矩阵如下所示： 以下哪项不可能是从 V0 出发的广度优先遍历序？ (2分) A. V0,V1,V3,V4,V2,V6,V5,V7 B. V0,V3,V1,V4,V2,V6,V5,V7 C. V0,V3,V1,V4,V6,V2,V7,V5 D. V0,V4,V3,V1,V6,V2,V7,V5 2-11 给定一个图的邻接矩阵如下，则从V1出发的宽度优先遍历序列（BFS，有多种选择时小标号优先）是： (2分) A. V1, V2, V4, V3, V6, V8, V10, V9, V7, V5 B. V1, V2, V3, V4, V5, V6, V7, V9, V8, V10 C. V1, V2, V4, V6, V8, V10, V9, V7, V5, V3 D. V1, V2, V3, V5, V7, V9, V10, V6, V8, V4 2-12 给出如下图所示的具有 7 个结点的网 G，哪个选项对应其正确的邻接矩阵？ A. B. C. D. 2-13 已知无向图 G 如下所示，使用克鲁斯卡尔（Kruskal）算法求图 G 的最小生成树，加入到最小生成树中的边依次是： A. (b,f), (b,d), (a,e), (c,e), (b,e) B. (b,f), (b,d), (b,e), (a,e), (c,e) C. (a,e), (b,e), (c,e), (b,d), (b,f) D. (a,e), (c,e), (b,e), (b,f), (b,d) 2-14 若使用 AOE 网估算工程进度，则下列叙述中正确的是： (2分) A. 关键路径是从源点到汇点边数最多的一条路径 B. 关键路径是从源点到汇点路径长度最长的路径 C. 增加任一关键活动的时间不会延长工程的工期 D. 缩短任一关键活动的时间将会缩短工程的工期 2-15下列关于无向连通图特征的叙述中，正确的是： 所有顶点的度之和为偶数 边数大于顶点个数减1 至少有一个顶点的度为1 A.只有1 B.只有2 C.1和2 D.1和3 2-16若无向图G =（V，E）中含7个顶点，要保证图G在任何情况下都是连通的，则需要的边数最少是： (3分) A.6 B.15 C.16 D.21 2-17 具有N（N&gt;0）个顶点的无向图至少有多少个连通分量？ A.0 B.1 C.N−1 D.N 2-18用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是？ A. 无序的 B. 拓扑有序 C. 逆拓扑有序 D. 以上都不对 2-19若要求在找到从S到其他顶点最短路的同时，还给出不同的最短路的条数，我们可以将Dijkstra算法略作修改，增加一个count[]数组：count[V]记录S到顶点V的最短路径有多少条。则count[V]应该被初始化为： A. 对所有顶点都有count[V]=1 B. 对所有顶点都有count[V]=0 C. 1count[S]=1; `对于其他顶点`V`则令`count[V]=0 D. 1count[S]=0; `对于其他顶点`V`则令`count[V]=1 2-20任何一个带权无向连通图的最小生成树—— A. 是唯一的 B. 是不唯一的 C. 有可能不唯一 D. 有可能不存在 程序填空题函数题6-1 邻接矩阵存储图的深度优先遍历 (20 分)12345678910111213141516/*void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )&#123; //cout &lt;&lt; vertex[v]; Visit(V); Visited[V] = true; for (int j = 0; j &lt; Graph-&gt;Nv; j++) if (Graph-&gt;G[V][j] == 1 &amp;&amp; Visited[j] == false) DFS(Graph,j,Visit);&#125;*/void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )&#123; Visit(V); Visited[V]=true; for(int j=0;j&lt;Graph-&gt;Nv;j++) &#123; if(Graph-&gt;G[V][j]==1&amp;&amp;Visited[j]==false)DFS(Graph, j, Visit); &#125;&#125; 6-2 邻接表存储图的广度优先遍历 (20 分)1234567891011121314151617181920212223242526void BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) )&#123; int w,j,Q[MaxVertexNum]; int first=0,late=0; Visit(S); Visited[S]=true; Q[late++]=S; PtrToAdjVNode tmp; while(late!=first) &#123; w=Q[first++]; tmp=Graph-&gt;G[w].FirstEdge; while(tmp) &#123; Vertex pos=tmp-&gt;AdjV; if(!Visited[pos]) &#123; Visit(pos); Visited[pos]=true; Q[late++]=pos; &#125; tmp=tmp-&gt;Next; &#125; &#125;&#125; 编程题第七章 查找判断题（错题：1-1,1-4,1-6）1-1在散列中，函数“插入”和“查找”具有同样的时间复杂度。T 1-2 当记录个数小于哈希表长度时，哈希查找平均查找长度必然为0。F 1-3 用向量和单链表表示的有序表均可使用折半查找方法来提高查找速度。F 1-4有n个数存放在一维数组A[1..n]中，在进行顺序查找时，这n个数的排列有序或无序其平均查找长度不同。F 1-5 折半查找法的查找速度一定比顺序查找法快。F 1-6就平均查找长度而言，分块查找最小，折半查找次之，顺序查找最大。F 1-7 hash表的平均查找长度与处理冲突的方法无关。F 选择题(错题：2-9,2-10)2-1 用二分查找从100个有序整数中查找某数，最坏情况下需要比较的次数是： A.7 2-2 在有n（n&gt;1000）个元素的升序数组A中查找关键字x。查找算法的伪代码如下所示： 123456k = 0;while ( k&lt;n 且 A[k]&lt;x ) k = k+3;if ( k&lt;n 且 A[k]==x ) 查找成功;else if ( k-1&lt;n 且 A[k-1]==x ) 查找成功; else if ( k-2&lt;n 且 A[k-2]==x ) 查找成功; else 查找失败; 本算法与二分查找（折半查找）算法相比，有可能具有更少比较次数的情形是： B.当x接近数组开头处 2-3 下列二叉树中，可能成为折半查找判定树（不含外部结点）的是： A. 2-4 在顺序表（8,11,15,19,25,26,30,33,42,48,50）中，用二分（折半）法查找关键码值20，需做的关键码比较次数为( )。 B.4 2-5 顺序查找n个元素的顺序表，若查找成功，则比较关键字的次数最多为( )次。 (2分) A.n 2-6 输入一个正整数序列（53,17,12,66,58,70,87,25,56,60），按次序构造一棵二叉排序树BS为（ ）。 A. 2-7 在下列查找的方法中，平均查找长度与结点个数无关的查找方法是： C.利用哈希（散列）表 2-8 对哈希(HASH)函数H(k)= k MOD m, 一般来说,m应取 (2分) A.素数 2-9将元素序列{18, 23, 4, 26, 31, 33, 17, 39}按顺序插入一个初始为空的、大小为13的散列表中。散列函数为：H(Key)=Key%13，采用线性探测法处理冲突。问：当第一次发现有冲突时，散列表的装填因子大约是多少？ C.0.31 2-10现有长度为 11 且初始为空的散列表 HT，散列函数是 H(k**ey)=k**ey%7，采用线性探查（线性探测再散列）法解决冲突。将关键字序列 87,40,30,6,11,22,98,20 依次插入到 HT 后，HT 查找失败的平均查找长度是： C.6 2-11 设有一组关键字 { 29，01， 13，15，56，20，87，27，69，9，10，74 }，散列函数为 H(k**ey)=k**ey%17，采用线性探测方法解决冲突。试在 0 到 18 的散列地址空间中对该关键字序列构造散列表，则成功查找的平均查找长度为 __ D.1.33 2-12 设有一组关键字 { 29，01， 13，15，56，20，87，27，69，9，10，74 }，散列函数为 H(k**ey)=k**ey%17，采用平方探测方法解决冲突。试在 0 到 18 的散列地址空间中对该关键字序列构造散列表，则成功查找的平均查找长度为 __ C.1.25 填空题（错题：4-1）4-1执行以下程序， 123456789101112131415161718#include &lt;stdio.h&gt;int main( )&#123; int array[10]=&#123;2, 12, 24, 36, 48, 49, 2333, 6666, 23333, 99999&#125;; int key=2333, flag=0, low=0, m, h=9, times=0; while(low &lt;= h)&#123; m = (low + h) / 2; times++; if(array[m] == key) &#123; printf(&quot;Found-%d-%d&quot;, m, times); flag = 1; break; &#125; else if(array[m] &gt; key) h = m - 1; else low = m + 1; &#125; if(flag == 0) printf(&quot;Not Found!&quot;); return 0;&#125; 程序运行结果（即：在屏幕上打印的内容）是Found-6-4 。 （注意：要严格按照程序打印的格式填写答案，包括字母的大小写、空格的多少、连字符-和叹号!的格式等，不得随意增加引号、空格等无关字符，否则不得分。例如printf(&quot;hello World&quot;);打印的内容就是hello World，而不是&quot;hello World&quot;。为防止格式书写错误，建议直接从上面的代码中复制部分相关内容。） 4-2 顺序查找算法的平均查找长度 在下面的线性表中 1( 15, 24, 32, 47, 50, 58, 62, 79, 83, 96 ) 若采用顺序查找算法，假设各元素的检索概率相同，则平均查找长度为 5.5 4-3 二分查找算法的最大查找长度 在下面的有序表中 1( 15, 24, 32, 47, 50, 58, 62, 79, 83, 96 ) 若采用二分查找算法，则最大查找长度为 4 函数题6-1 二分查找 (20 分)123456789101112Position BinarySearch( List L, ElementType x )&#123; int high=L-&gt;Last,low=1,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(x&lt;L-&gt;Data[mid])high=mid-1; else if(x&gt;L-&gt;Data[mid])low=mid+1; else return mid; &#125; return NotFound;&#125; 6-2 线性探测法的查找函数 (20 分)12345678910111213141516Position Find( HashTable h, ElementType key )&#123; int p0,p; int num=0; p=p0=Hash(key,h-&gt;TableSize); while(h-&gt;Cells[p].Info!=Empty&amp;&amp;h-&gt;Cells[p].Data!=key) &#123; num++; if(num==MAXTABLESIZE) &#123; return ERROR; &#125; p=(p0+num)%h-&gt;TableSize; &#125; return p;&#125; 6-3 有序数组的插入 (20 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445/*bool Insert( List L, ElementType X )&#123; if(L -&gt; Last + 1 == MAXSIZE)//满了 return false; for (int i = 0; i &lt;= L -&gt; Last; i++ ) &#123; if (L -&gt; Data[i] == X) //已经有了 return false; else if (L -&gt; Data[i] &lt; X) &#123; for (int j = L -&gt;Last; j &gt;= i; j -- )//i之后的后移一位 &#123; L -&gt; Data[j + 1] = L -&gt; Data[j]; &#125; L-&gt;Data[i] = X; L-&gt;Last ++; break; &#125; else if (i==L-&gt;Last &amp;&amp; L-&gt;Data[i]&gt; X)//插在最后一位 &#123; L-&gt;Data[L-&gt;Last+1] = X; L-&gt;Last ++; break; &#125; &#125; return true;&#125;*/bool Insert( List L, ElementType X )&#123; if(L-&gt;Last==MAXSIZE-1)return false; int low=0,high=L-&gt;Last,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(L-&gt;Data[mid]&gt;X)low=mid+1; else if(L-&gt;Data[mid]&lt;X)high=mid-1; else return false; &#125; for(int i=L-&gt;Last;i&gt;high;i--) L-&gt;Data[i+1]=L-&gt;Data[i]; L-&gt;Data[high+1]=X; L-&gt;Last++; return true;&#125; 6-4 创建哈希表及查找(拉链法) (10 分)123456789101112131415161718192021222324252627282930313233343536373839404142434445void CreateHash(HashTable HT[],int n)&#123; int x,num; HashNode *p; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; num=x%P; p=new HashNode; p-&gt;key = x; if(HT[num]==NULL) &#123; HT[num]=new HashNode; p-&gt;next=NULL; HT[num]-&gt;next=p; &#125; else &#123; p-&gt;next=HT[num]-&gt;next; HT[num]-&gt;next=p; &#125; &#125;&#125;float ASL(HashTable HT[])&#123; HashNode *p; int sum=0,len=0; for(int i=0;i&lt;P;i++) &#123; if(HT[i]==NULL)continue; else &#123; int cnt=1; p=HT[i]-&gt;next; while(p!=NULL) &#123; sum+=cnt; cnt++; len++; p=p-&gt;next; &#125; &#125; &#125; return sum*1.0/len;&#125; 编程题7-1 电话聊天狂人 (25 分) 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;string, int&gt; m; map&lt;string, int&gt;::iterator it;//迭代器（指针） int n, cnt = 0, people= 1; string s;//s存手机号 cin &gt;&gt; n; for (int i = 0; i &lt; n * 2; i++) &#123; cin &gt;&gt; s; m[s]++; &#125; for (it = m.begin(); it != m.end(); it++) &#123; if (it-&gt;second &gt; cnt) &#123;//第一个位置存储的second的大于人数，则 people = 1; s = it-&gt;first; cnt = it-&gt;second; &#125; else if (it-&gt;second == cnt) &#123;//电话狂人不唯一 people++;//电话狂人有几个 if (it-&gt;first &lt; s)//找最小的号码 s = it-&gt;first; &#125; &#125; cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; cnt; if (people != 1) cout &lt;&lt; &quot; &quot; &lt;&lt; people;&#125;//map容器 7-2 愤怒的牛 (25 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int a[100010];int l, r;int n,c; /*bool juge(int m)//判断距离m是否可以 &#123; int s = 0, last = 1;//记录上一个 for (int i = 2; i &lt;= n; i++)//依次枚举每个牛栏 &#123; if (a[i] - a[last]&lt;m)s++;//若此距离不满足当前答案，那么需要的牛栏数+1，即把当前牛放到下一个牛栏 else last = i;//否则就更新上一次的牛栏位置 ，即上一头牛放的位置 if (s&gt;n - c) return false;//若需要牛栏数大于最大牛栏数，此答案不可行 &#125; return true;&#125;*/ bool juge(int m) &#123; int ans = 1, last = 1; //因为第一个牛一定要占据第一个隔间（这样能使本题的答案最优），所以ans初始化为1 for (int i = 2; i &lt;=n; i++) &#123; if (a[i] - a[last] &gt;= m) &#123; ans++; //如果比最近距离要大的话，那么该隔间就放牛 last = i; &#125; &#125; if (ans &gt;= c)return true; //如果所选取的隔间数量&gt;=c，则说明枚举的最近距离成立，但是不够大，所以return true,继续枚举更大的距离 return false;&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;=n; i++)cin &gt;&gt; a[i]; l = 1; r = a[n] - a[1]; //右边界为n个隔间的总长度，最近距离一定小于等于这个数值 sort(a + 1, a + 1 + n); while (l &lt;=r) &#123; int mid = (l + r)/2; if (juge(mid))l = mid+1; //如果当前枚举的最近距离符合，那么就让l=mid,看更大的距离是否也符合（因为要求最大的最近距离） else r = mid-1; &#125; cout &lt;&lt; r&lt;&lt; endl; //由于最后l&lt;=r的时候还会运行一次，会让l-1(如果答案正确的话)，所以应该输出的是r return 0;&#125; 第八章 排序判断题1-1 仅基于比较的算法能得到的最好的“最坏时间复杂度”是O(NlogN)。T 1-2 对N个记录进行简单选择排序，比较次数和移动次数分别为O(N2)和O(N)。T 1-3 对N个记录进行快速排序，在最坏的情况下，其时间复杂度是O(NlogN)。F 1-4 希尔排序是稳定的算法。F 1-5 堆排序是稳定的排序算法。F 1-6 在堆排序中，若要进行升序排序，则需要建立大根堆。T 1-7 排序算法中的比较次数与初始元素序列的排列无关。F 1-8 排序的稳定性是指排序算法中的比较次数保持不变，且算法能够终止。F 1-9 对于n个记录的集合进行冒泡排序，在最坏情况下需要的时间是O(n2)。T 1-10 直接选择排序的时间复杂度为O(n2)，不受数据初始排列的影响。T 选择题(错题：2-6,2-11,2-12,2-13)2-1 对N个不同的数据采用冒泡算法进行从大到小的排序，下面哪种情况下肯定交换元素次数最多？ A.从小到大排好的 2-2 在对N个元素进行排序时，基于比较的算法中，其“最坏时间复杂度”中最好的是： C.O(Nlog**N) 2-3 对N个记录进行归并排序，归并趟数的数量级是： A.O(log**N) 2-4 有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为： D.84，79，56，38，40，46 2-5 采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是： C.递归次数与每次划分后得到的分区处理顺序无关 2-6有组记录的排序码为{46，79，56，38，40，84 }，采用快速排序（以位于最左位置的对象为基准而）得到的第一次划分结果为： D.{40,38,46,56,79,84} 2-7 对于10个数的简单选择排序，最坏情况下需要交换元素的次数为： A.9 将序列{ 2, 12, 16, 88, 5, 10, 34 }排序。若前2趟排序的结果如下： 第1趟排序后：2, 12, 16, 10, 5, 34, 88 第2趟排序后：2, 5, 10, 12, 16, 34, 88 则可能的排序算法是： C.快速排序 2-9 对初始数据序列{ 8, 3, 9, 11, 2, 1, 4, 7, 5, 10, 6 }进行希尔排序。若第一趟排序结果为（ 1, 3, 7, 5, 2, 6, 4, 9, 11, 10, 8 ），第二趟排序结果为（ 1, 2, 6, 4, 3, 7, 5, 8, 11, 10, 9 ），则两趟排序采用的增量（间隔）依次是： D.5, 3 2-10 下列排序算法中，占用辅助空间最多的是：( ) A.归并排序 2-11选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是： I、数据的规模 II、数据的存储方式 III、算法的稳定性 IV、数据的初始状态 D.I、II、III、IV 2-12 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列序列中，不可能是快速排序第二趟结果的是： D.5, 2, 12, 28, 16, 32, 72, 60 2-13 对大部分元素已有序的数组进行排序时，直接插入排序比简单选择排序效率更高，其原因是： (I). 直接插入排序过程中元素之间的比较次数更少 (II). 直接插入排序过程中所需要的辅助空间更少 (III). 直接插入排序过程中元素的移动次数更少 A.仅 I 2-14 下述几种排序方法中,( )是稳定的排序方法。 C.归并排序 填空题4-1 基于比较的排序方法，其最好的时间复杂度为O(nlogn) 4-2 时间复杂度为O(nlogn)的排序算法有归并排序、堆排序和快速排序 4-3对包含10个记录的表r[1..10]进行简单选择排序，所需进行的关键字间的比较次数为45 函数题6-1 快速排序 (15 分)12345678910111213141516171819202122int Partition(SqList &amp;L,int low,int high)&#123; int i=low,j=high; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;L.r[i].key&lt;=L.r[j].key)j--; if(i&lt;j)&#123;swap(L.r[i].key,L.r[j].key);i++;&#125; while(i&lt;j&amp;&amp;L.r[i].key&lt;=L.r[j].key)i++; if(i&lt;j)&#123;swap(L.r[i].key,L.r[j].key);j--;&#125; &#125; return i;&#125;void QuickSort(SqList &amp;L, int low, int high)&#123; if(low&gt;=high)return; else &#123; int pivot=Partition(L,low,high); QuickSort(L,low,pivot-1); QuickSort(L,pivot+1,high); &#125;&#125; 6-2 冒泡排序 (10 分)1234567891011void bubbleSort(int arr[], int n)&#123; int i,j; for(i=0;i&lt;n-1;i++) &#123; for(j=0;j&lt;n-i-1;j++) &#123; if(arr[j]&gt;arr[j+1])swap(&amp;arr[j],&amp;arr[j+1]); &#125; &#125;&#125; 6-3 简单选择排序 (10 分)1234567891011121314void SelectSort(SqList L)&#123; int i,j,mini,temp; int n = L.Length; for(i=1;i&lt;n;i++) &#123; mini=i; for(j=i+1;j&lt;n+1;j++) &#123; if(L.elem[mini]&gt;L.elem[j])mini=j; &#125; if(mini!=i)&#123;temp=L.elem[i];L.elem[i]=L.elem[mini];L.elem[mini]=temp;&#125; &#125;&#125; 6-4 堆排序 (10 分)12345678910111213141516171819void HeapAdjust( HeapType H, int s, int m)&#123; int dad,son,last,temp; dad=s;son=2*dad,last=m; while(son&lt;=last) &#123; if(son+1&lt;=last&amp;&amp;H.elem[son]&lt;H.elem[son+1])son++; if(H.elem[dad]&gt;H.elem[son])return; else &#123; temp=H.elem[son]; H.elem[son]=H.elem[dad]; H.elem[dad]=temp; dad=son; son=dad*2; &#125; &#125;&#125; 6-5 归并排序 (10 分)12345678910111213141516171819202122void Merge(SqList L,int low,int m,int high)&#123; int Q[high-low+1]; int i=low,j=m+1,k=0; while(i&lt;=m&amp;&amp;j&lt;=high) &#123; if(L.elem[i]&gt;=L.elem[j]) &#123; Q[k++]=L.elem[j++]; &#125; else if(L.elem[i]&lt;=L.elem[j]) &#123; Q[k++]=L.elem[i++]; &#125; &#125; while(i&lt;=m)Q[k++]=L.elem[i++]; while(j&lt;=high)Q[k++]=L.elem[j++]; for(int i=low,k=0;i&lt;=high;i++) &#123; L.elem[i]=Q[k++]; &#125;&#125; 编程题7-1 字符串的冒泡排序 (20 分) 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; string arr[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; &#125; for(int i=0;i&lt;n-1;i++) &#123; for(int j=0;j&lt;n-i-1;j++) &#123; if(arr[j]&gt;arr[j+1])swap(arr[j],arr[j+1]); &#125; if(i==k-1)break; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i]&lt;&lt;endl; return 0;&#125; 7-2 模拟EXCEL排序 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*#include&lt;iostream&gt;using namespace std;struct Info&#123; string id; string name; int score;&#125;;int main()&#123; int n,c,mini; cin&gt;&gt;n&gt;&gt;c; Info arr[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i].id&gt;&gt;arr[i].name&gt;&gt;arr[i].score; &#125; if(c==1) &#123; for(int i=0;i&lt;n-1;i++) &#123; mini=i; for(int j=i+1;j&lt;n;j++) &#123; if(arr[mini].id&gt;arr[j].id)mini=j; &#125; if(mini!=i)swap(arr[mini],arr[i]); &#125; &#125; else if(c==2) &#123; int exchange,bound,temp; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].id&gt;arr[j+1].id)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].name&gt;arr[j+1].name)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; &#125; else if(c==3) &#123; int exchange,bound,temp; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].id&gt;arr[j+1].id)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].score&gt;arr[j+1].score)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i].id&lt;&lt;&quot; &quot;&lt;&lt;arr[i].name&lt;&lt;&quot; &quot;&lt;&lt;arr[i].score&lt;&lt;endl; return 0;&#125;*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt; using namespace std;const int maxn = 100000 + 7;int n, c; struct node &#123; int id, sc; char name[22];&#125;a[maxn]; bool cmp1(node a, node b) &#123; return a.id &lt; b.id;&#125;bool cmp2(node a, node b) &#123; if(strcmp(a.name, b.name) == 0) return a.id &lt; b.id; return strcmp(a.name, b.name) &lt; 0;&#125;bool cmp3(node a, node b) &#123; if(a.sc == b.sc) return a.id &lt; b.id; return a.sc &lt; b.sc;&#125; int main() &#123; //char s[22], t[22]; //scanf(&quot;%s %s&quot;, s, t); //printf(&quot;%d\\n&quot;, strcmp(s, t)); scanf(&quot;%d %d&quot;, &amp;n, &amp;c); for(int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d %s %d&quot;, &amp;a[i].id, a[i].name, &amp;a[i].sc); &#125; if(c == 1) sort(a, a+n, cmp1); if(c == 2) sort(a, a+n, cmp2); if(c == 3) sort(a, a+n, cmp3); for(int i = 0; i &lt; n; ++i) printf(&quot;%.6d %s %d\\n&quot;, a[i].id, a[i].name, a[i].sc); return 0;&#125; 7-3 悄悄关注 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/*#include&lt;iostream&gt;using namespace std;struct Info&#123; string name; int zan;&#125;;int main()&#123; int n1,n2,avg=0; cin&gt;&gt;n1; string guanzhu[n1]; for(int i=0; i&lt;n1; i++) cin&gt;&gt;guanzhu[i]; cin&gt;&gt;n2; Info dianzan[n2],temp[n2]; for(int i=0; i&lt;n2; i++) &#123; cin&gt;&gt;dianzan[i].name&gt;&gt;dianzan[i].zan; avg+=dianzan[i].zan; &#125; avg /= n2; int flag=1,k=0; for(int i=0; i&lt;n2; i++) &#123; for(int j=0; j&lt;n1; j++) &#123; if(guanzhu[j]==dianzan[i].name) &#123; flag=0; break; &#125; &#125; if(flag&amp;&amp;dianzan[i].zan&gt;avg) &#123; temp[k++]=dianzan[i]; &#125; flag=1; &#125; if(k==0)cout&lt;&lt;&quot;Bing Mei You&quot;&lt;&lt;endl; else &#123; for(int i=0; i&lt;k-1; i++) &#123; int mini=i; for(int j=i+1; j&lt;k; j++) &#123; if(temp[j].name&lt;temp[mini].name)mini=j; &#125; if(mini!=i)swap(temp[mini],temp[i]); &#125; for(int i=0; i&lt;k; i++) cout&lt;&lt;temp[i].name&lt;&lt;endl; &#125; return 0;&#125;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;struct Info&#123; string name; int zan;&#125;;struct List&#123; Info dianzan[10000];&#125;;int Partition(List &amp;l,int first,int last)&#123; int i=first,j=last; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;l.dianzan[i].name&lt;=l.dianzan[j].name)j--; if(i&lt;j) &#123; swap(l.dianzan[i],l.dianzan[j]); i++; &#125; while(i&lt;j&amp;&amp;l.dianzan[i].name&lt;l.dianzan[j].name)i++; if(i&lt;j) &#123; swap(l.dianzan[i],l.dianzan[j]); j--; &#125; &#125; return i;&#125;void quicksort(List&amp;l,int first,int last)&#123; if(first&gt;=last)return; else &#123; int mid=Partition(l,first,last); quicksort(l,first,mid-1); quicksort(l,mid+1,last); &#125;&#125;int main()&#123; int n1,n2,zan,sum=0,flag=1,k=0; string name; List l; set&lt;string&gt; guanzhu; cin&gt;&gt;n1; for(int i=0;i&lt;n1;i++) &#123; cin&gt;&gt;name; guanzhu.insert(name); &#125; cin&gt;&gt;n2; for(int i=0;i&lt;n2;i++) &#123; cin&gt;&gt;name&gt;&gt;zan; sum+=zan; if(guanzhu.find(name)==guanzhu.end()) &#123; l.dianzan[k].name=name; l.dianzan[k++].zan=zan; &#125; &#125; sum/=n2; quicksort(l,0,k); for(int i=0;i&lt;k;i++) &#123; if(l.dianzan[i].zan&gt;=sum) &#123; cout&lt;&lt;l.dianzan[i].name&lt;&lt;endl; flag=0; &#125; &#125; if(flag)cout&lt;&lt;&quot;Bing Mei You&quot;&lt;&lt;endl; return 0;&#125;*/#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;int main()&#123; int n,m,i,j,k=0,s=0,f=0,a,fag=0; string s1,s2; map&lt;string,int&gt;p; set&lt;string&gt;p1; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;s1; p[s1]=0; &#125; cin&gt;&gt;m; int c[m]; char b[m][10]; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;s2&gt;&gt;a; s=s+a; if(p.find(s2)==p.end()) &#123; for(j=0;j&lt;sizeof(s2);j++) &#123; b[k][j]=s2[j]; &#125; c[k]=a; k++; &#125; else &#123; p[s2]=a; &#125; &#125; s=s/m; for(i=0;i&lt;k;i++) &#123; if(c[i]&gt;s) &#123; p1.insert(b[i]); f++; fag=1; &#125; &#125; if(fag==0) &#123; printf(&quot;Bing Mei You&quot;); &#125; else &#123; set&lt;string&gt;::iterator it; for(it=p1.begin();it!=p1.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"静态博客的创建","slug":"静态博客的建立","date":"2021-12-04T11:35:25.302Z","updated":"2022-04-19T01:06:00.156Z","comments":true,"path":"2021/12/04/静态博客的建立/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/","excerpt":"","text":"第一步：下载node​ D:\\my app\\nodejs 第二步：github注册​ -&gt;Zhang2002GZ.github.io（用户名.github.io） 第三步：下载git​ git for windows-&gt;cmd+r: git（D:\\my app\\Git） 第四步：SHH配置 (1)git_bash打开:$ ssh-keygen -t rsa -C “&#x32;&#x32;&#x35;&#49;&#55;&#x38;&#55;&#57;&#50;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;“-&gt;回车(4次)直至结束 记住这行Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa) 括号里面的地址是后面要用到的 (2)打开github-&gt;setting-&gt;SHH:title:Zhang2002GZ ;key:粘贴文本文档 user-&gt;zhangguozhi-&gt;.ssh-&gt;.pub 在github上建秘钥 第五步：hexo使用​ -&gt;文档 npm install hexo-cli -g //安装 hexo init blog //初始化博客 cd blog npm install //hexo server 新建目录blog-&gt;cmd+r-&gt;D:-&gt;cd blog-&gt;npm install hexo-cli -g-&gt;hexo init myblog-&gt;cd myblog-&gt;npm install -&gt;hexo s -p 4000 浏览器输入网址：localhost:4000 第六步：sublime安装​ -&gt;将博客目录直接拖进-&gt;## hello hexo PS：推荐直接在打开方式中选择记事本打开，在记事本里直接修改 第七步：hexo发布至github hexo-&gt;文档-&gt;部署repo sublime-&gt;_config.yml 1234567891011开头： \\# URL \\## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27; **url**: https://Zhang2002GZ.github.io末尾 \\# Deployment \\## Docs: https://hexo.io/docs/one-command-deployment deploy: **type: git repo: https://github.com/Zhang2002GZ/Zhang2002GZ.github.io.git branch: master** hexo-&gt;文档-&gt;部署 hexo g-&gt;npm install hexo-deployer-git –save-&gt;hexo d 123type: git repository: https://github.com/zhang2002gz/zhang2002gz.github.io.git branch: main hexo init( Start blogging with Hexo!)-&gt;静态生成本地的hexo页面hexo s(打开本地服务器：将http://localhost:4000可以看见博客；ctrl+c关闭服务器就看不见页面） -&gt;npm install hexo-deployer-git –save-&gt;生成页面hexo g-&gt;将本地文件上传github hexo d （error10054:这个保错就执行git config –global http.sslVerify “false”） **!**登入页面弹窗只在第一次创建的时候出现 第八步：美化 git clone https://github.com/theme-nexmoe/hexo-theme-nexmoe.git themes/nexmoe (git clone 改页面代码所在地址.git 存到themes目录下/新建的nexmoe) sublime修改_config.yml:theme: nexmoe 也可以在release里下载压缩包将它解压到themes中 npm install –save hexo-renderer-pug git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun theme: sbun 清理一下hexo clean ,生成一下 hexo g,hexo s(打开服务器），hexo d(上传） 其他检查： 123456789101112node -v git --version npm -v hexo -vssh $ ssh -T git@github.com （Hi zhang2002gz! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.）查看npm安装hexo插件的情况 npm ls --depth 0安装缺失的插件 npm install acorn --save 万能三件套： 12345git config --global --unset http.proxygit config --global --unset https.proxygit config --global http.sslVerify &quot;false&quot; 一些pure主题的配置hexo-theme-pure/README.cn.md at master · cofess/hexo-theme-pure (github.com) 1234567891011121314151617181920212223242526272829文章索引目录title: 文章标题categories: - 文章分类tags: - 文章标签toc: true # 是否启用内容索引sidebar侧边栏文章侧边栏默认为开启状态，如果某篇文章不想开启侧边栏，在文章开头配置加入“sidebar: none”即可：title: 文章标题categories: - 文章分类tags: - 文章标签sidebar: none # 是否启用sidebar侧边栏，none：不启用友情链接Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot; 安装主题git clone https://github.com/cofess/hexo-theme-pure.git themes/pure更新主题cd themes/puregit pull 相关视频【2021最新版】保姆级Hexo+github搭建个人博客_哔哩哔哩_bilibili Hexo博客开发之——WARN No layout index.html - 程序员大本营 (pianshen.com) 12345678910111213141516Git 全局设置: git config --global user.name &quot;zhang-guozhi&quot; git config --global user.email &quot;10094335+zhang-guozhi@user.noreply.gitee.com&quot; 创建 git 仓库: mkdir zhang-guozhi cd zhang-guozhi git init touch README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://gitee.com/zhang-guozhi/zhang-guozhi.git git push -u origin master 已有仓库? cd existing_git_repo git remote add origin https://gitee.com/zhang-guozhi/zhang-guozhi.git git push -u origin master 一些符号的使用12345加粗：**文字**取消加粗：\\**文字**显示\\ : \\\\ &gt; 文字 12345678910111213表格同一格里换行：文字&lt;br/&gt;---title: 基础知识1categories: - 智能车tags: - 笔记toc: true----空格：无序列表（下面那个点，回车会再有一个点）---回车（下面那个分隔线） Markdown设置字体颜色(2条消息) 【Markdown笔记】设置字体颜色_dadalaohua的博客-CSDN博客_markdown设置字体颜色 markdown中公式编辑教程markdown中公式编辑教程 - 简书 (jianshu.com)","categories":[],"tags":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-27T13:15:34.628Z","updated":"2022-03-28T16:04:26.767Z","comments":true,"path":"2021/11/27/hello-world/","link":"","permalink":"https://zhang0224gz.github.io/2021/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"},{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"语文","slug":"语文","permalink":"https://zhang0224gz.github.io/categories/%E8%AF%AD%E6%96%87/"},{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"},{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zhang0224gz.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"教育知识与能力","slug":"教育知识与能力","permalink":"https://zhang0224gz.github.io/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/"},{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]}