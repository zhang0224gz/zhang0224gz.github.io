{"meta":{"title":"Hexo","subtitle":"","description":"","author":"zhang0224gz","url":"https://zhang0224gz.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"categories/index.html","permalink":"https://zhang0224gz.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-10T12:34:35.626Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"about/index.html","permalink":"https://zhang0224gz.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-01-10T12:34:35.638Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"books/index.html","permalink":"https://zhang0224gz.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":true,"path":"links/index.html","permalink":"https://zhang0224gz.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-04T09:57:19.826Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"tags/index.html","permalink":"https://zhang0224gz.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-04T10:33:16.481Z","updated":"2021-12-04T09:57:19.826Z","comments":false,"path":"repository/index.html","permalink":"https://zhang0224gz.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"暑期社会实践投稿指北","date":"2022-09-04T00:21:29.392Z","updated":"2022-09-04T00:21:30.796Z","comments":true,"path":"2022/09/04/暑期社会实践投稿指北/","link":"","permalink":"https://zhang0224gz.github.io/2022/09/04/%E6%9A%91%E6%9C%9F%E7%A4%BE%E4%BC%9A%E5%AE%9E%E8%B7%B5%E6%8A%95%E7%A8%BF%E6%8C%87%E5%8C%97/","excerpt":"","text":"网站 备注 中青网 这个不用介绍，为了量化还是尽量尝试这一个 中国大学生在线 这个 大美校园 这一个实际上是一个微博号，确实有不少咱学校的在上面投稿 多彩大学生网 这个网站换过域名，原域名现在是一个博彩网站… 今日大学生网 这个网站就是我说的，一个三无网站，按照网信部门的要求，今日大学生网已经关停 中国大学生之声 这个也是被关停了…怎么说呢虚假的中字头 从凑大学生 链接找到了，怎么发文等后续找下 当代大学生网 这个与上面几个类似，这个也是靠这东西圈钱的，流程麻烦，投稿两元一篇… 爱开大学生网 这个和从凑应该是一家的，也是靠社会实践赚钱的，大概一篇不到一块… 大学生新闻网 跟上面那个的模式一模一样…估计是一家的… 大学生校园网 同上…同样的我在友链里还翻到了大学生家园真就模板都不改只换配色… 大学生网报 一众收费之中找到了一个免费,一天10篇免费… 类似的还有一大堆如http://www.university-china.com/这个域名的中国大学生网…这上面甚至一大堆友情链接，估计也是一家的。 只能说大学生的钱真好赚，我这就去写一个坐等收钱…","categories":[],"tags":[]},{"title":"","slug":"笔记/计算机网络/计算机网络实训","date":"2022-08-29T12:09:11.231Z","updated":"2022-09-04T08:42:46.183Z","comments":true,"path":"2022/08/29/笔记/计算机网络/计算机网络实训/","link":"","permalink":"https://zhang0224gz.github.io/2022/08/29/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E8%AE%AD/","excerpt":"","text":"title:计算机网络实训 实训一阶段1：基本网络通信 要求： 开发一个聊天程序； 包含客户端和服务器端； 编程语言不限； 要能在两台PC上运行。 初级阶段1：socket使用 在TCP中，客户端的实现流程：（1）创建客户端的socket对象 （2）建立与服务器之间的联系 （3）发送请求 （4）接收数据 （5）关闭连接 服务端的实现流程：（1）创建服务端的socket对象 （2）绑定服务端的地址 （3）设置监听器 （4）等待客户端的连接 （5）接收客户端的请求 （6）返回处理的结果到客户端 套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口 应用程序接口（英语：Application Programming Interface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。 1234567891011121314socket编程思路TCP服务端：1 创建套接字，绑定套接字到本地IP与端口 # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()2 开始监听连接 #s.listen()3 进入循环，不断接受客户端的连接请求 #s.accept()4 然后接收传来的数据，并发送给对方数据 #s.recv() , s.sendall()5 传输完毕后，关闭套接字 #s.close()TCP客户端:1 创建套接字，连接远端地址 # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()2 连接后发送数据和接收数据 # s.sendall(), s.recv()3 传输完毕后，关闭套接字 #s.close() subprocess 模块允许我们启动一个新进程，并连接到它们的输入/输出/错误管道，从而获取返回值。 Python3 网络编程 Python 提供了两个级别访问的网络服务。： 低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。 高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。 Socket又称&quot;套接字&quot;，应用程序通常通过&quot;套接字&quot;向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 网络中进程间如何通信，即利用三元组【ip地址，协议，端口】可以进行网络间通信了，那我们应该怎么实现了，因此，我们socket应运而生，它就是利用三元组解决网络通信的一个中间件工具 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。 123[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”[Shake 2] 套接字B：“好的，我这边已准备就绪。”[Shake 3] 套接字A：“谢谢你受理我的请求。 服务器端套接字 s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。listen函数中backlog的含义是什么？完成队列的长度 (https://zhuanlan.zhihu.com/p/78879634) s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来 客户端套接字 s.connect() 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。 公共用途的套接字函数 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 s.close() 关闭套接字 代码0.1 作用：可以实现服务端和客户端简单交互，但仅限同一个局域网内，且一对一，只能发送一句话 123456789101112错误类型：1.LookupError: unknown encoding: uft-8这个错误是记录错误类型的,第一次遇到LookupError ,这个是编码格式本来应该是utf-8 自己打字的时候打错了,打成uft-8 了 所以就出现了这个错误.2.AttributeError: &#x27;tuple&#x27; object has no attribute &#x27;send&#x27;错误原因： server.accept()的返回值是一对(conn, address)，其中conn是一个新的套接字对象，可用于在连接上发送和接收数据，地址是绑定到连接另一端的套接字的地址。解决方法：client,addr = server.accept()3.TimeoutError: [WinError 10060] 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。防火墙没开放该端口网上找到这个……经过24小时检验：socket仅限在局域网使用，所以……一个热点IP和学校内网一起玩……不可能，想的话买个服务器。所以要么开两个学校电脑，要么就在自己电脑上玩耍。host=&#x27;服务器的静态IP&#x27;（IPv4地址）host = socket.gethostbyname(socket.gethostname()) （土豆那缺儿，我们一直检验都连不起来原来它是IPv4网关……）4.这个时端口号未开放的原因，在防火墙里开放就行 123456789101112131415161718192021#客户端#客户端IP地址：192.168.55.43#服务器端IP地址：192.168.120.209import socket#host = socket.gethostname() #获取本地主机名host = &#x27;192.168.31.129&#x27;port = 8800 #设置端口print(host)##第一步：创建嵌套字，连接远端地址client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象client.connect((host,port)) #连接服务端，指定主机和端口##第二步：连接后发送数据/接收数据msg = client.recv(1024) #接收小于1024字节的数据##第三步：传输完毕，关闭嵌套字client.close()print(msg.decode(&#x27;utf-8&#x27;)) 123456789101112131415161718192021222324252627#服务端#客户端IP地址：192.168.55.43#服务器端IP地址：192.168.120.209import socket#host = socket.gethostname() #获取本地主机名host = &#x27;192.168.120.209&#x27;port = 8800print(host)##第一步：创建嵌套字，绑定套接字到本地IP与端口server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象server.bind((host,port)) #绑定端口号#bind():绑定地址（host,port）到套接字,在AF_INET下,以元组（host,port）的形式表示地址##第二步：监听连接server.listen(1) #开始监听;最大连接1台客户端，超过后排队##第三步：进入循环，不断接受客户端的连接请求while True: client,addr = server.accept() #创建客户端连接 print(&quot;连接地址：%s&quot;%str(addr)) ##第四步：接收传来的数据/发送给对方数据 msg = &#x27;Hello!&#x27; client.send(msg.encode(&#x27;utf-8&#x27;)) ##第五步：传输完毕后，关闭套接字 client.close() 为什么多个客户端可以连接服务器的同个端口？ 我们这里讲Socket连接： 1.端口只是一个数字辨识，不是真正的物理端口； 2.一个Socket连接的主键（即不同socket之间的区分）是由一个五元组{SRC-IP, SRC-PORT, DEST-IP, DEST-PORT, PROTOCOL}组成，即{源地址，源端口，目标地址，目标端口，协议}组成，那些说四元组不包含协议的说法是错误的。 3.一个进程可以拥有多个socket连接。 例子一、两个客户端连接在同个服务器的同个端口80，即有两个socket连接： - socket1 {SRC-A, 100, DEST-X,80, TCP} - socket2{SRC-B, 100, DEST-X,80, TCP} 主机A和主机B的地址不同，两台主机同时连接到服务器X的80端口。服务器要怎么处理这个连接是它的事，我们要理解的是为什么一个主机同个端口能监听多个客户端Socket连接。 解释： 1.是因为两个客户端的IP不同，服务器能识别出不同的Socket； 2.即使IP地址相同，端口不同，服务器也能够分辨； 3.只要服务器知道收到的请求和哪个socket相关，那么它就能使用这个socket正确地回复那个客户端； 4.如果对于不同的socket需要不同的端口，那么不仅仅浪费服务器资源，而且每次客户端连接上serverSocket之后还要另外分配新的端口和客户端通信。没必要。 例子二、不同的进程可以监听同一个端口。 因此在服务器的两个使用不同协议的进程可以监听同一个端口。 如果一个socket的辨识只是四元组不包括协议{SRC-IP, SRC-PORT, DEST-IP, DEST-PORT}，那么不同进程是不可能同时监听同一个端口的。没有协议的话一个客户端连接到同一台某个有两个进程监听端口的服务器，那么就没有什么机制可以确定客户端是要连接哪一个进程了。 总结： 不同协议可以监听同一个端口（不管是不是在服务器的同个进程） 某个协议的进程可以监听多个客户端的连接，因为只要五元组不同进程就能分辨。 从上面的例子可以知道，客户端同个进程也可以在同个端口用不同的协议与客户端建立连接。 一、Socket技术详解 - 简书 (jianshu.com) 代码0.2 作用：在0.1基础上，实现服务器接收数据，客户端发送数据 123456789101112131415161718192021222324#服务端import sockethost = socket.gethostname() #获取本地主机名port = 9999print(host)##第一步：创建嵌套字，绑定套接字到本地IP与端口server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象server.bind((host,port)) #绑定端口号#bind():绑定地址（host,port）到套接字,在AF_INET下,以元组（host,port）的形式表示地址##第二步：监听连接server.listen(2) #开始监听;最大连接1台客户端，超过后排队##第三步：进入循环，不断接受客户端的连接请求while True: client,addr = server.accept() #创建客户端连接 print(&quot;连接地址：%s&quot;%str(addr)) ##第四步：接收传来的数据和转发对方数据 msg = client.recv(1024) #接收小于1024字节的数据 print(msg.decode(&#x27;utf-8&#x27;)) ##第五步：传输完毕后，关闭套接字 client.close() 12345678910111213141516171819#客户端import sockethost = socket.gethostname() #获取本地主机名#host = socket.gethostbyname(socket.gethostname())#host = &#x27;39.144.108.89&#x27;port = 9999 #设置端口print(host)##第一步：创建嵌套字，连接远端地址client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象client.connect((host,port)) #连接服务端，指定主机和端口##第二步：连接后发送数据/接收数据msg = &#x27;Hello!&#x27;client.send(msg.encode(&#x27;utf-8&#x27;))##第三步：传输完毕，关闭嵌套字client.close() 代码0.3 作用：在0.2基础上，实现可传可接收，但存在问题，未解决 1234567891011121314151617181920212223242526272829303132333435#服务端import sockethost = socket.gethostname() #获取本地主机名#host = &#x27;192.168.120.29&#x27; #服务端IP地址port = 8800max_connect = 1 #最大连接客户端数max_receive_data = 1024 #最大接收字节数server_name = &#x27;老王&#x27; #设置用户名##第一步：创建嵌套字，绑定套接字到本地IP与端口server = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象server.bind((host,port)) #绑定端口号##第二步：监听连接server.listen(max_connect) #开始监听;最大连接1台客户端，超过后排队print(&#x27;Server is ready.&#x27;)##第三步：进入循环，不断接受客户端的连接请求while True: client,addr = server.accept() #创建客户端连接 print(&quot;连接地址：%s&quot;%str(addr)) ##第四步：接收传来的数据/发送给对方数据 #发送数据 send_msg = input(&#x27;请输入：&#x27;) send_msg = server_name + &#x27;: &#x27;+ send_msg client.send(send_msg.encode(&#x27;utf-8&#x27;)) if send_msg == &#x27;close&#x27;: break #接收数据 receive_msg = client.recv(max_receive_data) print(receive_msg.decode(&#x27;utf-8&#x27;)) ##第五步：传输完毕后，关闭套接字client.close() 12345678910111213141516171819202122232425262728#客户端import sockethost = socket.gethostname() #获取本地主机名#host = &#x27;192.168.31.129&#x27; #服务端IP地址port = 8800 #设置端口max_receive_data = 1024 #最大接收字节数client_name = &#x27;老刘&#x27; #设置用户名##第一步：创建嵌套字，连接远端地址client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象client.connect((host,port)) #连接服务端，指定主机和端口print(&#x27;Connecting is successful!&#x27;)##第二步：连接后发送数据/接收数据while True: #接收数据 receive_msg = client.recv(max_receive_data) print(receive_msg.decode(&#x27;utf-8&#x27;)) if receive_msg.decode(&#x27;utf-8&#x27;)==&#x27;close&#x27;: break #发送数据 send_msg = input(&#x27;请输入：&#x27;) send_msg = client_name + &#x27;: &#x27;+ send_msg client.send(send_msg.encode(&#x27;utf-8&#x27;)) ##第三步：传输完毕，关闭嵌套字client.close() 初级阶段2：hreading使用 12服务器端的套接字起到监听的作用（类似电话主机），每连接成功一个客户端，就返回一个和客户端通信的套接字（类似电话的分机），服务器端用每个“分机”和每个客户端进行通信。因为我们使用的是默认的阻塞套接字，服务器和每个客户端通信的过程都是阻塞的，所以，为了服务器可以“同时”（并发）和客户端进行通信，我们用到了多线程。 hreading(多线程)模块中包含了关于线程操作的丰富功能，包括：常用线程函数，线程对象，锁对象，递归锁对象，事件对象，条件变量对象，信号量对象，定时器对象，栅栏对象。 创建 Thread 对象有 2 种手段： 1.直接创建 Thread ，将一个 callable 对象从类的构造器传递进去，这个 callable 就是回调函数，用来处理任务。 2.编写一个自定义类继承 Thread，然后复写 run() 方法，在 run() 方法中编写任务处理代码，然后创建这个 Thread 的子类。 (29条消息) Python多线程编程(一）：threading 模块 Thread 类的用法详解_frank909的博客-CSDN博客_python threading Python 将一个列表里面的元素拼接成一个字符串: 注意: 1. 列表里面的元素必须全是字符串才可以使用join()进行拼接 2. 返回的是一个字符串 12item1 = [&quot;lowman&quot;, &quot;isbusy&quot;]item2 = &quot;,&quot;.join(item1) # 根据实际需要使用相应的分隔符连接列表元素,如 , : ; 或者空字符串 Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。 用户线程和守护线程的区别： 1.主线程结束后用户线程还会继续运行,JVM存活；主线程结束后守护线程和JVM的状态又下面第2条确定。 2.如果没有用户线程，都是守护线程，那么JVM结束（随之而来的是所有的一切烟消云散，包括所有的守护线程）。 (29条消息) Thread.setDaemon详解_starfe-geek的博客-CSDN博客_thread.setdeamon Threading模块的对象 描述 Thread 线程对象 Threading模块的Thread类 描述 name 线程名（属性） ident 线程标识符（属性） daemon 线程是否是守护线程（属性） init(group=None, tatget=None, name=None, args=(),kwargs ={}, verbose=None, daemon=None) 实例化一个线程对象，需要有一个可调用的 target，以及其参数 args或 kwargs。还可以传递 name 或 group 参数，不过后者还未实现。此外， verbose 标 志 也 是 可 接 受 的。 而 daemon 的 值 将 会 设定thread.daemon 属性/标志 start() 开启线程 run() 定义线程功能的方法（通常在子类中被应用开发者重写） (29条消息) Python3——多线程之threading模块_a1314521531的博客-CSDN博客_python3 threading Python中获取异常（Exception）信息 repr(e) 给出较全的异常信息，包括异常信息的类型，如1/0的异常信息 “ZeroDivisionError(‘integer division or modulo by zero’,)” 代码0.4 作用：在0.3基础上实现多客户端交流，但发送数据和接收数据（显示）安排不合理 (29条消息) python实现简易聊天室程序_Castria的博客-CSDN博客_python聊天室项目代码 首先服务器端创建ServerSocket对象，等待客户连接。 每当有一个客户连接上时，使用一个线程保存其Socket，把该线程保存在一个HashMap集合中。 客户端有信息发送给服务器时，服务器先获取要接收者用户名，根据用户名获取保存的线程（如果没有找到该线程则回发给发送者消息提示其需要联系的用户未上线），再根据该线程创建输出流，把消息转发给接收者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#服务器import socketimport threadinghost = socket.gethostname() # 获取本地主机名port = 9999 # 设置端口max_connect = 2 # 设置最大连接客户端数max_recedata = 1024 # 设置最大接收字节数print(host)server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建socket对象server.bind((host, port)) # 绑定端口号server.listen(max_connect) # 开始监听;最大连接2台客户端，超过后排队print(&#x27;ServerSocket is ready.&#x27;)cnt = 0 # 当前在线人数textList = [] # 存储历史记录socketList = [] # 存储已有客户端（套接字）# 自定义类继承，重写run()方法class ThreadCreate(threading.Thread): def __init__(self, client): # 线程初始化 threading.Thread.__init__(self) # 当作Thread的固定结构吧…… self.client = client # 保存嵌套字（客户端） socketList.append(client) # 把嵌套字存在列表里 def run(self): try: global cnt for sock in socketList: if sock == self.client: sock.send((&#x27;Old client.There are %d presons.&#x27;%(cnt)).encode(&#x27;utf-8&#x27;)) else: sock.send((&#x27;New Client is Coming.There are %d presons.&#x27;%(cnt)).encode(&#x27;utf-8&#x27;)) while True: word = self.client.recv(max_recedata).decode() #接收数据 textList.append(word) #生成历史记录 for sock in socketList: #给所有客户端发送新消息 sock.send((&#x27;\\n&#x27;+word).encode(&#x27;utf-8&#x27;)) except Exception as e: #客户端强制断开连接（关闭窗口） print(repr(e)) #如何加一个时间戳？ cnt = cnt-1 print(&#x27;Lose one person.There are %d persons.&#x27;%(cnt)) socketList.remove(self.client) #移除该客户端 for sock in socketList: sock.send((&#x27;Lose one person.There are %d persons.&#x27;%(cnt)).encode())while True: client, addr = server.accept() # 创建客户端连接，每次接收一个连接 print(&quot;连接地址：%s&quot; % str(addr)) try: # 关于历史记录的处理 if len(textList) == 0: client.send(&#x27;No message.&#x27;.encode(&#x27;utf-8&#x27;)) else: client.send(&#x27;\\n&#x27;.join(textList).encode(&#x27;utf-8&#x27;)) cnt = cnt + 1 # 来了一个人加一 # 给用户创建新进程 newThread = ThreadCreate(client) newThread.setDaemon(True) # 设置为守护线程 newThread.start() # 开启线程 print(&#x27;Connecting is successful!The number of people is &#x27; + str(cnt) + &#x27;.&#x27;) except Exception as e: print(repr(e)) # finally: # client.close() 12345678910111213141516171819202122232425262728293031323334353637383940#客户端import socketimport threadingserver_host = socket.gethostname() #获取本地主机名server_port = 9999 #设置端口max_recedata = 1024 # 设置最大接收字节数client_name = &#x27;Nacy&#x27;print(server_host)client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象print(&#x27;Connecting......&#x27;)client.connect((server_host,server_port)) #连接服务端，指定主机和端口print(&#x27;Connecting is successful!&#x27;)msg = client.recv(max_recedata) #先接收历史消息if msg.decode(&#x27;utf-8&#x27;)!=&#x27;No message.&#x27;: print(msg.decode(&#x27;utf-8&#x27;)+&#x27;\\n------以上是历史消息------\\n&#x27;)#接收文字的线程#由于用户的发送和接收消息是不同步的，在接收消息时线程会阻塞，所以另开启一个线程进行接收文字class ThreadReceive(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): while True: receive_msg = client.recv(max_recedata) print(receive_msg.decode(&#x27;utf-8&#x27;))textThread = ThreadReceive()textThread.start()#发送文字def send(): while True: send_msg = input(&#x27;请输入：&#x27;) if send_msg==&#x27;0&#x27;: break client.send((client_name+&#x27;: &#x27;+send_msg).encode(&#x27;utf-8&#x27;))send() 代码0.5 作用：在0.4基础上加了时间戳，将input里的字符删了，直接输就行…… (29条消息) Python 给某个文件名添加时间戳_cheney康的博客-CSDN博客 (29条消息) python：threading.Thread类的使用详解_啊啊啊西吧的博客-CSDN博客_python thread python中的多线程锁lock=threading.Lock()如何使用 - 开发技术 - 亿速云 (yisu.com) 12345678mutex = threading.Lock()#锁的使用#创建锁mutex = threading.Lock()#锁定mutex.acquire([timeout])#释放mutex.release() 发现没啥要修改的…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#服务端import socketimport socketimport threadinghost = socket.gethostname() # 获取本地主机名port = 9999 # 设置端口max_connect = 2 # 设置最大连接客户端数max_recedata = 1024 # 设置最大接收字节数print(host)server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建socket对象server.bind((host, port)) # 绑定端口号server.listen(max_connect) # 开始监听;最大连接2台客户端，超过后排队print(&#x27;ServerSocket is ready.&#x27;)cnt = 0 # 当前在线人数textList = [] # 存储历史记录socketList = [] # 存储已有客户端（套接字）# 自定义类继承，重写run()方法class ThreadCreate(threading.Thread): def __init__(self, client): # 线程初始化 threading.Thread.__init__(self) # 当作Thread的固定结构吧…… self.client = client # 保存嵌套字（客户端） socketList.append(client) # 把嵌套字存在列表里 def run(self): try: global cnt for sock in socketList: if sock == self.client: sock.send((&#x27;Welcome!There are %d presons.&#x27;%(cnt)).encode(&#x27;utf-8&#x27;)) else: sock.send((&#x27;New Client is Coming.There are %d presons.&#x27;%(cnt)).encode(&#x27;utf-8&#x27;)) while True: word = self.client.recv(max_recedata).decode() #接收数据 textList.append(word) #生成历史记录 for sock in socketList: #给所有客户端发送新消息 sock.send((&#x27;\\n&#x27;+word).encode(&#x27;utf-8&#x27;)) except Exception as e: #客户端强制断开连接（关闭窗口） print(repr(e)) #如何加一个时间戳？ cnt = cnt-1 print(&#x27;Lose one person.There are %d persons.&#x27;%(cnt)) socketList.remove(self.client) #移除该客户端 for sock in socketList: sock.send((&#x27;Lose one person.There are %d persons.&#x27;%(cnt)).encode())while True: client, addr = server.accept() # 创建客户端连接，每次接收一个连接 print(&quot;连接地址：%s&quot; % str(addr)) try: # 关于历史记录的处理 if len(textList) == 0: client.send(&#x27;No message.&#x27;.encode(&#x27;utf-8&#x27;)) else: client.send(&#x27;\\n&#x27;.join(textList).encode(&#x27;utf-8&#x27;)) cnt = cnt + 1 # 来了一个人加一 # 给用户创建新进程 newThread = ThreadCreate(client) newThread.setDaemon(True) # 设置为守护线程 newThread.start() # 开启线程 print(&#x27;Connecting is successful!The number of people is &#x27; + str(cnt) + &#x27;.&#x27;) except Exception as e: print(repr(e)) # finally: # client.close() 123456789101112131415161718192021222324252627282930313233343536373839#客户端import threadingserver_host = socket.gethostname() #获取本地主机名server_port = 9999 #设置端口max_recedata = 1024 # 设置最大接收字节数client_name = &#x27;Helen&#x27;print(server_host)lock = threading.Lock() #创建锁client = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #创建socket对象print(&#x27;Connecting......&#x27;)client.connect((server_host,server_port)) #连接服务端，指定主机和端口print(&#x27;Connecting is successful!&#x27;)msg = client.recv(max_recedata) #先接收历史消息if msg.decode(&#x27;utf-8&#x27;)!=&#x27;No message.&#x27;: print(msg.decode(&#x27;utf-8&#x27;)+&#x27;\\n------以上是历史消息------\\n&#x27;)#接收文字的线程#由于用户的发送和接收消息是不同步的，在接收消息时线程会阻塞，所以另开启一个线程进行接收文字class ThreadReceive(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): while True: receive_msg = client.recv(max_recedata) print(receive_msg.decode(&#x27;utf-8&#x27;))textThread = ThreadReceive()textThread.start()#发送文字def send(): while True: send_msg = input() if send_msg == &#x27;0&#x27;: break client.send((client_name+&#x27;: &#x27;+send_msg).encode(&#x27;utf-8&#x27;))send() 初级阶段3：可视化 代码0.6 作用：有问题，修理中……主要是服务器老炸了……可能是类的原因 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#服务端# -*- coding:utf-8 -*-import wximport socketimport threadingdef getIP(): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) s.connect((&quot;8.8.8.8&quot;, 80)) ip=s.getsockname()[0] return iphost = getIP() # 获取本地主机名port = 8000 # 设置端口max_connect = 2 # 设置最大连接客户端数max_recedata = 2048 # 设置最大接收字节数print(host)cnt = 0 # 当前在线人数textList = [] # 存储历史记录socketList = [] # 存储已有客户端（套接字）# 自定义类继承，重写run()方法class ThreadCreate(threading.Thread): def __init__(self, client): # 线程初始化 threading.Thread.__init__(self) # 当作Thread的固定结构吧…… self.client = client # 保存嵌套字（客户端） socketList.append(client) # 把嵌套字存在列表里 def run(self): try: global cnt for sock in socketList: if sock == self.client: sock.send((&#x27;Welcome!There are %d presons.&#x27;%(cnt)).encode()) else: sock.send((&#x27;New Client is Coming.There are %d presons.&#x27;%(cnt)).encode()) while True: word = self.client.recv(max_recedata).decode() #接收数据 textList.append(word) # 生成历史记录 for sock in socketList: # 给所有客户端发送新消息 sock.send((&#x27;\\n&#x27;+word).encode()) except Exception as e: # 客户端强制断开连接（关闭窗口） print(repr(e)) # 如何加一个时间戳？ cnt = cnt-1 print(&#x27;Lose one person.There are %d persons.&#x27;%(cnt)) socketList.remove(self.client) # 移除该客户端 for sock in socketList: sock.send((&#x27;Lose one person.There are %d persons.&#x27;%(cnt)).encode())class Frame(wx.Frame): def __init__(self): wx.Frame.__init__(self, None, title=&#x27;多人聊天系统（服务器）&#x27;, size=(400, 300),name=&#x27;frame&#x27;,style=541072960) self.qdck = wx.Panel(self) self.qdck.SetOwnBackgroundColour((255, 255, 255, 255)) self.Centre() self.an1 = wx.Button(self.qdck,size=(120, 40),pos=(44, 160),label=&#x27;启动客户端&#x27;,name=&#x27;button&#x27;) self.an1.SetAuthNeeded(True) self.an1.Bind(wx.EVT_BUTTON,self.an1_anbdj) self.an2 = wx.Button(self.qdck,size=(120, 40),pos=(227, 160),label=&#x27;关闭客户端&#x27;,name=&#x27;button&#x27;) self.an2.SetAuthNeeded(True) self.an2.Bind(wx.EVT_BUTTON,self.an2_anbdj) self.bq1 = wx.StaticText(self.qdck,size=(240, 40),pos=(80, 35),label=&#x27;多人聊天系统客户端&#x27;,name=&#x27;staticText&#x27;,style=2321) bq1_字体 = wx.Font(16,70,90,400,False,&#x27;Microsoft YaHei UI&#x27;,-1) self.bq1.SetFont(bq1_字体) def an1_anbdj(self,event): # print(&#x27;an1,按钮被单击&#x27;) server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建socket对象 server.bind((host, port)) # 绑定端口号 server.listen(max_connect) # 开始监听;最大连接2台客户端，超过后排队 print(&#x27;ServerSocket is ready.&#x27;) while True: client, addr = server.accept() # 创建客户端连接，每次接收一个连接 print(&quot;连接地址：%s&quot; % str(addr)) try: global cnt # 关于历史记录的处理 if len(textList) == 0: client.send(&#x27;No message.&#x27;.encode()) else: client.send(&#x27;\\n&#x27;.join(textList).encode()) cnt = cnt + 1 # 来了一个人加一 # 给用户创建新进程 newThread = ThreadCreate(client) newThread.setDaemon(True) # 设置为守护线程 newThread.start() # 开启线程 print(&#x27;Connecting is successful!The number of people is &#x27; + str(cnt) + &#x27;.&#x27;) except Exception as e: print(repr(e)) def an2_anbdj(self,event): print(&#x27;an2,按钮被单击&#x27;)class myApp(wx.App): def OnInit(self): self.frame = Frame() self.frame.Show(True) return Trueif __name__ == &#x27;__main__&#x27;: app = myApp() app.MainLoop() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# coding=utf-8import wximport socketimport threadingfrom time import sleep, localtimefrom datetime import datetimeserver_host = socket.gethostname()# 获取本地主机名server_port = 8000# 设置端口max_recedata = 2048# 设置最大接收字节数client_name = socket.gethostname()print(server_host)lock = threading.Lock()# 创建锁host_ip = &#x27;&#x27;client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 创建socket对象class chuangkou(wx.Frame): def __init__(self): self.liaotian = 0 # 判断是否取过消息记录 super(chuangkou, self).__init__(None, -1, title=&quot;多人聊天程序&quot;, size=(600, 600)) self.a = wx.Panel(self) # 创建一个画板 self.ip=wx.TextCtrl(self.a,style=wx.TE_PROCESS_ENTER ,value=&quot;请输入服务器的ip地址&quot;) # 创建一个输入服务器ip地址的输入框 self.b = wx.Button(self.a, wx.ID_ANY, &quot;确定&quot;) self.b.SetAuthNeeded(True) self.b.Bind(wx.EVT_BUTTON, self.b_anbdj) # 创建一个聊天创建的输入框 self.text = wx.TextCtrl(self.a, style=wx.TE_READONLY | wx.TE_MULTILINE | wx.TE_RICH2 | wx.BORDER_SIMPLE | wx.HSCROLL) self.text.SetBackgroundColour(&#x27;#d1d1d1&#x27;) # 颜色改变为灰 self.ctrl = wx.TextCtrl(self.a, style=wx.TE_PROCESS_ENTER | wx.TE_MULTILINE,value=&quot;&quot;) # 创建一个输入发送聊天内容的输入框 self.sent = wx.Button(self.a, wx.ID_ANY, &quot;发送&quot;) self.sent.SetAuthNeeded(True) self.sent.Bind(wx.EVT_BUTTON, self.sent_anbdj) box = wx.BoxSizer(wx.HORIZONTAL) # 创建一个垂直布局 box1 = wx.BoxSizer(wx.VERTICAL) # 创建一个平行布局 box1.Add(self.ip,proportion=3, flag=wx.EXPAND|wx.TOP,border=0) # 输入ip地址的输入框的布局 box1.Add(self.b, proportion=1, flag=wx.EXPAND | wx.TOP, border=0) # 查看聊天记录按钮的布局 box1.Add(self.text, proportion=30, flag=wx.EXPAND | wx.TOP, border=0) # 接收输入框的布局 box1.Add(self.ctrl, proportion=20, flag=wx.EXPAND | wx.TOP, border=0) # 发送的输入框的布局 box1.Add(self.sent, proportion=3, flag=wx.EXPAND | wx.TOP, border=0) self.a.SetSizer(box1) # 布局设置在a画板上 self.msg=&#x27;&#x27; def b_anbdj(self,event): global msg host_ip=self.ip.GetValue() toastone = wx.MessageDialog(None, &quot;链接的服务器地址为&quot;+host_ip, &quot;信息提示&quot;, wx.YES_DEFAULT | wx.ICON_QUESTION) if toastone.ShowModal() == wx.ID_YES: # 如果点击了提示框的确定按钮 toastone.Destroy() # 则关闭提示框 client.connect((host_ip, server_port)) # 连接服务端，指定主机和端口 toastone = wx.MessageDialog(None, &quot;Connecting is successful!&quot;, &quot;信息提示&quot;, wx.YES_DEFAULT | wx.ICON_QUESTION) if toastone.ShowModal() == wx.ID_YES: # 如果点击了提示框的确定按钮 toastone.Destroy() # 则关闭提示框 def sent_anbdj(self,event): send_msg = self.ctrl.GetValue() client.send((client_name + &#x27;: &#x27; + send_msg).encode()) # 接收文字的线程 # 由于用户的发送和接收消息是不同步的，在接收消息时线程会阻塞，所以另开启一个线程进行接收文字 def ThreadReceive(self): while True: self.msg = client.recv(max_recedata) self.text.AppendText(self.msg.decode() + &quot;\\n\\n&quot;)if __name__ == &#x27;__main__&#x27;: app = wx.App() # 初始化 shili = chuangkou() # 创建实例 shili.Show() # 显示窗口 app.MainLoop() # 窗口主循环 初级阶段4：线程改版+tkinter使用 0.5 作用:换了个线程控制方式 变化： 12server.listen() #监听server = socket.socket() #创建server对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#服务器端import socketimport threadinghost = socket.gethostname() #获取当前主机的IP地址port = 8000 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)#接收一个客户端连接，及其发送来数据def read_client(s): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket print(str(addr)+&#x27;已下线！&#x27;) SocketList.remove(s)#多线程：将收到的消息发送给所有客户端def send_client(s): try: while True: content = read_client(s) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 TextList.append(str(addr)+&#x27;: &#x27;+content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) except: print(&#x27;广播未成功！&#x27;)while True: client,addr = server.accept() SocketList.append(client) print(str(addr)+&#x27;已加入！&#x27;) try: #历史消息生成 if len(TextList)==0: client.send(&#x27;No message.&#x27;.encode(&#x27;utf-8&#x27;)) else: client.send(&#x27;\\n&#x27;.join(TextList).encode(&#x27;utf-8&#x27;)) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 threading.Thread(target=send_client, args=(client,)).start() except Exception as e: print(repr(e)) 1234567891011121314151617181920212223242526272829#客户端import socketimport threadingserver_host = socket.gethostname()server_port = 8000client = socket.socket() #创建socket对象print(&#x27;Connecting......&#x27;)client.connect((server_host,server_port)) #连接服务端，指定主机和端口print(&#x27;Connecting is successful!&#x27;)content = client.recv(2048).decode(&#x27;utf-8&#x27;)if content != &#x27;No message.&#x27;: print(content + &#x27;\\n------以上是历史消息------\\n&#x27;)def read_server(c): while True: #子线程负责从服务端接受数据并打印 content = c.recv(2048).decode(&#x27;utf-8&#x27;) print(content)threading.Thread(target=read_server, args=(client,)).start()while True: word = input() if word == &#x27;close&#x27;: break # 主线程负责将用户输入的数据发送到socket中 client.send(word.encode(&#x27;utf-8&#x27;)) 0.6 作用：0.5基础上优化（nickname）+进行图形界面可视化； Python 提供了多个图形开发界面的库，几个常用 Python GUI 库如下： Tkinter： Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口 .Tk 和 Tkinter 可以在大多数的 Unix 平台下使用,同样可以应用在 Windows 和 Macintosh 系统里。Tk8.0 的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。 注意*：Python3.x 版本使用的库名为 tkinter,即首写字母 T 为小写* 创建一个GUI程序 1、导入 Tkinter 模块 2、创建控件 3、指定这个控件的 master， 即这个控件属于哪一个 4、告诉 GM(geometry manager) 有一个控件产生了。 [Python GUI 编程(Tkinter) | 菜鸟教程 (runoob.com)](https://www.runoob.com/python/python-gui-tkinter.html#:~:text=Tkinter 是 Python 的标准 GUI 库。 Python 使用,Tkinter 库、而且 IDLE 也是用 Tkinter 编写而成、对于简单的图形界面 Tkinter 还是能应付自如。) (29条消息) TK-StringVar_Eider1998的博客-CSDN博客_stringvar()作用 Python Tkinter 框架控件（Frame） | 菜鸟教程 (runoob.com) (29条消息) python弹窗——tkinter.messagebox学习总结_鹿鹿有为啊的博客-CSDN博客_python tkinter 弹窗 tkinter的set()与get() - 做梦者造梦 - 博客园 (cnblogs.com) (29条消息) tkinter库最全使用教程_千禧皓月的博客-CSDN博客_tkinter (29条消息) 用tkinter.pack设计复杂界面布局_快乐清风客的博客-CSDN博客_tkinter复杂界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#服务端import socketimport threadinghost = socket.gethostname() #获取当前主机的IP地址port = 8000 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录Nickname = [] #存储用户呢称cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)#接收一个客户端连接，及其发送来数据def read_client(s,nickname): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket # print(str(addr)+&#x27;已下线！&#x27;) print(nickname + &#x27;已下线！&#x27;) SocketList.remove(s) Nickname.remove(nickname) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已下线！&#x27;).encode(&#x27;utf-8&#x27;))#多线程：将收到的消息发送给所有客户端def send_client(s,nickname): try: s.send((&#x27;,&#x27;.join(Nickname)).encode(&#x27;utf-8&#x27;)) #将用户列表发送给各客户端 while True: content = read_client(s) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 # TextList.append(str(addr)+&#x27;: &#x27;+content) TextList.append(nickname + &#x27;: &#x27; + content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((nickname + &#x27;: &#x27; + content).encode(&#x27;utf-8&#x27;)) except: print(&#x27;广播未成功！&#x27;)while True: client,addr = server.accept() SocketList.append(client) try: nickname = client.recv(2048).decode(&#x27;utf-8&#x27;) # print(str(addr)+&#x27;已加入！&#x27;) if nickname in Nickname: i = 1 while True: if nickname+str(i) in Nickname: i = i+1 else: nickname = nickname + str(i) break Nickname.append(nickname) print(nickname + &#x27;已加入！&#x27;) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已加入！&#x27;).encode(&#x27;utf-8&#x27;)) #历史消息生成 if len(TextList)==0: client.send(&#x27;No message.&#x27;.encode(&#x27;utf-8&#x27;)) else: client.send(&#x27;\\n&#x27;.join(TextList).encode(&#x27;utf-8&#x27;)) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 #加入线程中跑，加入函数为send_client，参数为client,nickname threading.Thread(target=send_client, args=(client,nickname,)).start() except Exception as e: print(repr(e)) 0.65 作用：0.6基础上的修改（显示在线人数和历史消息暂时删了，仅保留了聊天功能），先能用……还要解决子线程如何关闭的问题…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#服务端import socketimport threadinghost = socket.gethostname() #获取当前主机的IP地址port = 9999 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录Nickname = [] #存储用户呢称cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)#接收一个客户端连接，及其发送来数据def read_client(s,nickname): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket # print(str(addr)+&#x27;已下线！&#x27;) print(nickname + &#x27;已下线！&#x27;) SocketList.remove(s) Nickname.remove(nickname) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已下线！&#x27;).encode(&#x27;utf-8&#x27;))#多线程：将收到的消息发送给所有客户端def send_client(s,nickname): try: # s.send((&#x27;,&#x27;.join(Nickname)).encode(&#x27;utf-8&#x27;)) #将用户列表发送给各客户端 while True: content = read_client(s,nickname) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 # TextList.append(str(addr)+&#x27;: &#x27;+content) TextList.append(nickname + &#x27;: &#x27; + content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((nickname + &#x27;: &#x27; + content).encode(&#x27;utf-8&#x27;)) except Exception as e: # print(repr()) print(&#x27;广播未成功！&#x27;)while True: client,addr = server.accept() SocketList.append(client) nickname = client.recv(2048).decode(&#x27;utf-8&#x27;) # print(str(addr)+&#x27;已加入！&#x27;) if nickname in Nickname: i = 1 while True: if nickname+str(i) in Nickname: i = i+1 else: nickname = nickname + str(i) break Nickname.append(nickname) print(nickname + &#x27;已加入！&#x27;) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已加入！&#x27;).encode(&#x27;utf-8&#x27;)) # #历史消息生成 # if len(TextList)==0: # client.send(&#x27;No message.&#x27;.encode(&#x27;utf-8&#x27;)) # else: # client.send(&#x27;\\n&#x27;.join(TextList).encode(&#x27;utf-8&#x27;)) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 #加入线程中跑，加入函数为send_client，参数为client,nickname threading.Thread(target=send_client, args=(client,nickname,)).start() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#客户端import socketimport threadingfrom tkinter import *import tkinter.messagebox #弹窗库from tkinter import scrolledtext #滚动文本框server_host = socket.gethostname()server_port = 9999client = socket.socket() #创建socket对象print(&#x27;Connecting......&#x27;)#登入窗口：输入呢称def LoginWindow(): root = Tk() root.title(&#x27;一起来聊天 · 登录&#x27;) #窗口标题 root.geometry(&#x27;300x150&#x27;) #窗口大小 root.geometry(&#x27;+500+300&#x27;) #改变窗体位置（‘+横坐标+纵坐标’） nickname = StringVar() #昵称变量（对象）:在使用界面编程的时候，有些时候是需要跟踪变量的值的变化，以保证值的变更随时可以显示在界面上 root.resizable(0, 0) #将窗口大小设置为不可变 #登录函数（检查用户名是否为空，以及长度） def Login_in(): name = nickname.get() #???? if not name: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名为空！&#x27;) #消息警告框 elif len(name) &gt; 10: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名过长！最多为十个字符！&#x27;) else: root.destroy() client.connect((server_host, server_port)) # 连接服务端，指定主机和端口 print(&#x27;Connecting is successful!&#x27;) client.send(name.encode(&#x27;utf-8&#x27;)) # 传递用户昵称 ChatRoom(name) # 打开聊天窗口 #登录按钮、输入提示标签、输入框 Button(root, text=&quot;登录&quot;, command=Login_in, width=8, height=1).place(x=100, y=90, width=100, height=35) Label(root, text=&#x27;请输入昵称&#x27;, font=(&#x27;Fangsong&#x27;, 12)).place(x=10, y=20, height=50, width=80) Entry(root, textvariable=nickname, font=(&#x27;Fangsong&#x27;, 11)).place(x=100, y=30, height=30, width=180) root.mainloop()#聊天窗口def ChatRoom(nickname): root = Tk() root.geometry(&#x27;650x400&#x27;) # 窗口大小 root.resizable(0, 0) # 将窗口大小设置为不可变 root.geometry(&#x27;+500+300&#x27;) # 改变窗体位置（‘+横坐标+纵坐标’） # content = client.recv(2048).decode(&#x27;utf-8&#x27;) # if content != &#x27;No message.&#x27;: # past_text = content + &#x27;\\n------以上是历史消息------\\n&#x27; # 从服务器端获取当前用户列表 # UserList = [] # UserList = client.recv(2048).decode(&#x27;utf-8&#x27;).split(&#x27;,&#x27;) # UserList.insert(0, &#x27;------当前用户列表------&#x27;) # 窗口标题 # nickname = UserList[len(UserList)-1] root.title(&#x27;一起来聊天 · &#x27; + nickname) # name_text = StringVar() # name_text.set(UserList) # 用户列表文本设置 # listbox1 = Listbox(root, listvariable=name_text) # 用户列表，使用Listbox组件 # listbox1.place(x=5, y=0, width=500, height=400) #聊天界面 content = client.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox = scrolledtext.ScrolledText(root) # 聊天信息窗口，使用ScrolledText组件制作 ChatBox.place(x=5, y=0, width=500, height=300) # ChatBox.pack() ChatBox.insert(&#x27;end&#x27;,content) def read_server(c): while True: content = c.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox.insert(&#x27;end&#x27;, &#x27;\\n&#x27;+content+&#x27;\\n\\n&#x27;) ChatBox.see(tkinter.END) # ScrolledText组件方法，自动定位到结尾，否则只有消息在涨，窗口拖动条不动 ChatBox.update() # 更新聊天信息窗口，显示新的信息 threading.Thread(target=read_server, args=(client,)).start() #聊天输入框 word = StringVar() word.set(&#x27;&#x27;) SentBox = Entry(root,width=140,textvariable=word) #建一个输入框 SentBox.place(x=5,y=305,width=600,height=95) #设置大小和位置 #发送按钮 def sendtext(): content = word.get() #获得文本内容 if content==&#x27;end&#x27;: client.close() client.send(content.encode(&#x27;utf-8&#x27;)) word.set(&#x27;&#x27;) #用了一个标记记录点击的状态，不管内容是什么点了就变 sendButton = Button(root, text=&#x27;发 送&#x27;, font=(&#x27;Fangsong&#x27;, 18), bg=&#x27;white&#x27;, command=sendtext) sendButton.place(x=500, y=305, width=150, height=95) root.mainloop()LoginWindow() 0.67 作用：0.65上改了点细节（可视化界面加了个图片），先能用……要解决子线程关闭问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#服务器#服务端import socketimport threadinghost = socket.gethostname() #获取当前主机的IP地址port = 9999 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录Nickname = [] #存储用户呢称cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)#接收一个客户端连接，及其发送来数据def read_client(s,nickname): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket # print(str(addr)+&#x27;已下线！&#x27;) print(nickname + &#x27;已下线！&#x27;) SocketList.remove(s) Nickname.remove(nickname) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已下线！&#x27;).encode(&#x27;utf-8&#x27;))#多线程：将收到的消息发送给所有客户端def send_client(s,nickname): try: # s.send((&#x27;,&#x27;.join(Nickname)).encode(&#x27;utf-8&#x27;)) #将用户列表发送给各客户端 while True: content = read_client(s,nickname) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 # TextList.append(str(addr)+&#x27;: &#x27;+content) TextList.append(nickname + &#x27;: &#x27; + content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((nickname + &#x27;: &#x27; + content).encode(&#x27;utf-8&#x27;)) except Exception as e: # print(repr()) print(&#x27;广播未成功！&#x27;)while True: client,addr = server.accept() SocketList.append(client) nickname = client.recv(2048).decode(&#x27;utf-8&#x27;) # print(str(addr)+&#x27;已加入！&#x27;) if nickname in Nickname: i = 1 while True: if nickname+str(i) in Nickname: i = i+1 else: nickname = nickname + str(i) break Nickname.append(nickname) print(nickname + &#x27;已加入！&#x27;) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已加入！&#x27;).encode(&#x27;utf-8&#x27;)) # #历史消息生成 # if len(TextList)==0: # client.send(&#x27;No message.&#x27;.encode(&#x27;utf-8&#x27;)) # else: # client.send(&#x27;\\n&#x27;.join(TextList).encode(&#x27;utf-8&#x27;)) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 #加入线程中跑，加入函数为send_client，参数为client,nickname threading.Thread(target=send_client, args=(client,nickname,)).start() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#客户端import socketimport threadingfrom tkinter import *import tkinter.messagebox #弹窗库from tkinter import scrolledtext #滚动文本框server_host = socket.gethostname()server_port = 9999client = socket.socket() #创建socket对象print(&#x27;Connecting......&#x27;)#登入窗口：输入呢称def LoginWindow(): root = Tk() root.title(&#x27;一起来聊天 · 登录&#x27;) #窗口标题 root.geometry(&#x27;300x150&#x27;) #窗口大小 root.geometry(&#x27;+500+300&#x27;) #改变窗体位置（‘+横坐标+纵坐标’） nickname = StringVar() #昵称变量（对象）:在使用界面编程的时候，有些时候是需要跟踪变量的值的变化，以保证值的变更随时可以显示在界面上 root.resizable(0, 0) #将窗口大小设置为不可变 #登录函数（检查用户名是否为空，以及长度） def Login_in(): name = nickname.get() #???? if not name: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名为空！&#x27;) #消息警告框 elif len(name) &gt; 10: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名过长！最多为十个字符！&#x27;) else: root.destroy() client.connect((server_host, server_port)) # 连接服务端，指定主机和端口 print(&#x27;Connecting is successful!&#x27;) client.send(name.encode(&#x27;utf-8&#x27;)) # 传递用户昵称 ChatRoom(name) # 打开聊天窗口 #登录按钮、输入提示标签、输入框 Button(root, text=&quot;登录&quot;, command=Login_in, width=8, height=1).place(x=100, y=90, width=100, height=35) Label(root, text=&#x27;请输入昵称&#x27;, font=(&#x27;Fangsong&#x27;, 12)).place(x=10, y=20, height=50, width=80) Entry(root, textvariable=nickname, font=(&#x27;Fangsong&#x27;, 11)).place(x=100, y=30, height=30, width=180) root.mainloop()#聊天窗口def ChatRoom(nickname): root = Tk() root.geometry(&#x27;650x400&#x27;) # 窗口大小 root.resizable(0, 0) # 将窗口大小设置为不可变 root.geometry(&#x27;+500+300&#x27;) # 改变窗体位置（‘+横坐标+纵坐标’） # content = client.recv(2048).decode(&#x27;utf-8&#x27;) # if content != &#x27;No message.&#x27;: # past_text = content + &#x27;\\n------以上是历史消息------\\n&#x27; # 从服务器端获取当前用户列表 # UserList = [] # UserList = client.recv(2048).decode(&#x27;utf-8&#x27;).split(&#x27;,&#x27;) # UserList.insert(0, &#x27;------当前用户列表------&#x27;) # 窗口标题 # nickname = UserList[len(UserList)-1] root.title(&#x27;一起来聊天 · &#x27; + nickname) # name_text = StringVar() # name_text.set(UserList) # 用户列表文本设置 # listbox1 = Listbox(root, listvariable=name_text) # 用户列表，使用Listbox组件 # listbox1.place(x=5, y=0, width=500, height=400) img_png = PhotoImage(file=&#x27;QQ图片20220901201640.png&#x27;) label_img = Label(root, image=img_png) label_img.place(x=400, y=0, width=350, height=300) #聊天界面 content = client.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox = scrolledtext.ScrolledText(root) # 聊天信息窗口，使用ScrolledText组件制作 ChatBox.place(x=5, y=0, width=470, height=300) # ChatBox.pack() ChatBox.insert(&#x27;end&#x27;,content) def read_server(c): while True: content = c.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox.insert(&#x27;end&#x27;, &#x27;\\n&#x27;+content+&#x27;\\n\\n&#x27;) ChatBox.see(tkinter.END) # ScrolledText组件方法，自动定位到结尾，否则只有消息在涨，窗口拖动条不动 ChatBox.update() # 更新聊天信息窗口，显示新的信息 threading.Thread(target=read_server, args=(client,)).start() #聊天输入框 word = StringVar() word.set(&#x27;&#x27;) SentBox = Entry(root,width=140,textvariable=word) #建一个输入框 SentBox.place(x=5,y=305,width=475,height=90) #设置大小和位置 #发送按钮 def sendtext(): content = word.get() #获得文本内容 if content==&#x27;end&#x27;: client.close() client.send(content.encode(&#x27;utf-8&#x27;)) word.set(&#x27;&#x27;) #用了一个标记记录点击的状态，不管内容是什么点了就变 sendButton = Button(root, text=&#x27;发 送&#x27;, font=(&#x27;Fangsong&#x27;, 18), bg=&#x27;white&#x27;, command=sendtext) sendButton.place(x=490, y=308, width=150, height=85) root.mainloop()LoginWindow() (29条消息) Python—多线程编程（一）线程的创建，管理，停止_onesalatree的博客-CSDN博客_python线程开始结束 (29条消息) python GUI 多线程 暂停 恢复 结束_为此残生的博客-CSDN博客 (29条消息) Python多线程的退出控制_Messy…的博客-CSDN博客_python关闭线程的方法 (29条消息) python多线程之 终止子线程_水w的博客-CSDN博客_python 结束线程 实训一阶段2：可靠传输 要求： 了解聊天程序的一般原理； 按照带流量控制的协议改造聊天程序； 编程语言不限； 要能在两台PC上运行。 初级阶段5：可靠传输与流量控制 可靠传输：使用差错检测技术，接收方的数据链路层就可以检测出帧在传输过程中是否产生了误码。 如果可靠传输，能够在检测出误码之后，返回一个通知帧，告诉发送方之前传输的帧存在误码，也许可以解决误码重传的问题 数据链路层传输差错：比特差错、分组丢失、分组失序、分组重复 可靠传输：想方法实现发送端发送什么，接收端就收到什么 计算机网络之流量控制（停止-等待协议1:1、滑动窗口：后退N帧协议GBN、选择重传协议SR）、滑动窗口、可靠传输机制 1.什么是流量控制？ 流量控制是数据链路层的一种功能，流量控制对数据链路上的帧的发送速率进行控制，以使接收方有足够的缓冲空间来接受每个帧 流量控制的基本方法是由接收方控制发送方发送数据的速率 常见的流量控制方式有两种：停止-等待协议、滑动窗口协议 2.什么是可靠传输机制？ ​ 可靠传输机制是为了使数据可以正确稳定的传输和接收而制定的规则。 数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。 确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。 超时重传是指发送方在发送某一个数据帧以后就开始一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止。 自动重传请求（Auto Repeat reQuest，ARQ），通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一。 传统自动重传请求分为三种，即停等式（Stop-and-Wait）ARQ、后退N帧（Go-Back-N）ARQ以及选择性重传（Selective Repeat）ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大，帧在线路上可以连续地流动，因此又称为连续ARQ协议。 3.什么是滑动窗口机制？ 滑动窗口协议的基本原理就是在任意时刻，发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。 发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。 不同的滑动窗口协议窗口大小一般不同。 发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧。 PS：直接看王道考研-计算机网络 3.4 0.6 作用：CRC校验有问题，基础功能实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#客户端import socketimport threadingfrom tkinter import *import tkinter.messagebox #弹窗库from tkinter import scrolledtext #滚动文本框server_host = socket.gethostname()server_port = 9999client = socket.socket() #创建socket对象print(&#x27;Connecting......&#x27;)#登入窗口：输入呢称def LoginWindow(): root = Tk() root.title(&#x27;一起来聊天 · 登录&#x27;) #窗口标题 root.geometry(&#x27;300x150&#x27;) #窗口大小 root.geometry(&#x27;+500+300&#x27;) #改变窗体位置（‘+横坐标+纵坐标’） nickname = StringVar() #昵称变量（对象）:在使用界面编程的时候，有些时候是需要跟踪变量的值的变化，以保证值的变更随时可以显示在界面上 root.resizable(0, 0) #将窗口大小设置为不可变 #登录函数（检查用户名是否为空，以及长度） def Login_in(): name = nickname.get() #???? if not name: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名为空！&#x27;) #消息警告框 elif len(name) &gt; 10: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名过长！最多为十个字符！&#x27;) else: root.destroy() client.connect((server_host, server_port)) # 连接服务端，指定主机和端口 print(&#x27;Connecting is successful!&#x27;) client.send(name.encode(&#x27;utf-8&#x27;)) # 传递用户昵称 ChatRoom(name) # 打开聊天窗口 #登录按钮、输入提示标签、输入框 Button(root, text=&quot;登录&quot;, command=Login_in, width=8, height=1).place(x=100, y=90, width=100, height=35) Label(root, text=&#x27;请输入昵称&#x27;, font=(&#x27;Fangsong&#x27;, 12)).place(x=10, y=20, height=50, width=80) Entry(root, textvariable=nickname, font=(&#x27;Fangsong&#x27;, 11)).place(x=100, y=30, height=30, width=180) root.mainloop()#聊天窗口def ChatRoom(nickname): root = Tk() root.geometry(&#x27;650x400&#x27;) # 窗口大小 root.resizable(0, 0) # 将窗口大小设置为不可变 root.geometry(&#x27;+500+300&#x27;) # 改变窗体位置（‘+横坐标+纵坐标’） # content = client.recv(2048).decode(&#x27;utf-8&#x27;) # if content != &#x27;No message.&#x27;: # past_text = content + &#x27;\\n------以上是历史消息------\\n&#x27; # 从服务器端获取当前用户列表 # UserList = [] # UserList = client.recv(2048).decode(&#x27;utf-8&#x27;).split(&#x27;,&#x27;) # UserList.insert(0, &#x27;------当前用户列表------&#x27;) # 窗口标题 # nickname = UserList[len(UserList)-1] root.title(&#x27;一起来聊天 · &#x27; + nickname) # name_text = StringVar() # name_text.set(UserList) # 用户列表文本设置 # listbox1 = Listbox(root, listvariable=name_text) # 用户列表，使用Listbox组件 # listbox1.place(x=5, y=0, width=500, height=400) img_png = PhotoImage(file=&#x27;QQ图片20220901201640.png&#x27;) label_img = Label(root, image=img_png) label_img.place(x=400, y=0, width=350, height=300) #聊天界面 # content = client.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox = scrolledtext.ScrolledText(root) # 聊天信息窗口，使用ScrolledText组件制作 ChatBox.place(x=5, y=0, width=470, height=300) # ChatBox.pack() # ChatBox.insert(&#x27;end&#x27;,content) def read_server(c): while True: content = c.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox.insert(&#x27;end&#x27;, &#x27;\\n&#x27;+content+&#x27;\\n&#x27;) ChatBox.see(tkinter.END) # ScrolledText组件方法，自动定位到结尾，否则只有消息在涨，窗口拖动条不动 ChatBox.update() # 更新聊天信息窗口，显示新的信息 threading.Thread(target=read_server, args=(client,)).start() #聊天输入框 word = StringVar() word.set(&#x27;&#x27;) SentBox = Entry(root,width=140,textvariable=word) #建一个输入框 SentBox.place(x=5,y=305,width=475,height=90) #设置大小和位置 #发送按钮 def sendtext(): content = word.get() #获得文本内容 if content==&#x27;end&#x27;: client.close() client.send(content.encode(&#x27;utf-8&#x27;)) word.set(&#x27;&#x27;) #用了一个标记记录点击的状态，不管内容是什么点了就变 sendButton = Button(root, text=&#x27;发 送&#x27;, font=(&#x27;Fangsong&#x27;, 18), bg=&#x27;white&#x27;, command=sendtext) sendButton.place(x=490, y=308, width=150, height=85) root.mainloop()LoginWindow() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#服务端import socketimport threadingimport timehost = socket.gethostname() #获取当前主机的IP地址port = 9999 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录Nickname = [] #存储用户呢称cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)def CRC(crc,poly=&#x27;11001&#x27;): test_crc = int(crc,16) #将str类型转化成16进制 poly_crc8 = int(poly,16) # print(test_crc,poly_crc8) for bit in range(12): if test_crc&amp;0x800 != 0: #最高位是否为1 test_crc &lt;&lt;= 1 test_crc ^= poly_crc8 else: test_crc &lt;&lt;= 1 print(test_crc) return hex(test_crc)#接收一个客户端连接，及其发送来数据def read_client(s,nickname): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket # print(str(addr)+&#x27;已下线！&#x27;) print(nickname + &#x27;已下线！&#x27;) SocketList.remove(s) Nickname.remove(nickname) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已下线！&#x27;).encode(&#x27;utf-8&#x27;))#多线程：将收到的消息发送给所有客户端def send_client(s,nickname): try: # s.send((&#x27;,&#x27;.join(Nickname)).encode(&#x27;utf-8&#x27;)) #将用户列表发送给各客户端 while True: content = read_client(s,nickname) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 # TextList.append(str(addr)+&#x27;: &#x27;+content) TextList.append(nickname + &#x27;: &#x27; + content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((nickname + &#x27;: &#x27; + content).encode(&#x27;utf-8&#x27;)) data = CRC(content) for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((&#x27;Teacher: &#x27; + data).encode(&#x27;utf-8&#x27;)) except Exception as e: # print(repr()) print(&#x27;广播未成功！&#x27;)QianYan = [&#x27;你好呀！今天我们一起来学习SW。&#x27;, &#x27;可靠传输机制是为了使数据可以正确稳定的传输和接收而制定的规则。&#x27;, &#x27;流量控制是数据链路层的一种功能，流量控制对数据链路上的帧的发送速率进行控制，以使接收方有足够的缓冲空间来接受每个帧。&#x27;, &#x27;流量控制的基本方法是由接收方控制发送方发送数据的速率。&#x27;, &#x27;常见的流量控制方式有两种：`停止-等待协议、滑动窗口协议&#x27;, &#x27;那么，让我们开始体验停止-等待协议SW的魅力吧！&#x27;, &#x27;\\n\\n请输入十六进制数据&#x27;]while True: client,addr = server.accept() SocketList.append(client) nickname = client.recv(2048).decode(&#x27;utf-8&#x27;) # print(str(addr)+&#x27;已加入！&#x27;) if nickname in Nickname: i = 1 while True: if nickname+str(i) in Nickname: i = i+1 else: nickname = nickname + str(i) break Nickname.append(nickname) print(nickname + &#x27;已加入！&#x27;) for sock in SocketList: for i in QianYan: sock.send((&#x27;Teacher: &#x27; + i).encode(&#x27;utf-8&#x27;)) time.sleep(1) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 #加入线程中跑，加入函数为send_client，参数为client,nickname threading.Thread(target=send_client, args=(client,nickname,)).start() 0.65 作用：早上灵光一现，以为CRC是取模了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#服务端import socketimport threadingimport timehost = socket.gethostname() #获取当前主机的IP地址port = 9999 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录Nickname = [] #存储用户呢称cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)def DEC(data): s = data d = 0 while s: d = d*2 + (ord(s[0]) -ord(&#x27;0&#x27;)) s = s[1:] return ddef CRC(crc,poly=&#x27;11001&#x27;): p = DEC(poly) c = DEC(crc+&#x27;0000&#x27;) print(p,c) res = c%p return res#接收一个客户端连接，及其发送来数据def read_client(s,nickname): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket # print(str(addr)+&#x27;已下线！&#x27;) print(nickname + &#x27;已下线！&#x27;) SocketList.remove(s) Nickname.remove(nickname) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已下线！&#x27;).encode(&#x27;utf-8&#x27;))#多线程：将收到的消息发送给所有客户端def send_client(s,nickname): try: # s.send((&#x27;,&#x27;.join(Nickname)).encode(&#x27;utf-8&#x27;)) #将用户列表发送给各客户端 while True: content = read_client(s,nickname) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 # TextList.append(str(addr)+&#x27;: &#x27;+content) TextList.append(nickname + &#x27;: &#x27; + content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((nickname + &#x27;: &#x27; + content).encode(&#x27;utf-8&#x27;)) data = CRC(content) if data==0: word = &#x27;发送帧没问题。&#x27; else: word = &#x27;发送帧有问题。&#x27; for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((&#x27;Teacher: &#x27; + word).encode(&#x27;utf-8&#x27;)) except Exception as e: # print(repr()) print(&#x27;广播未成功！&#x27;)QianYan = [&#x27;你好呀！今天我们一起来学习SW。&#x27;, &#x27;可靠传输机制是为了使数据可以正确稳定的传输和接收而制定的规则。&#x27;, &#x27;流量控制是数据链路层的一种功能，流量控制对数据链路上的帧的发送速率进行控制，以使接收方有足够的缓冲空间来接受每个帧。&#x27;, &#x27;流量控制的基本方法是由接收方控制发送方发送数据的速率。&#x27;, &#x27;常见的流量控制方式有两种：`停止-等待协议、滑动窗口协议&#x27;, &#x27;那么，让我们开始体验停止-等待协议SW的魅力吧！&#x27;, &#x27;\\n\\n请输入十六进制数据&#x27;]while True: client,addr = server.accept() SocketList.append(client) nickname = client.recv(2048).decode(&#x27;utf-8&#x27;) # print(str(addr)+&#x27;已加入！&#x27;) if nickname in Nickname: i = 1 while True: if nickname+str(i) in Nickname: i = i+1 else: nickname = nickname + str(i) break Nickname.append(nickname) print(nickname + &#x27;已加入！&#x27;) for sock in SocketList: for i in QianYan: sock.send((&#x27;Teacher: &#x27; + i).encode(&#x27;utf-8&#x27;)) time.sleep(1) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 #加入线程中跑，加入函数为send_client，参数为client,nickname threading.Thread(target=send_client, args=(client,nickname,)).start() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#客户端import socketimport threadingfrom tkinter import *import tkinter.messagebox #弹窗库from tkinter import scrolledtext #滚动文本框server_host = socket.gethostname()server_port = 9999client = socket.socket() #创建socket对象print(&#x27;Connecting......&#x27;)#登入窗口：输入呢称def LoginWindow(): root = Tk() root.title(&#x27;一起来聊天 · 登录&#x27;) #窗口标题 root.geometry(&#x27;300x150&#x27;) #窗口大小 root.geometry(&#x27;+500+300&#x27;) #改变窗体位置（‘+横坐标+纵坐标’） nickname = StringVar() #昵称变量（对象）:在使用界面编程的时候，有些时候是需要跟踪变量的值的变化，以保证值的变更随时可以显示在界面上 root.resizable(0, 0) #将窗口大小设置为不可变 #登录函数（检查用户名是否为空，以及长度） def Login_in(): name = nickname.get() #???? if not name: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名为空！&#x27;) #消息警告框 elif len(name) &gt; 10: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名过长！最多为十个字符！&#x27;) else: root.destroy() client.connect((server_host, server_port)) # 连接服务端，指定主机和端口 print(&#x27;Connecting is successful!&#x27;) client.send(name.encode(&#x27;utf-8&#x27;)) # 传递用户昵称 ChatRoom(name) # 打开聊天窗口 #登录按钮、输入提示标签、输入框 Button(root, text=&quot;登录&quot;, command=Login_in, width=8, height=1).place(x=100, y=90, width=100, height=35) Label(root, text=&#x27;请输入昵称&#x27;, font=(&#x27;Fangsong&#x27;, 12)).place(x=10, y=20, height=50, width=80) Entry(root, textvariable=nickname, font=(&#x27;Fangsong&#x27;, 11)).place(x=100, y=30, height=30, width=180) root.mainloop()#聊天窗口def ChatRoom(nickname): root = Tk() root.geometry(&#x27;650x400&#x27;) # 窗口大小 root.resizable(0, 0) # 将窗口大小设置为不可变 root.geometry(&#x27;+500+300&#x27;) # 改变窗体位置（‘+横坐标+纵坐标’） # content = client.recv(2048).decode(&#x27;utf-8&#x27;) # if content != &#x27;No message.&#x27;: # past_text = content + &#x27;\\n------以上是历史消息------\\n&#x27; # 从服务器端获取当前用户列表 # UserList = [] # UserList = client.recv(2048).decode(&#x27;utf-8&#x27;).split(&#x27;,&#x27;) # UserList.insert(0, &#x27;------当前用户列表------&#x27;) # 窗口标题 # nickname = UserList[len(UserList)-1] root.title(&#x27;一起来聊天 · &#x27; + nickname) # name_text = StringVar() # name_text.set(UserList) # 用户列表文本设置 # listbox1 = Listbox(root, listvariable=name_text) # 用户列表，使用Listbox组件 # listbox1.place(x=5, y=0, width=500, height=400) img_png = PhotoImage(file=&#x27;QQ图片20220901201640.png&#x27;) label_img = Label(root, image=img_png) label_img.place(x=400, y=0, width=350, height=300) #聊天界面 # content = client.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox = scrolledtext.ScrolledText(root) # 聊天信息窗口，使用ScrolledText组件制作 ChatBox.place(x=5, y=0, width=470, height=300) # ChatBox.pack() # ChatBox.insert(&#x27;end&#x27;,content) def read_server(c): while True: content = c.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox.insert(&#x27;end&#x27;, &#x27;\\n&#x27;+content+&#x27;\\n&#x27;) ChatBox.see(tkinter.END) # ScrolledText组件方法，自动定位到结尾，否则只有消息在涨，窗口拖动条不动 ChatBox.update() # 更新聊天信息窗口，显示新的信息 threading.Thread(target=read_server, args=(client,)).start() #聊天输入框 word = StringVar() word.set(&#x27;&#x27;) SentBox = Entry(root,width=140,textvariable=word) #建一个输入框 SentBox.place(x=5,y=305,width=475,height=90) #设置大小和位置 #发送按钮 def sendtext(): content = word.get() #获得文本内容 if content==&#x27;end&#x27;: client.close() client.send(content.encode(&#x27;utf-8&#x27;)) word.set(&#x27;&#x27;) #用了一个标记记录点击的状态，不管内容是什么点了就变 sendButton = Button(root, text=&#x27;发 送&#x27;, font=(&#x27;Fangsong&#x27;, 18), bg=&#x27;white&#x27;, command=sendtext) sendButton.place(x=490, y=308, width=150, height=85) root.mainloop()LoginWindow() 0.7 作用：拿的网上的CRC但感觉还是错的…… crc原理Python - Search (bing.com) https://blog.csdn.net/smallfox233/article/details/111242813 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#服务端import socketimport threadingimport timehost = socket.gethostname() #获取当前主机的IP地址port = 9999 #设置防火墙开放端口SocketList = [] #存储客户端套接字的列表TextList = [] #存储聊天记录Nickname = [] #存储用户呢称cnt = 0 #当前客户端人数print(host)server = socket.socket() #创建server对象server.bind((host,port)) #绑定server.listen() #监听print(&#x27;服务器准备就绪！&#x27;)def TurnBin(expression): &#x27;&#x27;&#x27;将生成多项式转换为二进制字符串输出&#x27;&#x27;&#x27; # 输入数据处理 expression = expression.upper() # 大写转换 lis = list(expression.split(&quot;+&quot;)) # 以加号为标志进行分割 string = lis[-1] # 多项式末尾的数字1 del lis[-1] lis = lis[::-1] # 倒序 ## print(lis) # 二进制转换 for i in range(len(lis)): if len(string) == int(lis[i][1]): # 满足位数与变量的数字相同时 string += &quot;1&quot; else: for j in range(int(lis[i][1]) - len(string)): # 用0补全相差的位数 string += &quot;0&quot; string += &quot;1&quot; return string[::-1]def XOR(string1, string2): &#x27;&#x27;&#x27;将两个二进制串进行异或操作，不同为1&#x27;&#x27;&#x27; result = &quot;&quot; # 输入数据处理 if len(string1) &lt; len(string2): # 若前者的位数不足时 for i in range(len(string2) - len(string1)): # 对string1的首位补0 string1 = &quot;0&quot; + string1 if len(string1) &gt; len(string2): # 若后者的位数不足时 for i in range(len(string1) - len(string2)): # 对string2的首位补0 string2 = &quot;0&quot; + string2 ## print(string1,string2) # 异或计算 for i in range(len(string1)): if string1[i] != string2[i]: result += &quot;1&quot; else: result += &quot;0&quot; ## print(result) # 输出数据处理 for i in range(len(result)): # 消除异或结果中的无效0 if result[i] == &quot;1&quot;: # 找到第一个有效数据时 return result[i::] return resultdef CRC(string, expression): &#x27;&#x27;&#x27;产生CRC校验码&#x27;&#x27;&#x27; crc = &quot;&quot; # 最终的crc校验码 # 输入数据处理 bin_expression = TurnBin(expression) # 转换为二进制串 for i in range(len(bin_expression) - 1): # 在二进制串末尾补0 string += &quot;0&quot; ## print(string,bin_expression) # CRC计算 for i in range(len(string)): # 遍历被除数二进制串 crc += string[i] if len(crc) == len(bin_expression): # 当位数足够异或计算时 crc = XOR(crc, bin_expression) ## print(crc) # 输出数据处理 if len(crc) &lt; len(bin_expression) - 1: # 当crc位数不足时 for i in range(len(bin_expression) - len(crc)): # 在首部补0 crc = &quot;0&quot; + crc if len(crc) &gt; len(bin_expression) - 1: # 当crc位数过多时 crc = crc[len(crc) - len(bin_expression) + 1::] # 切片，消除首部多余的0 return crcdef CheckCRC(string, expression=&#x27;x4+x3+1&#x27;): # 检测传输数据是否正确，并打印结果 # 输入数据处理 bin_expression = TurnBin(expression) # 转换为二进制串 right_crc = string[len(string) - len(bin_expression) + 1::] # 原数据末尾的crc校验码 # CRC计算 crc = CRC(string[:len(string) - len(bin_expression) + 1:], expression) # 检验 if right_crc == crc: # 当尾部的CRC校验码，与首部数据生成的CRC校验码一致时 word =&quot;数据传输过程正常..\\n检测出的校验码：&quot;+str(crc)+&#x27;\\n数据尾部校验码：&#x27;+str(right_crc) else: word =&quot;数据传输过程出错..\\n检测出的校验码：&quot;+str(crc)+&#x27;\\n数据尾部校验码：&#x27;+str(right_crc) for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((&#x27;Teacher: &#x27; + word).encode(&#x27;utf-8&#x27;))#接收一个客户端连接，及其发送来数据def read_client(s,nickname): try: #接受客户端发送来的数据 return s.recv(2048).decode(&#x27;utf-8&#x27;) except: #客户端异常，连接失败，则删除该socket # print(str(addr)+&#x27;已下线！&#x27;) print(nickname + &#x27;已下线！&#x27;) SocketList.remove(s) Nickname.remove(nickname) for sock in SocketList: sock.send((&#x27;系统消息：&#x27; + nickname + &#x27;已下线！&#x27;).encode(&#x27;utf-8&#x27;))#多线程：将收到的消息发送给所有客户端def send_client(s,nickname): try: # s.send((&#x27;,&#x27;.join(Nickname)).encode(&#x27;utf-8&#x27;)) #将用户列表发送给各客户端 while True: content = read_client(s,nickname) #客户端消息 if content is None: #如果没有结束循环 break else: #如果有将消息保存到历史记录 # TextList.append(str(addr)+&#x27;: &#x27;+content) TextList.append(nickname + &#x27;: &#x27; + content) #将一个客户端发送过来的数据广播给其他客户端 for sock in SocketList: # sock.send((str(addr)+&#x27;: &#x27;+content).encode(&#x27;utf-8&#x27;)) sock.send((nickname + &#x27;: &#x27; + content).encode(&#x27;utf-8&#x27;)) CheckCRC(content) except Exception as e: # print(repr()) print(&#x27;广播未成功！&#x27;)QianYan = [ &#x27;你好呀！今天我们一起来学习SW。&#x27;, &#x27;可靠传输机制是为了使数据可以正确稳定的传输和接收而制定的规则。&#x27;, &#x27;流量控制是数据链路层的一种功能，流量控制对数据链路上的帧的发送速率进行控制，以使接收方有足够的缓冲空间来接受每个帧。&#x27;, &#x27;流量控制的基本方法是由接收方控制发送方发送数据的速率。&#x27;, &#x27;常见的流量控制方式有两种：`停止-等待协议、滑动窗口协议&#x27;, &#x27;那么，让我们开始体验停止-等待协议SW的魅力吧！&#x27;, &#x27;\\n\\n请输入高于4位的二进制数据&#x27;]while True: client,addr = server.accept() SocketList.append(client) nickname = client.recv(2048).decode(&#x27;utf-8&#x27;) # print(str(addr)+&#x27;已加入！&#x27;) if nickname in Nickname: i = 1 while True: if nickname+str(i) in Nickname: i = i+1 else: nickname = nickname + str(i) break Nickname.append(nickname) print(nickname + &#x27;已加入！&#x27;) for sock in SocketList: for i in QianYan: sock.send((&#x27;Teacher: &#x27; + i).encode(&#x27;utf-8&#x27;)) time.sleep(1) cnt = cnt + 1 #每当有客户连接后，就启动一个线程为其服务 #加入线程中跑，加入函数为send_client，参数为client,nickname threading.Thread(target=send_client, args=(client,nickname,)).start() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#客户端import socketimport threadingfrom tkinter import *import tkinter.messagebox #弹窗库from tkinter import scrolledtext #滚动文本框server_host = socket.gethostname()server_port = 9999client = socket.socket() #创建socket对象print(&#x27;Connecting......&#x27;)#登入窗口：输入呢称def LoginWindow(): root = Tk() root.title(&#x27;一起来聊天 · 登录&#x27;) #窗口标题 root.geometry(&#x27;300x150&#x27;) #窗口大小 root.geometry(&#x27;+500+300&#x27;) #改变窗体位置（‘+横坐标+纵坐标’） nickname = StringVar() #昵称变量（对象）:在使用界面编程的时候，有些时候是需要跟踪变量的值的变化，以保证值的变更随时可以显示在界面上 root.resizable(0, 0) #将窗口大小设置为不可变 #登录函数（检查用户名是否为空，以及长度） def Login_in(): name = nickname.get() #???? if not name: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名为空！&#x27;) #消息警告框 elif len(name) &gt; 10: tkinter.messagebox.showwarning(&#x27;Warning&#x27;, message=&#x27;用户名过长！最多为十个字符！&#x27;) else: root.destroy() client.connect((server_host, server_port)) # 连接服务端，指定主机和端口 print(&#x27;Connecting is successful!&#x27;) client.send(name.encode(&#x27;utf-8&#x27;)) # 传递用户昵称 ChatRoom(name) # 打开聊天窗口 #登录按钮、输入提示标签、输入框 Button(root, text=&quot;登录&quot;, command=Login_in, width=8, height=1).place(x=100, y=90, width=100, height=35) Label(root, text=&#x27;请输入昵称&#x27;, font=(&#x27;Fangsong&#x27;, 12)).place(x=10, y=20, height=50, width=80) Entry(root, textvariable=nickname, font=(&#x27;Fangsong&#x27;, 11)).place(x=100, y=30, height=30, width=180) root.mainloop()#聊天窗口def ChatRoom(nickname): root = Tk() root.geometry(&#x27;650x400&#x27;) # 窗口大小 root.resizable(0, 0) # 将窗口大小设置为不可变 root.geometry(&#x27;+500+300&#x27;) # 改变窗体位置（‘+横坐标+纵坐标’） # content = client.recv(2048).decode(&#x27;utf-8&#x27;) # if content != &#x27;No message.&#x27;: # past_text = content + &#x27;\\n------以上是历史消息------\\n&#x27; # 从服务器端获取当前用户列表 # UserList = [] # UserList = client.recv(2048).decode(&#x27;utf-8&#x27;).split(&#x27;,&#x27;) # UserList.insert(0, &#x27;------当前用户列表------&#x27;) # 窗口标题 # nickname = UserList[len(UserList)-1] root.title(&#x27;一起来聊天 · &#x27; + nickname) # name_text = StringVar() # name_text.set(UserList) # 用户列表文本设置 # listbox1 = Listbox(root, listvariable=name_text) # 用户列表，使用Listbox组件 # listbox1.place(x=5, y=0, width=500, height=400) img_png = PhotoImage(file=&#x27;QQ图片20220901201640.png&#x27;) label_img = Label(root, image=img_png) label_img.place(x=400, y=0, width=350, height=300) #聊天界面 # content = client.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox = scrolledtext.ScrolledText(root) # 聊天信息窗口，使用ScrolledText组件制作 ChatBox.place(x=5, y=0, width=470, height=300) # ChatBox.pack() # ChatBox.insert(&#x27;end&#x27;,content) def read_server(c): while True: content = c.recv(2048).decode(&#x27;utf-8&#x27;) ChatBox.insert(&#x27;end&#x27;, &#x27;\\n&#x27;+content+&#x27;\\n&#x27;) ChatBox.see(tkinter.END) # ScrolledText组件方法，自动定位到结尾，否则只有消息在涨，窗口拖动条不动 ChatBox.update() # 更新聊天信息窗口，显示新的信息 threading.Thread(target=read_server, args=(client,)).start() #聊天输入框 word = StringVar() word.set(&#x27;&#x27;) SentBox = Entry(root,width=140,textvariable=word) #建一个输入框 SentBox.place(x=5,y=305,width=475,height=90) #设置大小和位置 #发送按钮 def sendtext(): content = word.get() #获得文本内容 if content==&#x27;end&#x27;: client.close() client.send(content.encode(&#x27;utf-8&#x27;)) word.set(&#x27;&#x27;) #用了一个标记记录点击的状态，不管内容是什么点了就变 sendButton = Button(root, text=&#x27;发 送&#x27;, font=(&#x27;Fangsong&#x27;, 18), bg=&#x27;white&#x27;, command=sendtext) sendButton.place(x=490, y=308, width=150, height=85) root.mainloop()LoginWindow() 实训二阶段 (29条消息) Cisco Packet Tracer安装详解_@Protinx的博客-CSDN博客_cisco packet tracer 思科模拟器Cisco Packet Tracer是一个功能强大的网络仿真程序，允许学生实验与网络行为。但是这个软件是纯软件模拟，和真实的环境有差距，命令也不全。适合新手教程教学使用。 (29条消息) 思科Packet Tracer基础使用教程_冰镇阔落的博客-CSDN博客_cisco packet tracer教程 (29条消息) Cisco Packet Tracer软件介绍与使用方法_发光吖的博客-CSDN博客_packet tracer 一般选择高型号的路由器（可支持的命令比较多），在Packet Tracer 5.3里面推荐选择2811系列路由器。 交换机也选择高型号的，推荐选择2960系列。（注：2xxx系列为二层交换机，3xxx系列为三层交换机。两者交换功能相同，但三层交换机多了路由功能，在一些情况下三层交换机可以代替路由器，但不能完全替代路由器） 交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。 一般情况下选择（自动线）即可，或选择（直通线）。若方案要求选择专线，则需要选择（专线）。方案中线路大多为直通线（即以太网线），少数会有专线要求。 点击一下所要使用的线，然后点击需要连线的设备接口，从一个设备接口连线至另一个设备接口。（注：自动线不需要选择接口，其他两种线需要手动选择接口。直通线选择Fast开头的接口，专线选择Serial开头的接口） 注：自动线连好为虚线；直通线连好为实线。 交换机是用来连接局域网的，路由器是用来连接互联网的（也可以连接多个局域网） 各线缆两端有不同颜色的圆点，它们分别表示什么样的含义呢？ 链路圆点的状态 含义 亮绿色 物理连接准备就绪，还没有Line Protocol status 的指示 闪烁的绿色 连接激活 红色 物理连接不通，没有信号 黄色 交换机端口处于&quot;阻塞&quot;状态 路由器和交换机区别 路由器：寻址，转发（依靠 IP 地址），交换机：过滤，转发（依靠 MAC 地址） 交换机用于连接局域网，数据包在局域网内网的数据转发，路由器用于连接局域网和外网，数据包可以在不同局域网转发。 交换机工作于TCP/IP协议的最后一层数据链路层（物理层），路由器工作于网络层 交换机负责具体的数据包传输，路由器不负责包的实际传输，路由器只封装好要传输的数据包，然后交给交换机去传输（不一定是交换机，可能是其他传输技术），用java比喻大概简单理解为路由器是抽象类，定义好传输的数据包格式，交换机是具体实现类，也可以有其他实现类 交换机没有MAC地址和IP地址，路由器有MAC地址和IP地址（指纯碎的交换机和路由器，三层交换机是可以有IP地址的，路由器也有内置交换机功能的） 原文链接：https://blog.csdn.net/qq_21187515/article/details/119416934 12345678910111213141516171819202122232425262728293031Router&gt;enable Router#(Router&gt;en)在用户模式下输入enable即可进入特权模式。第二级别模式，可以对设备进行所有的查看、测试及简单的配置。Router#configure terminal Enter configuration commands, one per line. End with CNTL/Z.Router(config)#(Router#conf t)在特权模式下，输入configure terminal即可进入配置模式。第三级别模式，可以对设备进行管理配置。Router(config)#interface fastEthernet 0/0Router(config-if)#(Router(config)#int fa0/0 //定义0/0接口)其他配置模式Router(config-???)#。第四级别模式，可以对设备进行各种专用配置。如，进入配置设备接口的模式Router(config-if)#ip address 192.168.1.2 255.255.255.0(Router(config-if)#ip add 192.168.1.254 255.255.255.0)配置ip地址R2(config-if)#no shutdown(Router(config-if)#no sh)激活接口(Router(config-if)#do wr)Building configuration...Router(config-if)#do show ip rou //显示所有IP路由C 192.168.1.0/24 is directly connected, FastEthernet0/0 //路由表 123456789101112131415161718192021222324路由器配置Router&gt;enRouter#Router#conf tRouter(config)#int fa0/0 //定义0/0接口Router(config-if)#ip add 192.168.1.254 255.255.255.0Router(config-if)#no sh Router(config-if)#int fa0/1 //定义0/1接口Router(config-if)#ip add 192.168.2.254 255.255.255.0Router(config-if)#no sh //激活接口Router(config-if)#do wrRouter(config-if)#do show ip rou //显示所有IP路由Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area * - candidate default, U - per-user static route, o - ODR P - periodic downloaded static route Gateway of last resort is not set C 192.168.1.0/24 is directly connected, FastEthernet0/0 //路由表C 192.168.2.0/24 is directly connected, FastEthernet0/1 (29条消息) 交换机实验、VLAN创建_Air_Echo的博客-CSDN博客_创建vlan 打开**【PC中 &gt;&gt; Desktop &gt;&gt; Commond prompt】** pc0上 ping 192.168.20.1 (PC1)的ip地址 (29条消息) Cisco Packet Tracer 命令大全 【思科交换机模拟器命令大全】_zhangbw~的博客-CSDN博客_cisco packet tracer命令行 (29条消息) Cisco Packet Tracer—VLAN配置详解_HOPEAMOR的博客-CSDN博客 (29条消息) cisco交换机 配置一组端口,interface range_weixin_34194317的博客-CSDN博客 当使用interface range命令时有如下的规则: 有效的组范围: vlan从1 到4094 fastethernet 槽位/{first port} - {last port}, 槽位为0 gigabitethernet槽位/{first port} - {last port},槽位为0 port-channel port-channel-number - port-channel-number, port-channel号从1到64 端口号之间需要加入空格，如：interface range fastethernet 0/1 – 5 是有效的，而interface range fastethernet 0/1-5 是无效的. interface range 命令只能配置已经存在的interface vlan 所有在同一组的端口必须是相同类别的。 见以下例子: Switch# configure terminal Switch(config)# interface range fastethernet0/1 - 5 #switch trunk encapsulation dot1q IEEE 802.1Q协议，是vlan的一种封装方式，是公有协议。 还有一种trunk协议，是ISL，也是vlan的一种封装方式，不过这是Cisco思科私有协议，其他厂商不能用。 #switchport trunk是配置允许通过的vlan； switchport mode trunk是将端口配置成trunk模式； mode trunk //端口模式为trunk switchport trunk encapsulation dot1q //trunk协议封装为dot1q dot1q就是 IEEE 802.1Q协议，是vlan的一种封装方式，是公有协议。 还有一种trunk协议，是ISL，也是vlan的一种封装方式，不过这是Cisco思科私有协议，其他厂商不能用。 实训1：局域网分层结构 123451.基本任务三层交换上实现VLAN间路由；两层交换机上划分VLAN；VLAN数目不少于2个；自行规划IP地址 技术原理 三层交换机具备网络层的功能，实现 VLAN 相互访问的原理是：利用三层交换机的路由功能，通过识别数据包的 IP 地址，查找路由表进行选路转发，三层交换机利用直连路由可以实现不同 VLAN 之间的相互访问。 三层交换机给接口配置 IP 地址。采用 SVI（交换虚拟接口）的方式实现 VLAN 间互连。SVI 是指为交换机中的VLAN 创建虚拟接口，并且配置 IP 地址。 Tag VLAN是基于交换机端口的一种类型，主要用于使交换机的相同Vlan内的主机之间可以直接访问，同时对于不同Vlan的主机进行隔离。 trunk主要用在连接其它交换机，以便在线路上承载多个vlanWLAN是Wireless Local Area Network的简称，指应用无线通信技术将计算机设备互联起来，构成可以互相通信和实现资源共享的网络体系。 802.1x协议是WLAN第二代的认证技术，它是基于客户端-服务器（Client-Server)结构的访问控制和认证协议。它可以限制未经授权的用户/设备通过接入端口（Access Port)访问LAN/WLAN。 DOT1Q是提供VLAN识别和服务质量(QoS)级别的IEEE标准。电气和电子工程师协会（IEEE，全称是Institute of Electrical and Electronics Engineers）是一个美国的电子技术与信息科学工程师的协会，是世界上最大的非营利性专业技术学会。 ip routing 启用IP路由功能no ip routing 关闭IP路由功能 二层交换机与三层交换机区别 我们习惯说，在二层网络环境中相同vlan之间可以通信，不同vlan之间不可以通信，如果想通信必须借助三层设备，所以说三层交换机必须要做的事情是路由转发，但是二、三层交换机具体有什么区别呢？ 二层交换机工作于OSI模型的第2层(数据链路层)，故而称为二层交换机。二层交换技术发展比较成熟，二层交换机属数据链路层设备，可以识别数据包中的MAC地址信息，根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。具体的工作流程如下： （1） 当交换机从某个端口收到一个数据包，它先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的； （2） 再去读取包头中的目的MAC地址，并在地址表中查找相应的端口； （3） 如表中有与这目的MAC地址对应的端口，把数据包直接复制到这端口上； （4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。 ​ 不断的循环这个过程，对于全网的MAC地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。二层交换技术从网桥发展到VLAN（虚拟局域网），在局域网建设和改造中得到了广泛的应用。第二层交换技术是工作在OSI七层网络模型中的第二层，即数据链路层。它按照所接收到数据包的目的MAC地址来进行转发，对于网络层或者高层协议来说是透明的。它不处理网络层的IP地址，不处理高层协议的诸如TCP、UDP的端口地址，它只需要数据包的物理地址即MAC地址，数据交换是靠硬件来实现的，其速度相当快，这是二层交换的一个显著的优点。但是，它不能处理不同IP子网之间的数据交换。 ​ 传统的路由器可以处理大量的跨越IP子网的数据包，但是它的转发效率比二层低，因此要想利用二层转发效率高这一优点，又要处理三层IP数据包，三层交换技术就诞生了。 三层交换（也称多层交换技术，或IP交换技术）是相对于传统交换概念而提出的。众所周知，传统的交换技术是在OSI网络标准模型中的第二层——数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发。简单地说，**三层交换技术就是：二层交换技术＋三层转发技术。**三层交换机就是具有部分路由器功能的交换机。三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。三层交换技术的出现，解决了局域网中网段划分之后，网段中子网必须依赖路由器进行管理的局面，解决了传统路由器低速、复杂所造成的网络瓶颈问题。 实验步骤 1）在二层交换机上配置 VLAN2、VLAN3，分别将端口 2、端口 3 划分给 VLAN2、VLAN3。 （2）将二层交换机与三层交换机相连的端口 fa 0/1 都定义为 tag Vlan 模式。 （3）在三层交换机上配置 VLAN2、VLAN3，此时验证二层交换机 VLAN2、VLAN3下的主机之间不能相互通信。 （4）设置三层交换机 VLAN 间的通信，创建 VLAN2,VLAN3 的虚接口，并配置虚接口 VLAN2、VLAN3 的 IP 地址。 （5）查看三层交换机路由表。 （6）将二层交换机 VLAN2、VLAN3 下的主机默认网关分别设置为相应虚拟接口的 IP 地址。 （7）验证二层交换机 VLAN2,VALN3 下的主机之间可以相互通信。 switchport access vlan 3 语法： switchport access vlan vlan-id no switchport access vlan 该命令把一个Access接口指派给一个VLAN。使用 no 选项可以把接口指派到缺省的VLAN中。 缺省值：接口缺省的VLAN是 VLAN 1。 命令模式：接口配置模式 适用接口：2层物理接口。 说明：如果指定的VLAN不存在，则系统会创建这个VLAN，并把接口设置为该VLAN的成员。如果指定的VLAN已经存在，则把接口添加到该VLAN中。如果接口是一个Trunk口，该操作没有任何作用。可以用 show vlan 命令查看VLAN信息。 范例： Ruijie(config)# interface f0/1 Ruijie(config)# switchport Ruijie(config-if)# switchport access vlan 10 本例把 FastEthernat 0/1 口设置为2层口，并把它加入到 VLAN 10 中。 #switchport mode trunk 语法： switchport mode { access | trunk } no switchport mode 该命令**指定一个2层接口的模式，可以把接口指定为 access 接口或者 trunk 接口。**使用 no 选项可以把接口模式恢复为缺省值。 缺省值：接口的缺省模式是 access。 命令模式：接口配置模式 适用接口：2层物理接口、2层Aggregateport接口。 说明：如果一个接口的模式是 access，则该接口只能成为一个VLAN的成员，可以使用 switchport access vlan 命令把它指定给一个VLAN；如果一个接口的模式是 trunk，则该接口可以是多个VLAN的成员，可以用 switchport trunk 命令定义许可VLAN列表决定它所在的VLAN。 范例： Ruijie(config)# interface f0/1 Ruijie(config-if)# switchport mode trunk 本例把 FastEthernat 0/1 口设置为 Trunk 接口。 (29条消息) Switchport详细用法_天地良心的博客-CSDN博客 三个空的的口令分别是： interface e0 //根据图示这个是E0口。 192.168.2.1 255.255.255.0 //R1的S0接口的IP地址和子网掩码。 s0 //这个是送出接口 ip routing 是用在三层交换机上打开路由功能，默认是关闭的，ip router ospf 是在路由器上启用ospf等路由协议，ospf后面还要加个进程号，范围是0-65535，只具有本地意义 ip routing启用IP路由功能： 配置三层交换机启动路由功能：ip routing 。 配置VLAN IP地址： interface vlan vlan-id Ip address ip-address subnet-mask No shutdown 配置接口为三层模式： no switchport 配置DHCP中继转发： int vlan vlan-i Ip helper-address Dhcpserver-address 配置静态路由： ip route targetnet-address netmask nexthop-address 配置RIP协议： router rip 查看FIB表： show ip cef 查看邻接关系表： show adjacency detail 查看路由表： show ip route PC1 IP: 192.168.1.2 Submark: 255.255.255.0 Gateway: 192.168.1.1 PC2 IP: 192.168.2.2 Submark: 255.255.255.0 Gateway: 192.168.2.1 PC3 IP: 192.168.1.3 Submark: 255.255.255.0 Gateway: 192.168.1.1 二层交换机 Switch&gt;en Switch#conf t Enter configuration commands, one per line. End with CNTL/Z. Switch(config)#vlan 2 Switch(config-vlan)#exit Switch(config)#vlan 3 Switch(config-vlan)#int fa 0/2 Switch(config-if)#switchport access vlan 2 Switch(config-if)#int fa 0/3 Switch(config-if)#switchport access vlan 3 Switch(config-if)#int fa 0/1 Switch(config-if)#switchport mode trunk %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1, changed state to down %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1, changed state to up Switch(config-if)#end Switch# %SYS-5-CONFIG_I: Configured from console by console Switch#show vlan VLAN Name Status Ports 1 default active Fa0/4, Fa0/5, Fa0/6, Fa0/7 Fa0/8, Fa0/9, Fa0/10, Fa0/11 Fa0/12, Fa0/13, Fa0/14, Fa0/15 Fa0/16, Fa0/17, Fa0/18, Fa0/19 Fa0/20, Fa0/21, Fa0/22, Fa0/23 Fa0/24, Gig1/1, Gig1/2 2 VLAN0002 active Fa0/2 3 VLAN0003 active Fa0/3 1002 fddi-default act/unsup 1003 token-ring-default act/unsup 1004 fddinet-default act/unsup 1005 trnet-default act/unsup VLAN Type SAID MTU Parent RingNo BridgeNo Stp BrdgMode Trans1 Trans2 1 enet 100001 1500 - - - - - 0 0 2 enet 100002 1500 - - - - - 0 0 3 enet 100003 1500 - - - - - 0 0 1002 fddi 101002 1500 - - - - - 0 0 –More– 三层交换机 Switch&gt;en Switch#conf t Enter configuration commands, one per line. End with CNTL/Z. Switch(config)#vlan 2 Switch(config-vlan)#exit Switch(config)#vlan 3 Switch(config-vlan)#exit Switch(config)#int fa 0/1 Switch(config-if)#switchport trunk encapsulation dot1q Switch(config-if)#switchport mode trunk Switch(config-if)#switchport trunk allowed vlan 2,3 Switch(config-if)#exit Switch(config)#int fa 0/2 Switch(config-if)#switchport access vlan 2 Switch(config-if)#exit Switch(config)#int vlan 2 %LINK-5-CHANGED: Interface Vlan2, changed state to up %LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan2, changed state to up Switch(config-if)#ip address 192.168.1.1 255.255.255.0 Switch(config-if)#no shutdown Switch(config-if)#exit Switch(config)#int vlan 3 %LINK-5-CHANGED: Interface Vlan3, changed state to up %LINEPROTO-5-UPDOWN: Line protocol on Interface Vlan3, changed state to up Switch(config-if)#ip address 192.168.2.1 255.255.255.0 Switch(config-if)#no shutdown Switch(config-if)#exit Switch(config)#ip routing Switch(config)#exit Switch# %SYS-5-CONFIG_I: Configured from console by console Switch#show ip route Codes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2 E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area candidate default, U - per-user static route, o - ODR P - periodic downloaded static route Gateway of last resort is not set C 192.168.1.0/24 is directly connected, Vlan2 C 192.168.2.0/24 is directly connected, Vlan3 Switch#show vlan VLAN Name Status Ports 1 default active Fa0/3, Fa0/4, Fa0/5, Fa0/6 Fa0/7, Fa0/8, Fa0/9, Fa0/10 Fa0/11, Fa0/12, Fa0/13, Fa0/14 Fa0/15, Fa0/16, Fa0/17, Fa0/18 Fa0/19, Fa0/20, Fa0/21, Fa0/22 Fa0/23, Fa0/24, Gig0/1, Gig0/2 2 VLAN0002 active Fa0/2 3 VLAN0003 active 1002 fddi-default act/unsup 1003 token-ring-default act/unsup 1004 fddinet-default act/unsup 1005 trnet-default act/unsup VLAN Type SAID MTU Parent RingNo BridgeNo Stp BrdgMode Trans1 Trans2 1 enet 100001 1500 - - - - - 0 0 2 enet 100002 1500 - - - - - 0 0 3 enet 100003 1500 - - - - - 0 0 1002 fddi 101002 1500 - - - - - 0 0 –More– PC1 分别 ping PC2 和 PC3 PC&gt;ipconfig IP Address…: 192.168.1.2 Subnet Mask…: 255.255.255.0 Default Gateway…: 192.168.1.1 PC&gt;ping 192.168.2.2 Pinging 192.168.2.2 with 32 bytes of data: Request timed out. Reply from 192.168.2.2: bytes=32 time=25ms TTL=127 Reply from 192.168.2.2: bytes=32 time=20ms TTL=127 Reply from 192.168.2.2: bytes=32 time=20ms TTL=127 Ping statistics for 192.168.2.2: Packets: Sent = 4, Received = 3, Lost = 1 (25% loss), Approximate round trip times in milli-seconds: Minimum = 20ms, Maximum = 25ms, Average = 21ms 1232.拓展任务使用VTP管理交换机启用快速生成树，采用线路冗余的方式增加可靠性。 https://www.cnblogs.com/zoulongbin/p/9047390.html VTP的工作原理 VTP：虚拟局域网中继协议，VTP是一种消息协议，它使用第二层帧，在交换机之间传递VLAN信息，被称为VTP通告。有了VTP通告就可以再一台交换机上集中修改VLAN配置，所做的修改会被自动传播到网络中的其他交换机，从而实现VLAN配置的一致性。 VTP域：也称为VLAN管理域，由一个以上共享VTP域名相连接的交换机组成。也就是说，VTP域是一组VTP域名相同并通过中继链路互相连接的交换机。使用VTP首先需要建立一个VTP管理域，在同一管理域中的交换机共享他们的VLAN信息，并且一个交换机只能参加一个VTP管理域。 配置VTP域的要求如下： 1、域内的每台交换机都必须使用相同的VTP域名。 2、交换机必须是相邻的，即相邻的交换机并具有相同的域名。 3、交换机之前必须配置中继链路(也就是Trunk)。 它不通告自己的VLAN配置信息，对收到的VTP通告只转发而不会学习与更改自己的VLAN信息。 VTP的模式 1、服务器模式：充当VTP服务器模式的交换机负责它所在域中VLAN信息的管理工作。VTP服务器可以创建、删除或修改VLAN，并向外发送VTP通告，同时，VTP服务器也会学习域名相同的VTP通告信息。 2、客户机模式：处于VTP客户机模式的交换机不允许管理创建，删除或修改VLAN。它们监听本域中其他交换机的VTP通告，并相应修改它们自己的VTP配置。 3、透明模式：VTP透明模式中的交换机不参与VTP。当交换机处于透明模式时，它可以创建，删除或修改本地的VLAN信息，但 VTP通告 使用VTP时，加入VTP域的每台交换机在其中继端口上通告如下信息： 1、管理域 (即VTP的域名信息) 2、版本号 (使用VTP的版本号，只要校验服务器和客户机模式的版本是否一致) 3、配置修改编号 (默认为0，当修改VTP域的配置之后，此编号会加1) 4、它所知道的VLAN (即VTP中的所有VLAN) 5、每个VLAN的某些参数 (vlan的相关信息) 注意：当一台修改编号高于此VTP域中的修改编号的交换机加入此VTP域时，此交换机的中的VLAN配置会覆盖所有VTP域中的VLAN配置，所以将交换机加入VTP域时要格外小心。我们可以将交换机的VTP模式改为透明模式，再改回服务器模式或交换机模式，或者是将交换机的域名更改一下在改回来，就可以将交换机的修改编号初始为0。 VTP修剪 VTP修剪是VTP的一个功能，它能减少中继链路上不必要的广播流量。 配置VTP实例 在配置VTP之前，我们需要将VTP服务器和VTP客户机之间的链路设置为中继链路。 列如：将Switch1和Switch2的24号端口设置为trunk中继链路。 Switch1(config)#int f0/24 Switch1(config)#switchport mode trunk Switch1(config)#no sh Switch2(config)#int f0/24 Switch2(config)#switchport mode trunk Switch2(config)#no sh 配置VTP服务器模式 列如：将Switch1配置为VTP服务器，域名为test，秘密为123，配置VTP修剪。 Switch1#config terminal Switch1(config)#vtp domain test Switch1(config)#vtp mode server SWitch1(config)#vtp passwd 123 Switch1(config)#vtp pruning 配置VTP客户机模式 列如：将Switch2配置为VTP客户机，域名和密码必须和服务器器一致，否则将不匹配。 Switch2#config terminal Switch2(config)#vtp domain test Switch2(config)#vtp mode client SWitch2(config)#vtp passwd 123 Switch2(config)#vtp pruning 此时VTP服务器和VTP客户端就配置完成了，现在只需要在VTP服务器端创建VLAN，VTP客户端就可以自动学习到服务器端创建的VLAN，而不需要自己创建VLAN，但是注意，虽然VTP客户端可是自动学习VLAN，但是将端口加入VLAN的动作是不可以学习的，所以在客户端需要手动将端口添加到相应的VLAN中。 Unable to perform trunk negotiation on port Fa0/23 because of VTP domain mismatch这句话是什么意思？？是不能开启trunk在f0/23上！！因为VTP的域名错了！！你VTP配置的时候是不是名字有问题？？要就是配置一个！！要就是两边一样的！！不要两边不一样的！ 实训2 多域OSPF 1234要求：配置多域OSPF；Loopback口相当于PC；基本配置内容自主网络搜索。 OSPF多用于大型IPv4网络，是基于链路状态的路由协议，与基于距离矢量的路由协议相比具有更快的收敛速度，支撑的网络规模也更大。 OSPF（Open Shortest Path First）是IETF组织开发的一个基于链路状态的内部网关协议。目前针对IPv4协议使用的是OSPF Version 2（RFC2328）。OSPF是不属于任何一个厂商或组织私有的路由协议，使用Dijkstra的最短路径（SPF）算法计算路由。在OSPF中引入了区域的概念，有效的减少了路由选择协议对路由器CPU和内存的占用，同时也降低了路由选择协议的通信量，使得构建大型层次化网络成为可能 duplex auto 是双工的协商模式为自动 双工模式有两种，一种是full（全双工），一种是half（半双工） speed auto 是速率为协商模式为自动 一般的100M口支持: 10M，100M和自动模式 选择为自动模式则接口会和对端设备的接口进行协商，并自动选择最佳模式。 #ip access-group 10 out 将列表10所定义的条件应用禁止从此接口出去 该命令的详细说明如下： ip access-group {[access-list-number] |[ name]} [in | out] no ip access-group {[access-list-number] |[ name]} [in | out] 功能：将指定的访问列表应用到相关接口，并且指定acl起作用的方向。本命令的no操作为解除访问列表应用到相关接口，若没有指定方向，则默认为out； 若没有指定具体的[access-list-number] 或[name]而指定了方向，则默认为删除该方向上所有的访问列表的应用；若没有指定具体的[access-list-number] 或[name]也没有指定方向，则默认为删除out方向上所有的访问列表的应用。 参数：[access-list-number]为访问表表号，取值范围1～199；[name]为由ip access-list 命令指定的访问表名字，最长不超过8个字符；in为过滤入口的包；out为过滤出口的包。 缺省情况：没有任何访问表被应用至任何接口。若指定了绑定，而未指定方向，缺省为out。 命令模式：接口配置模式 使用指南：在访问列表应用到具体接口的具体方向之前，访问列表的规则是不起作用的。每个接口定义两个方向，即in和out方向。前者代表流入接口的方向， 后者代表流出接口的方向。规则可单独对in或out方向起作用，即只过滤入口的包或只过滤出口方向上的包，也可以两个方向都过滤。 应用到接口上的访问列表可以有多条，但只能有一条标准访问列表，对扩展访问列表来说，一个接口一个方向相同协议的访问列表只能有一条。访问列表的协议是指 每个表的协议缺省为这个表的第一条规则中指定要过滤的协议。若通过的信息包符合多条规则，则只有匹配的第一条规则有作用，匹配的顺序与规则应用到接口的先 后顺序一致。若规则中含有相互冲突的设置，以第一条匹配到的规则为准。 在当前时间不在分段时间过滤访问表设定的时间段时，将分段时间过滤访问表应用到接口是不起作用的，但等时间进入设定的时间段后，曾经应用到接口的分段时间过滤访问表会自动生效。 router ospf 10 Router ospf 10 中的 10 是这台路由器 Ospf 进程的 ID 号！ 路由器和我们的PC一样，是多任务系统，理论上能够支持多个 OSPF 进程同时运行！此ID号仅本地有效！ SNMP 是网络管理协议，OSPF 是路由协议，两者就不是一个东西，不能相提并论！ log-adjacency-changes log-adjacency-changes命令可用来激活路由协议邻接关系变化日志的功能（例如ospf或者ISIS等）。使用该命令来生成SYSLOG信息以用于网络操作与管理。日志信息对于故障排除也非常有用。log-adjacency-changes 是一个日志开关，意思是当 OSPF 探测到邻居关系发生变化时，将变化情况记录在系统日志里面！ network 192.168.233.160 0.0.0.3 area 1 1234567891011network 192.168.233.164 0.0.0.3 area 1 network 192.168.233.168 0.0.0.3 area 1 network 192.168.233.172 0.0.0.3 area 1 network 192.168.233.176 0.0.0.3 area 1 network 192.168.233.184 0.0.0.3 area 1 network 192.168.233.188 0.0.0.3 area 1 network 192.168.233.192 0.0.0.3 area 1 network 192.168.233.196 0.0.0.3 area 1 network 192.168.233.200 0.0.0.3 area 1 network 192.168.233.204 0.0.0.3 area 1network 10.228.1.0 0.0.0.15 area 1 是使用 OSPF 向邻居发布路由信息！ area 1 是 OSPF路由域中的 区域1，ospf 路由域分为骨干区域和非骨干区域，只有 area 0 是骨干区域，其他都是非骨干区域！ 0.0.0.3表示： 反掩码，表示匹配反掩码为1的位 0.0.0.255实际上是0.0.0.1111 1111 只要192.168.2.xxxx xxxx的网段就应用该路由 我自己把反掩码中的0理解为固定位，1理解为自由位。固定位就是不能变的，自由位是能变的，其实就是对前面ip的修饰，固定位就是他的网络段 原文链接：https://blog.csdn.net/qq_31828929/article/details/71191679 123456789101112131415PC与路由器的接口配置：interface FastEthernet0/0 ip address 192.168.1.254 255.255.255.0 duplex auto speed auto [(30条消息) 思科实验之配置ACL_晚风挽着浮云的博客-CSDN博客_思科配置acl](https://blog.csdn.net/weixin_57636278/article/details/123912132) interface FastEthernet0/0ip address 192.168.1.254 255.255.255.0no shutdownexit 1234567891011121314151617181920212223242526272829303132333435363738394041R1:interface GigabitEthernet0/0 ip address 172.16.10.1 255.255.255.0 no shutdown #开启接口exitrouter ospf 10 #开启ospf 进程号为10network 172.16.10.0 0.0.0.255 area 1 #宣告直连的网段；网段的反掩码；其直连的网段属于area1区域R2:interface GigabitEthernet0/0 ip address 172.16.10.2 255.255.255.0 no shuinterface GigabitEthernet0/1 ip address 172.16.20.1 255.255.255.0 no shu exitrouter ospf 10 network 172.16.10.0 0.0.0.255 area 1 #宣告直连，其直连的网段属于area1 区域 network 172.16.20.0 0.0.0.255 area 0 #area0是骨干区域 R3： interface GigabitEthernet0/0 ip address 172.16.20.2 255.255.255.0 no shuinterface GigabitEthernet0/1 ip address 172.16.30.1 255.255.255.0 no shu exitrouter ospf 10 network 172.16.20.0 0.0.0.255 area 0 network 172.16.30.0 0.0.0.255 area 2 R4： interface GigabitEthernet0/0 ip address 172.16.30.2 255.255.255.0 no shu exitrouter ospf 10 network 172.16.30.0 0.0.0.255 area 2 show ip route ping 172.16.30.2 https://blog.csdn.net/zhangzc0408/article/details/124372279 Loopback是路由器里面的一个逻辑接口。逻辑接口是指能够实现数据交换功能，但是物理上不存在、需要通过配置建立的接口。Loopback接口一旦被创建，其物理状态和链路协议状态永远是Up，即使该接口上没有配置IP地址 Loopback接口创建后一直保持UP状态，用户可通过配置Loopback接口达到提高网络可靠性的目的。 (30条消息) Loopback接口的主要作用及Loopback端口配置_JackLiu16的博客-CSDN博客_交换机loopback接口 OSPF多域配置_wx627255bd4ac6d的技术博客_51CTO博客 实训3 路由交换综合 1234567实训要求1.试验台环境：路由器为2811，交换机3560、2950；2.规划IP，配置接口，启动静态或动态路由协议，保障网络连通性；3.划分两个VLAN，VLAN 10采用192.168.10.0/24，VLAN 20采用192.168.20.20；4.能够实现VLAN间路由；5.禁止VLAN 20中的主机访问WWW服务，但不禁止Ping （VLAN10中主机可以访问WWW）。6.VLAN 20需要配置DHCP。 (30条消息) 交换机与路由器的通信的配置（2020.7.15）_penguinhd的博客-CSDN博客 SW13 Enable Conf t Vlan 10 Exit Interface f0/1 Switchport access vlan 10 Exit Interface f0/2 Switchport mode trunk sw14 Enable Conf t Vlan 20 Exit Interface f0/2 Switchport access vlan 20 Exit Interface f0/1 Switchport mode trunk sw12 enable conf t vlan 10 exit vlan 20 interface range f0/1-3 switchport mode trunk sw1 enable conf t vlan 10 exit vlan 20 exit interface f0/1 switchport tr en do switchport mode trunk exit interface vlan 10 ip address 192.168.10.1 255.255.255.0 exit interface vlan 20 ip address 192.168.20.1 255.255.255.0 exit ip routing Switch(config)#interface f0/2 Switch(config-if)#no switchport（使其成为路由器接口） Switch(config-if)#ip address 192.168.30.1 255.255.255.0 route 4 enable config t interface f0/0 no shutdown ip address 192.168.30.2 255.255.255.0 exit interface f0/1 no shutdown ip address 192.168.40.1 255.255.255.0 route 5 enable conf t interface f0/0 no shutdown ip address 192.168.40.2 255.255.255.0 exit interface f0/1 no shutdown ip address 192.168.50.1 255.255.255.0 什么是ACL？ ACL全称访问控制列表（Access Control List），主要通过配置一组规则进行过滤路由器或交换机接口进出的数据包， 是控制访问的一种网络技术手段， ACL适用于所有的被路由支持的协议，如IP、tcp、udp、ftp、www等。 什么是反掩码？ 反掩码就是通配符掩码 ， 通过标记0和1告诉设备应该匹配到哪位。 在反掩码中，相应位为1的地址在比较中忽略， 为0的必须被检查。IP地址与反掩码都是32位的数 由于跟子网掩码刚好相反，所以也叫反掩码 。 路由器使用的通配符掩码与源或目标地址一起来分辨匹配的地址范围，它与子网掩码不同。它不像子网掩码告诉 路由器IP地址是属于哪个子网（网段），通配符掩码告诉路由器为了判断出匹配，它需要检查IP地址中的多少位。 例如： 255.255.255.0 反掩码（wildcard-mask）就是0.0.0.255 255.255.255.248 反掩码（wildcard-mask）就是0.0.0.7 ACL工作原理： ACL使用包过滤技术，在路由器上读取OSI七层模型的第3层和第4层包头中的信息。如源地址，目标地址，源端口，目标端口等，根据预先定义好的规则，对包进行过滤，从而达到访问控制的目的。 对于路由器接口而言，ACL是有两个方向： **注意：**如果发现没有匹配的ACL规则，默认会丢弃该数据包，思科ACL规则默认会有一条隐藏的deny any any规则，而华三ACL规则默认是permit any any规则。 **入站----**如果是入站访问列表，则当路由器接收到数据包时，Cisco IOS 软件将检查访问列表中的条件语句，看是否有匹配。如果数据包被允许，则软件将继续处理该数据包。如果数据包被拒绝，则软件会丢弃该数据包。 **出站----**如果是出站访问列表，则当软件到接收数据包并将群其路由至出站接口后，软件将检查访问列表中的条件语句，看是否有匹配。如果数据包被允许，则软件会发送该数据包。如果数据包被拒绝，则软件会丢弃该数据包。 ACL两种类型： **标注：**允许在标准ACL和扩展ACL中使用名称代替访问控制列表号。 1、 标准的ACL 根据数据包的源IP地址来控制允许转发或拒绝数据包，访问控制列表号1~99。 标准访问控制列表配置命令如下： Router(config)#access-list access-list-number {permit|deny} source [souce-wildcard] 或者 Router(config)#ip access-list standard access-list-number Router(config-std-nacl)#Sequence Number{permit|deny} source [souce-wildcard] 下面是命令参数的详细说明 access-list-number：访问控制列表号，标准ACL取值是1-99，可以使用名称替代列表号。 Sequence Number：每条ACL规则列表序列号，可使用范围1-2147483647。 permit | deny：如果满足规则，则允许/拒绝通过。 source：数据包的源地址，可以是主机地址，也可以是网络地址 2、 扩展的ACL 根据数据包的源IP地址、目的IP地址、指定协议，端口、标志和时间来控制允许转发或拒绝数据包，访问控制列表号100~199 扩展访问控制列表配置命令如下： Router(config)#access-list access-list-number {permit|deny} protocol {source souce-wildcard destination destination-wildcard} [operator operan] 或者 Router(config)#ip access-list extended access-list-number Router(config-std-nacl)#{permit|deny} protocol {source souce-wildcard destination destination-wildcard} [operator operan] 下面是命令参数的详细说明 access-list-number：访问控制列表号，扩展ACL取值100-199，可以使用名称替代列表号。 Sequence Number：每条ACL规则列表序列号，可使用范围1-2147483647。 permit|deny：如果满足规则，则允许/拒绝通过。 protocol：用来指定协议的类型，如IP，TCP，UDP，ICMP等。 source、destination：源和目的，分别用来标示源地址和目的地址。 souce-wildcard、destination-wildcard：子网反码，souce-wildcard是源反码，destination-wildcard是目标反码。 operator operan：lt(小于)、gt(大于)、eq(等于)、neq(不等于)、rand(范围端口号)等。 DHCP ​ DHCP全称为Dynamic Host Configuration Protocol，中文含义为“动态主机配置协议”，通常被应用在大型的局域网络环境中，主要作用是集中管理、分配IP地址，使网络环境中的主机动态获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。 DHCP协议采用客户端/服务器模型，主机地址的动态分配任务由网络主机驱动。当DHCP服务器接收到来自网络主机申请地址的信息时，才会向网络主机发送相关的地址配置等信息，以实现网络主机地址信息的动态配置。 ​ DHCP服务器就是自动给电脑分配IP地址和子网掩码的服务器。比如我们设置了路由器的DHCP服务器，让DHCP服务器自动分配IP地址，从192.168.1.100到192.168.1.199(子网掩码会自动设置，我们无需设置)。 实训4 RIP一般配置方法 RIP（Routing Information protocol) 路由信息协议. 是一种内部网关协议（IGP），是一种动态路由选择协议，用于自治系统（AS）内的路由信息的传递。RIP协议基于距离矢量算法（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离。RIP通过UDP报文进行路由信息交换,使用的端口号为520. 这种协议的路由器只关心自己周围的世界，只与自己相邻的路由器交换信息，范围限制在15跳(15度)之内，再远，它就不关心了。RIP应用于OSI网络七层模型的应用层。各厂家定义的管理距离（AD，即优先级）如下：华为定义的优先级是100，思科定义的优先级是120。 第一步：将每个设备的IP地址配好 Router#configure terminal Enter configuration commands, one per line. End with CNTL/Z. Router(config)#interface g0/0 Router(config-if)#ip address 192.168.1.1 255.255.255.0 Router(config-if)#no shutdown Router(config-if)#exit Router(config)#interface Se0/3/0 Router(config-if)#ip address 10.0.0.1 255.0.0.0 Router(config-if)#no shutdown Router(config-if)#end Router# %SYS-5-CONFIG_I: Configured from console by console Router# 第二步：配置rip路由 Router(config)#hostname R0 R0(config)#end R0# %SYS-5-CONFIG_I: Configured from console by console R0#configure terminal Enter configuration commands, one per line. End with CNTL/Z. R0(config)#route rip R0(config-router)#network 192.168.1.0 R0(config-router)#network 10.0.0.0 R0(config-router)#end 实训5 华为交换初步 1234实训目的：了解VLAN的划分方法；了解VLAN特性；了解Trunk的配置方法 (30条消息) 二层交换机实现vlan 功能 (Cisco Packer Tracer 模拟器)_sizaif的博客-CSDN博客 主机配置： Switch&gt;en Switch#conf Switch(config)#vlan 10 // 创建 vlan 10 Switch(config-vlan)#vlan 20 // 创建 vlan 20 Switch(config-vlan)#EXIT Switch(config-if)#interface fa0/1 // 进入端口 f0/1 并配置为接入到vlan10 的access 模式 Switch(config-if)#switchport mode access Switch(config-if)#switchport access vlan 10 Switch(config-if)#interface fa0/2 //进入端口 f0/2 并配置为接入到vlan20 的access 模式 Switch(config-if)#switchport mode access Switch(config-if)#switchport access vlan 20 交换机配置： Switch&gt;en Switch#conf Switch(config)#interface fa0/24 // 进入端口f0/24 并设置为trun 模式，允许所以vlan通过 Switch(config-if)#switchport mode access Switch(config-if)#switchport mode trunk Switch(config-if)#switchport trunk allowed vlan all 192.168.1.1 ----- &gt;ping 192.168.2.2 ping不通 ：同一交换机下，不同vlan，不同网段 192.168.1.1 ----- &gt; ping 192.168.1.4 ping通： 跨交换机，同一vlan，同一网段 总结 123456Switch#show ip routeSwitch#show vlanSwitch#write #保存已写的内容 PC&gt;ipconfig IPPC&gt;ping 192.168.2.2 12345678910111213141516171819二层交换机Switch&gt;enSwitch#conf t#设置vlan Switch(config)#vlan 2Switch(config)#vlan 3Switch(config-vlan)#exit#同一个vlan交流，配置vlan就用switchport access vlan n就足够了Switch(config)#int fa 0/2Switch(config-if)#switchport access vlan 2Switch(config-if)#int fa 0/3Switch(config-if)#switchport access vlan 3#想vlan2和vlan3交流就得使用trunk协议，二层交换机上配置如下：Switch(config-if)#int fa 0/1Switch(config-if)#switchport mode trunk Switch(config-if)#end 12345678910111213141516171819202122232425三层交换机Switch&gt;enSwitch#conf tSwitch(config)#vlan 2Switch(config)#vlan 3Switch(config-vlan)#exit#三层交换机口配置 Switch(config)#int fa 0/1Switch(config-if)#switchport trunk encapsulation dot1qSwitch(config-if)#switchport mode trunkSwitch(config-if)#switchport trunk allowed vlan 2,3Switch(config-if)#exit#启动vlan n的使用Switch(config)#int vlan 2Switch(config-if)#ip address 192.168.1.1 255.255.255.0Switch(config-if)#no shutdownSwitch(config-if)#exit（vlan 3 同理）#开启三层交换机默认路由Switch(config)#ip routingSwitch(config)#exit 123456789101112131415161718192021222324252627282930##配置VTP服务器https://www.cnblogs.com/zoulongbin/p/9047390.html#三层交换机实现服务器Switch&gt;enableSwitch#vlan databaseSwitch(vlan)#vtp domain CCTVSwitch(vlan)#vtp server ##创建VLANSwitch(vlan)#vlan 10 name VLAN10Switch(vlan)#vlan 20 name VLAN20Switch(vlan)#exit ##配置VLAN IP地址Switch#configure terminalSwitch(config)#interface vlan 10Switch(config-if)#ip address 192.168.10.1 255.255.255.0Switch(config-if)#exitSwitch(config)#interface vlan 20Switch(config-if)#ip address 192.168.20.1 255.255.255.0Switch(config-if)#exit ##开启三层交换机默认路由3560SW(config)#ip routing #设置端口汇聚(trunk)Switch(config)#interface range fastEthernet 0/22-24Switch(config-if-range)#switchport trunk encapsulation dot1qSwitch(config-if-range)#switchport mode trunkSwitch(config-if-range)#no shutdownSwitch(config-if-range)#exit 1234567891011121314151617181920#二层交换机作为VTP客户端Switch#vlan databaseSwitch(vlan)#vtp domain CCTVSwitch(vlan)#vtp clientSwitch(vlan)#exit ##设置端口汇聚(trunk)Switch#configure terminalSwitch(config)#interface fastEthernet 0/24Switch(config-if)#switchport mode trunkSwitch(config-if)#no shutdownSwitch(config-if)#exit ##分配VLAN所属端口Switch#configure terminalSwitch(config)#interface range fastEthernet 0/1-5Switch(config-if-range)#switchport access vlan 10Switch(config-if-range)#switchport mode accessSwitch(config-if-range)#no shutdownSwitch(config-if-range)#exit 12345#PC机与路由器间的配置：Router(config-if)#interface FastEthernet0/0Router(config-if)#ip address 192.168.1.254 255.255.255.0Router(config-if)#no shutdownRouter(config-if)#exit 12345678#路由器与路由器间的配置Router(config-if)#interface GigabitEthernet0/0Router(config-if)#ip address 172.16.10.1 255.255.255.0Router(config-if)#no shutdown Router(config-if)#exit#ospf配置Router(config)#router ospf 10 Router(config-router)#network 172.16.10.0 0.0.0.255 area 1 1234567#配置loopback接口（ip自定义）Router(config)#interface loopback 0Router(config-if)#ip address 1.1.1.1 255.255.255.255Router(config-if)#no shutdownRouter(config)#interface loopback 1Router(config-if)#ip address 192.168.1.1 255.255.255.0Router(config-if)#no shutdown 12345#路由器地址配置Router(config)#interface g0/0Router(config-if)#ip address 192.168.1.1 255.255.255.0Router(config-if)#no shutdownRouter(config-if)#exit 123456#路由器RIP配置Router(config)#hostname R0R0(config)#route ripR0(config-router)#network 192.168.1.0R0(config-router)#network 10.0.0.0R0(config-router)#end 1234567主机的vlan配置：Switch(config)#vlan 10 Switch(config-vlan)#EXITSwitch(config-if)#interface fa0/1 Switch(config-if)#switchport mode access Switch(config-if)#switchport access vlan 10 12345二层交换机间的配置：Switch(config)#interface fa0/24 Switch(config-if)#switchport mode access Switch(config-if)#switchport mode trunk Switch(config-if)#switchport trunk allowed vlan all 123456789101112131415161718路由器与交换机间的配置：（1）交换机端口配置#f0/1协议配置Switch(config)#interface f0/1Switch(config-if)#switchport trunk encapsulation dot1qSwitch(config-if)#switchport mode trunkSwitch(config-if)#exit#f0/1 IP配置Switch(config)#interface f0/1Switch(config-if)#no switchport（使其成为路由器接口） Switch(config-if)#ip address 192.168.30.1 255.255.255.0（2）路由器配置Switch(config)#interface f0/0Switch(config-if)#no shutdownSwitch(config-if)#ip address 192.168.30.2 255.255.255.0Switch(config-if)#exit 1234567891011#DHCP:动态地址获取Switch(config)#ip dhcp pool vlan20Switch(dhcp-config)#network 192.168.20.254 255.255.255.0Switch(dhcp-config)#default-router 192.168.20.254Switch(dhcp-config)#dns-server 8.8.8.8Switch(dhcp-config)#end#telnet:远程登陆Switch（config）#enable password 123Switch（config）# line vty 0 2Switch（config-line）# password cisco","categories":[],"tags":[]},{"title":"卡尔曼滤波（修饰直立角度）","slug":"智能车/卡尔曼滤波","date":"2022-07-17T08:38:23.433Z","updated":"2022-07-17T08:40:54.878Z","comments":true,"path":"2022/07/17/智能车/卡尔曼滤波/","link":"","permalink":"https://zhang0224gz.github.io/2022/07/17/%E6%99%BA%E8%83%BD%E8%BD%A6/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//实验室传的#include &quot;headfile.h&quot;#include &quot;kalman_filter.h&quot;float angle, angle_dot; //外部需要引用的变量//-------------------------------------------------------float Q_angle=0.001, Q_gyro=0.003, R_angle=1.2, dt=0.008;//float P[2][2] = &#123; &#123; 1, 0 &#125;, &#123; 0, 1 &#125; &#125;; float Pdot[4] =&#123;0,0,0,0&#125;;const char C_0 = 1;float q_bias, angle_err, PCt_0, PCt_1, E, K_0, K_1, t_0, t_1;//-------------------------------------------------------void Kalman_Filter(float angle_m,float gyro_m) //gyro_m:gyro_measure&#123; angle+=(gyro_m-q_bias) * dt;//先验估计 Pdot[0]=Q_angle - P[0][1] - P[1][0];// Pk-&#x27; 先验估计误差协方差的微分 Pdot[1]=- P[1][1]; Pdot[2]=- P[1][1]; Pdot[3]=Q_gyro; P[0][0] += Pdot[0] * dt;// Pk- 先验估计误差协方差微分的积分 = 先验估计误差协方差 P[0][1] += Pdot[1] * dt; P[1][0] += Pdot[2] * dt; P[1][1] += Pdot[3] * dt; angle_err = angle_m - angle;//zk-先验估计 PCt_0 = C_0 * P[0][0]; PCt_1 = C_0 * P[1][0]; E = R_angle + C_0 * PCt_0; K_0 = PCt_0 / E;//Kk K_1 = PCt_1 / E; t_0 = PCt_0; t_1 = C_0 * P[0][1]; P[0][0] -= K_0 * t_0;//后验估计误差协方差 P[0][1] -= K_0 * t_1; P[1][0] -= K_1 * t_0; P[1][1] -= K_1 * t_1; angle += K_0 * angle_err;//后验估计//最优角度 q_bias += K_1 * angle_err;//后验估计 angle_dot = gyro_m-q_bias;//输出值（后验估计）的微分 = 角速度//最优角速度&#125; 12345678910111213#ifndef __KALMAN_FILTER_H__#define __KALMAN_FILTER_H__#include &quot;common.h&quot;#include &quot;headfile.h&quot;//#define rate angle_dotextern float angle, angle_dot; //外部需要引用的变量void Kalman_Filter(float angle_m,float gyro_m);#endif","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"大津法求图像动态阈值","slug":"智能车/大津法","date":"2022-07-17T08:25:09.202Z","updated":"2022-07-17T08:33:25.705Z","comments":true,"path":"2022/07/17/智能车/大津法/","link":"","permalink":"https://zhang0224gz.github.io/2022/07/17/%E6%99%BA%E8%83%BD%E8%BD%A6/%E5%A4%A7%E6%B4%A5%E6%B3%95/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实验室的师哥传的uint8 auto_threshold(uint8 * mt9v03x_image, int width,int height)//uint8 *image, uint16 col, uint16 row&#123; int colorarray[256] = &#123;0&#125;; int32_t tol_sumgray=0; int32_t tol_colsum=0; int32_t icp_colsum=0; int32_t max_colasg=0; int32_t icp_sumgray=0; uint8 threshold = 0; float exp1=0; float exp2=0; float copli_exp=0; float crt_vari=0; for(i = 0; i&lt;256; i++) colorarray[i] = 0; for(i = 0; i &lt; height; i++) &#123; for(j = 0; j &lt; width; j++) &#123; colorarray[(int) mt9v03x_image[i * width + j]]++; &#125; &#125; for(k=0; k&lt;=255; k++) &#123; tol_sumgray+=k*colorarray[k]; tol_colsum+=colorarray[k]; &#125; for(k=0; k&lt;=254; k++) &#123; icp_colsum+=colorarray[k]; max_colasg=tol_colsum-icp_colsum; icp_sumgray+=k*colorarray[k]; exp1=(float)icp_sumgray/icp_colsum; exp2=(float)(tol_sumgray-icp_sumgray)/max_colasg; copli_exp=icp_colsum*max_colasg*(exp1-exp2)*(exp1-exp2); if(copli_exp&gt;crt_vari) &#123; crt_vari=copli_exp; threshold=k; &#125; &#125; return (threshold+8);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//我写的……#define GrayScale 256#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80uint8 OTSU(void)&#123; uint16 i,j; uint8 img_row=row,img_col=col; uint16 histogram[GrayScale]; //灰度直方图 //第一步：初始化灰度直方图 for(i=0; i&lt;GrayScale; i++) histogram[i]=0; //第二步：统计每个灰度值出现得次数 for(i=0; i&lt;img_row; i++) for(j=0; j&lt;img_col; j++) ++histogram[mt9v03x_image[i][j]]; //第三步： 获取最小最大灰度值 uint16 minGray,maxGray; for(minGray=0;minGray&lt;256&amp;&amp;histogram[minGray]==0;minGray++); for(maxGray=255;maxGray&gt;minGray&amp;&amp;histogram[maxGray]==0;maxGray--); //第四步：分情况讨论 // 最大=最小，图像只有一种颜色 if(maxGray==minGray) return maxGray; //最大=最小+1，图像只有两种颜色 if(maxGray==minGray+1) return minGray; //第五步：统计[最小,最大]范围内的像素总数 uint16 PixelSum=0; for(i=minGray; i&lt;maxGray+1; i++) PixelSum += histogram[i]; //第六步：统计[最小,最大]范围内的灰度值总数(灰度值*出现次数) uint16 GraySum=0; for(i=minGray; i&lt;maxGray+1; i++) GraySum += histogram[i]*i; //第七步： 大津法优化 float w0; //前景像素点占整幅图像的百分比 float w1; //背景像素点占整幅图像的百分比 uint16 w0num; //前景像素点数 uint16 w1num; // 背景像素点数 uint16 u0gray; //前景灰度值 uint16 u1gray; //背景灰度值 float u0; //w0平均灰度 float u1; //w1平均灰度 float deltaTmp=0,deltaMax=-1; uint8 th; u0gray = u1gray = w0num = w1num = 0; for(i=minGray; i&lt;maxGray+1; i++) &#123; w0num += histogram[i]; w1num = PixelSum-w0num; w0 = w0num*1.0/PixelSum; w1 = w1num*1.0/PixelSum; u0gray += histogram[i]*i; u1gray = GraySum-u0gray; u0 = u0gray*1.0/w0num; u1 = u1gray*1.0/w1num; deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2 //第八步：遍历最大类间方差（因为呈正态分布） if(deltaTmp&gt;deltaMax) &#123; deltaMax = deltaTmp; th = i; &#125; &#125; return th; &#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"霍夫变换检测椭圆","slug":"智能车/霍夫变换检测椭圆","date":"2022-07-04T01:50:45.957Z","updated":"2022-07-17T08:25:38.210Z","comments":true,"path":"2022/07/04/智能车/霍夫变换检测椭圆/","link":"","permalink":"https://zhang0224gz.github.io/2022/07/04/%E6%99%BA%E8%83%BD%E8%BD%A6/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E6%A4%AD%E5%9C%86/","excerpt":"","text":"霍夫变换（一） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204//定义椭圆结构体，成员包含累积计数，中心点，长短半轴，倾斜角度 typedef struct Ellipse &#123; int accumulator; double xc, yc; double a, b; double angle;&#125; Ellipse;//创建格子，传累加器列表和精度 static std::vector&lt;double&gt; _create_bins(const std::vector&lt;double&gt;&amp; acc, double binSize) &#123; //把累加器列表中最大值取出，即计算得到的短半轴平方的所有值中最大的值 std::vector&lt;double&gt;::const_iterator maxPos = std::max_element(acc.begin(), acc.end()); double maxVal = *maxPos; //要返回的格子列表 std::vector&lt;double&gt; v; //格子是从0开始，到最大值，间隔为精度 for (double d = 0; d &lt; maxVal + binSize; d += binSize) &#123; v.push_back(d); &#125; return v;&#125;//然后是计算直方图数据的函数，传入累加器列表和格子列表，返回就是累加器列表中的值落入相应的格子的计算的列表 static std::vector&lt;int&gt; _histogram(const std::vector&lt;double&gt;&amp; acc, const std::vector&lt;double&gt;&amp; bins) &#123; //直方图的数据列表，大小比格子的边界数少1 std::vector&lt;int&gt; hist(bins.size()-1); //直方图数据初始化为0 for (int i = 0; i &lt; hist.size(); i++) &#123; hist[i] = 0; &#125; //遍历累加器列表中的数据，看落入了哪个格子 for (int i = 0; i &lt; acc.size(); i++) &#123; double a = acc[i]; //看落入哪个格子 for (int j = 0; j &lt; bins.size()-1; j++) &#123; //格子的左边值和右边值，除了最后一个格子，都是左闭右开 double left = bins[j]; double right = bins[j+1]; //如果值落入相应的格子，相应的直方图计算加1 if (a &gt;= left &amp;&amp; a &lt; right) &#123; hist[j]++; break; &#125; &#125; //如果为最后一个格子的边界，最后一个格子的计算也要加1，最后一个格子是左闭右也闭 if (a == bins[bins.size()-1]) &#123; hist[bins.size()-2]++; &#125; &#125; return hist;&#125;//定义算法的实现函数，返回检测到的椭圆列表//参数：传入的边缘图，//累计计数的阈值（即达到什么值才认为有效），//精度（主要用来定义直方图的格子），//轴的最小值，//轴的最大值（如果为-1，则取图像宽高中小的那个一半），//第一个轴的最大值（如果为-1，则无限制） static std::vector&lt;Ellipse&gt; _hough_ellipse(const cv::Mat&amp; edges, int threshold, double accuracy, int minAxis, int maxAxis=-1, int maxFirst=-1) &#123; //定义返回的列表 std::vector&lt;Ellipse&gt; results; //拿到图像的宽高 int numRows = edges.rows; int numCols = edges.cols; //边缘图像的非零点位置 std::vector&lt;int&gt; nonzeroXIndices, nonzeroYIndices; //把边缘图像的非零点找出来 for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j &lt; numCols; j++) &#123; if (edges.ptr&lt;uchar&gt;(i)[j] &gt; 0) &#123; nonzeroXIndices.push_back(j); nonzeroYIndices.push_back(i); &#125; &#125; &#125; //总共有多少非零点 int numPixels = nonzeroXIndices.size(); //累加器列表 std::vector&lt;double&gt; accumulator; //精度，即直方图的格子宽度，这里取平方，因为下面的算法计算短半轴时为了减少计算量也是用平方（不开方） double binSize = accuracy*accuracy; //最大的半轴值，也取平方以避免开方 double maxAxisSquared = maxAxis*maxAxis; //如果轴的最大值为-1，则取图像宽高中小的那个一半 if (maxAxis == -1) &#123; if (numRows &lt; numCols) &#123; maxAxisSquared = cvRound(0.5*numRows); &#125; else &#123; maxAxisSquared = cvRound(0.5*numCols); &#125; maxAxisSquared *= maxAxisSquared; &#125; //定义一些变量 int p1, p2, p, x1, y1, x2, y2, x, y; double x0, y0, a, b, d, k, dx, dy, fSquared, cosTauSquared, bSquared, alpha; //遍历所有非零点 for (p1 = 0; p1 &lt; numPixels; p1++) &#123; //取另一个非零点（因为点的顺序不影响，所以，已经处理过的非零点对不再处理） for (p2 = 0; p2 &lt; p1; p2++) &#123; //把点(x1,y1),(x2,y2)取出 x1 = nonzeroXIndices[p1]; y1 = nonzeroYIndices[p1]; x2 = nonzeroXIndices[p2]; y2 = nonzeroYIndices[p2]; //计算长半轴 dx = x1-x2; dy = y1-y2; a = 0.5*std::sqrt(dx*dx+dy*dy); //看第一个轴的最大值是否为-1，用于判断计算得到的a是否符合要求 bool bMaxFirst = (maxFirst == -1); if (maxFirst != -1) &#123; bMaxFirst = (a &lt;= maxFirst); &#125; //如果计算到的长半轴a符合要求（大于最小轴的值，并小于第一个轴最大值） if (a &gt; minAxis &amp;&amp; bMaxFirst) &#123; //计算中心点 x0 = 0.5*(x1+x2); y0 = 0.5*(y1+y2); //对非零点对，遍历所有非零的点计算短半轴 for (p = 0; p &lt; numPixels; p++) &#123; //取出假设的位于椭圆上的点 x = nonzeroXIndices[p]; y = nonzeroYIndices[p]; dx = x-x0; dy = y-y0; //计算此点到中心点的距离d d = std::sqrt(dx*dx+dy*dy); //如果此距离大于最小轴的值，则认为此点有可能为椭圆上的点 if (d &gt; minAxis) &#123; dx = x-x2; dy = y-y2; //计算f的值的平方 fSquared = dx*dx+dy*dy; //计算cosTau cosTauSquared = (a*a+d*d-fSquared) / (2*a*d); //再计算cosTau的平方 cosTauSquared *= cosTauSquared; //计算b平方的分母 k = a*a-d*d*cosTauSquared; //让b要在合理的条件内 if (k &gt; 0 &amp;&amp; cosTauSquared &lt; 1) &#123; //计算b的平方 bSquared = a*a*d*d*(1-cosTauSquared) / k; //计算到的b的平方要小于最大轴的值的平方 if (bSquared &lt;= maxAxisSquared) &#123; //把符合要求的短半轴的平方值放入累加器列表中 accumulator.push_back(bSquared); &#125; &#125; &#125; &#125; //对非零点对计算完所有短半轴b，看符合要求的值有没有，即累加器列表里是否有值 if (accumulator.size() &gt; 0) &#123; //有值，则说明有可能有相应的短半轴与这一对非零点组成的长轴构成一个椭圆 std::vector&lt;double&gt; bins; //下面是对累加器列表中的短半轴平方的数据进行处理，看能不能找到合适的短半轴， //首先是利用精度来创建格子 bins = _create_bins(accumulator, binSize); std::vector&lt;int&gt; hist; //然后按创建的格子计算累计器列表的直方图 hist = _histogram(accumulator, bins); //把直方图计数数据中的最大值找出来 std::vector&lt;int&gt;::iterator histMaxIter = std::max_element(hist.begin(), hist.end()); int histMax = *histMaxIter; //如果这个最大计数达到了要求的阈值，则说明这个短半轴的计算是可以构成一个椭圆的 if (histMax &gt; threshold) &#123; //计算倾斜角度 alpha = std::atan2(y2-y1, x2-x1); //把直方图最大值对应的格子索引计算出来 int maxIndex = histMaxIter - hist.begin(); //短半轴的值即为最大直方图计数值对应的格子的值的开方 b = std::sqrt(bins[maxIndex]); if (alpha != 0) &#123; //在OpenCV中，y轴是向下的，把角度改一下（其实问题不大) alpha = CV_PI - alpha; &#125; //最后保证计算得到的长半轴和短半轴都大于0，则认为确定了一个椭圆 if (a &gt; 0 &amp;&amp; b &gt; 0) &#123; //把确定的椭圆保存 Ellipse ellipse; ellipse.accumulator = histMax; ellipse.xc = x0; ellipse.yc = y0; ellipse.a = a; ellipse.b = b; ellipse.angle = alpha * 180 / CV_PI; results.push_back(ellipse); &#125; &#125; //累加器清零再进行下一对非零点 accumulator.clear(); &#125; &#125; &#125; &#125; return results;&#125; 霍夫椭圆（二） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//直接上函数，传进来源图像的高、宽、轮廓线的点，阈值，然后输出就是椭圆的参数 static bool _hough_ellipse2(int numRows, int numCols, const std::vector&lt;cv::Point&gt;&amp; contour, double threshold, cv::Point&amp; center, float&amp; a, float&amp; b, float&amp; theta) &#123; //定义最大距离的图，即源图上每个点到轮廓线（这个轮廓线是先被假定是一个椭圆）的最大距离的图 cv::Mat maxDists(numRows, numCols, CV_32FC1, cv::Scalar::all(0)); //任一点到轮廓线所有点的距离列表 std::vector&lt;float&gt; dists(contour.size()); //图像上每一个点到轮廓线上的点的距离计算 for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j &lt; numCols; j++) &#123; for (int k = 0; k &lt; contour.size(); k++) &#123; //计算图像上的点到轮廓线上的点的距离，并放入列表中 float dx = j-contour[k].x; float dy = i-contour[k].y; float dist = std::sqrt(dx*dx+dy*dy); dists[k] = dist; &#125; //从距离列表中找出最大的那个距离 std::vector&lt;float&gt;::iterator iter = std::max_element(dists.begin(), dists.end()); float maxDist = *iter; //把这个最大距离放到图中相应位置 maxDists.ptr&lt;float&gt;(i)[j] = maxDist; &#125; &#125; //有了最大距离的图，找到这个最大距离图中最小的那个距离，及这个最小距离所在的位置 double minVal; cv::Point minLoc; cv::minMaxLoc(maxDists, &amp;minVal, NULL, &amp;minLoc); //根据定理，最大距离中的最小那个对应椭圆的长半轴，而对应的位置就是椭圆中心 center = minLoc; a = (float)minVal; //接下来由短半轴和角度定义一个霍夫空间 cv::Mat houghSpace(std::floor(a+1), 180, CV_32SC1, cv::Scalar::all(0)); //因为轮廓线被假定为椭圆了，所以把轮廓线上的点，再加上离散的角度，带入椭圆公式计算短半轴 for (int i = 0; i &lt; contour.size(); i++) &#123; for (int j = 0; j &lt; 180; j++) &#123; //角度转为弧度 double angle = j*CV_PI/180; //中心点，前面已经确认 double p = center.x; double q = center.y; //轮廓上的点 double x = contour[i].x; double y = contour[i].y; //计算sin，cos double cosTheta = std::cos(angle); double sinTheta = std::sin(angle); //公式中加号左边那一项 double part1 = std::pow((x-p)*cosTheta+(y-q)*sinTheta, 2) / (a*a); //加号右边那一项的分子 double part2 = std::pow(-(x-p)*sinTheta+(y-q)*cosTheta, 2); //计算短半轴，要取到整数，所以用了floor这个函数，先进行了加1 int B = std::floor(std::sqrt(part2 / (1-part1)) + 1); //计算得到的短半轴大于0，且不大于长半轴，则霍夫空间对应短半轴和角度位置计算加1 if (B &gt; 0 &amp;&amp; B &lt;= a) &#123; houghSpace.ptr&lt;int&gt;(B)[j] += 1; &#125; &#125; &#125; //得到霍夫空间的累加计数，下面把累加计数的最大值找出来 double maxVal; cv::Point maxLoc; cv::minMaxLoc(houghSpace, NULL, &amp;maxVal, NULL, &amp;maxLoc); //如果最大计数大于给定的阈值，则说明这条轮廓线有成为椭圆的潜质 if (maxVal &gt;= threshold) &#123; //短半轴就是最大计数对应位置的y，角度就是x b = maxLoc.y; theta = maxLoc.x; //最后确保长短半轴都是大于1的，这才说明成功确认一条轮廓线为一个椭圆 return (a &gt; 1 &amp;&amp; b &gt; 1); &#125; return false;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383//网上代码：后期发现不需要也就不改了……#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/imgcodecs.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;//定义椭圆结构体，成员包含累积计数，中心点，长短半轴，倾斜角度 typedef struct Ellipse &#123; int accumulator; double xc, yc; double a, b; double angle;&#125; Ellipse;//创建格子，传累加器列表和精度 static std::vector&lt;double&gt; _create_bins(const std::vector&lt;double&gt;&amp; acc, double binSize) &#123; //把累加器列表中最大值取出，即计算得到的短半轴平方的所有值中最大的值 std::vector&lt;double&gt;::const_iterator maxPos = std::max_element(acc.begin(), acc.end()); double maxVal = *maxPos; //要返回的格子列表 std::vector&lt;double&gt; v; //格子是从0开始，到最大值，间隔为精度 for (double d = 0; d &lt; maxVal + binSize; d += binSize) &#123; v.push_back(d); &#125; return v;&#125;//然后是计算直方图数据的函数，传入累加器列表和格子列表，返回就是累加器列表中的值落入相应的格子的计算的列表 static std::vector&lt;int&gt; _histogram(const std::vector&lt;double&gt;&amp; acc, const std::vector&lt;double&gt;&amp; bins) &#123; //直方图的数据列表，大小比格子的边界数少1 std::vector&lt;int&gt; hist(bins.size()-1); //直方图数据初始化为0 for (int i = 0; i &lt; hist.size(); i++) &#123; hist[i] = 0; &#125; //遍历累加器列表中的数据，看落入了哪个格子 for (int i = 0; i &lt; acc.size(); i++) &#123; double a = acc[i]; //看落入哪个格子 for (int j = 0; j &lt; bins.size()-1; j++) &#123; //格子的左边值和右边值，除了最后一个格子，都是左闭右开 double left = bins[j]; double right = bins[j+1]; //如果值落入相应的格子，相应的直方图计算加1 if (a &gt;= left &amp;&amp; a &lt; right) &#123; hist[j]++; break; &#125; &#125; //如果为最后一个格子的边界，最后一个格子的计算也要加1，最后一个格子是左闭右也闭 if (a == bins[bins.size()-1]) &#123; hist[bins.size()-2]++; &#125; &#125; return hist;&#125;//定义算法的实现函数，返回检测到的椭圆列表//参数：传入的边缘图，//累计计数的阈值（即达到什么值才认为有效），//精度（主要用来定义直方图的格子），//轴的最小值，//轴的最大值（如果为-1，则取图像宽高中小的那个一半），//第一个轴的最大值（如果为-1，则无限制） static std::vector&lt;Ellipse&gt; _hough_ellipse(const cv::Mat&amp; edges, int threshold, double accuracy, int minAxis, int maxAxis=-1, int maxFirst=-1) &#123; //定义返回的列表 std::vector&lt;Ellipse&gt; results; //拿到图像的宽高 int numRows = edges.rows; int numCols = edges.cols; //边缘图像的非零点位置 std::vector&lt;int&gt; nonzeroXIndices, nonzeroYIndices; //把边缘图像的非零点找出来 for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j &lt; numCols; j++) &#123; if (edges.ptr&lt;uchar&gt;(i)[j] &gt; 0) &#123; nonzeroXIndices.push_back(j); nonzeroYIndices.push_back(i); &#125; &#125; &#125; //总共有多少非零点 int numPixels = nonzeroXIndices.size(); //累加器列表 std::vector&lt;double&gt; accumulator; //精度，即直方图的格子宽度，这里取平方，因为下面的算法计算短半轴时为了减少计算量也是用平方（不开方） double binSize = accuracy*accuracy; //最大的半轴值，也取平方以避免开方 double maxAxisSquared = maxAxis*maxAxis; //如果轴的最大值为-1，则取图像宽高中小的那个一半 if (maxAxis == -1) &#123; if (numRows &lt; numCols) &#123; maxAxisSquared = cvRound(0.5*numRows); &#125; else &#123; maxAxisSquared = cvRound(0.5*numCols); &#125; maxAxisSquared *= maxAxisSquared; &#125; //定义一些变量 int p1, p2, p, x1, y1, x2, y2, x, y; double x0, y0, a, b, d, k, dx, dy, fSquared, cosTauSquared, bSquared, alpha; //遍历所有非零点 for (p1 = 0; p1 &lt; numPixels; p1++) &#123; //取另一个非零点（因为点的顺序不影响，所以，已经处理过的非零点对不再处理） for (p2 = 0; p2 &lt; p1; p2++) &#123; //把点(x1,y1),(x2,y2)取出 x1 = nonzeroXIndices[p1]; y1 = nonzeroYIndices[p1]; x2 = nonzeroXIndices[p2]; y2 = nonzeroYIndices[p2]; //计算长半轴 dx = x1-x2; dy = y1-y2; a = 0.5*std::sqrt(dx*dx+dy*dy); //看第一个轴的最大值是否为-1，用于判断计算得到的a是否符合要求 bool bMaxFirst = (maxFirst == -1); if (maxFirst != -1) &#123; bMaxFirst = (a &lt;= maxFirst); &#125; //如果计算到的长半轴a符合要求（大于最小轴的值，并小于第一个轴最大值） if (a &gt; minAxis &amp;&amp; bMaxFirst) &#123; //计算中心点 x0 = 0.5*(x1+x2); y0 = 0.5*(y1+y2); //对非零点对，遍历所有非零的点计算短半轴 for (p = 0; p &lt; numPixels; p++) &#123; //取出假设的位于椭圆上的点 x = nonzeroXIndices[p]; y = nonzeroYIndices[p]; dx = x-x0; dy = y-y0; //计算此点到中心点的距离d d = std::sqrt(dx*dx+dy*dy); //如果此距离大于最小轴的值，则认为此点有可能为椭圆上的点 if (d &gt; minAxis) &#123; dx = x-x2; dy = y-y2; //计算f的值的平方 fSquared = dx*dx+dy*dy; //计算cosTau cosTauSquared = (a*a+d*d-fSquared) / (2*a*d); //再计算cosTau的平方 cosTauSquared *= cosTauSquared; //计算b平方的分母 k = a*a-d*d*cosTauSquared; //让b要在合理的条件内 if (k &gt; 0 &amp;&amp; cosTauSquared &lt; 1) &#123; //计算b的平方 bSquared = a*a*d*d*(1-cosTauSquared) / k; //计算到的b的平方要小于最大轴的值的平方 if (bSquared &lt;= maxAxisSquared) &#123; //把符合要求的短半轴的平方值放入累加器列表中 accumulator.push_back(bSquared); &#125; &#125; &#125; &#125; //对非零点对计算完所有短半轴b，看符合要求的值有没有，即累加器列表里是否有值 if (accumulator.size() &gt; 0) &#123; //有值，则说明有可能有相应的短半轴与这一对非零点组成的长轴构成一个椭圆 std::vector&lt;double&gt; bins; //下面是对累加器列表中的短半轴平方的数据进行处理，看能不能找到合适的短半轴， //首先是利用精度来创建格子 bins = _create_bins(accumulator, binSize); std::vector&lt;int&gt; hist; //然后按创建的格子计算累计器列表的直方图 hist = _histogram(accumulator, bins); //把直方图计数数据中的最大值找出来 std::vector&lt;int&gt;::iterator histMaxIter = std::max_element(hist.begin(), hist.end()); int histMax = *histMaxIter; //如果这个最大计数达到了要求的阈值，则说明这个短半轴的计算是可以构成一个椭圆的 if (histMax &gt; threshold) &#123; //计算倾斜角度 alpha = std::atan2(y2-y1, x2-x1); //把直方图最大值对应的格子索引计算出来 int maxIndex = histMaxIter - hist.begin(); //短半轴的值即为最大直方图计数值对应的格子的值的开方 b = std::sqrt(bins[maxIndex]); if (alpha != 0) &#123; //在OpenCV中，y轴是向下的，把角度改一下（其实问题不大) alpha = CV_PI - alpha; &#125; //最后保证计算得到的长半轴和短半轴都大于0，则认为确定了一个椭圆 if (a &gt; 0 &amp;&amp; b &gt; 0) &#123; //把确定的椭圆保存 Ellipse ellipse; ellipse.accumulator = histMax; ellipse.xc = x0; ellipse.yc = y0; ellipse.a = a; ellipse.b = b; ellipse.angle = alpha * 180 / CV_PI; results.push_back(ellipse); &#125; &#125; //累加器清零再进行下一对非零点 accumulator.clear(); &#125; &#125; &#125; &#125; return results;&#125;//直接上函数，传进来源图像的高、宽、轮廓线的点，阈值，然后输出就是椭圆的参数 static bool _hough_ellipse2(int numRows, int numCols, const std::vector&lt;cv::Point&gt;&amp; contour, double threshold, cv::Point&amp; center, float&amp; a, float&amp; b, float&amp; theta) &#123; //定义最大距离的图，即源图上每个点到轮廓线（这个轮廓线是先被假定是一个椭圆）的最大距离的图 cv::Mat maxDists(numRows, numCols, CV_32FC1, cv::Scalar::all(0)); //任一点到轮廓线所有点的距离列表 std::vector&lt;float&gt; dists(contour.size()); //图像上每一个点到轮廓线上的点的距离计算 for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j &lt; numCols; j++) &#123; for (int k = 0; k &lt; contour.size(); k++) &#123; //计算图像上的点到轮廓线上的点的距离，并放入列表中 float dx = j-contour[k].x; float dy = i-contour[k].y; float dist = std::sqrt(dx*dx+dy*dy); dists[k] = dist; &#125; //从距离列表中找出最大的那个距离 std::vector&lt;float&gt;::iterator iter = std::max_element(dists.begin(), dists.end()); float maxDist = *iter; //把这个最大距离放到图中相应位置 maxDists.ptr&lt;float&gt;(i)[j] = maxDist; &#125; &#125; //有了最大距离的图，找到这个最大距离图中最小的那个距离，及这个最小距离所在的位置 double minVal; cv::Point minLoc; cv::minMaxLoc(maxDists, &amp;minVal, NULL, &amp;minLoc); //根据定理，最大距离中的最小那个对应椭圆的长半轴，而对应的位置就是椭圆中心 center = minLoc; a = (float)minVal; //接下来由短半轴和角度定义一个霍夫空间 cv::Mat houghSpace(std::floor(a+1), 180, CV_32SC1, cv::Scalar::all(0)); //因为轮廓线被假定为椭圆了，所以把轮廓线上的点，再加上离散的角度，带入椭圆公式计算短半轴 for (int i = 0; i &lt; contour.size(); i++) &#123; for (int j = 0; j &lt; 180; j++) &#123; //角度转为弧度 double angle = j*CV_PI/180; //中心点，前面已经确认 double p = center.x; double q = center.y; //轮廓上的点 double x = contour[i].x; double y = contour[i].y; //计算sin，cos double cosTheta = std::cos(angle); double sinTheta = std::sin(angle); //公式中加号左边那一项 double part1 = std::pow((x-p)*cosTheta+(y-q)*sinTheta, 2) / (a*a); //加号右边那一项的分子 double part2 = std::pow(-(x-p)*sinTheta+(y-q)*cosTheta, 2); //计算短半轴，要取到整数，所以用了floor这个函数，先进行了加1 int B = std::floor(std::sqrt(part2 / (1-part1)) + 1); //计算得到的短半轴大于0，且不大于长半轴，则霍夫空间对应短半轴和角度位置计算加1 if (B &gt; 0 &amp;&amp; B &lt;= a) &#123; houghSpace.ptr&lt;int&gt;(B)[j] += 1; &#125; &#125; &#125; //得到霍夫空间的累加计数，下面把累加计数的最大值找出来 double maxVal; cv::Point maxLoc; cv::minMaxLoc(houghSpace, NULL, &amp;maxVal, NULL, &amp;maxLoc); //如果最大计数大于给定的阈值，则说明这条轮廓线有成为椭圆的潜质 if (maxVal &gt;= threshold) &#123; //短半轴就是最大计数对应位置的y，角度就是x b = maxLoc.y; theta = maxLoc.x; //最后确保长短半轴都是大于1的，这才说明成功确认一条轮廓线为一个椭圆 return (a &gt; 1 &amp;&amp; b &gt; 1); &#125; return false;&#125;int main(int argc, char **argv) &#123; /* //测试代码，读入一张图片 cv::Mat src = cv::imread(&quot;/home/xlll/Downloads/opencv/samples/data/pic3.png&quot;, cv::IMREAD_COLOR); if (src.empty()) &#123; std::cout &lt;&lt; &quot;failed to read image!&quot; &lt;&lt; std::endl; return EXIT_FAILURE; &#125; //转为灰度图 cv::Mat gray; cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY); //高斯平滑去一下噪声 cv::Mat gb; cv::GaussianBlur(gray, gb, cv::Size(7, 7), 2, 2); int kernelSize = 3; //使用Canny算法检测这张图的边缘图 double cannyThresh = 100; cv::Mat edges, dx, dy; cv::Sobel(gb, dx, CV_16SC1, 1, 0, kernelSize, 1, 0, cv::BORDER_REPLICATE); cv::Sobel(gb, dy, CV_16SC1, 0, 1, kernelSize, 1, 0, cv::BORDER_REPLICATE); cv::Canny(dx, dy, edges, cannyThresh/2, cannyThresh, false); //用于霍夫椭圆检测的参数，这个算法的参数不好调，这几个参数是根据这张图调好的值 int threshold = 135; double accuracy = 15; int minAxis = 30; int maxFirst = 48; int maxAxis = 58; //调用算法，返回检测到的椭圆 std::vector&lt;Ellipse&gt; ellipses; ellipses = _hough_ellipse(edges, threshold, accuracy, minAxis, maxAxis, maxFirst); //看检测到几个 std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; ellipses.size() &lt;&lt; &quot; ellipses.&quot; &lt;&lt; std::endl; //原图克隆一份，用于画椭圆 cv::Mat dst = src.clone(); //把所有检测到的椭圆画到图上，并把椭圆相关参数打印出来 for (int i = 0; i &lt; ellipses.size(); i++) &#123; Ellipse ellipse = ellipses[i]; cv::ellipse(dst, cv::Point(cvRound(ellipse.xc), cvRound(ellipse.yc)), cv::Size(cvRound(ellipse.a), cvRound(ellipse.b)), ellipse.angle, 0, 360, cv::Scalar(255, 0, 255), 2, cv::LINE_AA); std::cout &lt;&lt; &quot;Ellipse &quot; &lt;&lt; i &lt;&lt; &quot;: xc = &quot; &lt;&lt; cvRound(ellipse.xc) &lt;&lt; &quot;, yc = &quot; &lt;&lt; cvRound(ellipse.yc) &lt;&lt; &quot;, a = &quot; &lt;&lt; cvRound(ellipse.a) &lt;&lt; &quot;, b = &quot; &lt;&lt; cvRound(ellipse.b) &lt;&lt; &quot;, angle = &quot; &lt;&lt; ellipse.angle &lt;&lt; &quot;, accumulator = &quot; &lt;&lt; ellipse.accumulator &lt;&lt; std::endl; &#125; //显示图像 cv::imshow(&quot;src&quot;, src); cv::imshow(&quot;edges&quot;, edges); cv::imshow(&quot;dst&quot;, dst); cv::waitKey(0);*/ //测试代码，读入一张图片 cv::Mat src = cv::imread(&quot;/home/xlll/Downloads/opencv/samples/data/detect_blob.png&quot;, cv::IMREAD_COLOR); if (src.empty()) &#123; std::cout &lt;&lt; &quot;failed to read image!&quot; &lt;&lt; std::endl; return EXIT_FAILURE; &#125; //转为灰度图 cv::Mat gray; cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY); cv::Mat gb; //高斯平滑一下 cv::GaussianBlur(gray, gb, cv::Size(3, 3), 2, 2); //使用Canny算法检测这张图的边缘图 int kernelSize = 3; double cannyThresh = 35; cv::Mat edges, dx, dy; cv::Sobel(gb, dx, CV_16SC1, 1, 0, kernelSize, 1, 0, cv::BORDER_REPLICATE); cv::Sobel(gb, dy, CV_16SC1, 0, 1, kernelSize, 1, 0, cv::BORDER_REPLICATE); cv::Canny(dx, dy, edges, cannyThresh/2, cannyThresh, false); //查找边缘图的轮廓线 std::vector&lt;std::vector&lt;cv::Point&gt;&gt; contours; cv::findContours(edges, contours, cv::RETR_LIST, cv::CHAIN_APPROX_NONE); //克隆图片用于输出 cv::Mat dst = src.clone(); for (int i = 0; i &lt; contours.size(); i++) &#123; float a, b, theta; cv::Point center; //阈值定义，可根据实际情况更改 double threshold = contours[i].size() * 0.33; //如果成功检测为椭圆，把椭圆画出来，并输出椭圆相应的参数 if (_hough_ellipse2(dst.rows, dst.cols, contours[i], threshold, center, a, b, theta)) &#123; cv::ellipse(dst, cv::Point(center.x, center.y), cv::Size(cvRound(a), cvRound(b)), theta, 0, 360, cv::Scalar(255, 0, 255), 2, cv::LINE_AA); std::cout &lt;&lt; &quot;center = (&quot; &lt;&lt; center.x &lt;&lt; &quot;, &quot; &lt;&lt; center.y &lt;&lt; &quot;), a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; &quot;, theta = &quot; &lt;&lt; theta &lt;&lt; std::endl; &#125; &#125; //显示相应的图像 cv::imshow(&quot;src&quot;, src); cv::imshow(&quot;edges&quot;, edges); cv::imshow(&quot;dst&quot;, dst); cv::waitKey(0); return 0;&#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"算法基础","slug":"刷题/算法基础","date":"2022-06-29T14:58:27.560Z","updated":"2022-06-29T14:59:56.905Z","comments":true,"path":"2022/06/29/刷题/算法基础/","link":"","permalink":"https://zhang0224gz.github.io/2022/06/29/%E5%88%B7%E9%A2%98/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"算法基础 递归和递推 递归 1递归算法在计算机系统中用栈帮助实现，一般常见的算法有深度优先遍历（DFS），可以解决的问题有迷宫问题是否连通的问题，递推会对应一个递归搜索树，递归搜索树可以帮助我们更好的理解递归的流程，递归要注意的有是否可以进行剪枝，在迷宫问题中，也要考虑是否要保存原有的迷宫。 入门例题 递归实现指数型枚举 123456789101112131415161718192021222324252627从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。输入格式输入一个整数 n。输出格式每行输出一种方案。同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。对于没有选任何数的方案，输出空行。本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。数据范围1≤n≤15输入样例：3输出样例：322 311 31 21 2 3 题解： 对于指数型枚举一个数只有选与不选的区分，所以我们从第一个位置，枚举到第n个位置，在第i个位置上，i这个数只有选与不选的区别，选的话我们将st[i]记录为i；不选记录为-1；一直到u&gt;n时枚举了所有的位置，此时输出即可，要注意的是在输出完后要记得return掉 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=20;int n;int st[N];void dfs(int u)&#123; if(u&gt;n)&#123; for(int i=1;i&lt;=n;i++)&#123; if(st[i]==1) cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return ; &#125; st[u]=1; dfs(u+1); st[u]=-1; dfs(u+1);&#125;int main()&#123; cin&gt;&gt;n; dfs(1); return 0;&#125; 递归实现排列型枚举 1234567891011121314151617181920212223把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。输入格式一个整数 n。输出格式按照从小到大的顺序输出所有方案，每行 1 个。首先，同一行相邻两个数用一个空格隔开。其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。数据范围1≤n≤9输入样例：3输出样例：1 2 31 3 22 1 32 3 13 1 23 2 1 题解 在排列型枚举中，我们有n个位置，在每个位置上分别枚举这个位置可以放那个数，所以我们有一个path数组来记录排列的方案，使用st的bool数组来判断这个数是否选过。 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=15;int n;bool st[N];int path[N];void dfs(int u)&#123; if(u&gt;n)&#123;//所有位置枚举完成 for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return ; &#125; for(int i=1;i&lt;=n;i++)&#123;//在第u个位置上枚举所有方案，这个位置上可以放置所有没有被用过的数字。 if(!st[i])&#123; path[u]=i; st[i]=true;//表示这个数被用过了 dfs(u+1); st[i]=false;//还原状态，保证回溯时下一层递归一致。 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(1); return 0;&#125; 递归实现组合型枚举 1234567891011121314151617181920212223242526272829从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。输入格式两个整数 n,m ,在同一行用空格隔开。输出格式按照从小到大的顺序输出所有方案，每行 1 个。首先，同一行内的数升序排列，相邻两个数用一个空格隔开。其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 1 3 5 7 排在 1 3 6 8 前面）。数据范围n&gt;0 ,0≤m≤n ,n+(n−m)≤25输入样例：5 3输出样例：1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 题解 在组合数枚举中，我们可以通过认为确定枚举的顺序来通过类似排列数的方法来实现，不同的一点时在排列数枚举时，我们要在传一个参数num表示前一位枚举到那个数字，首先写一个朴素方法，该方法的时间是1601ms 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=25;int n,m;int path[N];bool st[N];void dfs(int u,int num)&#123; if(u&gt;m)&#123; for(int i=1;i&lt;=m;i++)&#123; cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!st[i]&amp;&amp;i&gt;num)&#123; st[i]=true; path[u]=i; dfs(u+1,i); st[i]=false; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,0); return 0;&#125; 下面做一个优化 我们在递归前提前判断一个，上一个位置的数是否合理，如果后面剩的数字不能满足m个位置和递增的条件就直接return掉，进行剪枝，优化时间复杂度。该方法的时间是103ms 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=25;int n,m;int path[N];bool st[N];void dfs(int u,int num)&#123; if(num&gt;n-m+u-1)return; if(u&gt;m)&#123; for(int i=1;i&lt;=m;i++)&#123; cout&lt;&lt;path[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!st[i]&amp;&amp;i&gt;num)&#123; st[i]=true; path[u]=i; dfs(u+1,i); st[i]=false; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,0); return 0;&#125; 迷宫问题 通过深度优先搜索（DFS）方法实现。 迷宫问题一 12345678910111213141516171819202122232425262728293031一天蒜头君掉进了一个迷宫里面，蒜头君想逃出去，可怜的蒜头君连迷宫是否有能逃出去的路都不知道。看在蒜头君这么可怜的份上，就请聪明的你告诉蒜头君是否有可以逃出去的路。输入格式第一行输入两个整数 nn 和 mm，表示这是一个 n \\times mn×m 的迷宫。接下来的输入一个 nn 行 mm 列的迷宫。其中 &#x27;S&#x27; 表示蒜头君的位置，&#x27;*&#x27;表示墙，蒜头君无法通过，&#x27;.&#x27;表示路，蒜头君可以通过&#x27;.&#x27;移动，&#x27;T&#x27;表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。输出格式输出一个字符串，如果蒜头君可以逃出迷宫输出&quot;yes&quot;，否则输出&quot;no&quot;。数据范围1 \\le n, m \\le 101≤n,m≤10。输出时每行末尾的多余空格，不影响答案正确性样例输入1复制3 4S**...*.***T样例输出1复制no样例输入2复制3 4S**.....***T样例输出2复制yes 题解 我们读入所有数据，然后获得起点S的坐标。然后深度优先遍历，在迷宫问题中进入DFS后，要先判断是否到中点，在判断是否是障碍物，然后标记该点访问过了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=15;int n,m;char g[N][N];int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;bool st[N][N];bool dfs(int x,int y)&#123; if(g[x][y]==&#x27;T&#x27;)&#123; return true; &#125; if(g[x][y]==&#x27;*&#x27;) return false; st[x][y]=true; for(int i=0;i&lt;4;i++)&#123; int a=x+dx[i],b=y+dy[i]; if(a&gt;n||a&lt;=0||b&lt;=0||b&gt;m)continue; if(st[a][b])continue; if(dfs(a,b))&#123; return true; &#125; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int x,y; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;g[i][j]; if(g[i][j]==&#x27;S&#x27;)&#123; x=i; y=j; &#125; &#125; &#125; if(dfs(x,y))&#123; cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; &#125; return 0;&#125; 迷宫问题二 1234567891011121314151617181920212223242526272829蒜头君在你的帮助下终于逃出了迷宫，但是蒜头君并没有沉浸于喜悦之中，而是很快的又陷入了思考，从这个迷宫逃出的最少步数是多少呢？输入格式第一行输入两个整数 nn 和 mm，表示这是一个 n \\times mn×m 的迷宫。接下来的输入一个 nn 行 mm 列的迷宫。其中 &#x27;S&#x27; 表示蒜头君的位置，&#x27;*&#x27;表示墙，蒜头君无法通过，&#x27;.&#x27;表示路，蒜头君可以通过&#x27;.&#x27;移动，&#x27;T&#x27;表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。输出格式输出整数，表示蒜头君逃出迷宫的最少步数，如果蒜头君无法逃出迷宫输出 -1−1。数据范围1 \\le n, m \\le 101≤n,m≤10。输出时每行末尾的多余空格，不影响答案正确性样例输入1复制3 4S**...*.***T样例输出1复制-1样例输入2复制3 4S**.....***T样例输出2复制5 题解 本题要求判断是否可以到达并且要计算出最短路径，其实用宽度优先搜索更为合适，因为宽度优先搜索第一次到达目的地就是最短路径，但是我们使用深度优先也可以实现，我们定义一个最短量来储存最短的路径，当每一次到达目的点就比较一下与最短路的大小，交换最短路径长度，因此我们要遍历所有的可行路径，所以就要回溯访问状态，所以在一个遍历后就要复原，将一个点置为未访问，额额额，在 这道题中，我开始忘了读入n和m所以出现了segment段错误，还检查了好久没查到。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=15;char g[N][N];bool st[N][N];int Min=99999;int m,n;int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;void dfs(int x,int y,int stmp)&#123; if(stmp&gt;Min) return ; if(g[x][y]==&#x27;T&#x27;)&#123; Min=min(Min,stmp); return; &#125; st[x][y]=true; if(g[x][y]==&#x27;*&#x27;) return ; for(int i=0;i&lt;4;i++)&#123; int a=x+dx[i],b=y+dy[i]; if(a&gt;n||a&lt;=0||b&gt;m||b&lt;=0) continue; if(st[a][b]) continue; if(g[a][b]==&#x27;*&#x27;) continue; dfs(a,b,stmp+1); st[a][b]=false; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int a,b; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;g[i][j]; if(g[i][j]==&#x27;S&#x27;)&#123; a=i,b=j; &#125; &#125; &#125; dfs(a,b,0); if(Min==99999)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;Min&lt;&lt;endl; &#125; return 0;&#125; 迷宫问题三 123456789101112131415161718192021222324252627282930313233343536373839经过思考蒜头君终于解决了怎么计算一个迷宫的最短路问题，于是蒜头君找到一个新的迷宫图，来验证自己是否真的会计算一个迷宫的最短路。为了检验自己计算的是否正确，蒜头君特邀你一起来计算。输入格式第一行输入两个整数 nn 和 mm，表示这是一个 n \\times mn×m 的迷宫。接下来的输入一个 nn 行 mm 列的迷宫。其中&#x27;@&#x27;表示蒜头君的位置，&#x27;#&#x27;表示墙，蒜头君无法通过，&#x27;.&#x27;表示路，蒜头君可以通过&#x27;.&#x27;移动，所有在迷宫最外围的&#x27;.&#x27;都表示迷宫的出口（蒜头君每次只能移动到四个与他相邻的位置——上，下，左，右）。输出格式输出整数，表示蒜头君逃出迷宫的最少步数，如果蒜头君无法逃出迷宫输出 -1−1。数据范围1 \\le n,m \\le 151≤n,m≤15。输出时每行末尾的多余空格，不影响答案正确性样例输入1复制9 13##############@..........######.#.#.#.##...........##.#.#.#.#.#.##.#.......#.##.#.#.#.#.#.##...........######.#######样例输出1复制11样例输入2复制4 6#.#####.#.###...@#######样例输出2复制5 题解 该迷宫问题与第二个迷宫问题类似，我们也要求出最短路径，所以一样要使用minn记录短的路径。 但是这个题要注意到达的条件，和第二个迷宫终点判断不一样，这个题要观察迷宫的构造，判断终止条件。所以这道题尽量从1开始存储迷宫图。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=20;int n,m;int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;char g[N][N];bool st[N][N];int minn=99999;void dfs(int x,int y,int stmp)&#123; if(stmp&gt;minn)return ; if(x==0||y==0||x==n+1||y==m+1)&#123; minn=min(minn,stmp); return ; &#125; st[x][y]=true; for(int i=0;i&lt;4;i++)&#123; int a=x+dx[i],b=y+dy[i]; if(g[a][b]==&#x27;#&#x27;)continue; if(st[a][b])continue; dfs(a,b,stmp+1); st[a][b]=false; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int x,y; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;g[i][j]; if(g[i][j]==&#x27;@&#x27;)&#123; x=i;y=j; &#125; &#125; &#125; dfs(x,y,0); if(minn==99999)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;minn-1&lt;&lt;endl; &#125; return 0;&#125; 好了，dfs递归就先写到这里，之后图论的时候我们在聊。 递推 入门例题 斐波那契数列 12345678910输入一个整数 n ，求斐波那契数列的第 n 项。假定从 0 开始，第 0 项为 0。数据范围0≤n≤39样例输入整数 n=5 返回 5 题解 该题十分基础，我们要理解斐波那契数列的组成，数列中从每一项都是前两项的和，所以如果不要求存下一些数的数值，我们就可以直接使用，几个变量操作不用进行数组创建。 123456789101112131415class Solution &#123;public: int Fibonacci(int n) &#123; if(n&lt;=1)return n; if(n==2) return 1; int a=1,b=1; int t; for(int i=3;i&lt;=n;i++)&#123; t=a+b; a=b; b=t; &#125; return t; &#125;&#125;; 费解的开关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475你玩过“拉灯”游戏吗？25 盏灯排成一个 5×5 的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。下面这种状态1011101101101111000011011在改变了最左上角的灯的状态后将变成：0111111101101111000011011再改变它正中间的灯后状态将变成：0111111001110011010011011给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。输入格式第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。输出格式一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。数据范围0&lt;n≤500输入样例：3001110101110001110101110011101111011111011111111110111111111111111111111111输出样例：32-1 题解 该题我们分析可以发现，我们可以通过枚举第一行的5个灯的32中开与不开的状态来实现，因为第一行开关确定以后，第一行的开关亮与不亮只与下一层开关有关，如果i-1行j列是关的，我们就开一下i行j列的灯就可以使上一个灯泡开，一次递推我们就可以实现是否所有灯都能开，要注意的是我们要保存一下开始的灯泡状态，因为要枚举32次，积累一下位运算&gt;&gt; 我们可以通过op&gt;&gt;i&amp;1表示第一行的灯是否开，这是通过二进制存储实现的，我们用0表示不开，用1表示开。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=510;char g[6][6],backup[6][6];int dx[6]=&#123;-1,0,1,0,0&#125;,dy[6]=&#123;0,1,0,-1,0&#125;;int n;void turn(int x,int y)&#123; for(int i=0;i&lt;5;i++)&#123; int a=x+dx[i],b=y+dy[i]; if(a&lt;0||a&gt;=5||b&lt;0||b&gt;=5)continue; g[a][b]^=1; &#125;&#125;int main()&#123; cin&gt;&gt;n; while(n--)&#123; for(int i=0;i&lt;5;i++)cin&gt;&gt;g[i]; int ans=10; for(int op=0;op&lt;32;op++)&#123; memcpy(backup,g,sizeof g); int stmp=0; for(int i=0;i&lt;5;i++)&#123; if(op&gt;&gt;i&amp;1)&#123; turn(0,i); stmp++; &#125; &#125; for(int i=1;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; if(g[i-1][j]==&#x27;0&#x27;)&#123; turn(i,j); stmp++; &#125; &#125; &#125; bool suf=true; for(int j=0;j&lt;5;j++)&#123; if(g[4][j]==&#x27;0&#x27;)&#123; suf=false; break; &#125; &#125; if(suf)&#123; ans=min(ans,stmp); &#125; memcpy(g,backup,sizeof backup); &#125; if(ans&gt;6)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125; 二分和前缀和 二分 二分简介 123456789二分分为整数二分和实数二分两种，#### 整数二分步骤：1. 找一个区间[L, R]，使得答案一定在该区间中2. 找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点。3. 分析中点M在该判断条件下是否成立，如果 （成立，考虑答案在那个区间。如果不成立，考虑答案在那个区间）4. 如果更新方式写的是R = Mid，则此时l=mid+1，这是mid更新方式是 如果更新方式是l=mid;则mid=l+r+1&gt;&gt;1;c此时r=mid-1； 入门例题 二分查找一 12345678910111213141516171819202122232425262728293031323334蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问整数 xx 是否在数组 AA 中。输入格式第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。接下来一行有 nn 个整数 a_ia i​ 。接下来 mm 行，每行有 11 个整数 xx，表示蒜头君询问的整数。输出格式对于每次查询，如果可以找到，输出&quot;YES&quot;，否则输出&quot;NO&quot;。数据范围1≤n,m≤1e5 0≤x≤1e6输出时每行末尾的多余空格，不影响答案正确性样例输入复制10 51 1 1 2 3 5 5 7 8 9014910样例输出复制NOYESNOYESNO 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e5+10;int num[N];int n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)cin&gt;&gt;num[i]; sort(num,num+n); while(m--)&#123; int t; cin&gt;&gt;t; int l=0,r=n-1; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(num[mid]&gt;=t)&#123; r=mid; &#125;else&#123; l=mid+1; &#125; &#125; if(num[l]!=t)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125; 二分查找二 123456789101112131415161718192021222324252627282930313233343536蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问在数组 AA 中，大于等于 xx 的最小值是多大？输入格式第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。接下来一行有 nn 个整数 a_ia i​ 。接下来 mm 行，每行有 11 个整数 xx，表示蒜头君询问的整数。输出格式对于每次查询，如果可以找到，输出这个整数。否则输出 -1。数据范围1≤n,m≤1e5 0≤x≤1e6输出时每行末尾的多余空格，不影响答案正确性样例输入复制10 51 1 1 2 3 5 5 7 8 9014910样例输出复制1159-1 题解 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e6+10;int n,m;int num[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)cin&gt;&gt;num[i]; sort(num,num+n); while(m--)&#123; int t; cin&gt;&gt;t; int l=0,r=n-1; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(num[mid]&gt;=t)&#123; r=mid; &#125;else&#123; l=mid+1; &#125; &#125; if(num[l]&gt;=t)&#123; cout&lt;&lt;num[l]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; &#125; return 0;&#125; 二分查找三 123456789101112131415161718192021222324252627282930313233343536蒜头君手上有个长度为 nn 的数组 AA。由于数组实在太大了，所以蒜头君也不知道数组里面有什么数字，所以蒜头君会经常询问在数组 AA 中，比 xx 大的最小值是多大？但是这次蒜头君要求这个数字必须大于 xx，不能等于 xx。输入格式第一行输入两个整数 nn 和 mm，分别表示数组的长度和查询的次数。接下来一行有 nn 个整数 a_ia i​ 。接下来 mm 行，每行有 11 个整数 xx，表示蒜头君询问的整数。输出格式对于每次查询，如果可以找到，输出这个整数。否则输出 -1−1。数据范围1≤n,m≤1e5 0≤x≤1e6输出时每行末尾的多余空格，不影响答案正确性样例输入复制10 51 1 1 2 3 5 5 7 8 9014910样例输出复制125-1-1 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e6+10;int n,m;int num[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)cin&gt;&gt;num[i]; sort(num,num+n); while(m--)&#123; int t; cin&gt;&gt;t; int l=0,r=n-1; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(num[mid]&gt;t)&#123; r=mid; &#125;else&#123; l=mid+1; &#125; &#125; if(num[l]&gt;t)&#123; cout&lt;&lt;num[l]&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; &#125; return 0;&#125; 搜索与图论 深度优先搜索（DFS） 宽度优先搜索（BFS） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt; PII;const int N=210;char g[N][N];int dis[N][N];int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;int n,m;int T;int bfs(PII start)&#123; queue&lt;PII&gt; q; memset(dis,-1,sizeof dis); dis[start.x][start.y]=0; q.push(start); while(!q.empty())&#123; PII t=q.front(); q.pop(); for(int i=0;i&lt;4;i++)&#123; int a=t.x+dx[i],b=t.y+dy[i]; if(a&gt;=n||a&lt;0||b&gt;=m||b&lt;0)continue; if(g[a][b]==&#x27;#&#x27;)continue; if(dis[a][b]!=-1)continue; if(g[a][b]==&#x27;E&#x27;)return dis[t.x][t.y]+1; q.push(&#123;a,b&#125;); dis[a][b]=dis[t.x][t.y]+1; &#125; &#125; return -1;&#125;int main()&#123; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;m; PII start; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;g[i][j]; if(g[i][j]==&#x27;S&#x27;)&#123; start=&#123;i,j&#125;; &#125; &#125; &#125; // cout&lt;&lt;start.x&lt;&lt;start.y&lt;&lt;endl; int distence=bfs(start); if(distence==-1)&#123; cout&lt;&lt;&quot;oop!&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;distence&lt;&lt;endl; &#125; &#125; return 0;&#125; 求最短路径 单源最短路 所有边权都是正数 朴素Dijkstra算法（稠密图） ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=510;int n,m;int g[N][N];int dist[N];bool st[N];int dijkstra()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; for(int i=0;i&lt;n;i++)&#123; int t=-1; for(int j=1;j&lt;=n;j++)&#123; if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))&#123; t=j; &#125; &#125; st[t]=true; for(int j=1;j&lt;=n;j++)&#123; dist[j]=min(dist[j],dist[t]+g[t][j]); &#125; &#125; if(dist[n]==0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(g,0x3f,sizeof g); while(m--)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; g[a][b]=min(g[a][b],c); &#125; int t=dijkstra(); cout&lt;&lt;t&lt;&lt;endl; return 0;&#125; 堆优化Dijkstra算法（稀疏图） 存在负权边 bellman-ford算法 12345678910111213141516171819202122232425262728给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。注意：图中可能 存在负权回路 。输入格式第一行包含三个整数 n,m,k。接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。输出格式输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。如果不存在满足条件的路径，则输出 impossible。数据范围1≤n,k≤500,1≤m≤10000,任意边长的绝对值不超过 10000。输入样例：3 3 11 2 12 3 11 3 3输出样例：3 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=510,M=1e4+10;int n,m,k;int dist[N],backup[N];struct Edge&#123; int a,b,c;&#125;edges[M];void bellman_ford()&#123; memset(dist,0x3f,sizeof dist); dist[1]=0; for(int i=0;i&lt;k;i++)&#123; memcpy(backup,dist,sizeof dist); for(int j=0;j&lt;m;j++)&#123; auto e=edges[j]; dist[e.b]=min(dist[e.b],backup[e.a]+e.c); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;m;i++)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; edges[i]=&#123;a,b,c&#125;; &#125; bellman_ford(); if(dist[n]&gt;0x3f3f3f/2)cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;dist[n]&lt;&lt;endl; return 0;&#125; 多源汇最短路 数学 数论 试除法求质数 12345678bool is_prime(int x)&#123; if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) return false; return true;&#125; 分解质因数 123456789101112131415161718192021222324251、题目：给定n个正整数ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。输入格式第一行包含整数n。接下来n行，每行包含一个正整数ai。输出格式对于每个正整数ai,按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。每个正整数的质因数全部输出完毕后，输出一个空行。数据范围1≤n≤100,1≤ai≤2∗109输入样例：268输出样例：2 13 12 3 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void divide(int x)&#123; for(int i=2;i&lt;=x/i;i++)&#123; if(x%i==0)&#123; int cnt=0; while(x%i==0)&#123; x/=i; cnt++; &#125; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; if(x&gt;1)cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;1&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--)&#123; int x; cin&gt;&gt;x; divide(x); cout&lt;&lt;endl; &#125; return 0;&#125; 筛质数 123456789101112131415给定一个正整数 n，请你求出 1∼n1∼n 中质数的个数。输入格式共一行，包含整数 n。输出格式共一行，包含一个整数，表示 1∼n1∼n 中质数的个数。数据范围1≤n≤1061≤n≤106输入样例： 欧式筛法 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=100010;int prime[N],cnt;int n;bool st[N];void get_prime(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!st[i])&#123; prime[cnt++]=i; for(int j=i+i;j&lt;=n;j+=i)&#123; st[j]=true; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; get_prime(n); cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 线性筛法 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N= 1000010;int primes[N], cnt;bool st[N];void get_primes(int n)&#123; for (int i = 2; i &lt;= n; i ++ ) &#123; if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) &#123; st[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 试除法求约数 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;void get_divisors(int n)&#123; vector&lt;int&gt;divs; for(int i=1;i&lt;=n/i;i++)&#123; if(n%i==0)&#123; divs.push_back(i); if(i*i!=n)divs.push_back(n/i); &#125; &#125; sort(divs.begin(),divs.end()); for(auto s:divs)&#123; cout&lt;&lt;s&lt;&lt;endl; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; get_divisors(n); return 0;&#125; 求约数个数 利用算法基本定理，先分解质因数，然后约数个数就是每个质因数的指数+1的乘积。 1234当然还有更简单的方法，考虑下我们小时候学过的分解质因数的知识。360=2*2*2*3*3*5=2^3+3^2+5那么360的约数只能为2^a*3^b*5^c2（a的范围(0-3),b的范围(0-2),c的范围(0-1)），因此360的约数有4*3*2=24个。具体实现方法： 该题求解了100的阶乘的约数的个数。其中使用的哈希map也可以换成简单的map 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;unoredered_map&gt;using namespace std;int main()&#123; map&lt;int,int&gt; mp; for(int j=2;j&lt;=100;j++)&#123; int n=j; for(int i=2;i&lt;=n/i;i++)&#123; if(n%i==0)&#123; while(n%i==0)&#123; n/=i; mp[i]++; &#125; &#125; &#125; if(n&gt;1)mp[n]++; &#125; for(auto x:mp)&#123; cout&lt;&lt;x.first&lt;&lt;&quot; &quot;&lt;&lt;x.second+1&lt;&lt;endl; &#125; long long res=1; for(auto x:mp)&#123; res*=(x.second+1); &#125; cout&lt;&lt;res;&#125; 求约数的和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N = 110, mod = 1e9 + 7;int main()&#123; int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; primes; while (n -- ) &#123; int x; cin &gt;&gt; x; for (int i = 2; i &lt;= x / i; i ++ ) while (x % i == 0) &#123; x /= i; primes[i] ++ ; &#125; if (x &gt; 1) primes[x] ++ ; &#125; LL res = 1; for (auto p : primes) &#123; LL a = p.first, b = p.second; LL t = 1; while (b -- ) t = (t * a + 1) % mod; res = res * t % mod; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 求最大公约数 辗转相除法又叫欧几里得法 123int gcd(int a,int b)&#123; return b?gcd(b,a%b):a;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[]},{"title":"","slug":"笔记/数据库1","date":"2022-06-26T12:30:07.979Z","updated":"2022-06-26T12:30:07.979Z","comments":true,"path":"2022/06/26/笔记/数据库1/","link":"","permalink":"https://zhang0224gz.github.io/2022/06/26/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%931/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"The Art of Public Speaking","slug":"英语/演讲的艺术","date":"2022-06-17T11:26:13.995Z","updated":"2022-06-27T15:31:30.548Z","comments":true,"path":"2022/06/17/英语/演讲的艺术/","link":"","permalink":"https://zhang0224gz.github.io/2022/06/17/%E8%8B%B1%E8%AF%AD/%E6%BC%94%E8%AE%B2%E7%9A%84%E8%89%BA%E6%9C%AF/","excerpt":"","text":"U1 Speaking in Public 12345all walks of life 各行各业useful skills and strategies 有用的技能和策略multinational companies 跨国公司；跨国企业all-round language ability 全面的语言能力verbally 口头上地（而非书面地或行动上地）；用动词地；用言辞地 Practical Benefits： Enhance your confidence Get rid of stage fright 怯场 To be a good speaker How to deal with nervousness? Get prepared Change your thinking Face your fears Take up more assignments Trick your brain into believing Believe in yourself Get feedback Dealing with nervousness Acquire Speaking Experience Prepare, Prepare, Prepare Think Positively Use the power of Visualization Know That Most Nervousness Is Not Visible Don’t Expect Perfection What are the guidelines（指导方针，参考） for being ethical speakers? Make sure that the goals for your speech is ethically sound. Be fully prepared for each speech. Use information that is truthful or be honest in what you say. Put ethical principles into practice. Avoid biases and stereotypes or show respect for your audience. ​ (模式化的思想，老一套；公式化人物；铅版，铅版浇铸，铅版印刷；v. 对……形成刻板的看法，（尤指）对……有成见；使用铅版) Avoid name-calling(n. 骂人，中伤) and other forms of abusive language. Plagiarism and the Internet (抄袭与互联网) Global Plagiarism 全盘剽窃 Patchwork Plagiarism 拼贴剽窃 Incremental Plagiarism 局部剽窃 有两种方法可以避免局部剽窃。第一种方法是自己做调研笔记时要注意分清哪些是直接引语，哪些是复述的资料，哪些是自己的评论。第二种方法是多一些谨慎，再感到没有把握时，为稳妥起见，还是注明出处为好。 –Quotation 引用 使用引言时，一定要说明引言的出处。 –Paraphrases 改述 如果你没有直接引用某人的话，而是借鉴了某人的思路，并且使用了一部分原话，演讲者应该提供信息的来源。 U2 Warming-up Warming-up n. 准备活动；准备运动 Discussion Prepare arguments for speeches 为演讲准备论据 Work out for your voice 锻炼你的声音 123456SEE-l: Statement Elaboration(细化,加工) Example Illustration- ​ Friendship is one of life’s great blessings. 生命的伟大的祝福- ​ Friendship is the result of long-term alliances. 这是长期联盟的结果- ​ Friendship is the opposite of solitude. 孤独的反义词- ​ Friendship is priceless -- and it can also be ageless.(永恒的) I used to form friendships based on how much we had in common. I didn&#x27;t go so far as to check blood type or astrological sign检查血型或星座,but I certainlygravitated toward those who shared my tastes被和我 品味相同的人吸引 in music, food and fashion. Evaluate the quality of arguments 评估论据的质量 1.Clarity 清楚 — Is the argument understandable? Was the language easy to understand? ​ Was the speaker clear in their diction? ​ Was there any vagueness(n. 模糊；含糊；暧昧；茫然) or were there missing elements? 2.Accuracy 准确 — Is the information true and complete? Do the conclusions being drawn derive appropriately from the information available? 3.Precision 精确,严谨,细致 — Are there enough details to satisfy the specific requirements? Does the action have sufficient features presented to solve the problem? 4.Relevancy 关联,恰当 — Is the argument “on point”(适用,合时宜,合适)? In other words, does it relate to the other arguments being made? Can you see the links between the claims and the data? Does the argument match the organization being used? 5.Significance 意义 — How important is the argument? Are there any statistics to back up the claim(支持这一说法)? What value is being expressed? Are the values the same as those the audience holds? What will happen if we don’t take the advice in the speech?如果我们不接受演讲中的建议会发生什么? 6.Depth 深度 — When evaluating an issue, is there a need to understand other specifics within the issue? 7.Breadth 宽度 — When evaluating an issue, are there other areas of interest 其他感兴趣的领域necessary for understanding the complete picture全貌? 8.Logic 逻辑 — Does the argument make sense? 有意义；讲得通；言之有理 Do the conclusions come from the analysis and evidence provide? Do the arguments throughout the speech cohere(vi. 凝聚；连贯；粘着；一致) with each other? 整个演讲的论点彼此连贯吗? Is there consistency 一致性，连贯性? 9.Fairness 公平,公正 — Is an objective position being taken?是否采取了客观立场? Are there other points of view that need to be considered? Work out for your voice 锻炼你的声音 Avoid Lip-laziness Rule of Pronunciation Linking 发音连读规则 Learn to imitate ​ Speech Imitation 言语模仿 U3 Organizing the Speech How to make introductory speeches clearly? Don’t cover too much material; Organize speeches with topical order;按主题顺序组织演讲; Make sure each paragraph focuses on a single aspect of the topic. 确保每一段都专注于主题的一个方面 1234567Dear professors: Good afternoon. My name’s Wang Juan majoring in ideological and political. I’ll be finishing my undergraduate education in QUFU Normal University, located in the hometown of Confucius, and I’m looking forward to pursuing my master degree in your university. Just as my school’s motto “Never be contented with your study, never be impatient with your teaching” tells me, I have been trying to be an industrious student. With my hard working and my teachers’ guidance, I won the National Endeavor Scholarship, the Endeavor Scholarship of Shandong Province and the first scholarship of my school many times. At the same time, I participated in contest ten times and social practical activities six times and won a lot of wards and certificates. In addition, I have also finished a research project with my peers. These experiences really broaden my view on my future major. Moreover, I’m especially warm-hearted, participating in many activities held by our government. I worked as a volunteer for the Fifth Citizen Sports Meeting of Rizhao and the aid education in remote areas. From these activities, I enjoyed the happiness of making contributions to our society. What’s more, I have a wide range of interests. I have a passion for reading books, which broadens my horizon. I’m also attracted by listening to music and playing badminton. The major that I hope to pursue for my further education is ideological and political education as my major. My passionate interest in it can explain why I choose it as my major. I read many books related to my major such as the Communist Manifesto and Dialectics of Nature. With the qualified teachers and the great platform for doing researches, Southeast University has become my dream place for years. I firmly believe, led by the distinguished professors and scholars here, I will go further on ideological and political education. Thank you for your attention. How to be creative in developing your topic? mysterious,suspenseful,drama,adventure,danger 神秘、悬疑、戏剧、冒险、危险 clorful &amp; descriptive language 丰富多彩的描述性语言 witty remarks &amp; jokes 诙谐的评论和笑话 funny situations Or: sincere/enthusiastic Organizing the Speech Introduction To get the audience’s attention and interest, To create a dramatic or colorful opening, … pose a question; tell a story; make a startling statement; open with a quotation… 开头部分还应该引导听众对主题内容有一个初步的了解，要对主体部分的讨论要点给出明确清晰的预览陈述。 Body What are the most commonly used methods of organization? relate the events in a chronological order / in a topical order 把这些事件按时间顺序/主题顺序联系起来 Limit the number of main points!Don’t introduce irrelevant information.Make your main points stand out by introducing each with a transition statement. 限制要点的数量!不要介绍无关的信息。用一个过渡语句来介绍你的主要观点，使其脱颖而出。 Conclusion Let the audience know you are about to finish. Reinforce your major theme. 强化你的主题。 End on a dramatic, clever, or thought-provoking note.以一个戏剧性的，聪明的，或发人深省的笔记结束。 Delivering your speech 演讲呈现技巧 Speak extemporaneously 即兴演讲 Rehearsing the speech 排练演讲 Presenting the speech 展示演讲 U4 Selecting a Topic Selecting a Topic Topic: the subject of a speech 演讲的主题 Two Broad Categories of Topics (1) Subjects you know a lot about. 123Most people speak best about subjects with which they are most familiar.Think about a topic, draw on your own knowledge and experience.Think about unusual experiences or special expertise(n. 专门知识；专门技术；专家的意见). ​ (2) Subjects you want to know more about. 12345Make your speech a learning experience.★A subject about which you already have some knowledge or expertise but not enough to prepare a speech without doing additional research.★ A subject you want to explore for the first time. ★ A subject about which you hold strong opinions and beliefs, such as global warming, media violence, helping people with disabilities, vegetarianism素食 , preserving nature sanctuary禁猎区 . no designated topics How to choose a topic? The topic is determined by: occasion, audience, speaker’s qualifications Brainstorming: a method of generating ideas for speech topics by free association of words and ideas. Procedures: A. Personal inventory 盘点法 B. Clustering 聚类法 C. Internet search网络搜索 Guidelines A. Interesting to us B. Interesting to the audience C. Appropriate to the situation D. Appropriate to the time limit E. Manageable Determining the General Purpose General purpose: the broad goal of a speech To inform: act as a teacher or lecturer, enhance the knowledge and understanding of your listeners — to give them information that they did not have before. To persuade: act as an advocate or a partisan（虔诚信徒）, win over your listeners to your point of view – go get them to believe something or do something. To entertain: help listeners have a good time by getting them to relax, smile, and laugh. Determining the Specific Purpose Specific purpose: a single infinitive phrase that states precisely what a speaker hopes to accomplish in his or her speech. It should focus on one aspect of a topic. ①Write the Purpose Statement as a Full Infinitive原形 Phrase ②Express Your Purpose as a Statement, Not as a Question ③Avoid Figurative比喻的 Language in Your Purpose Statement ④Make Sure Your Specific Purpose Is Not Too Vague模糊的 or General大体的 ⑤Choose a Specific Purpose That Is Appropriate for Your Audience ⑥Choose a Specific Purpose You Can Achieve in the Allotted分配 Time Phrasing用短语描述 the Central Idea Central idea: a one-sentence statement that sums up or encapsulates（压缩，概述） the major ideas of a speech. Make sure the central idea is not too general. Express the central idea as a full sentence. State the central idea as a declarative sentence, not as a question. Avoid figurative language in the central idea. How to write a purpose? -Topic -general purpose -specific purpose -Central idea -Main point U5 Using Language 1 Using Language Accurately Using Language Clearly ​ Use familiar words ：short, sharp words ​ Choose concrete words ​ Eliminate clutter消除杂波 Simple words: before, if, now Cluttered counterparts: prior to, in the eventuality of, at this point in time 12345- Suggestions:- ​ Throw away unnecessary words.- ​ Keep your language lean and lively.- ​ Beware of using several words where one or two will do.- ​ Avoid flabby phrases Using Language Vividly Imagery(比喻，形象化） The use of vivid language to create mental images of objects, actions, or ideas.创造物体、动作或思想的心理形象 Concrete Words 具体词汇 123- for example:- in the end of the speech, many students will say “let&#x27;s embrace the bright future”- “I would be gratified to live a life like this after graduation: after a day&#x27;s work, I came back to my little apartment, make myself a simple meal, sit down and late practise some yoga, and enjoy a moment of peace by myself. Plain it maybe to some people, but it is the future I&#x27;d like to have.” Simile 明喻 明喻是在本质上不同但又有共同点的事物之间进行的一种明确的比较。它总是包含单词“like”或“as”。 Metaphor 暗喻 暗喻是在本质上不同但又有共同之处的事物之间隐含的比较。 1Imagine the book of your life, its covers, its beginning and end, and your birth and your death. You can only know the moments in between, the moments that make up your life. It makes no sense for you to fear what is outside of those covers, whether before your birth or after your death. And you needn’t worry how long the book is, or whether it is a comic strip or an epic. The only thing that matters is that you make it a good story. Rhythm（节奏） The pattern of sound in a speech created by the choice and arrangement of words. U6 Using Language 2 Using Language Vividly Using Language Vividly-Rhythm Parallelism 排比，对偶 将一组内容相关、结构相似的字、词、句排列在一起。 1With this faith we will be able to work together, to pray together, to struggle together, to go to jail together, to stand up for freedom together, knowing that we will be free one day. Repetition 反复 在连续的句子开头或结尾重复使用相同的词或短语。 1Tonight, HIV marches resolutely toward AIDS in more than a million American homes, littering its pathway with the bodies of the young, young men, young women, young parents, and young children. We must imagine greatly, dare greatly, and act greatly. Alliteration 头韵 在相邻或相近的单词中重复使用同一个辅音做开头音。 1Time and again these men and women struggled and sacrificed. We remain the most prosperous, powerful nation on Earth. With old friends and former foes, we will work tirelessly to lessen the nuclear threat, and roll back the specter of a warming planet. Antithesis 对仗 以平行结构将相对的观点放在一起。 1That&#x27;s one small step for man; one giant leap for mankind. Using Language Appropriately Appropriateness to the topic、speaker、occasion、audience Using Language Inclusively U7 Supporting Your Ideas Supporting Your Ideas Presenting the central ideas/purpose Conclusion Two criteria of choosing supporting materials: Authority/expertise 权威/专业知识 Accuracy Basic Kinds of Supporting Materials Examples (specific, personal, lively) Statistics Testimony 证据 Examples (specific, personal, lively) Brief Exampls 简要事例 Specific Instances / Specific Cases Extended Examples 扩展的例子 narratives—stories 叙事 illustrations 例证 anecdotes 趣闻轶事 Hypothetical Examples 假设的例子 “suppose that” “imagine that” “what if” Tips for Using Examples (1) Make examples vivid and richly textured(生动且层次丰富） (2) Reinforce examples with statistics or testimony （运用数据或证言强化事例） Statistics / Numerical Data Single Statistics Multiple Statistics Tips for Using Statistics (1) Use representative statistics 代表性的数据 (2) Identify the sources of statistics (3) Use the statistics from the reliable source (4) Round off complicated statistics 复杂的统计数字四舍五入 (5) Explain the statistics (6) Use visual aids to clarify statistics 使用视觉辅助工具来澄清统计数据 Testimony 证词，证言；证据，证明 Testimony is about other people’s words or ideas. Quotations or paraphrases used to support a point. Expert Testimony Peer Testimony Tips for Using Testimony (1) Decide whether to quote or paraphrase 决定是引用还是转述 (2) Quote or paraphrase accurately (3) Use testimony from qualified source (4) Use testimony from unbiased source (5) Identify the people you quote or paraphrase U8 英语写作之常见句法错误 Run-on Sentences（流水句） Def: A run-on sentence is a sentence in which two or more independent clauses (that is, complete sentences) are joined with no punctuation or conjunction. 指错误地将两个独立分句合写在一个句子里面，没有正确地用标点或连词加以分离。 ​ (1) Comma Splice （逗号使用错误） 逗号使用错误相当于中文写作中常出现的“一逗到底”的现象，这种现象在英文写作中是不允许的。具体表现为使用逗号但是并没有并列连词将两个独立分句写在一个句子里. ​ (2) Fused Sentence（融合句） 根本不使用标点把两个独立分句合写在一个句子里。 Sentence Fragments （句子碎片；零散句） Def: A fragment is only a piece of a complete thought. It can be phrases or dependent clauses or any incomplete word group that begins with capital letter and ends with a period, question mark, or exclamation point but is grammatically incomplete. 一般是指某句子看上去样子像个句子，但它从语法上讲并不是一个句子，是模仿真的句子的假句子。 一个完整的句子最基本的要素就是主语(a subject) +动词(a verb)+完整意思(a complete thought) U9 123456789an imaginary story 一个虚构的故事illustration 插画 插图 例证 说明 fable 寓言；谎言，无稽之谈；神话，传说 hypothetical example 假设的例子 simulated example 模拟的例子Analogies 类比；类推法causal reasoning 因果推理emotional appeals statistics 情感诉求；感性诉求 U10 Main Points Three basic parts of a speech Introduction Body Conclusion 外包装 + 内核 + 外包装 Listeners demand coherence.与听众需求一致性 Strategic organization Using a clear and specific method of speech organization The process of organizing the body begins when you determine the main points.组织正文的过程从你确定要点开始 Select them carefully;仔细选择他们 Phrase them precisely; 短语精确 Arrange them strategically.战略安排他们 Establish the main points 确立要点 Rule 1: Sometimes the main points are evident from your specific purpose statement. ​ 有时候，从你的特定目的陈述中，要点是显而易见的。 12345678Specific Purpose: To inform my audience about the goals, structure, and member states of the United States.Central Idea: Composed of five administrative bodies and 192 member states, the United Nations is devoted to promoting international cooperation.Main Points: I. The overarching（主要的） goal of the United Nations is to promote international cooperation. II. The United Nations is divided into five administrative bodies. III. The United Nations is made up of 192 member states. Rule 2: Even if the main points are not stated expressly in your specific purpose, they can be easy to project from it. ​ 即使在你的具体目的中没有明确说明要点，它们也可以很容易地投射出来。 123456789Specific purpose: To inform my audience about the four events in women’s gymnastics.Central Idea: The four events in women’s gymnastics are floor exercise, vault, balance beam, and uneven parallel bars.Main Points: I. Floor exercise combines dancing, acrobatics, and tumbling. II. Vault features explosive power and dramatic midair maneuvers. III. Balance beam requires precise routines and perfect coordination. IV. Uneven parallel bars demand strength, flexibility, and agility. Organizing the Main Points 组织要点 The order in which you will present your main points depends on your topic, your purpose, and your audience. Patterns of Organization 语篇组织模式 Chronological order 时间顺序 1234567Specific Purpose: To inform my audience how the Great Wall of China was built.Central Idea: The Great Wall of China was built in three major stages.Main Points: I. Building of the Great Wall began during the Qin Dynasty of 221-206 B.C. II. New sections of the Great Wall were added during the Han Dynasty of 206 B.C.-220 A.D. III. The Great Wall was completed during the Ming Dynasty of 1368-1644. Spatial order 空间顺序 1234567Specific purpose: To inform my audience about the structure of a typhoon.Central Idea: A typhoon is made up of three parts of going from inside to outside.Main points: I. At the center of a typhoon is the calm, cloud-free eye. II. Surrounding the eye is the eyewall, a dense ring of clouds that produces the most intense wind and rainfall. III. Rotating around the eyewall are large bands of clouds and precipitation called spiral（螺旋状的） rain bands（降雨带）. Problem-solution order 问题解决的顺序 ​ a method of speech organization in which the first main point deals with the existence of a problem and the second main point presents a solution to the problem. 123456789Specific Purpose: To persuade my audience that tougher measures are needed to control illegal selling of antiques.Central Idea: Illegal selling of antiques is a serious problem that requires a combination of government action and individual awareness.Main points: I. Illegal selling of antiques is a serious problem in parts of China. II. The problem can be solved by a combination of government action and individual awareness. Most appropriate for persuasive speeches. Topical order 话题顺序 1234567891011 Your specific purpose is “ To inform my audience of the achievements of Leonardo da Vinci”.Chronologically 按年代地 从历史上: his achievements in each stage of his career.Topically 总论地: divide his achievements into categories. Specific Purpose: To inform my audience about the achievements of Leonardo da Vinci.Central Idea: Leonardo da Vinci was accomplished as a painter, an inventor, and as astronaut.Main Points: I. As a painter, Leonardo da Vinci produced the Mona Lisa, the Last Supper, and other masterpieces. II. As an inventor, he drew plans for an parachute and a flying machine. III. As an astronomer, he concluded that the earth revolves around the sun. Causal Division 因果关系 cause to effect effect to cause Pro-con division 利弊关系 pro con Tips for Preparing the Main Points 准备要点的技巧 Limit the number of main points. Keep main points separate. Try to use the same pattern of wording for main points. Balance the amount of time devoted to main points. Make the Main Points a Whole Unity 123456Topic: “Apple” has changed the world.Specific purpose: To inform the audience that three apples have changed the world.Main points: The apple of morality, eaten by Adam and Eve, help people to differentiate good from evil. The apple of science, discovered by Newton, taught people to explore the truth. The apple of creativity, created by Steve Jobs, changed people’s ways of communication and ways of life. Supporting Materials ​ the materials used to support a speaker’s ideas. The three major kinds of supporting materials are examples, statistics, and testimony. Examples Brief examples Extended examples Factual examples 客观事实引用 Hypothetical examples Statistics Testimony Expert testimony Peer testimony Connectives 连接符 连接词 连词 联结词 Types of connectives transitions 关联词 internal previews 内部提示 internal summaries 内部总结 signposts 标识语 ​ Now that we have a clear understanding of the problem, let me share the solution with you. ​ We have spoken so far of Guan Yu’s skill as a warrior, but above all it is his honor and righteousness that make him a mythic figure in Chinese history. ​ Keeping these points in mind about sign language, let’s return to the sentence I started with. [Internal Summary]: Let’s sum up what we have discussed so far. First, we have seen that Li Shizhen’s classic work Bencao Gangmu divides the substances from minerals into four categories. Second, we have seen that it divides the substances from animals into six categories. [Transition]: Now let us see how it divides the substances from plants. U11 Beginning and Ending the Speech Introduce Introduce the topic and the main points 例1：Today I will talk with you about ※the causes of high blood pressure; ※ the strain high blood pressure is putting on China’s health care system ※ and what people can do to reduce the likelihood of having high blood pressure. 第一，简短。切忌冗长、信息量大的内容介绍，加重听众的记忆负担。 第二，表达方式富有变化。尽量不要采用报幕式的方法展示演讲内容。可以适当使用修辞、幽默等语言技巧，使语言形式更加活泼。 Get Attention and Interest A: Relate the topic to the audience. 将话题与听众联系起来。 B: State the importance of your topic. 陈述主题的重要性。 C: Startle the audience. 使听众震惊 D: Arouse the curiosity of the audience. E: Question the audience. F: Begin with a quotation. G: Tell a story. H: Using unexpected props 利用意想不到的道具 Attention grabber tell a personal story ​ true life experience, real, sincere As a famous saying goes: “Tell me a fact and I’ll learn. Tell me a truth and I’ll believe. Tell me a story and I’ll remember.” offer thought-provoking questions 提供发人深省的问题 ​ Why? How? What if? making dramatic statement startling statement 惊人的声明 using shocking statistics 用令人震惊的统计数据 start your speech with an intresting quotation Create a Positive Relationship with the Audience Especially important when： The speaker is controversial or advocates an unpopular position； In cross-cultural communication. 尤其重要: 演讲者是有争议的或主张不受欢迎的立场; 在跨文化交际 Establish Credibility Your credibility can be based on research, firsthand knowledge, or some combination of the two. 你的可信度可以建立在研究、第一手知识或两者结合的基础上。 Tips for the Introduction (1) Keep the introduction relatively brief. (2) Be on the lookout for possible introductory materials as you do your research. 在你做研究的时候，要注意可能的介绍性材料。 (3) Be creative in devising your introduction. 在自我介绍的设计上要有创意。 (4) Don’t worry about the exact wording of your introduction until you have finished the body of the speech. (5) Don’t apologize in your introduction. (6) Work out your introduction in detail. (7) Don’t start talking too soon. 不要太早开口。 Conclusion A conclusion can serve the following functions. To create a sense of completeness to the speech to sum up To win the audience for the last time To reinforce our points 加强我们的观点 A conclusion can be achieved in the following ways. Summarizing your speech 总结要点 总结要点是最常见的一种结尾方式，在信息性演讲中使用尤为频繁。演讲者通过重申演讲的 中心思想和主要观点来帮助听众有条理地总结演讲内容，使听众对演讲内容留下全局印象。 End with a quotation Make a dramatic statement Refer to the introduction 演讲的结构不是线性的，而是环状的。鉴于此，演讲者可以在结尾时有意识地将结束语与开篇语呼应，从而达到语篇流畅、统一的效果 Issuing an appeal 呼吁行动式 劝说性演讲中较为常用。演讲者不仅要听众同意和接受自己的观点，在结束时还要呼吁听众采取行动，并和听众一起想象采取行动后的美好未来，已达到规劝听众并让他们采取自由行动的目的。 Tips for Conclusion (1) Keep an eye for possible concluding materials as you research and develop the speech. (2) Conclude with a bang, not a whimper. (3) Don’t be long-winded. The conclusion makes up no more than 5-10 percent of your speech. (4) Don’t end with an apology. Statements U12 Outlining the Speech Preparation outline: a detailed outline developed during the process of speech preparation that includes the title, specific purpose, central idea, introduction, main points, subpoints, connectives, conclusion, and bibliography of a speech. 准备提纲:在准备演讲的过程中形成的详细的提纲，包括演讲的标题、具体目的、中心思想、引言、要点、子要点、连接词、结论和参考书目。 Guidelines for the Preparation Outline ​ 1. State the specific purpose and central idea.陈述具体目的和中心思想 ​ 2. Label the introduction, body, and conclusion.标注引言、正文和结论 ​ 3. Use a consistent pattern of symbolization and indentation（缩格）.使用一致的符号和缩进模式 ​ 4. State main points and subpoints in full sentences.用完整的句子陈述要点和次要要点 ​ 5. Label transitions, internal summaries, and internal previews.标签转换、内部摘要和内部预览 ​ 6. Attach a bibliography.附上参考书目 ​ 7. Give your speech a title. 给你的演讲起个标题 Speaking outline: a brief outline used to jog a speaker’s memory during the presentation of a speech.It helps you remember what you want to say. A condensed version of your preparation outline. ​ It should contain key words or phrases, essential statistics and quotations. ​ It should also include cues to direct and sharpen your delivery. Guidelines for the Speaking Outline ​ 1. Follow the visual framework used in the preparation outline. ​ 2. Make sure the outline is legible（易读的）. ​ 3. Keep the outline as brief as possible. ​ 4 .Give yourself cues for delivering the speech. U13 Speaking to Inform Types of informative speeches ​ (1) Speeches about objects ​ (2) Speeches about processes ​ (3) Speeches about events ​ (4) Speeches about concepts Speeches about processes explain how something is made, how something is done, or how something works 123456SMART---an acronym S (specific goal): What is the goal of the new project you want to start.M (measurable): List all the features you need to accomplish to start the project.A (action): When will you start.R (realistic): Is the project small enough to finish it in the specified time frame.T (time): In the beginning of July 2020 everything should be fine. Organizing Informative Speeches ​ chronological; spatial; topical Tips for Informative Speeches Don’t overestimate what the audience knows. Don’t be too technical. Personalize your ideas. Avoid abstractions. Be creative. Avoid boring the audience with familiar information. Speech Evaluation Criteria E-Excellent G-Good A-Average F-Fair P-Poor 12345Introduction- Gain attention and interest- Introduce the topic clearly- Establish credibility- Effectively preview main points 12345678Body- Main points are clear- Organization well-planned- Main points fully supported- Sources cited and indentified clearly- Language clear, accurate, appropriate- Connectives used effectively- Visual aids effective 1234Conclusion- Prepared audience for an ending- Reinforced central idea- Ended on a strong note 1234567891011Delivery- Began speech without rushing- Maintain appropriate eye contact- Avoided distracting mannerism 避免分散注意力的特殊习惯- Articulated words clearly- Used pauses effectively- Used vocal variety to add impact- Communicated enthusiasm for topic- Speech presented extemporaneously 即兴演讲- Visual aids clear and visible, presented well- Departed from lectern without rushing U14 Speaking to Persuade The psychology of persuasion Target audience Three major kinds of persuasive speeches The methods of persuasion. Building Credibility Using evidence Reasoning Appealing to emotions Methods you can use to hit the target in the following three kinds of persuasive speeches speeches on questions of fact A question of fact means a question about the truth or falsity of an assertion ​ 有关事实的说服性演讲的目的是说服听众同意演讲者对某一事实真伪的判断。 12345- Specific purpose: To persuade my audience that Marilyn Monroe did not die of suicide.- Main Points: - A. Medical check proves no sign of hypnotics&#x27; overdosing in Monroe.- B. Evidence and witnesses on the scene suggested it was more of a murder crime.- C. Rumor went that Monroe had complicated relationship with the Kennedy Brothers. speeches on questions of value Question of value means a question about the worth, rightness, morality, and so forth of an idea or action. ​ 价值问题指的是关于一种思想或行为的价值、正确性、道德性等问题 Whenever you give a speech on a question of value, be sure to give special thought to the standards for your value judgment 每当你就价值问题发表演讲时，一定要特别考虑你的价值判断标准 组织关于价值问题的演讲 最常见的方法是把你的第一个要点用于建立你的价值判断的标准，然后把你的第二个要点用于将这些标准应用到你演讲的主题上。 12345678910Specific purpose: To persuade my audience the jogging is the ideal workout option.Main points:1. An ideal workout option should meet three major standards. A. It should be good for one&#x27;s health. B. It should be economical. C. It should be flexible.2. Jogging meets all three standards for an ideal workout option. A. Jogging offers multiple health benefits. B. Jogging does not cost any money. C. Jogging can be done anywhere, anytime. speeches on questions of policy. Question of policy means a question about whether a specific course of action should or should not be taken.Types of speeches on questions of policy include speeches to gain passive agreement and speeches to gain immediate action. ​ 政策问题指的是某一具体行动方针是否应该采取的问题。关于政策问题的演讲类型包括获得被动同意的演讲和获得立即行动的演讲。 Speeches to gain passive agreement(以获得听众认可为目标的演讲） ​ Persuasive speeches in which the speaker’s goal is to convince the audience that a given policy is desirable without encouraging the audience to take action in support of the policy. ​ 说服性演讲，演讲者的目标是说服听众某一政策是可取的，但不鼓励听众采取行动支持该政策。 1To persude my audience that public speaking should be a required course for English majors. Speeches to gain immediate action(以促使听众立即行动为目标的演讲） ​ Persuasive speeches in which the speaker’s goal is to convince the audience to take action in support of a given policy. ​ 说服性演讲，演讲者的目标是说服听众采取行动支持某一特定政策。 1To persuade my audience to donate blood on a regular basis. Organizing Speeches on Questions of Policy problem-solution order 问题解决方案的顺序 A method of organizing persuasive speeches in which the first main point deals with the existence of a problem and the second main point presents a solution to the problem ​ 第一个要点说明问题的存在，第二个要点提出问题的解决方案 problem-cause-solution order A method of organizing persuasive speeches in which the first main point identifies a problem,the second main point analyzes the causes of the problem,and the third main point presents a solution to the problem. 第一个要点确定问题，第二个要点分析问题的原因，第三个要点提出问题的解决方案 comparative advantages order 比较优势的顺序 A method of organizing persuasive speeches in which each main point explains why a speaker’s solution to a problem is preferable to other proposed solutions ​ 每个要点都说明为什么演讲者对某个问题的解决方案比其他提出的解决方案更可取 motivated sequence （动机序列法） A method of organizing persuasive speeches that seek immediate action.要求立即采取 attention(引起听众的注意） need（解释解决问题的必要性） satisfaction（提出解决问题的办法） visualization（形象地描述采用上述办法的好处） action（号召听众立即采取行动） Methods of persuasion 1.Building credibility (ethos） Credibility are affected by competence and character 信誉受能力和品格的影响 Explain your competence Establish common ground with your audience 与你的听众建立共同立场 show respect for your listeners deliver your speeches fluently, expressively and with conviction 演讲要流利、有表现力、有说服力 2 .Using evidence（logos) Specific evidence is more persuasive . Novel evidence is more persuasive if evidence is new to the audience. Evidence from credible sources is more persuasive. 3.Reasoning The process of drawing a conclusion on the basis of evidence ​ (1)（归纳论证）Reasoning from specific instances particular facts to a general conclusion 用具体的事实来概括结论 ​ (2)（演绎论证）Reasoning from principle move from the general to the specific 从一般到具体 ​ (3)（因果论证）Causal reasoning seeks to establish the relationship between causes and effects 试图建立因果关系 ​ (4)（类比论证）Analogical reasoning Compare two similar cases and infers the truth of both 比较两个相似的案例，并推断两者的真相 四种常见的推理 根据具体事例推理 避免轻率结论/用词准确，避免一概而论/利用数字和材料支撑 根据原理推理 从普遍原理走向特殊的结论的过程 原理（大前提）必须准确/推理要有相的说服力 根据因果推理 避免两者仅仅时间有联系，而非因果/不要简化为单一事件起因 类比推理 类比实例必须是可比较的/类比的角度和立场具有多样性 fallacies you should guard against 常见的谬误 (1) red herring 红鲱鱼 引入完全不相干的物体，使听众从正在讨论的问题中走神 (2) ad hominem 对人不对事 转而攻击人而不是争议之中的问题 除非这个的性格和诚实水平足够成为有效议题 ​ (3) bandwagon 从众效应 如果某项是受欢迎的，那么它一定是最好的、正确的等等 ​ (4) slippery slope 滑坡谬误 只有走错了一步就不可避免的延续下去 4.Appealing to emotions（pathos) U15 Speaking on Special Occasions Speeches of Introducation 引见致词 A speech of introduction is an address that introduces the main speaker to the auience. Tips: Be brief: 2-3minutes Make sure your remakrs are completely accurate Adapt your remarks to the occasion Adapt your remarks to the main speaker Adpat your remarks to the Audience Speeches of Acceptance 获奖致词 A speech to give thanks for a gift or an award. When giving such a speech, you thank the people who are bestowing the award recognize the people who helped you gain it. 致谢:为礼物或奖品而致谢的演说在做这样的演讲时，你要感谢颁奖的人，感谢帮助你获奖的人。 Speeches of Toast 祝酒词 A speech of saying a fews words of greeting, celebartion, or thanks in conjunction with a meal or reception. 祝词:在宴会或招待会上说几句问候、庆祝或感谢的话 Some toasts are very brief: – a few sentences of welcome ​ – wishes for good health ​ – Joyful marriage ​ – a prosperous career Commemorative Speeches 纪念性演讲 Commemorative speeches are speeches of praise or celebration. Your aim is to pay tribute to a person, a group of people, an institution, or an idea. Your fundamental purpose is to inspire the audience: ​ to arouse and heighten their appreciation of or admiration for the person, institution, or idea. 纪念演讲是赞美或庆祝的演讲。 你的目标是向一个人、一群人、一个机构或一个想法致敬。 你的根本目的是激励听众:激发并提高他们对这个人、机构或想法的欣赏或钦佩","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[]},{"title":"报错集合","slug":"报错集合","date":"2022-05-28T01:32:21.423Z","updated":"2022-05-31T10:16:53.532Z","comments":true,"path":"2022/05/28/报错集合/","link":"","permalink":"https://zhang0224gz.github.io/2022/05/28/%E6%8A%A5%E9%94%99%E9%9B%86%E5%90%88/","excerpt":"","text":"报错1：yarn create umi myapp @typescript-eslint/parser@5.26.0: The engine “node” is incompatible with this module. Expected version “^12.22.0 || ^14.17.0 || &gt;=16.0.0”. Got “12.14.0” error Found incompatible module. info Visit https://yarnpkg.com/en/docs/cli/create for documentation about this command. @typescript-eslint/parser@5.26.0:引擎“Node”与此模块不兼容。预期的版本”^ 12.22.0 | | ^ 14.17.0 | | &gt; = 16.0.0”。有“12.14.0” 错误发现不兼容的模块 \\info访问https://yarnpkg.com/en/docs/cli/create获取该命令的相关文档。 解决办法 : 命令行执行即可 1yarn config set ignore-engines true 重新install项目包，发现还有问题。 删除node_modules包和yarn.lock文件，重新yarn install。 1234567891011121314151617181920//安装npm install -g yarn //查看版本yarn -v // 初始化yarn init // 添加包yarn add [package]yarn add [package]@[version]yarn add [package]@[tag]// 添加到不同依赖项yarn add [package] --devyarn add [package] --peeryarn add [package] --optional// 升级包yarn upgrade [package]// 移除依赖包yarn remove [package]// 安装所有依赖yarn 或 yarn install 报错2：Stylelint node.js基于 Chrome V8 引擎的 Javascript 运行环境 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 Stylelint是一个强大的，现代的代码检查工具，与ESLint类似，Stylelint能够通过定义一系列的编码风格规则帮助我们避免在样式表中出现错误。 npm is two things: first and foremost, it is an online repository for the publishing of open-source Node.js projects; second, it is a command-line utility for interacting with said repository that aids in package installation, version management, and dependency management. A plethora of Node.js libraries and applications are published on npm, and many more are added every day. These applications can be searched for on https://www.npmjs.com/. Once you have a package you want to install, it can be installed with a single command-line command. Stylelint:Please specify path to ‘stylelint’ package correctly Stylelint:请正确指定’ styelint '包的路径 错误原因：这是因为没有在dos窗口下载stylelint导致的，下载了就行了 Stylelint: no configuration provided for D:\\workspace… Stylelint:没有为D:\\工作区提供配置… 错误原因：node.js下载后需要在工程中添加相关配置文件；一般我们写web不需要使用到stylelint哈……我打开的那个工程有这些pycharm默认打开了…… 解决办法：直接取消勾选Enable就行 pycharm中使用stylelint/nodejs全局环境重新配置 第一步：首先得安装 node.js 官网下载安装。 ​ 配置依赖的环境变量 npm config list 获取npm配置信息 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【D:\\Develop\\nodejs】下创建两个文件夹【node_global】及【node_cache】如下图： 创建完两个空文件夹之后，打开cmd命令窗口，输入 12npm config set prefix &quot;D:\\Develop\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Develop\\nodejs\\node_cache&quot; 接下来设置环境变量，关闭cmd窗口，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量” 进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入【D:\\my app\\nodejs\\node_global\\node_modules】，将【用户变量】下的【Path】修改为【D:\\Develop\\nodejs\\node_global】 配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口， express模块是 JavaScript 库或文件，可以用 Node 的 require () 函数将它们导入其它代码。 Express 本身就是一个模块，Express 应用中使用的中间件和数据库也是。 下面的代码以 Express 框架为例展示了如何通过名字来导入模块。 全局安装 命令：npm install express -g -g代表安装到nodejs安装目录下的lib里面，而-d代表把相依性套件也一起安装。 2、本地安装 命令：npm install express 本地安装是安装在当前文件目录下，安装完成后，可以看到当前文件目录下多了一个“node_modules”文件夹，它里面有一个“express”文件夹 输入如下命令进行模块的全局安装： 1npm install express -g # -g是全局安装的意思 上面ok之后 我们安装淘宝的cnpm镜像，因为国外的很慢。我们可以采用cnpm install 来代替npm安装 1$ npm install -g cnpm --registry=https://registry.npm.taobao.org npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 我们首先安装nrm，这里-g代表全局安装 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 注意： 有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ ps: 也可以不配置，配置主要是为了下面第二步寻找安装stylelint依赖的路径文件夹用。默认在 C:\\Users\\用户名\\AppData\\Roaming\\npm 文件夹中。 设置好后，我的依赖包都安装在 node_modules 这个文件夹内： D:\\work\\nodejs\\npm-global\\node_modules 第二步： 全局安装 stylelint cmd 中输入： 12npm install -g stylelint # 安装stylelint包npm install -g stylelint-config-standard # 安装标准配置文件 下面是安装stylelint依赖的路径： ​ D:\\work\\nodejs\\npm-global\\node_modules\\stylelint 第三步：设置pycharm 第四步：在项目中新建一个名为.stylelintrc.json 的文件 在文件中写入： 123&#123;&quot;extends&quot;:&quot;stylelint-config-standard&quot;&#125; 转载链接地址：(8条消息) pycharm中使用stylelint_寻寻觅觅oO的博客-CSDN博客 nodeJS安装和环境变量的配置 - 发疯的man - 博客园 (cnblogs.com) pycharm文档说明：Stylelint | PyCharm (jetbrains.com) 报错3：JSON standard does not allow such tokens JSON标准不允许这样的标记 报错4：npm安装报错 （npm ERR! code EPERM npm ERR! syscall mkdir npm ERR! path C:\\Program Files\\nodejs\\node_ca…） 使用npm 安装vue的时候突然报错了： 错误详解 该错误发生在修改npm的全局安装路径之后，再执行npm install 包 -g或是npm install 包时发生，但是在管理员身份下运行cmd，均能执行成功。 2.1 修改npm全局安装： 命令行： 12npm config set prefix &quot;D:\\my app\\nodejs\\node_global&quot;npm config set cache &quot;D:\\my app\\nodejs\\node_cache&quot; 在C盘User/用户名/下有一个.npmrc的文件 将上述node_global文件夹的路径加入环境变量 2.2 导致该安装问题的原因 没有管理员权限，无法在node_global和node_cache两个文件夹下进行一些必要的操作 2.3 解决方法： 1.删除.npmrc文件 该文件在：C:\\Users{账户}\\下的.npmrc文件， 一般这种类型的都是默认被隐藏，一定要选择将隐藏取消掉 删掉即可。 2.或者直接用命令清理就行，控制台输入： 1npm cache clean --force 删除用户下的.npmrc文件，即不改变全局安装的路径（不够好，本质问题仍没有解决，全局还是会安装在C盘） 每次都用管理员身份运行命令行（不够方便，vscode 下的命令行默认也不是管理员身份运行的） 直接修改node_global和node_cache文件夹的权限： 右键文件夹，打开属性，切换到安全选项卡 选择编辑，将没有打钩的位置全部打上钩（即将其它用户的权限设置为与管理员相同），应用即可。 npm WARN using --force Recommended protections disabled. npm WARN using——force建议的保护被禁用。 警告，使用 --force 将禁用推荐的保护","categories":[],"tags":[]},{"title":"JavaScript","slug":"笔记/Web/web3","date":"2022-05-08T05:35:05.080Z","updated":"2022-05-18T15:26:06.594Z","comments":true,"path":"2022/05/08/笔记/Web/web3/","link":"","permalink":"https://zhang0224gz.github.io/2022/05/08/%E7%AC%94%E8%AE%B0/Web/web3/","excerpt":"","text":"1.初级 1.1 JS的使用方法 12345678//第一种：写在head标签里//不推荐头部使用：根据代码运行是自上而下解释的特性，会先解析head标签里JS，然后才解析元素，故需要监听//需添加 window.onload&lt;script&gt; window.onload = function()&#123; alert(123);// 弹出框，默认设置不可修改 &#125;&lt;/script&gt; 1234//第二种：写在body结束标签上面&lt;script&gt; alert(123);&lt;/script&gt; 123456789//第三种：外部导入JS文件//写在body结束标签上面的内容&lt;script src=&quot;demo.js&quot;&gt; //注意：在引入js文件的script里面，一定不能写js代码 //可以另起一行，按照法二在标签内写js代码&lt;/script&gt;//写在.js文件中的内容alert(123); 栗子： 123456789&lt;body&gt;&lt;p&gt;Hello world!&lt;/p&gt;&lt;script src=&quot;demo.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(123); // 在前端控制台console打印出123&lt;/script&gt;&lt;/body&gt; 1.2 JS获取元素的方法 在js中想要操作元素，或者说执行一些行为，首先需要获取到对应的元素。才能进行下一步的操作，所以要首先学会如何获取元素 1234//JS获取独有标签document.title 获取标题document.head 获取头部信息document.body 获取body内容 12345678//其他标签的获取通过id获取元素：document.getElementById(&quot;idname&quot;); 通过class获取元素：document.getElementsByClassName(&quot;classname&quot;);通过标签名获取元素：document.getElementsByTagName(&quot;tagdem&quot;); 表单中的name：document.getElementsByName(&quot;name&quot;);selector选择器(不兼容IE7及以下):document.querySelector (&quot;&quot;); 通过CSS选择器获取一个document.querySelectorAll(&quot;&quot;); 通过CSS选择器获取所有 栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS获取元素的方法&lt;/title&gt; &lt;style&gt; #p1&#123;&#125; .p2&#123;&#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt;&lt;p id=&quot;p1&quot; class=&quot;p2&quot;&gt;我是段落标签1&lt;/p&gt;&lt;p class=&quot;p2&quot;&gt;我是段落标签2&lt;/p&gt;&lt;p name=&quot;p3&quot;&gt;我是段落标签3&lt;/p&gt;&lt;script&gt; //1.通过id获取元素 var oP = document.getElementById(&quot;p1&quot;) //var/let 定义一个变量，通过变量接收获取的元素（注意：变量名不能使用关键字和变量名） console.log(oP); //2.通过class获取元素 //当不唯一的时候，需要使用下标，下表从0开始 //法一：下标在document.getElementsByClassName(&quot;p2&quot;)后面 var oP = document.getElementsByClassName(&quot;p2&quot;)[1]; console.log(oP); //法二：下标在oP后面 var oP = document.getElementsByClassName(&quot;p2&quot;); console.log(oP[1]); //3.通过标签名获取元素 var oP = document.getElementsByTagName(&quot;p&quot;); console.log(oP[2]); //4.表单中的name var oP = document.getElementsByName(&quot;p3&quot;); // name属性值不是唯一的 类数组 console.log(oP[0]); //5.selector选择器 //法一：通过选择器获取单个 var oP = document.querySelector(&quot;#p1&quot;); var oP = document.querySelector(&quot;.p2&quot;); console.log(oP[0]);//下标使用失败：只能获取选择器选择的第一个元素，谁在最前面就获取谁，加下标没有用 //法二：通过选择器获取多个 var oP = document.querySelectorAll(&quot;.p2&quot;); console.log(oP[1]); //只有id和获取单个选择器不需要加下标，其他都要加下标才显示一个否则是一个集合 // 不支持伪类和伪元素选择器 // “=”是赋值的意思，通常要用赋值的形式 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314//获取嵌套元素&lt;body&gt;&lt;p id=&quot;p1&quot; CLASS=&quot;p2&quot;&gt;我是段落标签4 &lt;span&gt;111111&lt;/span&gt;&lt;/p&gt;&lt;script&gt; //id 只能使用document.getElementById(&quot;p1&quot;)获取元素,其他可以更换开头（document，id），但不能是集合（嵌套元素）//获取嵌套在p标签中的span标签 var oP = document.getElementById(&quot;p1&quot;);//获取元素，只要保证它是一个确定的标签即可，例： var oP1 = oP.getElementsByTagName(&quot;span&quot;); console.log(oP1[0]);&lt;/script&gt; 1.3 JS的基本事件 事件含义：所谓事件，是指JavaScript捕获到用户的操作，并做出正确的响应 使用：在事件函数里而，有一个关键字this，代表当前发事件的这个元素。事件通过函数完成，在函数内部书写自己想要实现的效果 12345//鼠标事件左键单击 onclick左键双击 ondblclick鼠标移入 onmouseover/onmouseenter鼠标移出 onmouseout/onmouseleave 栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS基本事件&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;p1&quot; CLASS=&quot;p2&quot;&gt;我是段落标签1&lt;/p&gt;&lt;p class=&quot;p2&quot;&gt;我是段落标签2&lt;/p&gt;&lt;p name=&quot;p3&quot;&gt;我是段落标签3&lt;/p&gt;&lt;div&gt; 111&lt;/div&gt; &lt;script&gt; var oP = document.getElementById(&quot;p1&quot;); //鼠标单击事件 oP.onclick = function() &#123; // oP.innerText = &quot;&lt;h1&gt;我不是段落标签1&lt;/h1&gt;&quot;; //可以带标签进行渲染这个标签,上面只显示文本不会渲染 oP.innerHTML = &#x27;&lt;h1&gt;我不是段落标签1&lt;/h1&gt;&#x27; &#125; //鼠标（连续）双击事件 oP.ondblclick = function ()&#123; oP.innerHTML = &#x27;&lt;h1&gt;我不是段落标签1&lt;/h1&gt;&#x27; &#125; //鼠标滑入滑出事件 var oP1 = document.getElementsByTagName(&quot;div&quot;)[0]; oP1.onmouseenter = function()&#123; oP1.innerText = &quot;byebye&quot;; &#125; oP1.onmouseleave = function () &#123; oP1.innerText = &quot;hello&quot;; &#125; //在修改别的标签时，得使用innerHTML(会解析标签),innerText(不会解析标签) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.4 JS修改样式 js可以修改规范和不规范的标签的样式，也可以配合点击事件等一起使用 12.style.height 单个样式修改.style.cssText 多个样式修改 栗子： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS修改样式&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; border: 1px solid red; background-color: #3A87CD; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 111&lt;/div&gt;&lt;script&gt; var obox = document.querySelector(&quot;div&quot;); //元素获取值 var obox = document.querySelector(&quot;div&quot;).value; obox.onclick = function () &#123; obox.style.width = &quot;100px&quot;; //.是不能.一个变量可以使用 obox.style[&quot;width&quot;]=&quot;20px&quot; //style[] 可以是一个变量也可以是一个字符串 obox.style.height = &quot;100px&quot;; obox.style.background = &quot;red&quot;; //可以使用cssText修改多个 //obox.style.csstext = &quot;width: 100px; height: 100px;&quot; &#125; //一般情况下不这么做(JS和CSS混合在一起)，因为一般css很多 //Question: 如何将JS和CSS分开呢？ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.5 JS操作标签属性 12345678规范的标签属性： . 符号直接操作(可读可写) .id 修改id .className 修改class不规范(自定义)的标签属性：获取： .getAttribute()设置： .setAttribute() (增/添)移除： .removeAttribute() (删)判断： .hasAttribute() 栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS操作标签属性&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; border: 1px solid red; background-color: #3A87CD; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;&lt;!--对于页面当中这些属性是可读并且可写的操作--&gt;&lt;script&gt; // 标签属性的可写（可赋值、修改值）可读（可以打印出来）-&gt; .操作 var obox = document.querySelector(&quot;div&quot;); console.log(obox.id); //undefined obox.id = &quot;box1&quot;; console.log(obox.id); //box1 //添加一个class属性，并且class的属性值为box1 obox.className = &quot;box2&quot;;//增：有则增，无则改 obox.className = &quot;box3&quot;;//不是再加一个，是修改操作 //className只操作合法属性 //合法属性：非自定义，页面标签原本已有的属性名 console.log(obox.className);//查 obox.removeAttribute(&quot;class&quot;);//删 //自定义属性的增删改查 obox.setAttribute(&quot;abc&quot;,&quot;abc1&quot;);//增 obox.setAttribute(&quot;class&quot;,&quot;abc1&quot;); obox.setAttribute(&quot;abc&quot;,&quot;abc2&quot;);//改：无则增，有则改 console.log(obox.hasAttribute(&quot;class&quot;));//查：存在true不存在false obox.removeAttribute(&quot;class&quot;);//删 //合法属性也可以通过自定义属性方式添加 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6 JS与CSS分离 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS与CSS分离&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; border: 1px solid red; background-color: #3A87CD; &#125; .box1&#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt; &lt;script&gt; var obox = document.querySelector(&quot;div&quot;); obox.onclick = function() &#123; //增/改选择器的两种方法 // obox.className = &quot;box1&quot;; obox.setAttribute(&quot;class&quot;,&quot;box1&quot;); &#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1.7 JS的基本数据类型 123456789number 数字string 字符串boolean 布尔型undefined 未定义null 空（对象）object 对象前五个是简单数据类型，最后一个是复杂数据类型typeof x 显示数据类型 栗子： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS基本数据类型&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //这些类型都是关键字 //number 数字 var a = 123; console.log(typeof a); //string 字符串 var b = &quot;123&quot;; console.log(typeof b); //boolean 布尔型 var c = true; console.log(typeof c); //undefined 未定义 var d; console.log(typeof d); //null 空（对象）-&gt; 是属于六大基本数据类型之一，只是在显示的时候将其归为object显示 var e = null; console.log(typeof e); //object 对象 （数组（列表），函数 -&gt;复杂数据类型） var f = [1,2,3,4,5]; console.log(typeof f);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.提升 2.1 JS运算符 算术运算符 算术运算符(基础数字运算) + - * / % 当不是数字之间的运算的时候，+号两边一旦有字符串(引号引起的部分)，那么+号就不再是数学运算了，而是拼接，最终结果是字符串。 -/*% 尽量将字符串转换成数字（隐式类型转换) NaN: Not a Number number 赋值运算符 += -= = /= = 这些是基本的赋值运算符，除此之外还有*++ --**,这两个都存在隐式类型转换，会全部转成数字。 逻辑运算符 JS中的逻辑运算用：&amp;&amp;、||、! 来表示。 &amp;&amp; 和 || 不会进行类型转换，！则会进行类型转换，将后面的数据先转换为布尔型在取反 比较运算符 &lt; != &gt;= &lt;= == === 如果等号两边是boolean、string、number三者中任意两者进行比较时，优先转换为数字进行比较。 如果等号两边出现了null或undefined,null和undefined除了和自己相等，就彼此相等 NaN==NaN 返回false，NaN和所有值包括自己都不相等。 栗子： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS运算符&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //算术运算符 document.write(1 + &#x27;2&#x27; + &quot;&lt;br/&gt;&quot;);//&#x27;12&#x27; +为字符拼接 document.write(1 - &#x27;2&#x27; + &quot;&lt;br/&gt;&quot;);//-1 隐式转换为number型(- % * /) document.write(1 + true + &quot;&lt;br/&gt;&quot;);//2 true=1,false=0 document.write(1 + null + &quot;&lt;br/&gt;&quot;);//1 null=0 document.write(1 + undefined + &quot;&lt;br/&gt;&quot;);//NAN: not a Number number //赋值运算符 var a = 1; var b = null; document.write(a++ +&quot;&lt;br/&gt;&quot;);//1 document.write(a +&quot;&lt;br/&gt;&quot;);//2 document.write(++a +&quot;&lt;br/&gt;&quot;);//3 document.write(++b +&quot;&lt;br/&gt;&quot;);//隐式转换 null-&gt;number = 0 //比较运算符 document.write((&#x27;2&#x27; == 2) + &quot;&lt;br/&gt;&quot;);//true ==在JS中是等于但为不全等（只判断值是否相等，不判断类型） document.write((&#x27;2&#x27; === 2) + &quot;&lt;br/&gt;&quot;);//false === 全等，先去判断类型是否一致再去判断值是否相等 //逻辑运算符 document.write((2&gt;3&amp;&amp;2&lt;5) + &quot;&lt;br/&gt;&quot;);//false &amp;&amp;与 document.write((2&gt;3||2&lt;5) + &quot;&lt;br/&gt;&quot;);//true ||或 document.write(!(2&gt;3&amp;&amp;2&lt;5) + &quot;&lt;br/&gt;&quot;);//true !非 //隐式转换：-/*% ++ -- (其他类型转number), ！(转为布尔型取反) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2 JS流程控制 JS中流程控制是if判断和switch选择 栗子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS流程控制&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //if判断 var food = &quot;山竹&quot;; if(food == &quot;dinner&quot;) &#123; document.write(&quot;真饱！&quot;); &#125; else if(food == &quot;山竹&quot;)&#123; document.write(&quot;我吃了，但没吃饱！&quot;); &#125; else&#123; document.write(&quot;好饿！&quot;); &#125; //简化写法 var a = 1; a&gt;1?console.log(a+1):console.log(a+3);//表达式?为真的值:为假的值; //switch选择 var day = 1; switch(day)&#123; case 1: document.write(&quot;今天星期一&quot;); break;//如果不加break;会一直运行到有break的地方，或default结束 case 2: document.write(&quot;今天星期二&quot;); break; case 3: document.write(&quot;今天星期三&quot;); break; case 4: document.write(&quot;今天星期四&quot;); break; case 5: document.write(&quot;今天星期五&quot;); break; case 6: document.write(&quot;今天星期六&quot;); break; case 7: document.write(&quot;今天星期日&quot;); break; &#125; var sex = &quot;girl&quot;; switch(sex)&#123; case &quot;girl&quot;: document.write(&quot;她是女孩。&quot;); break; case &quot;boy&quot;: document.write(&quot;他是男孩。&quot;); break; default: document.write(&quot;写错啦！&quot;); &#125; //break 关键字 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3 JS循环 for循环 for(initialize; test; increment)&#123; statment &#125; JS中的for循环相当于while的简写，更加方便 while循环 while (expression)&#123; statement &#125; while是一个基本的循环语句，expression为真的时候，就会执行循环体 do…while循环 do…while和while类似，只是会先执行一个循环 for in语句 JS中的for也支持类似于python中的用法，可以遍历对象所有的属性。 栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS循环&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //for循环（先判断再执行） //声明循环变量，判断循环条件，更新循环变量 for(var i=1; i&lt;=10; i++)&#123; document.write(&quot;我是&quot; + i + &quot;号&lt;br/&gt;&quot;); &#125; for(var i=1;i&lt;=10;i++) &#123; if(i==6)&#123; continue;//跳出本次循环，继续下次循环 &#125; document.write(&quot;我是&quot; + i + &quot;号&lt;br/&gt;&quot;); &#125; //while循环（先判断再执行） var i = 1; while(i&lt;=5)&#123; document.write(i + &quot;&lt;br/&gt;&quot;); i++; &#125; //do...while循环（先执行再判断） var i = 1; do&#123; document.write(i + &quot;&lt;br/&gt;&quot;); i++; &#125;while(i&lt;1); //for in 语句 var array = [1,2,3,4,5];//数组即Python中的列表 for(var i in array)&#123; document.write(i + &quot; &quot;,array[i] + &quot;&lt;br/&gt;&quot;)//i接收的对应元素的下标 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.4 JS字符串方法 length 长度；slice 切片；substring 截取 indexOf 索引；split 分割；replace 替换 栗子： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS字符串方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var str = &quot;hello world!&quot; //str[0] = &#x27;a&#x27;; //同样字符串不可更改 console.log(str.length);//长度 console.log(str.slice(1, 4));//切片，从下标1切到下标4 [1,4) console.log(str.substring(1, 4));//截取，从下标1切到下标4 [1,4) //切片不会自动比较参数的大小，截取会比较参数的大小，都是左闭右开 //str.slice(4, 1)/str.substring(4, 1) console.log(Object.key(str));//查看对象的方法&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.5 数组方法 length 长度；push 追加；unshift 添加 pop,shift 删除；indexOf 查找 改：slice 切片, join 拼接, sort 正向排序, reverse 反向无排序 栗子： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;数组方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var array = [&quot;橘子&quot;,&quot;苹果&quot;,&quot;香蕉&quot;,&quot;栗子&quot;]; array[1] = &quot;葡萄&quot;; console.log(array.length);//长度 console.log(array.slice(1, 3));//切片，左闭右开 var arr = [&#x27;a&#x27;,&#x27;c&#x27;,&#x27;b&#x27;,&#x27;g&#x27;,&#x27;d&#x27;]; console.log(arr.reverse());//反向，无排序 // console.log(arr.sort());//正向排序 console.log(array.join(&#x27;-&#x27;));//拼接&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.6 JS循环练习 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var oli = document.querySelectorAll(&quot;ul li&quot;);//获取元素 4个li // console.log(oli); //从Nodelist类数组中取出4个li元素 for(var i=0; i&lt;oli.length;i++)&#123; oli[i].onclick = function ()&#123;//点击对应的元素弹出对应的文本内容 //alert(this.innerText);//获取元素自身的文本内容 alert(i);//获取下标但全都变成4 -&gt; 作用域问题 //JS里面for循环是没有块级作用域概念，即局部作用域/局部变量 //因为没有此概念，因此它是一个全局变量的i //全局变量的i，当循环的时候for循环执行到另外一个事件的时候，循环里面正常 // 获取i的值，当循环进到事件里面之后此地方的i是for循环第一个不符合条件的值4 &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解决alert(i);的办法: 解决办法1： var定义的全局变量i 换成局部变量 let 解决办法2：利用index_num存储下标值 12345678910&lt;script&gt; var oli = document.querySelectorAll(&quot;ul li&quot;);//获取元素 4个li //解决办法1： var定义的全局变量i 换成局部变量 let for(let i=0; i&lt;oli.length;i++)&#123; oli[i].onclick = function ()&#123;//点击对应的元素弹出对应的文本内容 alert(i);//获取下标 &#125; &#125;&lt;/script&gt; 123456789101112&lt;script&gt; var oli = document.querySelectorAll(&quot;ul li&quot;);//获取元素 4个li for(var i=0; i&lt;oli.length;i++)&#123; // 解决办法2：利用index_num存储下标值 oli[i].index_num = i; oli[i].onclick = function ()&#123;//点击对应的元素弹出对应的文本内容 alert(this.index_num);//读取的是循环里面提前存的0,1,2,3，不是事件存的 &#125; &#125; &lt;/script&gt; 3.进阶 3.1 JS的内置对象 JS内部已经内置了不少对象，类似于Python中的内置模块，可以直接使用，并且对象一般不需要导入，可以直接使用。 Math对象是一个处理数学相关的对象，可以用来执行在数学相关的内容 12345678910Math.sqrt(4)//开方 Math.abs(-7)//绝对值 Math.PI//π Math.pow(2, 2)//幂运算 x^y Math.round(3.6)//取整 4 四舍五入 Math.ceil(3.4)//向上取整 4 Math.floor(3.6)//向下取整 3 Math.max(3, 1, 7, 9)//求最大值 Math.min(2, 1, 5, 6)//求最小值 Math.random()//随机数：默认[0-1] 1234//自定义随机数范围 console.log(Math.random());//随机数：默认[0-1] console.log(Math.random()*100);//[0,100] console.log(Math.round(Math.random()*100));//取[0,100]整数 日期对象也是常用对象之一，基本和常用的方法都是需要了解和熟悉 12345678910111213//定义一个日期对象 var today = new Date();//本机电脑的时间，不是网络时间 var year = today.getFullYear();//获取年 var month = today.getMonth();//获取月：国外月份从零开始 var date = today.getDate();//获取日 var day = today.getDay();//获取星期 var hour = today.getHours();//获取小时 var min = today.getMinutes();//获取分钟 var sec = today.getSeconds();//获取秒 //变量合并 document.write(&quot;现在是北京时间：&quot;+year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec+&quot;&lt;br/&gt;&quot;) 12345678910//时间戳 //从1970年到现在时间的总秒数，相当于生活中的密码锁 //当你生成一个新的区块的时候，这个时间戳会按照时间的顺序去反复生成一个对应的数据化的密码。 //如果有黑客想要攻击网站或软件时候，不仅仅需要获取对应这个区块的系统资料还需要破解每一个时间戳所生成的记录 //时间戳用来记录数据的一些关键的时间点，保障数据的一些安全性 //时间戳：1000ms = 1s var timestan = Date.now();//获取时间戳 document.write(timestan);//ms为单位 //可以网上进行转换 栗子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS的内置对象&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //数学对象 console.log(Math.sqrt(4));//开方 console.log(Math.abs(-7));//绝对值 console.log(Math.PI);//π console.log(Math.pow(2, 2));//幂运算 x^y console.log(Math.round(3.6));//取整 4 四舍五入 console.log(Math.ceil(3.4));//向上取整 4 console.log(Math.floor(3.6));//向下取整 3 console.log(Math.max(3, 1, 7, 9));//求最大值 console.log(Math.min(2, 1, 5, 6));//求最小值 console.log(Math.random());//随机数：默认[0-1] console.log(Math.random()*100);//[0,100] console.log(Math.round(Math.random()*100));//取[0,100]整数 //日期对象 //定义一个日期对象 var today = new Date();//本机电脑的时间，不是网络时间 console.log(today); var year = today.getFullYear(); console.log(year); var month = today.getMonth(); console.log(month);//国外月份从零开始 var month = today.getMonth()+1; console.log(month); var day = today.getDay();//获取星期 console.log(day); var date = today.getDate();//获取日 console.log(date); var hour = today.getHours(); console.log(hour); var min = today.getMinutes(); console.log(min); var sec = today.getSeconds(); console.log(sec); //变量合并 document.write(&quot;现在是北京时间：&quot;+year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec+&quot;&lt;br/&gt;&quot;) //时间戳 从1970年到现在时间的总秒数，相当于生活中的密码锁 //当你生成一个新的区块的时候，这个时间戳会按照时间的顺序去反复生成一个对应的数据化的密码。 //如果有黑客想要攻击网站或软件时候，不仅仅需要获取对应这个区块的系统资料还需要破解每一个时间戳所生成的记录 //时间戳用来记录数据的一些关键的时间点，保障数据的一些安全性 //时间戳：1000ms = 1s var timestan = Date.now(); document.write(timestan);//ms为单位 //可以网上进行转换&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.2 JS的Window对象 Window对象是所有客户端JS特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符window来引用它。 Window对象定义了一些属性和方法，比如：alert()方法、非常重要的document属性等 计时器就是Window中的一个方法，可以用来实现计时的一些操作。 定时器的使用 12345678910//创建定时器 //setTimeout在指定的时间后仅执行一次 setTimeout(function ()&#123; console.log(123); &#125;,1000);//毫秒为单位 //setInterval以指定时间为周期循环执行 setInterval(function ()&#123; console.log(321); &#125;,1000); 1234567891011//清除定时器 //先通过一个变量接收 var timer1 = setTimeout(function ()&#123; console.log(123); &#125;,1000); clearTimeout(timer1); var timer2 = setInterval(function ()&#123; console.log(321); &#125;,1000); clearInterval(timer2); 定时器可以实现定时操作，并且通过window对象来实现跳转操作 windows的使用 1234567//打开一个新窗口var w = window.open();//创建一个空白窗口var w = window.open(&quot;demo.html&quot;,&quot;haha&quot;,&quot;width=300,height=200&quot;);//第三个参数非标准，html5规范也主张浏览器忽略它w.alert(&quot;hello!&quot;);//弹出框w.location = &quot;https://www.bilibili.com/&quot;;//跳转新页面的传统方式w.close();//关闭窗口 3.3 JS的函数 JS 的函数包裹在花括号当中，使用关键词function来定义。函数可以挂载在一个对象上，作为一个对象的属性，称为对象的方法。 JS函数特性：在JS中，函数即对象，程序可以随意操控它们。比如，JS可以把函数赋值给变量，或者作为参数传递给其他的函数，甚至可以设置属性，调用它们的方法。 JS有名函数和匿名函数 有名函数：有名字的函数，使用时是：函数名加上括号执行，充当时间函数执行 匿名函数：没有名字的函数，匿名函数不能单独出现，一般充当事件函数，比如点击事件调用的函数 12345678910//有名函数 function func()&#123; console.log(1);//打印一个1 &#125; func();//函数调用//匿名函数 document.onclick = function ()&#123; console.log(2);//事件触发调用 &#125; 函数的参数/传参 形参，实参，不定参数 12345678910//x为形参（形式参数），3为实参（实际参数） function func(x)&#123; console.log(x); &#125; func(3); function sum(x,y)&#123; console.log(x + y); &#125; sum(1,7); 123456789101112131415161718192021//不定参数（不定长参数） function add(x,y)&#123; console.log(x, y); console.log(arguments);//不定长参数:统一获取，有多少拿多少 &#125; add(1); add(2,3); add(1,2,3); //add(1); 1 undefined //获取不定长参数arguments中的值 function add1()&#123; // console.log(arguments); for(var i=0; i&lt;arguments.length;i++) &#123; console.log(arguments[i]);//数组值 &#125; for(var i in arguments)&#123; document.write(i);//索引值 &#125; &#125; add1(1,3,5,7,9); 函数的分类 功能性函数，返回性函数 1234567//功能性函数 //无返回值，得到的结果为undefined // alert(1); var a = alert(1);//定义一个变量无值传入 console.log(a);//undefined var b = console.log(2); console.log(b); 1234567891011121314151617181920212223242526//返回性函数 //有返回值，所以会返回结果 var oBox = document.querySelector(&quot;div&quot;); console.log(oBox);//&lt;div&gt;&lt;/div&gt; //自定义一个函数 function func1()&#123; console.log(8); &#125; var a = func1();//8 console.log(a);//undefined function func2()&#123; console.log(1); return &quot;我返回了&quot;; &#125; var a = func2();//1 console.log(a);//我返回了 //return返回后的函数不会执行 function func3()&#123; console.log(7); return &quot;我返回了&quot;; console.log(3); &#125; var a = func3();//7 console.log(a);//我返回了 函数的作用域 全局作用域，函数作用域，块级作用域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//在函数内部不使用var声明的变量都会成为全局变量//在函数内部使用var声明的变量是局部变量var a = 100;function func() &#123; var a = 200; alert(a);&#125;alert(a);//100func();//200alert(a);//100var a = 100;function func() &#123; // var a = 200; a = 200; alert(a);&#125;alert(a);//100func();//200alert(a);//200var a = 100;function func1() &#123; var a = 200; function func2() &#123; var a = 300; &#125; func2(); alert(a);&#125;alert(a);//100func1();//200alert(a);//100var a = 100;function func1() &#123; var a = 200; function func2() &#123; a = 300; //子作用域只能改变父作用域的值，不能向上改变 &#125; func2(); alert(a);&#125;alert(a);//100func1();//300alert(a);//100 1234567891011121314//推荐用let，块级作用域的变量 &#123; var i = 1; &#125; console.log(i); &#123; //块级作用域/局部作用域 //只在花括号内部有效 let j = 2; console.log(j); &#125; // console.log(j);报错 自定义函数 ~ + - ！() 123456789~function ()&#123; console.log(1); &#125;(); +function ()&#123; console.log(1); &#125;(); -function ()&#123; console.log(1); &#125;(); 栗子： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS函数&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;script&gt; var oBox = document.getElementsByTagName(&quot;div&quot;); function func()&#123; alert(1); &#125;; oBox.onclick = func;//当作点击事件时，不能加上括号&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.4 JS异常 写代码会出现或多或少的错误，而出现错误就会终止代码的运行；能不能在可能出现错误的代码它不出现错误或执行自己写的错误 提供一些异常处理机制，具有一部分异常恢复能力 123456789try&#123; //先执行这里，没有问题的话就会执行完成&#125;catch(e)&#123; //如果输入不合法，将执行这里的逻辑 alert(e);//告诉用户产生了什么错误 throw new Error(&quot;太胖了！&quot;);//或者自定义错误&#125;finally&#123; //不管是否抛出异常，都会执行&#125; 栗子： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS异常&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=&quot;btn&quot; onclick=&quot;func()&quot;&gt;点我&lt;/button&gt;&lt;script&gt;//正确代码：// function func() &#123;// var num = 123;// alert(&quot;我是&quot;+num);// &#125; function func() &#123; //var num = 123; try&#123; alert(&quot;我是&quot;+num); &#125;catch(e)&#123; alert(&quot;错误类型：&quot;+e.name+&quot; 错误信息：&quot;+e.message); &#125;finally &#123; alert(&quot;我已经执行完毕&quot;); &#125; &#125; //捕获异常 function func() &#123; var num = 123; try&#123; if(num&lt;100)throw &quot;太小了&quot;; if(num==100)throw &quot;刚昂好&quot;; if(num&gt;100)throw &quot;太大了&quot;; //e接受throw里的信息 &#125;catch(e)&#123; alert(e); &#125;finally &#123; alert(&quot;我已经执行完毕&quot;); &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4.练习","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://zhang0224gz.github.io/tags/Web/"}]},{"title":"数据库第三章","slug":"笔记/数据库","date":"2022-05-01T11:34:02.458Z","updated":"2022-06-15T04:24:34.764Z","comments":true,"path":"2022/05/01/笔记/数据库/","link":"","permalink":"https://zhang0224gz.github.io/2022/05/01/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455CREATE SCHEMA `school`DEFAULT CHARACTER SET utf8COLLATE utf8_bin;-- CREATE DATABASE `school`;-- Drop DATABASE `school`;use school;create table `student`( `sno` char(10) not null primary key, `sname` varchar(45) not null , `sage` int null default 18, `sdept` varchar(45))COMMENT = &#x27;学生信息表&#x27;;drop table student;create table course( cno char(4) not null primary key, cname varchar(45) not null, -- 列级约束 cpno char(4) references cno, credit tinyint);-- drop table course;create table sc( sno char(10), cno char(4), score int, -- 表级约束 primary key (sno,cno), -- 约束限制：constraint关键字 constraint `fk_sno` foreign key(sno) references student(sno), foreign key(cno) references course(cno) -- 类型要一致，宽度要一致);drop table sc;问题：Error Code: 1822. Failed to add the foreign key constraint. Missing index for constraint &#x27;fk_sno&#x27; in the referenced table &#x27;student&#x27;MySQL报这个错时去检查外键设置！！！这个外键是不是另外一个表的主键设置外键的时候需要注意以下几点：（1）外键是用于两个表的数据之间建立连接，可以是一列或者多列，即一个表可以有一个或多个外键。（2）这个表里面设置的外键必须是另外一个表的主键！（3）外键可以不是这个表的主键，但必须和另外一个表的主键相对应（字段的类型和值必须一样）。（4）带有主键的那张表称为父表，含外键的是子表，必须先删除外键约束才能删除父表。所以：school生成表时忘记给sno加主键了。经过搜索暂没有法子直接修改数据为主键，故删表重写QAQ刚刚了解constraint约束，发现一个加主键的法子alter table student add constraint pk primary key (sno);格式为：alter table 表格名称 add constraint 约束名称 增加的约束类型 （列名） constraint `fk_sno` foreign key(sno) references student(sno)没有写名字系统会默认生成名字，如：sc_ibfk_1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071，根据内容划分2.根据作用域、作用范围划分域(列)完整性：域完整性是对数据表中字段属性的约束实体完整性在MySQL中实现：通过主键约束和候选键约束实现的参照完整性：也就是说是MySQL的外键3.根据声明语句的书写形式、约束声明的位置划分列级约束name varchar(20) default ‘老王’表级约束[constraint fk_name] foreign key(deptno) references dept(deptno) 所有的列都声明完了，再声明约束create table emp(empno int promary key auto_increment,ename varchar(32) not null,deptno int,[constraint fk_name] foreign key(deptno) references dept(deptno) – 添加外键约束);[]可选择内容，去掉id、name组合值不能重复，单一重复可通过constraint id_unique unique(id, name) – 添加复合约束练习代码：USE school;CREATE TABLE t1(#default:默认约束, 域完整性;指定某列的默认值，插入数据时候，此列没有值，则用default指定的值来填充id INT DEFAULT 1,#,写; : id INT DEFAULT 1;#错误代码： 1064#You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27; at line 2#错误代码： 1064#You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;name varchar(20) default &#x27;老王&#x27;)&#x27; at line 1NAME VARCHAR(20) DEFAULT &#x27;老王&#x27;);#插入操作INSERT INTO t1 VALUES (&#x27;haha&#x27;);#未要求要全部写入#错误代码： 1136#Column count doesn&#x27;t match value count at row 1INSERT INTO t1(id) VALUES (3);INSERT t1(NAME) VALUES (&#x27;haha&#x27;);#修改默认值ALTER TABLE t1 MODIFY id INT DEFAULT 4;ALTER TABLE t1 MODIFY NAME VARCHAR(20) DEFAULT &#x27;小白&#x27;;#删除默认值操作modify/changeALTER TABLE t1 MODIFY id INT;ALTER TABLE t1 CHANGE NAME NAME VARCHAR(20);#查询内容SELECT * FROM t1;CREATE TABLE t2(#not null: 非空约束，域完整性;指定某列的值不为空，在插入数据的时候必须非空 ‘’ 不等于 null, 0不等于 nullid INT NOT NULL,NAME VARCHAR(20) NOT NULL);#插入操作INSERT t2(id) VALUES (2);#错误代码： 1364#Field &#x27;name&#x27; doesn&#x27;t have a default valueINSERT t2(NAME) VALUES (&#x27;小花&#x27;);#错误代码： 1364#Field &#x27;id&#x27; doesn&#x27;t have a default valueINSERT t2 VALUES (3,&#x27;小华&#x27;),(5,&#x27;小黑&#x27;);#添加not null约束#1.建表时#2.alter语句添加:alter…modify/change…ALTER TABLE t2 MODIFY id INT NOT NULL;ALTER TABLE t2 MODIFY NAME VARCHAR(20) NOT NULL;#删除约束：alter…modify/change…ALTER TABLE t2 MODIFY id INT;ALTER TABLE t2 CHANGE NAME NAME VARCHAR(10);#alter完全修改内容SELECT * FROM t2;CREATE TABLE t3(#unique: 唯一约束，实体完整性；指定列或者列组合不能重复，保证数据的唯一性；不能出现重复的值，但是可以有多个null；同一张表可以有多个唯一的约束id INT UNIQUE,NAME VARCHAR(20));#插入操作INSERT t3(id) VALUES (2);INSERT t3(NAME) VALUES (&#x27;小花&#x27;);INSERT t3 VALUES (3,&#x27;小华&#x27;),(5,&#x27;小黑&#x27;);#内容重复输入INSERT t3 VALUES (3,&#x27;小华&#x27;),(5,&#x27;小黑&#x27;);#错误代码： 1062#Duplicate entry &#x27;3&#x27; for key &#x27;t3.id&#x27;#添加约束ALTER TABLE t3#删除约束ALTER TABLE t3 DROP INDEX id_unique;DROP id ON t3;SELECT * FROM t3; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#SQL：结构化的查询语言#交互式SQL，嵌入式SQL#select 目标表达式列表#from 目标关系列表#where 目标条件列表 -&gt; 条件子句#order by 排序子句#group by 分组子句#一、单表查询#一个for语句遍历所有的行#数据库中第三种状态：除了真假，还有未知#目标列查询 *,col1,col2#目标表达式列表 重命名 数学表达式函数use school;select * from student;select sno,sname from student;#重命名select sno as &#x27;学号&#x27;, sname as &#x27;姓名&#x27; from student;#as和单引号可省略，单引号使用防止字符有空格select sno 学号,sname as &#x27;姓 名&#x27; from student;select 2022-sage &#x27;出生年份&#x27; from student;#不加&#x27;出生年份&#x27;以&#x27;2022-sage&#x27;作为列名select 2022-sage from student;select cno from course;#可跟函数select lower(cno) from course;select upper(cno) from course;#聚集函数/统计查询select count(*) from student;select count(*) as &#x27;班级人数&#x27; from student;#单条件查询whereselect sno,sname,ssex from student where ssex=&#x27;女&#x27;;select sno,sname,ssex,sage from student where sage&lt;=30 and ssex=&#x27;男&#x27;;select sno,sname,ssex,sage from student where sage&lt;=30 or ssex=&#x27;男&#x27;;#&#x27;男&#x27;不要加空格,虽然有些软件可以自动去两边空格,仅侥幸select * from student where sdept=&#x27;计算机系&#x27; or sdept=&#x27;历史系&#x27;;#减短查询：查询集合inselect * from student where sdept in (&#x27;计算机系&#x27;,&#x27;音乐系&#x27;,&#x27;历史系&#x27;);select * from student where sage&gt;=23 and sage&lt;25;#[23,25)select * from student where not sage&gt;=23 and sage&lt;25;select * from student where sage between 23 and 25;#并，闭区间[23,25]，多条件无法实现 #一个for语句遍历所有的行，where为真true才被选中#数据库中第三种状态：除了真假，还有未知select * from course;select * from course where not cpno=&#x27;C001&#x27;; #为空未被选中select * from course where cpno!=&#x27;C001&#x27;; select * from course where cpno=null;#无法比较……得到未知select * from course where cpno is null;select * from course where cpno is not null;#方式一select * from course where not (cpno is null);#方式二#只限制前三条查询：起始下标0,偏移量3（网页分页查询使用）select * from student where ssex=&#x27;男&#x27; limit 0,3;#所有的人按系科排序（默认：升序排序asc）-&gt; 字符集utf8 排序规则utf8_binselect * from student order by sdept desc;select * from student order by sdept desc, sage asc;#放最后执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#单表查询的分组聚集查询#select 目标表达式列表 from 目标关系列表 where 目标条件列表 group by 分组条件列表(方便计算) order by 排序列列表(排序所依赖的列，方便看，最后一个子句)select * from course where cpno=null;#where子句只认后面结果是否为真，null不管在哪是不是空和任何数据得到结果都是不知道，无法比较 select * from course where cpno is null;select * from course where not(cpno is null);select lower(cno),cname from course;select * from student order by sdept asc, sage desc;#1.coubt(*)记得元祖的数目(整个行)，2.某个分量里出现的个数(某一列)select count(*) from student;select count(*) from student where ssex=&#x27;男&#x27;;select count(ssex) from student where ssex=&#x27;女&#x27;;#没去重，记了两次 -&gt; distinctselect count(distinct ssex) from student where ssex=&#x27;女&#x27;;select count(distinct ssex) from student;select * from course order by cpno asc;#升序排列空值放最上面,可能作为最小值看待 #聚集查询/统计查询select count(*) as &#x27;人数&#x27;, max(sage) as &#x27;最大年龄&#x27;, min(sage) as &#x27;最小年龄&#x27;, sum(sage), avg(sage) from student;#正常，更多都是用在分组统计#空值统计是不在内的select cpno, count(*) from course group by cpno;#询问：空值怎办？是否有一个专有的分组？ 分组和排序,空值都算在内 (空值作为一个具体的值也参与分组,只是计数,但不能进行计算:求平均值...)select count(*) as &#x27;人数&#x27;, max(sage) as &#x27;最大年龄&#x27;, min(sage) as &#x27;最小年龄&#x27;, sum(sage), avg(sage) from student where ssex=&#x27;男&#x27;;select sdept, count(*) as &#x27;人数&#x27;, max(sage) as &#x27;最大年龄&#x27;, min(sage) as &#x27;最小年龄&#x27;, sum(sage), avg(sage) from student group by sdept;#对分组进行筛选#where是对元祖进行筛选，having是对分组进行筛选（具体的值），无太大差别（having必须在group by后面用，可以使用聚集函数count(*)&gt;=2）select sdept, count(*) as &#x27;人数&#x27;, max(sage) as &#x27;最大年龄&#x27;, min(sage) as &#x27;最小年龄&#x27;, sum(sage), avg(sage) from student group by sdept having count(*)&gt;=2;select sdept,avg(sage) as &#x27;平均年龄&#x27; from student where ssex=&#x27;男&#x27; group by sdept having avg(sage)&gt;=22;#可以使用别名进行筛选，&#x27;平均年龄&#x27;&gt;=22当成字符串和22比较 -&gt; 平均年龄&gt;=22select sdept,avg(sage) as &#x27;平均年龄&#x27; from student where ssex=&#x27;男&#x27; group by sdept having 平均年龄&gt;=22;#名字里含有空格加 ``(用于表名，列名)select sdept,avg(sage) as &#x27;平 均 年 龄&#x27; from student where ssex=&#x27;男&#x27; group by sdept having `平 均 年 龄`&gt;=22;#单表查询的模糊查询 likeselect * from student where sname like &quot;刘%&quot;; # %：0个或多个字符 select * from course where cname like &#x27;%C语言%&#x27;; #对大小写敏感Ccselect * from student where sname like &#x27;诸葛_&#x27;; #一个 _ 表示一个字符#内容就含有%和_:替代别人的功能卸载掉 \\% 或 \\_select * from course where cname like &#x27;\\%C语言%&#x27;;#若\\也作为内容,使用\\\\表示内容,利用ESCAPE寻找其它字符赋予其\\的功能select * from course where cname like &#x27;1%C语言%&#x27; escape &#x27;1&#x27;;#用的比较少好，一般用正则表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#多表查询#1.连接查询#最简单链接：笛卡尔积(交叉连接)cross join#内连接inner join...on:一般连接，等值连接，自然连接(公共属性上的等值连接)nature join#外连接：左外连接left join...on，右外连接right join...on，全外连接full join#2.嵌套查询:不相关子查询(干完就跑路)、相关子查询(交错互通，内层查询都要看一下外层查询，外层查询都要看一下内层查询)#不相关子查询(干完就跑路) in(…)#一个值 ‘=’；多个值 ‘in&#x27;或&#x27;=ANY&#x27;#sname&lt;&gt;&quot;刘备&quot; : 不包括刘备#&quot;&gt; ALL&quot; == &gt; max 大于所有的#&quot;&gt; ANY&quot; == &gt;min 大于某一个 P92#3.集合查询待续……use school;#单表查询 9&#x27;：#简单查询、条件查询、空值查询(is null/is not null)、#between and、count(*) min(*)，目标表达式(列名、重名、运算、函数)、#分组查询(group by...having)、模糊查询(like，escape，&quot;\\\\&quot;)、排序字句(order by...asc/desc)#select 目标表达式列表 from 目标关系列表 where 目标条件列表(and,or,not分割) group by 分组列 order by 排序依据列+排序方式select * from sc;select sno from sc where cno=&quot;C003&quot;;#找出选修C001也选修C003的同学学号select sno,cno from sc where cno=&quot;C001&quot; and cno=&quot;C003&quot;;#错的(select sno,cno from sc where cno=&quot;C001&quot;) union (select sno,cno from sc where cno=&quot;C003&quot;);select sno from sc where cno=&quot;C001&quot; and sno in (select sno from sc where cno=&quot;C003&quot;);select sc.sno,sname,sc.cno,cname,grade from student,course,sc where student.sno=sc.sno and sc.cno=course.cno and sc.cno=&quot;C003&quot;;#多表查询#1.连接查询select * from student,sc where student.sno=sc.sno;select sno,sname from student,sc where student.sno=sc.sno and cno=&quot;C003&quot;;#Error Code: 1052. Column &#x27;sno&#x27; in field list is ambiguousselect student.sno,sname from student,sc where student.sno=sc.sno and cno=&quot;C003&quot;;select sc.sno,sname from (student inner join sc on student.sno=sc.sno) where cno=&quot;C003&quot;;#最简单链接：笛卡尔积(交叉连接)cross joinselect * from student,sc;select * from student cross join sc;#内连接inner join...on:一般连接，等值连接，自然连接(公共属性上的等值连接)nature join,select * from student inner join sc;select sc.sno,sname from (student inner join sc on student.sno=sc.sno) where cno=&quot;C003&quot;;select * from student natural join sc;#只剩一行snoselect * from student natural join student;#Error Code: 1066. Not unique table/alias: &#x27;student&#x27;select * from student A natural join student B;#自己与自己自然连接，先相等再去掉一份#外连接：左外连接left join...on，右外连接right join...on，全外连接full joinselect * from student left join sc on student.sno=sc.sno;select * from sc right join student on student.sno=sc.sno;select * from student full join sc on student.sno=sc.sno;#Error Code: 1054. Unknown column &#x27;student.sno&#x27; in &#x27;on clause&#x27;select * from student full join sc ;#2.嵌套查询:不相关子查询(干完就跑路)、相关子查询(交错互通，内层查询都要看一下外层查询，外层查询都要看一下内层查询)#不相关子查询(干完就跑路)select sno,sname from student wheresno in (select cno from sc where cno=&quot;C003&quot;);select sname from student where sdept=(select sdept from student where sname=&quot;刘备&quot;);#一个值 ‘=’；多个值 ‘in&#x27;或&#x27;=ANY&#x27;select sname from student where sname&lt;&gt;&quot;刘备&quot; and sdept=(select sdept from student where sname=&quot;刘备&quot;);#sname&lt;&gt;&quot;刘备&quot; 不包括刘备select * from student where sdept&lt;&gt;&quot;计算机系&quot; and sage&gt;ANY (select sage from student where sdept=&quot;计算机系&quot;);#&quot;&gt; ALL&quot; == &gt; max 大于所有的#&quot;&gt; ANY&quot; == &gt;min 大于某一个 P92#3.集合查询(select sno,cno from sc where cno=&quot;C001&quot;) union (select sno,cno from sc where cno=&quot;C003&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#SQL查询 select#一、单表查询#1.目标查询 from#2.条件查询 where#3.分组查询 group by#4.排序查询 order by#二、多表查询#1.连接查询 cross join#2.嵌套查询#（1）不相关子查询#（2）相关子查询 EXISTS#3.集合查询 use school;select * from student;#连接查询select b.* from student a,student b where a.sname=&#x27;刘备&#x27; and b.sname&lt;&gt;&quot;刘备&quot; and a.sdept=b.sdept;select * from student a,student b where a.sname=&#x27;刘备&#x27; and b.sname&lt;&gt;&quot;刘备&quot; and a.sdept=b.sdept;#不相关子查询select sdept from student where sname=&quot;刘备&quot;;select * from student where sname&lt;&gt;&quot;刘备&quot; and sdept=(select sdept from student where sname=&quot;刘备&quot;);#相关子查询select * from student X where X.sname&lt;&gt;&quot;刘备&quot; and EXISTS(select * from student Y where Y.sname=&quot;刘备&quot; and Y.sdept=X.sdept);#EXISTS 存在谓词：只要有返回值就为真select * from sc where sno=&#x27;202006001&#x27; and cno=&#x27;C003&#x27;;select sname from student where EXISTS (select * from sc where sno=student.sno and cno=&#x27;C003&#x27;);#m*nselect sname from student,sc where student.sno=sc.sno and cno=&#x27;C003&#x27;;select sname from student where sno in (select sno from sc where cno=&#x27;C003&#x27;);#m+n#最难最重要: 存在谓词表达全部和否定select sname from student,sc where student.sno=sc.sno and cno&lt;&gt;&#x27;C003&#x27;;#错误！！！select sname from student where sno not in (select sno from sc where cno=&#x27;C003&#x27;);#m+nselect * from course where not exists(select * from sc where sno=&#x27;202006001&#x27; and cno=course.cno);select * from course where exists(select * from sc where sno=&#x27;202006001&#x27; and cno=course.cno);#查询选修了全部课程的学生的信息 等价于 不存在一门课该学生没有选修select sno,sname from student where not exists(select * from course where not exists(select * from sc where student.sno=sc.sno and sc.cno=course.cno));select sno,sname from student where not exists(select * from course where cpno=&#x27;C003&#x27; AND not exists(select * from sc where student.sno=sc.sno and sc.cno=course.cno));#查询选修了【202006001选修的课】全部课程的学生信息 等价于 不存在这么一门课，刘备选了而你没有选select sno from sc A where not exists(select * from sc B where B.sno=&#x27;202006001&#x27; and not exists(select * from sc C where B.cno=C.cno and A.sno=C.sno));#查询选修了【202006001选修的课】全部课程的学生信息 等价于 不存在这么一门课，刘备选了而你没有选(distinct去重）select distinct sno from sc A where not exists(select * from sc B where B.sno=&#x27;202006001&#x27; and not exists(select * from sc C where B.cno=C.cno and A.sno=C.sno)); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290USE school;DELIMITER $$ CREATE PROCEDURE insert_student( p_sno CHAR(10), p_sname VARCHAR(50), p_sex VARCHAR(1), p_age INT, p_dept VARCHAR(20) )BEGIN # 声明变量info，以表明插入是否成功。 DECLARE info VARCHAR(20) DEFAULT &#x27;插入成功&#x27;; # 异常处理 DECLARE CONTINUE HANDLER FOR 1062 SET info=&#x27;插入失败，不能插入重复的数据&#x27;; INSERT INTO student VALUES(p_sno,p_sname,p_sex,p_age,p_dept); SELECT info;END $$ DELIMITER ;SET @sno=&#x27;202006012&#x27;;SET @sname=&#x27;魏延&#x27;;SET @ssex=&#x27;男&#x27;;SET @sage=25;SET @sdept=&#x27;计算机系&#x27;;SET @sno=&#x27;202006012&#x27;;SET @sname=&#x27;甄宓&#x27;;SET @ssex=&#x27;女&#x27;;SET @sage=32;SET @sdept=&#x27;汉语言系&#x27;;CALL insert_student(@sno,@sname,@ssex,@sage,@sdept);SELECT * FROM student;#系统变量，用户自定义变量，局部变量select @@version;#delimiter双$符号的作用#插入一个相同学号的同学#插入一个超出字符限制的数据#区别和联系#存储过程使用call,可返回好多输出变量，作为一句话调用#函数不用call调用，写上就可以得到值，可以作为表达式一部分#触发器在满足特定条件下才能触发#游标#创建存储过程delimiter $$create procedure proc01()begin select sname,sage from student;end $$delimiter ;call proc01;#定义局部变量: 用户自定义，在begin/end块中有效#declare var_name type [default var_value];delimiter $$create procedure proc02()begin declare tname varchar(20) default &quot;student&#x27;s name&quot;; -- declare tname varchar(5) default &quot;student&#x27;s name&quot;; set tname = &#x27;Yangyang&#x27;; select tname;end $$delimiter ;call proc02();#Error Code: 1406. Data too long for column &#x27;tname&#x27; at row 1drop procedure proc02;#用户变量：用户自定义，不需要提前声明，使用及声明；可在begin/end块外有效(外部也可以使用用户变量)# @var_namedelimiter $$create procedure proc03()begin set @tname = &#x27;potato&#x27;; select @tname;end $$delimiter ;call proc03();select @tname;#系统变量分为全局变量和会话变量# @@global.var_name#全局变量在MYSQL启动的时候由服务器自动将他的初始化为默认值#会话变量在每次建立一个新的连接的时候,由MYSQL来初始化,MYSQL会将当前所有全局变量的值复制一份,来作为会话变量#全局变量的修改会影响整个服务器,但是对会话变量的修改,只会影响到当前的会话(也就是当前的数据库连接)#可以更改的系统变量,我们可以利用set语句进行更改show global variables;-- 查看全局变量select @@sort_buffer_size;-- 查看某全局变量set @@sort_buffer_size = 50000;-- 修改全局变量的值set global sort_buffer_size = 100000;select @@sort_buffer_size;#存储过程传参#in表示传入的参数,可以传入数值或者变量,即使传入变量,并不会改变变量的值,可以内部更改,#仅仅作用在函数范围内delimiter $$create procedure proc04(in miniage int,in maxage int)begin select * from student where sage&gt;miniage and sage&lt;maxage;end $$delimiter ;drop procedure proc04;call proc04(22,30);#out表示从存储过程内部传值给调用者delimiter $$create procedure proc05(in in_sage int, out out_sname varchar(45))begin select sname into out_sname from student where sage=in_sage;end $$delimiter ;call proc05(22,@out_res);select @out_res;#inout表示从外部传入的参数经过修改后可以返回的变量,既可以使用传入变量的值#也可以修改变量的值(即使函数执行完)delimiter $$create procedure proc06(inout num int)begin set num = num*10;end $$delimiter ;set @inout_num = 2;call proc06(@inout_num);select @inout_num;#流程控制-判断#if...then...;#elseif...then...;#end if;#判断IF语句包含多个条件判断,根据结果为TURE和FALSE执行语句,与编程语言中的if、else if、#else语法类似delimiter $$create procedure proc07(in score int)begin if score&lt;60 then select &#x27;不及格&#x27;; elseif score&gt;=60 and score&lt;80 then select &#x27;及格&#x27;; elseif score&gt;=80 and score&lt;90 then select &#x27;良好&#x27;; elseif score&gt;=90 and score&lt;=100 then select &#x27;优秀&#x27;; else select &#x27;成绩错误！&#x27;; end if;end $$delimiter ;set @score = 79;call proc07(@score);delimiter $$create procedure proc08(in in_name varchar(45))begin declare var_float decimal(7,2); -- 定义局部变量，7个长度，2个小数 declare res varchar(20); select sage into var_float from student where sname=in_name; if var_float&gt;25 then set res=&#x27;毕业了&#x27;; else set res=&#x27;在上学&#x27;; end if; select res;end $$delimiter ;call proc08(&#x27;刘备&#x27;);delimiter $$create procedure proc07(in score int)begin declare res varchar(45); if score&lt;60 then set res= &#x27;不及格&#x27;; elseif score&gt;=60 and score&lt;=100 then set res= &#x27;及格&#x27;; else set res= &#x27;成绩错误&#x27;; end if; select res as &#x27;成绩结果&#x27;;end $$delimiter ;drop procedure proc07;set @score=55;call proc07(@score);#流程控制-case#case... #when...then...;#else...;#end case;#CASE是另一个条件判断语句,类似于编程语言中的switch语法#语法一:当case后面的语句与when后面的语句相等时,则会执行then后面的语句,如果均不匹配则执行else#语法二:直接写case 当when后面的条件成立则执行then后面的语句,如果都不成立,则执行elsedelimiter $$create procedure proc08(in food varchar(45),in pay_type int)begin case &#x27;面包&#x27; when 1 then select &#x27;微信支付&#x27;; when 2 then select &#x27;支付宝支付&#x27;; else select &#x27;其他支付方式&#x27;; end case; case &#x27;饮料&#x27; when 1 then select &#x27;微信支付&#x27;; when 2 then select &#x27;支付宝支付&#x27;; else select &#x27;其他支付方式&#x27;; end case;end $$delimiter ;call proc08(&#x27;饮料&#x27;,2);#控制流程-循环#循环分类：while、repeate、loop#循环控制：leave 类似于break,跳出,结束当前所在的循环# iteater 类似于continue,继续,结束本次循环,继续下一次#label:while...do#...#if...then leave label;#end while lable;delimiter $$create procedure proc09(in insertCount int)begin declare i int default 1; label:while i&lt;=insertCount do insert into student(sno,sname) values(i,concat(&#x27;user-&#x27;,i)); set i=i+1;end while label;end $$delimiter ;drop procedure proc09;call proc09(10);delimiter $$create procedure proc10(in delCount int)begin declare i int default 1; label:while i&lt;=delCount do delete from student where sno=i; if i=5 then leave label; end if; set i = i+1; end while label;end $$delimiter ;drop procedure proc10;call proc10(10);#Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column. Cannot use range access on index &#x27;PRIMARY&#x27; due to type or collation conversion on field &#x27;sno&#x27; To disable safe mode, toggle the option in Preferences -&gt; SQL Editor and reconnect.#因为MySql运行在safe-updates模式下，该模式会导致非主键条件下无法执行update或者delete命令。可以通过以下SQL进行状态查询show variables like &#x27;SQL_SAFE_UPDATES&#x27;;SET SQL_SAFE_UPDATES = 0;#label:repeat#...;#until 条件表达式;#end repeat label;delimiter $$create procedure proc11(in insertCount int)begin declare i int default 1; label:repeat insert into student(sno,sname) values(i,concat(&#x27;user-&#x27;,i)); set i=i+1; until i&gt;insertCount end repeat label; select &#x27;循环结束&#x27;;end $$delimiter ;call proc11(10);#label:loop# ...# if 条件表达式 then leave label;# end if;# end loop label;delimiter $$create procedure proc12(in delCount int)begin declare i int default 1; label:loop delete from student where sno=i; set i=i+1; if i&gt;delCount then leave label; end if; end loop label;end $$delimiter ;drop procedure proc12;call proc12(10);#调用储存过程显示Error Code: 1305. PROCEDURE school.proc12 does not exist#1.首先考虑是否是此储存过程当真不在，查看当前存储过程，发现存储过程存在：#show procedure status;# 2.此时想到是用户没有当前存储过程的调用权限，赋予存储过程权限给当前用户，此时又出现了一个错误#GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;#ERROR 1133 (42000): Can&#x27;t find any matching row in the user table#通过查询资料发现，需要先将当前的存储过程刷新，再执行授权语句：#FLUSH PRIVILEGES;#GRANT ALL PRIVILEGES ON test.* TO &#x27;root&#x27;@localhost;#3.再执行调用此存储过程，显示成功调用","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"","slug":"笔记/操作系统/第二章","date":"2022-04-23T09:34:54.928Z","updated":"2022-06-01T10:11:25.612Z","comments":true,"path":"2022/04/23/笔记/操作系统/第二章/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/23/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"磁盘调度算法笔记–（FCFS、SSTF、SCAN、CSCAN） 为了减少对文件的访问时间，应采用一种最佳的磁盘调度算法。使各种进程对磁盘平均访问时间最小。由于在访问磁盘的事件中主要是寻道时间，因此，磁盘调度算法的目标是是磁盘的平均寻道时间最小。目前磁盘调度算法有以下几类： 1.先来先服务(FCFS)：根据进程请求访问磁盘的先后次序进行调度。 假设磁头的初始位置是100号磁道，有多个进程先后陆续的请求访问55，58，39，18，90，160，150，38，184号磁道 按照FCFS的规则，按照请求到达的顺序，磁头需要一次移动到55，58，39，90，160，150，38，184号磁道 磁头总共移动的磁道个数为45+3+19+21+72+70+10+112+146=498 平均寻道长度为498/9=55.3个磁道 优点：公平，性能还可以 缺点：如果有大量进程竞争使用磁盘，请求访问磁道很分散，则FCFS在性能上很差，寻道时间长。 最短寻道时间优先（SSTF）：其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，但这种调度算法却不能保证平均寻道时间最短。 假设磁头的初始位置是100号磁道，有多个进程先后陆续的请求访问55，58，39，18，90，160，150，38，184号磁道 按照SSTF的规则，请求到达的 ​ 磁头总共移动了（100-18）+（184-18）=248个磁道 平均寻道长度为248/9=27.5个磁道 优点：性能较好，平均寻道时间短 缺点：可能产生“饥饿”现象 扫描算法（SCAN）：当磁头正在由里向外移动时，SCAN算法所选择的下一个访问对象应是其欲访问的磁道，既在当前磁道之外，又是距离最近的。这样由里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向，由外向里移动。也叫电梯算法。 磁头总共移动了（184-100）+（184-18）=250个磁道 平均寻道长度为250/9=27.8个磁道 优点：性能较好，平均寻道时间短，不会产生饥饿现象 缺点：1，只有到最边上的磁道才能改变磁头的移动方向。2.SCAN对于各个位置磁道响应频率不平均。 循环扫描算法（CSCAN）：为了减少SCAN算法造成的某些进程的请求被严重推迟，CSCAN算法规定磁头单向移动。 磁头总共移动了（184-100）+（184-18）+（90-18）=322个磁道 平均寻道长度为322/9=35.8个磁道 优点：比起SCAN算法，对于各位置磁道的响应频率很平均。 缺点：只有到边上才能改变磁头移动方向，比起SCAN算法来，平均寻道时间更长。 进程同步与互斥是进程管理的重点，也是操作系统学科的一个难点。 具体包括:进程同步的基本概念、实现临界区互斥的基本方法(包括软件实现方法、硬件实现方法)、信号量(P、V操作)、管程、经典同步问题(包括生产者-消费者问题、读者-写者问题、哲学家进餐问题等)。我们一定要掌握P、V操作的概念、流程，以及P、V操作在同步问题、互斥问题中的应用。 首先,要求掌握进程的概念，其中进程和程序这两个概念的区别和联系一定要搞清楚。 第二,要记住进程的三个基本状态以及它们之间相互转换条件，一定要记住不可能从就绪状态直接转换到等待状态。 第三,需要理解进程控制和原语这两个概念，掌握进程的创建、撤销、阻塞、唤醒的条件，理解四种原语的执行过程。 第四,理解什么是并发进程间的直接制约以及由直接制约所引发的进程同步，重点要掌握如何用P、V原语操作实现同步问题，要会利用P、V原语操作来解决经典的同步问题； 第五,了解进程的通信方式及它们各自的特点； 第六,要理解进程和线程的异同以及多线程模型","categories":[],"tags":[]},{"title":"废的摄像头代码","slug":"智能车/废的代码","date":"2022-04-20T12:41:00.948Z","updated":"2022-07-17T08:29:27.395Z","comments":true,"path":"2022/04/20/智能车/废的代码/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/20/%E6%99%BA%E8%83%BD%E8%BD%A6/%E5%BA%9F%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//2022/07/17//最后一版的1.0，经过二十天的折磨终于实现大道至简了，我觉得这是反应最快的思路了#include &quot;headfile.h&quot;#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80uint8 threshold_max;uint8 mid_x,mid_y,pre_x,pre_y,temp_x,temp_y;uint16 n,count_noBeacon=0,zero=0;uint32 sum_x,sum_y;uint8 flag_stick=0,flag_beacon=1,flag_row=0;void camera(void)&#123; uint8 i,j,flag; flag=0; threshold_max = 180; sum_x=0,sum_y=0; n=0; pre_x = mid_x; pre_y = mid_y; if(mt9v03x_finish_flag)&#123; mt9v03x_finish_flag=0; ips200_displayimage032(mt9v03x_image[0],col,row); //找中心点 for(i=17;i&lt;row;i++)&#123; for(j=0;j&lt;col;j++)&#123; if(mt9v03x_image[i][j]&gt;threshold_max)&#123; sum_x = sum_x + j; sum_y = sum_y + i; n++; flag=1; if(n&gt;400)flag_row=1; &#125; &#125; &#125; if(flag)&#123; mid_x = sum_x/n; mid_y = sum_y/n; ips200_showfloat(0,19,mid_x,6,3); ips200_showfloat(80,19,mid_y,6,3); for(i=mid_x-10;i&lt;mid_x+10;i++) ips200_drawpoint(i,mid_y,RED); for(i=mid_y-10;i&lt;mid_y+10;i++) ips200_drawpoint(mid_x,i,RED); &#125;else&#123; mid_x=0; mid_y=0; ips200_showstr(0,19,&quot; not find points !&quot;); &#125; point_deal();//处理点的坐标（畸变影响） flag_stick = stick();//是否一直怼着信标灯/停住出现卡死状态 &#125;&#125;//处理点的坐标（畸变影响）void point_deal(void)&#123; //判断是否找到信标灯 if(mid_x==0)&#123; count_noBeacon++; if(count_noBeacon&gt;=3)&#123; flag_beacon=0;//没找到灯 &#125;else&#123; //在没找到点比较少时，将发现的点的坐标给予现在的坐标 if(pre_x!=0&amp;&amp;pre_y!=0)&#123; temp_x = pre_x; temp_y = pre_y; &#125; mid_x = temp_x; mid_y = temp_y; &#125; &#125; else&#123; count_noBeacon=0; flag_beacon=1;//找到信标灯 &#125; //处理x if(mid_x&lt;=110)&#123; mid_x=mid_x-20; if(mid_x&lt;=0)mid_x=0; &#125;else&#123; mid_x=mid_x+20; &#125; //处理y（当很靠近灯的时候） if(flag_row)&#123; mid_y=mid_y-5; flag_row=0; &#125;&#125;//一直怼着信标灯/停住出现卡死状态uint8 stick(void)&#123; uint8 bias; bias=mid_x-pre_x; if(bias==0)&#123; zero++; &#125;else&#123; zero=0; &#125; if(zero&gt;=20)&#123;//(zero&gt;=3&amp;&amp;flag_beacon==0)//有20个重复的画面并且未找到信标灯 zero=0; return 1;//卡死了 &#125;else&#123; return 0;//没卡死 &#125;&#125;#ifndef _imgDeal_H_#define _imgDeal_H_#include &quot;headfile.h&quot;// **************************** 宏定 义 **************************** #define col MT9V03X_W //120 //MT9V03X_W 宽 #define row MT9V03X_H//80 //MT9V03X_H 高 // **************************** 变量定义 ****************************extern uint8 threshold_max;extern uint8 mid_x,mid_y,pre_x,pre_y,temp_x,temp_y;extern uint16 n,count_noBeacon,zero;extern uint32 sum_x,sum_y;extern uint8 flag_stick,flag_beacon,flag_row;// **************************** 函数定义 ****************************extern void camera(void);extern void point_deal(void);extern uint8 stick(void);#endif 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425432022/07/15#include &quot;headfile.h&quot;#include&lt;string.h&gt;#include&lt;math.h&gt;#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80#define white 255#define black 0#define GrayScale 256#define maxnum 1000#define offset 0uint8 mid_x,mid_y;uint8 pre_x,pre_y;uint8 zero=0,count_beacon=0;uint8 threshold;//=70;//灰20-70；白70-126 -127-0uint8 bin_img[row][col]; //二值化图 uint8 domains[row][col]; //连通域图////uint8 area_start[maxnum];//uint8 area_end[maxnum];//uint8 area_row[maxnum];//uint8 num_area; //uint8 area_label[maxnum];//uint8 point[col+20][2];//int equalLabels[maxnum][2];//可以不加二值化浪费时间，直接通过阈值来判断//只改变与偏差有关的，与中线有关的间接有关的都不改变//滤波等，思考……效率问题//#define RED 0xF800 // 红色//#define BLUE 0x001F // 蓝色//#define YELLOW 0xFFE0 // 黄色//#define GREEN 0x07E0 // 绿色//#define WHITE 0xFFFF // 白色//#define BLACK 0x0000 // 黑色 //#define GRAY 0X8430 // 灰色//#define BROWN 0XBC40 // 棕色//#define PURPLE 0XF81F // 紫色//#define PINK 0XFE19 //main函数void camera(void)&#123; uint8 stick_flag;//卡死标志 if(mt9v03x_finish_flag) &#123; mt9v03x_finish_flag=0; threshold=100; ips200_displayimage032(mt9v03x_image[0],col,row); Binarization(threshold);// ips200_displayimage032(bin_img[0],col, row); // Find_Beacon(); // stick_flag=stick();// if(stick_flag==1&amp;&amp;flag_beacon==0)&#123;// //卡死在那,令车略微向后退//// duty_l=duty_r=-7000;// duty_l=-duty_l;// duty_r=-duty_r;// &#125;// if(stick_flag==1&amp;&amp;fabs(mid_x-pre_x)&lt;6&amp;&amp;fabs(mid_y-pre_y)&lt;6)&#123;// duty_l=-duty_l-5000;// duty_r=-duty_r-5000;// &#125;// if(flag_beacon==0)&#123;// duty_l=0;// duty_r=duty_r+5000;// &#125;// if(flag_beacon==1)&#123;// duty_l=duty_l+5000;// duty_r=duty_r+5000;// &#125; &#125;&#125;//图像二值化 void Binarization(uint8 threshold)&#123; uint8 i,j,m,n; uint8 flag_red=0;//信标灯没有阈值大于180的点 for(i=0; i&lt;row; i++) &#123; for(j=0; j&lt;col; j++) &#123;// domains[i][j]=0; if(mt9v03x_image[i][j]&gt;threshold) bin_img[i][j]=white; else bin_img[i][j]=black; if(mt9v03x_image[i][j]&gt;160)&#123; ips200_drawpoint(j,i,RED); flag_red=1; for(m=j-10;m&lt;j+10;m++) ips200_drawpoint(m,i,RED); for(n=i-10;n&lt;i+10;n++) ips200_drawpoint(j,n,RED); &#125; &#125; &#125; ips200_showfloat(0,16,flag_red,6,3);&#125;uint8 flag_beacon=1,flag_row=0;//判断是否找到信标灯void Find_Beacon(void)&#123;// Connect_domains(); pre_x=mid_x; pre_y=mid_y; Find_CenterPoint();// if(bin_img[pre_x][pre_y]==black&amp;&amp;flag_beacon==1)&#123;// DirG_Output= -1200;// flag_beacon=0;// &#125;&#125;//一直怼着信标灯/停住出现卡死状态uint8 stick(void)&#123; uint8 bias; bias=mid_x-pre_x; if(bias==0)&#123; zero++; &#125;else&#123; zero=0; &#125; if(zero&gt;=20)&#123;//(zero&gt;=3&amp;&amp;flag_beacon==0)//有20个重复的画面并且未找到信标灯 zero=0; return 1;//卡死了 &#125;else&#123; return 0;//没卡死 &#125;&#125;//找中心点void Find_CenterPoint(void)&#123; uint8 i,j; uint8 point_count=0; uint8 x,y,row_current=0; uint8 left,right,top,bottom; uint8 n=0; uint16 sum_x=0,sum_y=0; uint8 x_pre=0,y_pre=0; uint8 flag=0;//没有找到第一个白点 for(i=0;i&lt;row;i++)&#123; for(j=0;j&lt;col;j++)&#123; if(row_current!=i)&#123; point_count=0; row_current=i; x_pre=y_pre=0; flag=0; &#125; if(bin_img[i][j]==white)&#123; point_count++; &#125;else&#123; if(point_count&gt;=1&amp;&amp;flag==0)&#123; x = j-1-point_count/2; y = i; while(bin_img[y][x-left]==white)&#123; left++; &#125; while(bin_img[y][x+right]==white)&#123; right++; &#125; while(bin_img[y-top][x]==white)&#123; top++; &#125; while(bin_img[y+bottom][x]==white)&#123; bottom++; &#125; if((bottom-top)&lt;2&amp;&amp;(top-bottom)&lt;2&amp;&amp;(left-right)&lt;2&amp;&amp;(right-left)&lt;2)&#123; // point[n][0]=x;// point[n++][1]=y;// ips200_drawpoint(x,y,RED);// ips200_drawpoint(x+1,y,RED);// ips200_drawpoint(x-1,y,RED);// ips200_drawpoint(x,y-1,RED);// ips200_drawpoint(x,y+1,RED); // if(right-left&gt;=18)flag_row=1;// sum_x += x;// sum_y += y;// n++;// flag_beacon=1; if(x_pre==0&amp;&amp;y_pre==0)&#123; if(right-left&gt;=18)flag_row=1; x_pre=x; y_pre=y; sum_x += x; sum_y += y; n++; &#125;else if(x-x_pre&lt;=1)&#123; if(right-left&gt;=18)flag_row=1; sum_x += x; sum_y += y; n++; x_pre=x; y_pre=y; &#125;else&#123; flag=1; &#125; &#125; &#125; point_count=0; left=right=top=bottom=0; &#125; if(j==col-1&amp;&amp;bin_img[i][col-1]==white)&#123; x = j-1-point_count/2; y = i; while(bin_img[y][x-left]==white)&#123; left++; &#125; while(bin_img[y][x+right]==white)&#123; right++; &#125; while(bin_img[y-top][x]==white)&#123; top++; &#125; while(bin_img[y+bottom][x]==white)&#123; bottom++; &#125; if((bottom-top)&lt;2&amp;&amp;(top-bottom)&lt;2&amp;&amp;(left-right)&lt;2&amp;&amp;(right-left)&lt;2)&#123; // point[n][0]=x;// point[n++][1]=y;// ips200_drawpoint(x,y,RED);// ips200_drawpoint(x+1,y,RED);// ips200_drawpoint(x-1,y,RED);// ips200_drawpoint(x,y-1,RED);// ips200_drawpoint(x,y+1,RED); // if(right-left&gt;=18)flag_row=1;// sum_x += x;// sum_y += y;// n++;// flag_beacon=1; if(x_pre==0&amp;&amp;y_pre==0)&#123; if(right-left&gt;=18)flag_row=1; x_pre=x; y_pre=y; sum_x += x; sum_y += y; n++; &#125;else if(x-x_pre&lt;=1)&#123; if(right-left&gt;=18)flag_row=1; sum_x += x; sum_y += y; n++; x_pre=x; y_pre=y; &#125;else&#123; flag=1; &#125; point_count=0; left=right=top=bottom=0; &#125; &#125; &#125; &#125; mid_x = sum_x/n; mid_y = sum_y/n; ips200_drawpoint(mid_x,mid_y,RED); ips200_drawpoint(mid_x+1,mid_y,RED); ips200_drawpoint(mid_x-1,mid_y,RED); ips200_drawpoint(mid_x-1,mid_y-1,RED); ips200_drawpoint(mid_x,mid_y-1,RED); ips200_drawpoint(mid_x+1,mid_y-1,RED); ips200_drawpoint(mid_x-1,mid_y+1,RED); ips200_drawpoint(mid_x,mid_y+1,RED); ips200_drawpoint(mid_x+1,mid_y+1,RED); if(mid_x==0)&#123; count_beacon++; if(count_beacon&gt;=3)&#123; flag_beacon=0;//没找到灯 &#125;else&#123; mid_x=pre_x; mid_y=pre_y; &#125; &#125; else&#123; count_beacon=0; flag_beacon=1;//找到信标灯// mid_x=mid_x;// mid_y=mid_y; &#125; if(mid_x&lt;=110)&#123; mid_x=mid_x-20; if(mid_x&lt;=0)mid_x=0; &#125;else&#123; mid_x=mid_x+20; &#125; if(flag_row)&#123; mid_y=mid_y-5; flag_row=0; &#125;&#125;//大津算法//uint8 OTSU(void)//&#123;// uint16 i,j;// uint8 img_row=row,img_col=col; // uint16 histogram[GrayScale]; //灰度直方图// // //第一步：初始化灰度直方图// for(i=0; i&lt;GrayScale; i++)// histogram[i]=0; // // //第二步：统计每个灰度值出现得次数// for(i=0; i&lt;img_row; i++)// for(j=0; j&lt;img_col; j++)// ++histogram[mt9v03x_image[i][j]];// // // //第三步： 获取最小最大灰度值// uint16 minGray,maxGray;// for(minGray=0;minGray&lt;256&amp;&amp;histogram[minGray]==0;minGray++);// for(maxGray=255;maxGray&gt;minGray&amp;&amp;histogram[maxGray]==0;maxGray--);// // //第四步：分情况讨论// // 最大=最小，图像只有一种颜色// if(maxGray==minGray)// return maxGray;// //最大=最小+1，图像只有两种颜色// if(maxGray==minGray+1)// return minGray;// // //第五步：统计[最小,最大]范围内的像素总数// uint16 PixelSum=0;// for(i=minGray; i&lt;maxGray+1; i++)// PixelSum += histogram[i];// // //第六步：统计[最小,最大]范围内的灰度值总数(灰度值*出现次数)// uint16 GraySum=0;// for(i=minGray; i&lt;maxGray+1; i++)// GraySum += histogram[i]*i;// //// //第七步： 大津法优化// float w0; //前景像素点占整幅图像的百分比 // float w1; //背景像素点占整幅图像的百分比 // uint16 w0num; //前景像素点数 // uint16 w1num; // 背景像素点数 // uint16 u0gray; //前景灰度值 // uint16 u1gray; //背景灰度值 // float u0; //w0平均灰度// float u1; //w1平均灰度// float deltaTmp=0,deltaMax=-1;// uint8 th;// // u0gray = u1gray = w0num = w1num = 0;// for(i=minGray; i&lt;maxGray+1; i++)// &#123;// w0num += histogram[i];// w1num = PixelSum-w0num;// w0 = w0num*1.0/PixelSum;// w1 = w1num*1.0/PixelSum;// u0gray += histogram[i]*i;// u1gray = GraySum-u0gray;// u0 = u0gray*1.0/w0num;// u1 = u1gray*1.0/w1num;// deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); // //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2// // //第八步：遍历最大类间方差（因为呈正态分布） // if(deltaTmp&gt;deltaMax)// &#123;// deltaMax = deltaTmp;// th = i;// &#125;// &#125;// return th; // //&#125;//////连通域//void Connect_domains(void)&#123;// uint16 i,j;// uint8 s,e,r,l;// searchArea();// markArea();// // for(i=0;i&lt;num_area;i++)&#123;// r=area_row[i];// s=area_start[i];// e=area_end[i];// l=area_label[i];// for(j=s;j&lt;=e;j++)&#123;// domains[r][j]=l;//// ips200_drawpoint(j,r,RED);//// ips200_drawpoint(j+1,r,RED);// &#125; // &#125;//&#125;////void searchArea(void)&#123;// uint8 i,j;// uint16 ns=0,ne=0,nr=0;// num_area = 0;// // for(i=0;i&lt;row;i++)&#123;// if(bin_img[i][0]==white)&#123;// num_area++;// area_start[ns++]=0;// &#125;// for(j=1;j&lt;col;j++)&#123;// if(bin_img[i][j-1]==black&amp;&amp;bin_img[i][j]==white)&#123;// num_area++;// area_start[ns++]=j;// &#125;else if(bin_img[i][j]==black&amp;&amp;bin_img[i][j-1]==white)&#123;// area_end[ne++]=j-1;// area_row[nr++]=i;// &#125;// &#125;// if(bin_img[i][col-1]==white)&#123;// area_end[ne++]=col-1;// area_row[nr++]=i;// &#125;// &#125;//&#125;////void markArea(void)&#123;// uint8 i,j;//// int nel=0;// uint8 label=1;// uint8 row_current=0;// uint8 index_currentFirstArea=0;// uint8 index_preFirstArea=0;// uint8 index_preLastArea=0;// // for(i=0;i&lt;num_area;i++)&#123;// area_label[i]=0;// &#125;// // for(i=0;i&lt;num_area;i++)&#123;// //轮到下一行时，变量更新 // if(row_current!=area_row[i])&#123;// row_current = area_row[i];// index_preFirstArea = index_currentFirstArea;// index_preLastArea = i-1;// index_currentFirstArea = i;// &#125;// // if(row_current!=area_row[index_preFirstArea]+1)&#123;// //相邻行不存在子区域 // area_label[i]=label++;// &#125;else&#123;// //当前行与上一行进行比较 // for(j=index_preFirstArea;j&lt;=index_preLastArea;j++)&#123;// if(area_start[i]&lt;=area_end[j]+offset&amp;&amp;area_end[i]&gt;=area_start[j]-offset)&#123;// //相连的情况 // if(area_label[i]==0)&#123;// //没有标记情况 // area_label[i]=area_label[j];// &#125;//// else if(area_label[i]!=area_label[j])&#123;//// //已经标记过，保存等价对 //// equalLabels[nel][0]=area_label[i];//// equalLabels[nel++][1]=area_label[j];//// &#125;// &#125;else if(area_end[i]&lt;area_start[j]-offset)&#123;// //不相连的情况 // if(index_preFirstArea&lt;j-1)// index_preFirstArea=j-1;// j=index_preLastArea;// &#125;// &#125;// &#125;// //这一行循环完与上一行不存在联系 // if(area_label[i]==0)&#123;// area_label[i] = ++label;// &#125;// &#125; //&#125;#ifndef _imgDeal_H_#define _imgDeal_H_#include &quot;headfile.h&quot;#include&lt;string.h&gt;#include&lt;math.h&gt;// **************************** 宏定 义 **************************** #define col MT9V03X_W //120 //MT9V03X_W 宽 #define row MT9V03X_H//80 //MT9V03X_H 高 #define white 255#define black 0#define GrayScale 256#define maxnum 1000#define offset 0// **************************** 变量定义 ****************************extern uint8 threshold;extern uint8 mid_x,mid_y;extern uint8 pre_x,pre_y;extern uint8 zero,count_beacon;extern uint8 bin_img[row][col]; extern uint8 area_start[maxnum];extern uint8 area_end[maxnum];extern uint8 area_row[maxnum];extern uint8 num_area; extern uint8 area_label[maxnum];extern uint8 point[col+20][2];extern uint8 flag_beacon,flag_row;//extern uint8 stick_flag;//extern uint8 equalLabels[maxnum][2];// **************************** 函数定义 ****************************extern void camera(void);extern void Find_Beacon(void);extern void Binarization(uint8 threshold);extern uint8 OTSU(void);extern void searchArea(void);extern void markArea(void);extern void Connect_domains(void);extern void Find_CenterPoint(void);extern uint8 stick(void);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366#include &quot;headfile.h&quot;#include&lt;string.h&gt;#include&lt;math.h&gt;#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80#define white 255#define black 0#define GrayScale 256#define maxnum 1000#define offset 0uint8 mid_x,mid_y;uint8 pre_x,pre_y;uint8 zero=0;uint8 bias;uint8 stick_flag=0;//判断车是否被卡死uint8 count_beacon=0;uint8 flag_beacon=0;uint8 begin_beacon=0;uint8 automatic_start=0;uint8 flag1=0;uint8 threshold;//=70;//灰20-70；白70-126 -127-0uint8 bin_img[row][col]; //二值化图 uint8 domains[row][col]; //连通域图uint8 area_start[maxnum];uint8 area_end[maxnum];uint8 area_row[maxnum];uint8 num_area; uint8 area_label[maxnum];uint8 point[col+20][2];//int equalLabels[maxnum][2];//可以不加二值化浪费时间，直接通过阈值来判断//只改变与偏差有关的，与中线有关的间接有关的都不改变//滤波等，思考……效率问题//#define RED 0xF800 // 红色//#define BLUE 0x001F // 蓝色//#define YELLOW 0xFFE0 // 黄色//#define GREEN 0x07E0 // 绿色//#define WHITE 0xFFFF // 白色//#define BLACK 0x0000 // 黑色 //#define GRAY 0X8430 // 灰色//#define BROWN 0XBC40 // 棕色//#define PURPLE 0XF81F // 紫色//#define PINK 0XFE19 //main函数void camera(void)&#123; if(mt9v03x_finish_flag) &#123; mt9v03x_finish_flag=0; stick_flag = stick(); threshold=70;// ips200_showfloat(0,15,threshold,6,3);// if(threshold&lt;70)threshold=70; Binarization(threshold); ips200_displayimage032(bin_img[0],col, row); Find_Beacon(); &#125;&#125;void Find_Beacon(void)&#123;// Connect_domains(); pre_x=mid_x; pre_y=mid_y; Find_CenterPoint();// if(mid_x==0&amp;&amp;mid_y==0)&#123;// mid_x=pre_x;// mid_y=pre_y;// &#125;&#125;//一直怼着信标灯,出现卡死状态uint8 stick(void)&#123; bias = mid_y-pre_y; if(bias==0)&#123; zero++; &#125;else&#123; zero=0; &#125; if(zero&gt;=3&amp;&amp;flag1==1)&#123; zero=0; return 1; &#125;else&#123; return 0; &#125;&#125;//找中心点void Find_CenterPoint(void)&#123; uint8 i,j; uint8 point_count=0; uint8 x,y,row_current=0; uint8 left,right,top,bottom; uint8 n=0; uint16 sum_x=0,sum_y=0; for(i=0;i&lt;row;i++)&#123; for(j=0;j&lt;col;j++)&#123; if(row_current!=i)&#123; point_count=0; row_current=i; &#125; if(bin_img[i][j]==white)&#123; point_count++; &#125;else&#123; if(point_count&gt;=2)&#123; x = j-1-point_count/2; y = i; while(bin_img[y][x-left]==white)&#123; left++; &#125; while(bin_img[y][x+right]==white)&#123; right++; &#125; while(bin_img[y-top][x]==white)&#123; top++; &#125; while(bin_img[y+bottom][x]==white)&#123; bottom++; &#125; if((bottom-top)&lt;2&amp;&amp;(top-bottom)&lt;2&amp;&amp;(left-right)&lt;2&amp;&amp;(right-left)&lt;2)&#123; // point[n][0]=x;// point[n++][1]=y;// ips200_drawpoint(x,y,RED);// ips200_drawpoint(x+1,y,RED);// ips200_drawpoint(x-1,y,RED);// ips200_drawpoint(x,y-1,RED);// ips200_drawpoint(x,y+1,RED); sum_x += x; sum_y += y; n++; flag1=1; &#125; &#125; point_count=0; left=right=top=bottom=0; &#125; &#125; &#125; mid_x = sum_x/n;//信标灯纵坐标 mid_y = sum_y/n;//信标灯横坐标 ips200_drawpoint(mid_x,mid_y,RED); ips200_drawpoint(mid_x+1,mid_y,RED); ips200_drawpoint(mid_x-1,mid_y,RED); ips200_drawpoint(mid_x,mid_y-1,RED); ips200_drawpoint(mid_x,mid_y+1,RED); if(mid_x==0)&#123; count_beacon++; if(count_beacon&gt;=3)&#123; flag_beacon=0;//没找到信标灯 mid_x=0; mid_y=0; &#125;else&#123; begin_beacon=1;//信标灯打开 count_beacon=0; flag_beacon=1;//找到信标灯 automatic_start=1;//自动发车标志位 &#125;&#125;//图像二值化 void Binarization(uint8 threshold)&#123; uint8 i,j; for(i=0; i&lt;row; i++) &#123; for(j=0; j&lt;col; j++) &#123; domains[i][j]=0; if(mt9v03x_image[i][j]&gt;threshold) bin_img[i][j]=white; else bin_img[i][j]=black; &#125; &#125;&#125;//大津算法uint8 OTSU(void)&#123; uint16 i,j; uint8 img_row=row,img_col=col; uint16 histogram[GrayScale]; //灰度直方图 //第一步：初始化灰度直方图 for(i=0; i&lt;GrayScale; i++) histogram[i]=0; //第二步：统计每个灰度值出现得次数 for(i=0; i&lt;img_row; i++) for(j=0; j&lt;img_col; j++) ++histogram[mt9v03x_image[i][j]]; //第三步： 获取最小最大灰度值 uint16 minGray,maxGray; for(minGray=0;minGray&lt;256&amp;&amp;histogram[minGray]==0;minGray++); for(maxGray=255;maxGray&gt;minGray&amp;&amp;histogram[maxGray]==0;maxGray--); //第四步：分情况讨论 // 最大=最小，图像只有一种颜色 if(maxGray==minGray) return maxGray; //最大=最小+1，图像只有两种颜色 if(maxGray==minGray+1) return minGray; //第五步：统计[最小,最大]范围内的像素总数 uint16 PixelSum=0; for(i=minGray; i&lt;maxGray+1; i++) PixelSum += histogram[i]; //第六步：统计[最小,最大]范围内的灰度值总数(灰度值*出现次数) uint16 GraySum=0; for(i=minGray; i&lt;maxGray+1; i++) GraySum += histogram[i]*i; //第七步： 大津法优化 float w0; //前景像素点占整幅图像的百分比 float w1; //背景像素点占整幅图像的百分比 uint16 w0num; //前景像素点数 uint16 w1num; // 背景像素点数 uint16 u0gray; //前景灰度值 uint16 u1gray; //背景灰度值 float u0; //w0平均灰度 float u1; //w1平均灰度 float deltaTmp=0,deltaMax=-1; uint8 th; u0gray = u1gray = w0num = w1num = 0; for(i=minGray; i&lt;maxGray+1; i++) &#123; w0num += histogram[i]; w1num = PixelSum-w0num; w0 = w0num*1.0/PixelSum; w1 = w1num*1.0/PixelSum; u0gray += histogram[i]*i; u1gray = GraySum-u0gray; u0 = u0gray*1.0/w0num; u1 = u1gray*1.0/w1num; deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2 //第八步：遍历最大类间方差（因为呈正态分布） if(deltaTmp&gt;deltaMax) &#123; deltaMax = deltaTmp; th = i; &#125; &#125; return th; &#125;//连通域void Connect_domains(void)&#123; uint16 i,j; uint8 s,e,r,l; searchArea(); markArea(); for(i=0;i&lt;num_area;i++)&#123; r=area_row[i]; s=area_start[i]; e=area_end[i]; l=area_label[i]; for(j=s;j&lt;=e;j++)&#123; domains[r][j]=l;// ips200_drawpoint(j,r,RED);// ips200_drawpoint(j+1,r,RED); &#125; &#125;&#125;void searchArea(void)&#123; uint8 i,j; uint16 ns=0,ne=0,nr=0; num_area = 0; for(i=0;i&lt;row;i++)&#123; if(bin_img[i][0]==white)&#123; num_area++; area_start[ns++]=0; &#125; for(j=1;j&lt;col;j++)&#123; if(bin_img[i][j-1]==black&amp;&amp;bin_img[i][j]==white)&#123; num_area++; area_start[ns++]=j; &#125;else if(bin_img[i][j]==black&amp;&amp;bin_img[i][j-1]==white)&#123; area_end[ne++]=j-1; area_row[nr++]=i; &#125; &#125; if(bin_img[i][col-1]==white)&#123; area_end[ne++]=col-1; area_row[nr++]=i; &#125; &#125;&#125;void markArea(void)&#123; uint8 i,j;// int nel=0; uint8 label=1; uint8 row_current=0; uint8 index_currentFirstArea=0; uint8 index_preFirstArea=0; uint8 index_preLastArea=0; for(i=0;i&lt;num_area;i++)&#123; area_label[i]=0; &#125; for(i=0;i&lt;num_area;i++)&#123; //轮到下一行时，变量更新 if(row_current!=area_row[i])&#123; row_current = area_row[i]; index_preFirstArea = index_currentFirstArea; index_preLastArea = i-1; index_currentFirstArea = i; &#125; if(row_current!=area_row[index_preFirstArea]+1)&#123; //相邻行不存在子区域 area_label[i]=label++; &#125;else&#123; //当前行与上一行进行比较 for(j=index_preFirstArea;j&lt;=index_preLastArea;j++)&#123; if(area_start[i]&lt;=area_end[j]+offset&amp;&amp;area_end[i]&gt;=area_start[j]-offset)&#123; //相连的情况 if(area_label[i]==0)&#123; //没有标记情况 area_label[i]=area_label[j]; &#125;// else if(area_label[i]!=area_label[j])&#123;// //已经标记过，保存等价对 // equalLabels[nel][0]=area_label[i];// equalLabels[nel++][1]=area_label[j];// &#125; &#125;else if(area_end[i]&lt;area_start[j]-offset)&#123; //不相连的情况 if(index_preFirstArea&lt;j-1) index_preFirstArea=j-1; j=index_preLastArea; &#125; &#125; &#125; //这一行循环完与上一行不存在联系 if(area_label[i]==0)&#123; area_label[i] = ++label; &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483492022/7/4 #include &quot;headfile.h&quot;#include&lt;string.h&gt;#include&lt;math.h&gt;#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80#define white 255#define black 0#define GrayScale 256int mid_x,mid_y;int threshold;//=70;//灰20-70；白70-126 -127-0uint8 bin_img[row][col]; //二值化图 //可以不加二值化浪费时间，直接通过阈值来判断//只改变与偏差有关的，与中线有关的间接有关的都不改变//滤波等，思考……效率问题//#define RED 0xF800 // 红色//#define BLUE 0x001F // 蓝色//#define YELLOW 0xFFE0 // 黄色//#define GREEN 0x07E0 // 绿色//#define WHITE 0xFFFF // 白色//#define BLACK 0x0000 // 黑色 //#define GRAY 0X8430 // 灰色//#define BROWN 0XBC40 // 棕色//#define PURPLE 0XF81F // 紫色//#define PINK 0XFE19 //main函数void camera(void)&#123; if(mt9v03x_finish_flag) &#123;// threshold=OTSU();// ips200_showfloat(0,15,threshold,6,3);// if(threshold&lt;90)threshold=90;// threshold=255; //加一个：黑白天阈值限定// Binarization(threshold);// ips200_displayimage032(bin_img[0],col, row);// Find_Beacon();// ips200_showfloat(0,15,mt9v03x_image[60][100],6,3);// ips200_displayimage032(mt9v03x_image[0],col, row);// ips200_drawpoint(100,60,RED);// Scan_Point1(); &#125;&#125;void Find_Beacon(void)&#123; int i,j; int n_row=0,n_col=0,sum_row=0,sum_col=0;//记录白块的行和列的个数，行或列的总和 int n1,n2; int point_row[col];//记录每行白点所在列 int point_col[row][5];//记录每行所有连续白点的中心线 int point_temp[row][2];//记下每行产生连续白点行数和产生的连续白点数 for(i=0;i&lt;row;i++) &#123; point_temp[i][0] = -1; point_temp[i][1] = 0; point_col[i][0] = -1; point_col[i][1] = -1; point_col[i][2] = -1; point_col[i][3] = -1; point_col[i][4] = -1; &#125; for(i=0;i&lt;row;i++) &#123; n_row = 0,sum_row=0;// memset(point_row,-1,sizeof(point_row)); for(j=0;j&lt;col;j++) &#123; if((mt9v03x_image[i][j-1]&gt;threshold)&amp;&amp;(mt9v03x_image[i][j]&gt;threshold)&amp;&amp;(mt9v03x_image[i][j+1]&gt;threshold)) &#123; point_row[n_row++] = j;//记下连续白点的列 point_temp[i][0] = i; //记下存在白点的行 // ips200_drawpoint(j,i,RED); &#125; &#125; if(n_row!=0)&#123;//可以使用120个点的如果点与点间又3个点的间隔就算另一个图 point_temp[i][1] = 1; n1 = 0,n2=0; //记录第几个白块(存列数),记录有多少个连续的白点 for(j=0;j&lt;n_row;j++) &#123; sum_row += point_row[j]; n2++; if(point_row[j+1]-point_row[j]&gt;2) &#123; point_temp[i][1]++; point_col[i][n1++] = sum_row/n2; sum_row = 0; n2 = 0; &#125; &#125; n_col++; ips200_drawpoint(point_col[i][0],i,BLUE); ips200_drawpoint(point_col[i][0],i+1,BLUE); ips200_drawpoint(point_col[i][0],i-1,BLUE); &#125; &#125; if(n_col==0&amp;&amp;n_row==0)&#123;//找不到点 mid_x = col/2; mid_y = row/2; &#125;else&#123; n_row = 0,n_col=0; sum_row=0,sum_col=0; for(i=1;i&lt;row;i++) &#123; if(point_temp[i][1]==1) &#123; sum_col += point_col[i][0]; sum_row += point_temp[i][0]; n_row++; if(point_col[i+1][0]==-1&amp;&amp;point_col[i-1][0]==-1&amp;&amp;fabs(point_col[i+1]-point_col[i])&gt;2&amp;&amp;fabs(point_col[i-1]-point_col[i])&gt;2) &#123; mid_x = sum_col/n_row; mid_y = sum_row/n_row; sum_row = 0; sum_col = 0; n_row = 0; &#125; &#125; &#125; &#125; // ips200_showfloat(0,13,n_row,4,3);// ips200_showfloat(0,14,sum_col,4,3);// ips200_showfloat(0,15,sum_row,4,3); ips200_showfloat(0,16,mid_x,4,3); ips200_showfloat(0,17,mid_y,4,3); ips200_drawpoint(mid_y,mid_x,RED);//列，行 ips200_drawpoint(mid_y,mid_x+1,RED); ips200_drawpoint(mid_y+1,mid_x,RED); ips200_drawpoint(mid_y+1,mid_x+1,RED);&#125;//图像二值化 void Binarization(int threshold)&#123; int i,j; for(i=0; i&lt;row; i++) &#123; for(j=0; j&lt;col; j++) &#123; if(mt9v03x_image[i][j]&gt;threshold) bin_img[i][j]=white; else bin_img[i][j]=black; &#125; &#125;&#125;//大津算法int OTSU(void)&#123; int i,j; int img_row=row,img_col=col; int histogram[GrayScale]; //灰度直方图 //第一步：初始化灰度直方图 for(i=0; i&lt;GrayScale; i++) histogram[i]=0; //第二步：统计每个灰度值出现得次数 for(i=0; i&lt;img_row; i++) for(j=0; j&lt;img_col; j++) ++histogram[mt9v03x_image[i][j]]; //第三步： 获取最小最大灰度值 int minGray,maxGray; for(minGray=0;minGray&lt;256&amp;&amp;histogram[minGray]==0;minGray++); for(maxGray=255;maxGray&gt;minGray&amp;&amp;histogram[maxGray]==0;maxGray--); //第四步：分情况讨论 // 最大=最小，图像只有一种颜色 if(maxGray==minGray) return maxGray; //最大=最小+1，图像只有两种颜色 if(maxGray==minGray+1) return minGray; //第五步：统计[最小,最大]范围内的像素总数 int PixelSum=0; for(i=minGray; i&lt;maxGray+1; i++) PixelSum += histogram[i]; //第六步：统计[最小,最大]范围内的灰度值总数(灰度值*出现次数) int GraySum=0; for(i=minGray; i&lt;maxGray+1; i++) GraySum += histogram[i]*i; //第七步： 大津法优化 double w0; //前景像素点占整幅图像的百分比 double w1; //背景像素点占整幅图像的百分比 int w0num; //前景像素点数 int w1num; // 背景像素点数 int u0gray; //前景灰度值 int u1gray; //背景灰度值 double u0; //w0平均灰度 double u1; //w1平均灰度 double deltaTmp=0,deltaMax=-1; int th; u0gray = u1gray = w0num = w1num = 0; for(i=minGray; i&lt;maxGray+1; i++) &#123; w0num += histogram[i]; w1num = PixelSum-w0num; w0 = w0num*1.0/PixelSum; w1 = w1num*1.0/PixelSum; u0gray += histogram[i]*i; u1gray = GraySum-u0gray; u0 = u0gray*1.0/w0num; u1 = u1gray*1.0/w1num; deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2 //第八步：遍历最大类间方差（因为呈正态分布） if(deltaTmp&gt;deltaMax) &#123; deltaMax = deltaTmp; th = i; &#125; &#125; return th; &#125;void Binarization(int threshold)&#123; int i,j; for(i=0; i&lt;row; ++i) &#123; for(j=0; j&lt;col; ++j) &#123; if(mt9v03x_image[i][j]&gt;threshold) bin_img[i][j]=white; else bin_img[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0;&#125;void Find_Beacon(void)&#123; int i,j; int n_row=0,n_col=0,sum_row=0,sum_col=0;//记录白块的行和列的个数，行或列的总和 int n1,n2; int point_row[col];//记录每行白点所在列 int point_col[row][5];//记录每行所有连续白点的中心线 int point_temp[row][2];//记下每行产生连续白点行数和产生的连续白点数 for(i=0;i&lt;row;i++) &#123; point_temp[i][0] = -1; point_temp[i][1] = 0; point_col[i][0] = -1; point_col[i][1] = -1; point_col[i][2] = -1; point_col[i][3] = -1; point_col[i][4] = -1; &#125; for(i=0;i&lt;row;i++) &#123; n_row = 0,sum_row=0;// memset(point_row,-1,sizeof(point_row)); for(j=0;j&lt;col;j++) &#123; if((mt9v03x_image[i][j-1]&gt;threshold)&amp;&amp;(mt9v03x_image[i][j]&gt;threshold)&amp;&amp;(mt9v03x_image[i][j+1]&gt;threshold)) &#123; point_row[n_row++] = j;//记下连续白点的列 point_temp[i][0] = i; //记下存在白点的行 // ips200_drawpoint(j,i,RED); &#125; &#125; if(n_row!=0)&#123;//可以使用120个点的如果点与点间又3个点的间隔就算另一个图 point_temp[i][1] = 1; n1 = 0,n2=0; //记录第几个白块(存列数),记录有多少个连续的白点 for(j=0;j&lt;n_row;j++) &#123; sum_row += point_row[j]; n2++; if(point_row[j+1]-point_row[j]&gt;2) &#123; point_temp[i][1]++; point_col[i][n1++] = sum_row/n2; sum_row = 0; n2 = 0; &#125; &#125; n_col++; ips200_drawpoint(point_col[i][0],i,BLUE); ips200_drawpoint(point_col[i][0],i+1,BLUE); ips200_drawpoint(point_col[i][0],i-1,BLUE); &#125; &#125; if(n_col==0&amp;&amp;n_row==0)&#123;//找不到点 mid_x = col/2; mid_y = row/2; &#125;else&#123; n_row = 0,n_col=0; sum_row=0,sum_col=0; for(i=1;i&lt;row;i++) &#123; if(point_temp[i][1]==1) &#123; sum_col += point_col[i][0]; sum_row += point_temp[i][0]; n_row++; if(point_col[i+1][0]==-1&amp;&amp;point_col[i-1][0]==-1&amp;&amp;fabs(point_col[i+1]-point_col[i])&gt;2&amp;&amp;fabs(point_col[i-1]-point_col[i])&gt;2) &#123; mid_x = sum_col/n_row; mid_y = sum_row/n_row; sum_row = 0; sum_col = 0; n_row = 0; &#125; &#125; &#125; &#125; // ips200_showfloat(0,13,n_row,4,3);// ips200_showfloat(0,14,sum_col,4,3);// ips200_showfloat(0,15,sum_row,4,3);// ips200_showfloat(0,16,mid_x,4,3);// ips200_showfloat(0,17,mid_y,4,3); ips200_drawpoint(mid_y,mid_x,RED);//列，行 ips200_drawpoint(mid_y,mid_x+1,RED); ips200_drawpoint(mid_y+1,mid_x,RED); ips200_drawpoint(mid_y+1,mid_x+1,RED);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921932022/7/2 void Find_Beacon(void)&#123; int i,j; int n_row=0,n_col=0,sum_row=0,sum_col=0;//记录白块的行和列的个数，行或列的总和 int n_ int point_row[col];//记录每行点的状态（黑/白) int point_col[row][5];//记录每行有几个白块 int point_temp[row][2];//记录每行是否有白块，并记下行数和产生的白块数 for(i=0;i&lt;row;i++) &#123; point_temp[i][0] = -1; point_temp[i][1] = 0; &#125; for(i=0;i&lt;row;i++) &#123; n_row = 0,sum_row=0;// memset(point_row,-1,sizeof(point_row)); for(j=0;j&lt;col;j++) &#123; if((mt9v03x_image[i][j-1]&gt;threshold)&amp;&amp;(mt9v03x_image[i][j]&gt;threshold)&amp;&amp;(mt9v03x_image[i][j+1]&gt;threshold)) &#123; point_row[n_row++] = j;//记下连续白点的列 point_temp[i][0] = i; //记下存在白点的行 // ips200_drawpoint(j,i,RED); &#125; &#125; if(n_row!=0)&#123;//可以使用120个点的如果点与点间又3个点的间隔就算另一个图 for(j=1;j&lt;n_row;j++) &#123; if(point_row[j]-point_row[j-1]&gt;2) &#125; point_col[i] = sum_row/n_row; n_col++; ips200_drawpoint(point_col[i],i,BLUE); ips200_drawpoint(point_col[i],i+1,BLUE); ips200_drawpoint(point_col[i],i-1,BLUE); &#125; &#125; if(n_col==0&amp;&amp;n_row==0)&#123; //找不到点 mid_x = col/2; mid_y = row/2; &#125;else&#123; n_row = 0,n_col=0; sum_row=0,sum_col=0; for(i=1;i&lt;row-1;i++) &#123; if(point_temp[i]!=0&amp;&amp;point_temp[i+1]!=0&amp;&amp;point_temp[i-1]!=0) &#123; sum_row += point_temp[i]; n_row++; sum_col += point_col[i]; &#125; &#125; mid_x = sum_col/n_row; mid_y = sum_row/n_row; &#125; // ips200_showfloat(0,13,n_row,4,3);// ips200_showfloat(0,14,sum_col,4,3);// ips200_showfloat(0,15,sum_row,4,3);// ips200_showfloat(0,16,mid_x,4,3);// ips200_showfloat(0,17,mid_y,4,3); ips200_drawpoint(mid_y,mid_x,RED);//列，行 ips200_drawpoint(mid_y,mid_x+1,RED); ips200_drawpoint(mid_y+1,mid_x,RED); ips200_drawpoint(mid_y+1,mid_x+1,RED);&#125; if(sumhang&gt;110) &#123; KP1=15; KD1=0.1; KP2=15; KD1=0.1; setspeed2= 20+(sumlie-93)*2.4; setspeed1= 20-(sumlie-93)*2.4; speedave=speed1+speed2; if(speedave&lt;80) &#123; setspeed1= 200-(sumlie-93)*2.4;//1.5 setspeed2= 200+(sumlie-93)*2.4;//1.5; &#125; MotorDuty1 =speedout1 - 1.8*(gyroz+9); MotorDuty2 =speedout2 + 1.8*(gyroz+9); &#125; else if(sumhang&gt;=33 &amp;&amp;sumhang &lt;=110) &#123; KP1=29; KD1=0.1; KP2=29; KD1=0.1; setspeed2= 0+(sumlie-93)*2.4; setspeed1= 0-(sumlie-93)*2.4; speedave=speed1+speed2; if(speedave&lt;80)// &#123; setspeed1= 200-(sumlie-93)*2.4;//1.5 setspeed2= 200+(sumlie-93)*2.4;//1.5; &#125; MotorDuty1 =speedout1 - 1.8*(gyroz+9); MotorDuty2 =speedout2 + 1.8*(gyroz+9); &#125; else if(sumhang&gt;=40 &amp;&amp;sumhang &lt;55)//滑行 &#123; KP1=15; KD1=0.1; KP2=15; KD1=0.1; setspeed2= 200+(sumlie-93)*2.4; setspeed1= 200-(sumlie-93)*2.4; MotorDuty1 =speedout1 - 1.8*(gyroz+9); MotorDuty2 =speedout2 + 1.8*(gyroz+9); &#125; else if(sumhang&lt;25)//加速 &#123; KP1=15; KD1=0.1; KP2=15; KD1=0.1; setspeed2= 330+(sumlie-93)*2.4+sumhang*10;//250 setspeed1= 330-(sumlie-93)*2.4+sumhang*10; MotorDuty1 =speedout1 - 2.5*(gyroz+9); MotorDuty2 =speedout2 + 2.5*(gyroz+9); &#125; else//冲 &#123; KP1=15; KD1=0.1; KP2=15; KD1=0.1; setspeed2= 580+(sumlie-93)*2.4;//430//460 setspeed1= 580-(sumlie-93)*2.4;//430 MotorDuty1 =speedout1 - 3.6*(gyroz+9); MotorDuty2 =speedout2 + 3.6*(gyroz+9); &#125; if(MotorDuty1&gt;6000) MotorDuty1 = 6000;//限幅*********需测量 if(MotorDuty2&gt;6000) MotorDuty2 = 6000;//限幅 &#125; else // 没有发现有白色点 &#123; nolight=1; beaconFlashCnt++; if(beaconFlashCnt&gt;5) &#123; KP1=15; KD1=0.1; KP2=15; KD2=0.1; setspeed1= 260; setspeed2= 0; MotorDuty1 = speedout1 - 0.5*(gyroz+9); MotorDuty2 = speedout2 + 0.5*(gyroz+9); //sumhang=1; &#125; &#125; if(1) &#123; MotorCtrl(-MotorDuty1, MotorDuty2); &#125; else &#123; MotorDuty1 =0; MotorDuty2 =0; MotorCtrl(-MotorDuty2 ,-MotorDuty1); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792022/7/1 #ifndef _imgDeal_H_#define _imgDeal_H_#include &quot;headfile.h&quot;// **************************** 宏定 义 **************************** #define col MT9V03X_W //120 //MT9V03X_W 宽 #define row MT9V03X_H//80 //MT9V03X_H 高 #define white 255#define black 0// **************************** 变量定义 ****************************extern uint8 bin_img[row][col]; extern uint8 gray_img[row][col]; extern int point[row];extern int threshold;extern int mid_x,mid_y;// **************************** 函数定义 ****************************extern void camera(void);extern void Binarization(int threshold);extern int OTSU(void);extern void Scan_Point1(void);extern void Bin_Image_Filter(void);extern void sign_Beacon(int x,int y,int top,int bottom);//extern void sign_Beacon(int x,int y);#endif#include &quot;headfile.h&quot;#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80#define white 255#define black 0#define GrayScale 256uint8 bin_img[row][col]; //二值化图 uint8 gray_img[row][col]; //灰度图 int mid_x,mid_y;int threshold;//=70;//灰20-70；白70-126 -127-0//可以不加二值化浪费时间，直接通过阈值来判断//只改变与偏差有关的，与中线有关的间接有关的都不改变//滤波等，思考……效率问题//#define RED 0xF800 // 红色//#define BLUE 0x001F // 蓝色//#define YELLOW 0xFFE0 // 黄色//#define GREEN 0x07E0 // 绿色//#define WHITE 0xFFFF // 白色//#define BLACK 0x0000 // 黑色 //#define GRAY 0X8430 // 灰色//#define BROWN 0XBC40 // 棕色//#define PURPLE 0XF81F // 紫色//#define PINK 0XFE19 //main函数void camera(void)&#123; if(mt9v03x_finish_flag) &#123; // threshold=OTSU(); threshold=70; //加一个：黑白天阈值限定 Binarization(threshold); ips200_displayimage032(bin_img[0],col, row); // ips200_displayimage032(mt9v03x_image[0],col, row); Scan_Point1(); &#125;&#125;//简单找点void Scan_Point1(void)&#123; int i,j,k=1; int left,right,top,bottom; int sum=0; int point[row]; int flag1=1,flag2=1; for(i=0;i&lt;row;i++) point[i] = 0; //第一步：找到左右边界进行折半取中值 for(i=0;i&lt;row;i++) &#123; left=col,right=0; for(j=0;j&lt;col; ) &#123; if(bin_img[i][j]==255) &#123; if(left==col)left=j; right = j+1; flag1=0; continue; &#125; j++; &#125; if(left&lt;right)point[i]=(left+right)&gt;&gt;1; else point[i]=0xff; &#125; //第二步：找到上下边界，折半得中点坐标 top=row,bottom=0,k=0; for(i=0;i&lt;row;) &#123; if(point[i]!=0xff) &#123; if(top==row)top=i; bottom=i+1; k += 1; flag2=0; continue; &#125; i++; &#125; //第三步：判断是否存在在信标灯 if(top&lt;=bottom) &#123; for(i=top;i&lt;=bottom;i++) &#123; if(point[i]!=0xff)sum += point[i]; &#125; mid_x = sum/k; mid_y = top+(bottom-top)&gt;&gt;1; &#125; if(flag1==0&amp;&amp;flag2==0)&#123; ips200_drawpoint(mid_x,mid_y,RED);//列，行 ips200_drawpoint(mid_x+1,mid_y+1,RED);//列，行 ips200_drawpoint(mid_x,mid_y+1,RED);//列，行 ips200_drawpoint(mid_x+1,mid_y,RED);//列，行 sign_Beacon(mid_x,mid_y,top-10,bottom+10); &#125; if(flag1==1&amp;&amp;flag2==1)&#123; mid_x=120; &#125;&#125;//标出信标灯的位置void sign_Beacon(int x,int y,int top,int bottom)&#123; int i,j; if(top&lt;0)top=0; if(bottom&gt;120)bottom=120; for(i=top;i&lt;bottom;++i) &#123; ips200_drawpoint(x,i,RED);//列，行 for(j=0;j&lt;col;++j) ips200_drawpoint(j,y,RED);//列，行 &#125; &#125;//图像二值化 void Binarization(int threshold)&#123; int i,j; for(i=0; i&lt;row; ++i) &#123; for(j=0; j&lt;col; ++j) &#123; if(mt9v03x_image[i][j]&gt;threshold) bin_img[i][j]=white; else bin_img[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0;&#125;//过滤噪点void Bin_Image_Filter(void)&#123; int i,j; for(i=1; i&lt;row-1;++i) &#123; for(j=1; j&lt;col-1;++j) &#123; if((bin_img[i][j]==0)&amp;&amp;(bin_img[i-1][j]+bin_img[i-1][j+1]+bin_img[i+1][j]+bin_img[i][j+1]+bin_img[i][j+2]&gt;3)) bin_img[i][j]=1; else if((bin_img[i][j]==1)&amp;&amp;(bin_img[i-1][j]+bin_img[i-1][j+1]+bin_img[i+1][j]+bin_img[i][j+1]+bin_img[i][j+2]&lt;2)) bin_img[i][j]=0; &#125; &#125;&#125;//大津算法int OTSU(void)&#123; int i,j; int img_row=row,img_col=col; int histogram[GrayScale]; //灰度直方图 //第一步：初始化灰度直方图 for(i=0; i&lt;GrayScale; ++i) histogram[i]=0; //第二步：统计每个灰度值出现得次数 for(i=0; i&lt;img_row; ++i) for(j=0; j&lt;img_col; ++j) ++histogram[mt9v03x_image[i][j]]; //第三步： 获取最小最大灰度值 int minGray,maxGray; for(minGray=0;minGray&lt;256&amp;&amp;histogram[minGray]==0;++minGray); for(maxGray=255;maxGray&gt;minGray&amp;&amp;histogram[minGray]==0;--maxGray); //第四步：分情况讨论 // 最大=最小，图像只有一种颜色 if(maxGray==minGray) return maxGray; //最大=最小+1，图像只有两种颜色 if(maxGray==minGray+1) return minGray; //第五步：统计[最小,最大]范围内的像素总数 int PixelSum=0; for(i=minGray; i&lt;maxGray+1; ++i) PixelSum += histogram[i]; //第六步：统计[最小,最大]范围内的灰度值总数(灰度值*出现次数) int GraySum=0; for(i=minGray; i&lt;maxGray+1; ++i) GraySum += histogram[i]*i; //第七步： 大津法优化 double w0; //前景像素点占整幅图像的百分比 double w1; //背景像素点占整幅图像的百分比 int w0num; //前景像素点数 int w1num; // 背景像素点数 int u0gray; //前景灰度值 int u1gray; //背景灰度值 double u0; //w0平均灰度 double u1; //w1平均灰度 double deltaTmp=0,deltaMax=-1; int th; u0gray = u1gray = w0num = w1num = 0; for(i=minGray; i&lt;maxGray; i++) &#123; w0num += histogram[i]; w1num = PixelSum-w0num; w0 = w0num*1.0/PixelSum; w1 = w1num*1.0/PixelSum; u0gray += histogram[i]*i; u1gray = GraySum-u0gray; u0 = u0gray*1.0/w0num; u1 = u1gray*1.0/w1num; deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2 //第八步：遍历最大类间方差（因为呈正态分布） if(deltaTmp&gt;deltaMax) &#123; deltaMax = deltaTmp; th = i; &#125; &#125; return th; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148//简单找点void Scan_Point1(void) &#123; int i,j; int sum,num; int point[row];// int right,left,bottom,top; int flag,top,bottom; //第一步：找到左右边界进行折半取中值 flag=0; for(i=0;i&lt;row;++i) &#123; sum=0,num=0; for(j=0;j&lt;col-1;++j) &#123; if(bin_img[i][j]==255&amp;&amp;bin_img[i][j+1]==255)&#123; sum += j; ++num; &#125;else if(bin_img[i][j-1]==255&amp;&amp;bin_img[i][j]==0&amp;&amp;bin_img[i][j+1]==0) break; &#125; if(sum) point[i] = sum/num; else&#123; point[i] = 0xff; ++flag; &#125; &#125; //第二步：找到上下边界，折半得中点坐标 if(flag&lt;row) &#123; sum=0,num=0,flag=1; for(i=0;i&lt;row-1;++i) &#123; if(point[i] != 0xff)&#123; sum += point[i]; ++num; if(flag)&#123; top = i; flag = 0; &#125; &#125;else if(point[i]==0xff&amp;&amp;point[i-1]!=0xff&amp;&amp;point[i+1]==0xff)&#123; bottom = i; break; &#125; &#125; if(num) &#123; mid_x = sum/num; mid_y = top + num/2; ips200_drawpoint(mid_x,mid_y,RED);//列，行 ips200_drawpoint(mid_x+1,mid_y+1,RED);//列，行 ips200_drawpoint(mid_x,mid_y+1,RED);//列，行 ips200_drawpoint(mid_x+1,mid_y,RED);//列，行 sign_Beacon(mid_x,mid_y,top-10,bottom+10); &#125; &#125;else&#123; mid_x=120; &#125; &#125;void Scan_Point1(void) &#123; int i,j; int sum,num; int point[row];// int right,left,bottom,top; int flag,top,bottom; //第一步：找到左右边界进行折半取中值 flag=0; for(i=0;i&lt;row;++i) &#123; sum=0,num=0; for(j=0;j&lt;col;++j) &#123;// if(flag)&#123;// if(mt9v03x_image[i][j]&gt;=70)&#123;// left = j;// flag = 0;// &#125;// &#125;else&#123;// if(mt9v03x_image[i][j-1]&gt;=70&amp;&amp;mt9v03x_image[i][j]&lt;70&amp;&amp;mt9v03x_image[i][j+1]&lt;70)&#123;// right = j;// flag = 1;// break;// &#125;// &#125; if(mt9v03x_image[i][j]&gt;69)&#123; sum = sum + j; ++num; &#125;else if(mt9v03x_image[i-1][j]&gt;=70&amp;&amp;mt9v03x_image[i][j]&lt;70&amp;&amp;mt9v03x_image[i][j+1]&lt;70) break; &#125;// if(flag==0&amp;&amp;j==col)right = col-1;// if(left&lt;right)// point[i] = (left+right)&gt;&gt;1;// else// point[i] = 0xff;// left = right = 0; if(sum) point[i]=sum/num; else&#123; point[i] = 0xff; ++flag; &#125; &#125; //第二步：找到上下边界，折半得中点坐标 if(flag!=row) &#123; sum=0,num=0,flag=1; for(i=0;i&lt;row;++i) &#123; if(point[i] != 0xff)&#123; sum += point[i]; num++; if(flag)&#123; top = i; flag = 0; &#125; &#125;else if(point[i]==0xff&amp;&amp;point[i-1]!=0xff&amp;&amp;point[i+1]==0xff)&#123; bottom = i; break; &#125; &#125; mid_x = sum/num; mid_y = first + num/2; ips200_drawpoint(mid_x,mid_y,RED);//列，行 sign_Beacon(mid_x,mid_y,top,bottom); &#125;else&#123; mid_x=120; &#125; &#125;//标出信标灯的位置void sign_Beacon(int x,int y,int top,int bottom)&#123; int i,j; for(i=top-10;i&lt;bottom+10;++i) &#123; ips200_drawpoint(x,i,RED);//列，行 for(j=0;j&lt;col;++j) ips200_drawpoint(j,y,RED);//列，行 &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#include &quot;headfile.h&quot;#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80#define white 255#define black 0#define GrayScale 256uint8 bin_img[row][col]; //二值化图 uint8 gray_img[row][col]; //灰度图 int mid_x,mid_y;//可以不加二值化浪费时间，直接通过阈值来判断//只改变与偏差有关的，与中线有关的间接有关的都不改变//滤波等，思考……效率问题//#define RED 0xF800 // 红色//#define BLUE 0x001F // 蓝色//#define YELLOW 0xFFE0 // 黄色//#define GREEN 0x07E0 // 绿色//#define WHITE 0xFFFF // 白色//#define BLACK 0x0000 // 黑色 //#define GRAY 0X8430 // 灰色//#define BROWN 0XBC40 // 棕色//#define PURPLE 0XF81F // 紫色//#define PINK 0XFE19 //main函数void camera(void)&#123; int threshold;//=70;//灰20-70；白70-126 -127-0 if(mt9v03x_finish_flag) &#123;// threshold=OTSU(); threshold=70; //加一个：黑白天阈值限定 Binarization(threshold); ips200_displayimage032(bin_img[0],col, row); Scan_Point1(); &#125; &#125;//图像二值化 void Binarization(int threshold)&#123; int i,j; for(i=0; i&lt;row; ++i) &#123; for(j=0; j&lt;col; ++j) &#123; if(mt9v03x_image[i][j]&gt;threshold) bin_img[i][j]=white; else bin_img[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0;&#125;//大津算法int OTSU(void)&#123; int i,j; int img_row=row,img_col=col; int histogram[GrayScale]; //灰度直方图 //第一步：初始化灰度直方图 for(i=0; i&lt;GrayScale; ++i) histogram[i]=0; //第二步：统计每个灰度值出现得次数 for(i=0; i&lt;img_row; ++i) for(j=0; j&lt;img_col; ++j) ++histogram[mt9v03x_image[i][j]]; //第三步： 获取最小最大灰度值 int minGray,maxGray; for(minGray=0;minGray&lt;256&amp;&amp;histogram[minGray]==0;++minGray); for(maxGray=255;maxGray&gt;minGray&amp;&amp;histogram[minGray]==0;--maxGray); //第四步：分情况讨论 // 最大=最小，图像只有一种颜色 if(maxGray==minGray) return maxGray; //最大=最小+1，图像只有两种颜色 if(maxGray==minGray+1) return minGray; //第五步：统计[最小,最大]范围内的像素总数 int PixelSum=0; for(i=minGray; i&lt;maxGray+1; ++i) PixelSum += histogram[i]; //第六步：统计[最小,最大]范围内的灰度值总数(灰度值*出现次数) int GraySum=0; for(i=minGray; i&lt;maxGray+1; ++i) GraySum += histogram[i]*i; //第七步： 大津法优化 double w0; //前景像素点占整幅图像的百分比 double w1; //背景像素点占整幅图像的百分比 int w0num; //前景像素点数 int w1num; // 背景像素点数 int u0gray; //前景灰度值 int u1gray; //背景灰度值 double u0; //w0平均灰度 double u1; //w1平均灰度 double deltaTmp=0,deltaMax=-1; int th; u0gray = u1gray = w0num = w1num = 0; for(i=minGray; i&lt;maxGray; i++) &#123; w0num += histogram[i]; w1num = PixelSum-w0num; w0 = w0num*1.0/PixelSum; w1 = w1num*1.0/PixelSum; u0gray += histogram[i]*i; u1gray = GraySum-u0gray; u0 = u0gray*1.0/w0num; u1 = u1gray*1.0/w1num; deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2 //第八步：遍历最大类间方差（因为呈正态分布） if(deltaTmp&gt;deltaMax) &#123; deltaMax = deltaTmp; th = i; &#125; &#125; return th; &#125;//简单找点//void Scan_Point1(void)//&#123;// int i,j,k;// int left,right,top,bottom;// int sum=0;// int point[row];// int flag1=1,flag2=1;// // for(i=0;i&lt;row;i++)// point[i] = 0;// // //第一步：找到左右边界进行折半取中值// for(i=0;i&lt;row;i++)// &#123;// left=col,right=0;// for(j=0;j&lt;col-3; )// &#123;// //连续四个点确定为信标//// if(bin_img[i][j]=255&amp;&amp;bin_img[i][j+1]==255&amp;&amp;bin_img[i][j+2]==255&amp;&amp;bin_img[i][j+3]==255)//// &#123;//// if(left==col)left=j-1;//// right = j+3;//// j += 4;//// continue;//// &#125;// if(bin_img[i][j]==255)// &#123;// if(left==col)left=j-1;// right = j;// j += 1;// flag1=0;// continue;// &#125;// j++;// &#125;// // if(left&lt;right)point[i]=(left+right)/2;// else point[i]=0xff;// // &#125; // //第二步：找到上下边界，折半得中点坐标// top=row,bottom=0,k=0;// for(i=0;i&lt;row-1;)// &#123;//// if(point[i]!=0xff&amp;&amp;point[i+1]!=0xff&amp;&amp;point[i+2]!=0xff&amp;&amp;point[i+3]!=0xff)//// &#123;//// if(top==row)top=i;//// bottom=i+3;//// i += 4;//// k += 4;//// continue;//// &#125;// if(point[i]!=0xff)// &#123;// if(top==row)top=i;// bottom=i+1;// i += 1;// k += 1;// flag2=0;// continue;// &#125;// i++;// &#125;// //第三步：判断是否存在在信标灯// if(top&lt;=bottom)// &#123;// for(i=top;i&lt;=bottom;i++)// &#123;// if(point[i]!=0xff)sum += point[i];// &#125;// mid_x = sum/k;// mid_y = top+(bottom-top)/2;// &#125;// if(flag1==0&amp;&amp;flag2==0)&#123;// ips200_drawpoint(mid_x,mid_y,RED);//列，行// ips200_drawpoint(mid_x+1,mid_y+1,RED);//列，行// ips200_drawpoint(mid_x,mid_y+1,RED);//列，行// ips200_drawpoint(mid_x+1,mid_y,RED);//列，行// sign_Beacon(mid_x,mid_y);// &#125;// // if(flag1==1&amp;&amp;flag2==1)&#123;// mid_x=120;// &#125;//&#125;// //过滤噪点void Bin_Image_Filter(void)&#123; int i,j; for(i=1; i&lt;row-1;++i) &#123; for(j=1; j&lt;col-1;++j) &#123; if((bin_img[i][j]==0)&amp;&amp;(bin_img[i-1][j]+bin_img[i-1][j+1]+bin_img[i+1][j]+bin_img[i][j+1]+bin_img[i][j+2]&gt;3)) bin_img[i][j]=1; else if((bin_img[i][j]==1)&amp;&amp;(bin_img[i-1][j]+bin_img[i-1][j+1]+bin_img[i+1][j]+bin_img[i][j+1]+bin_img[i][j+2]&lt;2)) bin_img[i][j]=0; &#125; &#125;&#125;//标出信标灯的位置void sign_Beacon(int x,int y)&#123; int i,j; for(i=0;i&lt;row;i++) &#123; ips200_drawpoint(x,i,RED);//列，行 for(j=0;j&lt;col;j++) &#123; ips200_drawpoint(j,y,RED);//列，行 &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &quot;headfile.h&quot;#define col MT9V03X_W //宽 #define row MT9V03X_H //高 #define white 255#define black 0int bin_img[row][col]; //二值化图 int gray_img[row][col]; //灰度图 //图像二值化 void Binarization(void)&#123; int i,j; int threshold=OTSU(); for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; if(mt9v03x_image[i][j]&gt;=threshold) bin_img[i][j]=white; else bin_img[i][j]=black; gray_img[i][j]=mt9v03x_image[i][j]; &#125; &#125; mt9v03x_finish_flag = 0;&#125;//大津法求阈值 -&gt; 优化！速度慢！光线影响！(亮导致阈值高，暗导致阈值低) int OTSU(void)&#123; int i,j; int GrayScale=256; int pixelSum=row*col/4,graySum=0; //像素点总和，灰度值总和 int pixCount[GrayScale]; //灰度直方图 float pixPro[GrayScale]; //归一化处理 //第一步：初始化 for(i=0;i&lt;GrayScale;i++) &#123; histogram[i] = 0; normalization[i] = 0; &#125; //第二步：统计0-255灰度值出现次数 for(i=0;i&lt;row;i+=2) &#123; for(j=0;j&lt;col;j+=2) &#123; histogram[gray_img[i][j]]++; graySum += gray_img[i][j]; &#125; &#125; //第三步：灰度直方图归一化 [0,1] for(i=0;i&lt;GrayScale;i++) &#123; normalization[i] = histogram[i]*1.0/pixelSum; &#125; //第四步： 大津法公式套用 float w0 = 0; //前景像素点占整幅图像的比例 float w1 = 0; //背景景像素点占整幅图像的比例 double u0tmp; double u1tmp; double u0; //w0平均灰度 double u1; //w1平均灰度 double deltaTmp; double deltaMax = 0; int th = 0; w0 = w1 = u0tmp = u1tmp = u0 = u1 = deltaTmp = 0; for(i=0;i&lt;GrayScale;i++) &#123;// for (int j = 0; j &lt; GrayScale; j++) // &#123;// if (j &lt;= i) //前景// &#123; // w0 += pixPro[j];// u0tmp += j * pixPro[j];// &#125; // else //背景// &#123; // w1 += pixPro[j];// u1tmp += j * pixPro[j];// &#125;// &#125; w0 += pixPro[j]; u0tmp += j * pixPro[j]; w1 = 1-w0; u1tmp = graySum/pixelSum-u0tmp; u0 = u0tmp / w0; u1 = u1tmp / w1; deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2 //第五步：0-255中找到大津法打分最高的阈值(正态分布) if (deltaTmp &gt; deltaMax) &#123; deltaMax = deltaTmp; th = i; &#125; if (deltaTmp &lt; deltaMax) break; &#125; return th;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;iostream&gt;using namespace std;//uint8 imgDeal1[MT9V03X_H][MT9V03X_W];//uint8 arr[9];int arr[9];int MT9V03X_H=10,MT9V03X_W=10;//int mt9v03x_image[MT9V03X_H][MT9V03X_W];//噪声处理 // *********************************************************************///快速排序 // *********************************************************************/void Quick_Sort(int begin,int end) &#123; int mid,i,j,temp; if(begin&gt;end) return; mid=filter[begin]; i=begin; j=end; while(i!=j) &#123; while(filter[j]&gt;=mid&amp;&amp;j&gt;i) j--; while(filter[i]&lt;=mid&amp;&amp;j&gt;i) i++; if(i&lt;j) &#123; temp=filter[i]; filter[i]=filter[j]; filter[j]=temp; &#125; &#125; filter[begin]=filter[i]; filter[i]=mid; Quick_Sort(begin,i-1); Quick_Sort(i+1,end);&#125;int filter[9];//中值滤波：斑点噪声和椒盐噪声 //用于当找到细小白点进行判断是否为灯，将白点过滤 // *********************************************************************/int MedianFilter(void)&#123; int mid; //第一步：3*3的观察窗，快速排序或堆排序 (使用灰度图像) Quick_Sort(0,8); //第二步：求出中值 mid = filter[4]; //第三步：替换白点 return mid;&#125;int point[row];//求信标灯各行的中值 void find_LR(void) &#123; int i,j; int left,right; for(i=0;i&lt;row;i++) &#123; left=col,right=0; for(j=0;j&lt;col-1;j++) &#123; //同一行要连续两个白点显示 if(!bin_img[i][j]&amp;&amp;!bin_img[i][j+1]) &#123; if(left==col)left=j; //左边缘确定 right = j+1; //右边缘确定 &#125; &#125; if(left&lt;right)point[i]=(left+right)/2; else point[i]=col; &#125;&#125;//求信标灯的坐标(mid_x,mid_y) void find_XY(void)&#123; int i,j,flag1=1,flag2=1,m=0,n=0,sum=0; int mid_x,mid_y; for(i=0;i&lt;row-3;i++) &#123; if(point[i]!=col&amp;&amp;point[i+1]!=col)//连续四个点确定为信标灯 &#123; if(flag1) &#123; m=i; flag1=0; &#125; else if(flag2)n++; &#125; else &#123; if(n&gt;=3)flag2=0; else flag1=1; &#125; &#125; for(j=0;j&lt;n;i++)sum+=point[m+j]; mid_x = sum/(n+1); mid_y = m+(n&gt;&gt;1);&#125;//判断是否是信标灯：因为环境中也存在红外光但信标灯是闪烁的，故和其他红外区分 int isBeacon()&#123; int i,j; int threshold; int bin_img1[row][col],bin_img2[row][col]; threshold=OTSU(); for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; if(mt9v03x_image[i][j]&gt;=threshold) bin_img1[i][j]=white; else bin_img1[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0; systick_delay_ms(2); threshold=OTSU(); for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; if(mt9v03x_image[i][j]&gt;=threshold) bin_img2[i][j]=white; else bin_img2[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0; for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; bin_img[i][j]=bin_img1[i][j]^bin_img2[i][j]; &#125; &#125;&#125;//均值滤波// *********************************************************************/int main()&#123;// Quick_Sort(0,18);// for(int i=0;i&lt;19;i++)// cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280#include &quot;headfile.h&quot;#define col MT9V03X_W //120 //MT9V03X_W 宽 #define row MT9V03X_H//80 //MT9V03X_H 高 #define white 255#define black 0uint8 bin_img[row][col]; //二值化图 uint8 gray_img[row][col]; //灰度图 int pixCount[256]; //灰度直方图float pixPro[256]; //归一化处理 void camera(void)&#123; Binarization(); ips200_displayimage032(bin_img[0],MT9V03X_W, MT9V03X_H); // isBeacon(); find_LR();// find_XY();&#125;//图像二值化 void Binarization(void)&#123; int i,j;// int threshold=OTSU(); int threshold=129; for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; if(mt9v03x_image[i][j]&gt;=threshold) bin_img[i][j]=white; else bin_img[i][j]=black; gray_img[i][j]=mt9v03x_image[i][j]; &#125; &#125; mt9v03x_finish_flag = 0;&#125;int point[row];//求信标灯各行的中值 void find_LR(void) &#123; int i,j; int left,right; for(i=0;i&lt;row;i++) &#123; left=col,right=0; for(j=0;j&lt;col-1;j++) &#123; //同一行要连续两个白点显示 if(!bin_img[i][j]&amp;&amp;!bin_img[i][j+1]) &#123; if(left==col)left=j; //左边缘确定 right = j+1; //右边缘确定 ips200_drawpoint(left,i,RED); &#125; &#125; if(left&lt;right)point[i]=(left+right)/2; else point[i]=col; ips200_drawpoint(right,i,RED); &#125;&#125;//求信标灯的坐标(mid_x,mid_y) void find_XY(void)&#123; int i,j,flag1=1,flag2=1,m=0,n=0,sum=0; int mid_x,mid_y; for(i=0;i&lt;row-3;i++) &#123; if(point[i]!=col&amp;&amp;point[i+1]!=col)//连续四个点确定为信标灯 &#123; if(flag1) &#123; m=i; flag1=0; &#125; else if(flag2)n++; &#125; else &#123; if(n&gt;=3)flag2=0; else flag1=1; &#125; &#125; for(j=0;j&lt;n;i++)sum+=point[m+j]; mid_x = sum/(n+1); mid_y = m+(n&gt;&gt;1); ips200_drawpoint(mid_x,mid_y,BLUE);&#125;void Scan_Point2(void)&#123; int i,j; int left,right; int threshold=70; for(i=0;i&lt;row;i++) &#123; left=col,right=0; for(j=1;j&lt;col-1;j++) &#123; if(mt9v03x_image[i][j-1]&gt;threshold&amp;&amp;mt9v03x_image[i][j]&gt;threshold&amp;&amp;mt9v03x_image[i][j+1]&gt;threshold) &#123; if(left==col)left=j-1; ips200_drawpoint(left,i,RED);//列，行 ips200_showint8(120,139,left); ips200_showint8(120,140,i); &#125; &#125; &#125; &#125; //判断是否是信标灯：因为环境中也存在红外光但信标灯是闪烁的，故和其他红外区分 void isBeacon(void)&#123; int i,j; int threshold; int bin_img1[row][col],bin_img2[row][col]; threshold=OTSU(); for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; if(mt9v03x_image[i][j]&gt;=threshold) bin_img1[i][j]=white; else bin_img1[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0; systick_delay_ms(2); threshold=OTSU(); for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; if(mt9v03x_image[i][j]&gt;=threshold) bin_img2[i][j]=white; else bin_img2[i][j]=black; &#125; &#125; mt9v03x_finish_flag = 0; for(i=0;i&lt;row;i++) &#123; for(j=0;j&lt;col;j++) &#123; bin_img[i][j]=bin_img1[i][j]^bin_img2[i][j]; &#125; &#125;&#125;//大津法求阈值 -&gt; 优化！速度慢！光线影响！(亮导致阈值高，暗导致阈值低) //不能用，直立对光线要求高，大津法1ms会导致闪频等，若使用需要加滤波//int OTSU(void)//&#123;// int i,j;// int GrayScale=256;// int pixelSum=row*col/4,graySum=0; //像素点总和，灰度值总和 //// int pixCount[256]; //灰度直方图//// float pixPro[256]; //归一化处理 // // //第一步：初始化 // for(i=0;i&lt;GrayScale;i++)// &#123;// pixCount[i] = 0;// pixPro[i] = 0; // &#125; // // //第二步：统计0-255灰度值出现次数// for(i=0;i&lt;row;i+=2)// &#123;// for(j=0;j&lt;col;j+=2)// &#123;// pixCount[mt9v03x_image[i][j]]++;// graySum += mt9v03x_image[i][j];// &#125;// &#125;// // //第三步：灰度直方图归一化 [0,1] // for(i=0;i&lt;GrayScale;i++)// &#123;// pixPro[i] = pixCount[i]*1.0/pixelSum;// &#125;// // //第四步： 大津法公式套用// float w0 = 0; //前景像素点占整幅图像的比例// float w1 = 0; //背景景像素点占整幅图像的比例 // double u0tmp;// double u1tmp;// double u0; //w0平均灰度// double u1; //w1平均灰度// double deltaTmp;// double deltaMax = 0;// int th = 0;// // w0 = w1 = u0tmp = u1tmp = u0 = u1 = deltaTmp = 0;// for(i=0;i&lt;GrayScale;i++)// &#123;//// for (int j = 0; j &lt; GrayScale; j++) //// &#123;//// if (j &lt;= i) //前景//// &#123; //// w0 += pixPro[j];//// u0tmp += j * pixPro[j];//// &#125; //// else //背景//// &#123; //// w1 += pixPro[j];//// u1tmp += j * pixPro[j];//// &#125;//// &#125;// // w0 += pixPro[j];// u0tmp += j * pixPro[j];// w1 = 1-w0;// u1tmp = graySum/pixelSum-u0tmp;// // u0 = u0tmp / w0;// u1 = u1tmp / w1;// deltaTmp = (float)(w0 * w1 * (u0 - u1)*(u0 - u1)); //类间方差公式 g = w0 * w1 * (u0 - u1) ^ 2// // //第五步：0-255中找到大津法打分最高的阈值(正态分布) // if (deltaTmp &gt; deltaMax) // &#123;// deltaMax = deltaTmp;// th = i;// &#125;// if (deltaTmp &lt; deltaMax) break;// &#125;//// return th;//&#125;//快速排序//void Quick_Sort(int begin,int end) //&#123;// int mid,i,j,temp;// if(begin&gt;end)// return;// mid=arr[begin];// i=begin;// j=end;// while(i!=j)// &#123;// while(arr[j]&gt;=mid&amp;&amp;j&gt;i)// j--;// while(arr[i]&lt;=mid&amp;&amp;j&gt;i)// i++;// if(i&lt;j)// &#123;// temp=arr[i];// arr[i]=arr[j];// arr[j]=temp;// &#125;// &#125;// arr[begin]=arr[i];// arr[i]=mid;// Quick_Sort(begin,i-1);// Quick_Sort(i+1,end);//&#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"连通域算法（灰度图像处理）","slug":"智能车/连通域算法","date":"2022-04-20T01:48:59.440Z","updated":"2022-07-17T08:50:24.111Z","comments":true,"path":"2022/04/20/智能车/连通域算法/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/20/%E6%99%BA%E8%83%BD%E8%BD%A6/%E8%BF%9E%E9%80%9A%E5%9F%9F%E7%AE%97%E6%B3%95/","excerpt":"","text":"用FPGA做图像处理的基础知识 在一些工业领域用的图像传感器有哪些？ FPGA完成某些机器视觉任务的处理流程 为什么用FPGA进行数据处理能达到最高的实时性 课程b站《从零开始系统学FPGA》 一二比较重要：建立时间、保持时间、插入流水线寄存器提高电路频率等这些概念都是面试必问的；用实时流水线的方式处理各种数据是FPGA运用的精髓；Verilog写代码必备能力 工业上除了会用到手机和相机中常见的面阵传感器之外，还会用到线阵传感器。线阵传感器的分辨率是几k乘1，也就是它只扫描一行图像，主要用于扫描仪里和一些需要扫描传送带上的物料的工业应用场合。 物料传送-&gt;机器视觉-&gt;执行机构：物料检测分选系统 代码部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261//网上原代码 1 class AreaMark 2 &#123; 3 public: 4 AreaMark(const Mat src,int offset); 5 int getMarkedArea(vector&lt;vector&lt;int&gt;&gt; &amp;area); 6 void getMarkedImage(Mat &amp;dst); 7 8 private: 9 Mat src; 10 int offset; 11 int numberOfArea=0; 12 vector&lt;int&gt; labelMap; 13 vector&lt;int&gt; labelRank; 14 vector&lt;int&gt; stArea; 15 vector&lt;int&gt; enArea; 16 vector&lt;int&gt; rowArea; 17 vector&lt;int&gt; labelOfArea; 18 vector&lt;pair&lt;int, int&gt;&gt; equalLabels; 19 20 void markArea(); 21 void searchArea(); 22 void setInit(int n); 23 int findRoot(int label); 24 void unite(int labelA, int labelB); 25 void replaceEqualMark(); 26 &#125;; 27 28 // 构造函数 29 // imageInput:输入待标记二值图像 offsetInput:0为四连通，1为八连通 30 AreaMark::AreaMark(Mat imageInput,int offsetInput) 31 &#123; 32 src = imageInput; 33 offset = offsetInput; 34 &#125; 35 36 // 获取颜色标记图片 37 void AreaMark::getMarkedImage(Mat &amp;dst) 38 &#123; 39 Mat img(src.rows, src.cols, CV_8UC3, CV_RGB(0, 0, 0)); 40 cvtColor(img, dst, CV_RGB2HSV); 41 42 int maxLabel = *max_element(labelOfArea.begin(), labelOfArea.end()); 43 vector&lt;uchar&gt; hue; 44 for (int i = 1; i&lt;= maxLabel; i++) 45 &#123; 46 // 使用HSV模型生成可区分颜色 47 hue.push_back(uchar(180.0 * (i - 1) / (maxLabel + 1))); 48 &#125; 49 50 for (int i = 0; i &lt; numberOfArea; i++) 51 &#123; 52 for (int j = stArea[i]; j &lt;= enArea[i]; j++) 53 &#123; 54 dst.at&lt;Vec3b&gt;(rowArea[i], j)[0] = hue[labelOfArea[i]]; 55 dst.at&lt;Vec3b&gt;(rowArea[i], j)[1] = 255; 56 dst.at&lt;Vec3b&gt;(rowArea[i], j)[2] = 255; 57 &#125; 58 &#125; 59 60 cvtColor(dst, dst, CV_HSV2BGR); 61 &#125; 62 63 // 获取标记过的各行子区域 64 int AreaMark::getMarkedArea(vector&lt;vector&lt;int&gt;&gt; &amp;area) 65 &#123; 66 searchArea(); 67 markArea(); 68 replaceEqualMark(); 69 area.push_back(rowArea); 70 area.push_back(stArea); 71 area.push_back(enArea); 72 area.push_back(labelOfArea); 73 return numberOfArea; 74 &#125; 75 76 void AreaMark::searchArea() 77 &#123; 78 for (int row = 0; row &lt; src.rows; row++) 79 &#123; 80 // 行指针 81 const uchar *rowData = src.ptr&lt;uchar&gt;(row); 82 83 // 判断行首是否是子区域的开始点 84 if (rowData[0] == 255) 85 &#123; 86 numberOfArea++; 87 stArea.push_back(0); 88 &#125; 89 90 for (int col = 1; col &lt; src.cols; col++) 91 &#123; 92 // 子区域开始位置的判断：前像素为背景，当前像素是前景 93 if (rowData[col - 1] == 0 &amp;&amp; rowData[col] == 255) 94 &#123; 95 // 在开始位置更新区域总数、开始位置vector 96 numberOfArea++; 97 stArea.push_back(col); 98 // 子区域结束位置的判断：前像素是前景，当前像素是背景 99 &#125;else if (rowData[col - 1] == 255 &amp;&amp; rowData[col] == 0)100 &#123;101 // 更新结束位置vector、行号vector102 enArea.push_back(col - 1);103 rowArea.push_back(row);104 &#125;105 &#125;106 // 结束位置在行末107 if (rowData[src.cols - 1] == 255)108 &#123;109 enArea.push_back(src.cols - 1);110 rowArea.push_back(row);111 &#125;112 &#125;113 &#125;114115116117 void AreaMark::markArea()118 &#123;119 int label = 1;120 // 当前所在行121 int curRow = 0;122 // 当前行的第一个子区域位置索引123 int firstAreaCur = 0;124 // 前一行的第一个子区域位置索引125 int firstAreaPrev = 0;126 // 前一行的最后一个子区域位置索引127 int lastAreaPrev = 0;128129 // 初始化标签都为0130 labelOfArea.assign(numberOfArea, 0);131 132 // 遍历所有子区域并标记133 for (int i = 0; i &lt; numberOfArea; i++)134 &#123;135 // 行切换时更新状态变量136 if (curRow != rowArea[i])137 &#123;138 curRow = rowArea[i];139 firstAreaPrev = firstAreaCur;140 lastAreaPrev = i - 1;141 firstAreaCur = i;142 &#125;143144 // 相邻行不存在子区域145 if (curRow != rowArea[firstAreaPrev] + 1)146 &#123;147 labelOfArea[i] = label++;148 continue;149 &#125;150 // 对前一行进行迭代151 for (int j = firstAreaPrev; j &lt;= lastAreaPrev; j++)152 &#123;153 // 判断是否相连154 if (stArea[i] &lt;= enArea[j] + offset &amp;&amp; enArea[i] &gt;= stArea[j] - offset)155 &#123;156 if (labelOfArea[i] == 0)157 // 之前没有标记过158 labelOfArea[i] = labelOfArea[j];159 else if (labelOfArea[i] != labelOfArea[j])160 // 之前已经被标记，保存等价对161 equalLabels.push_back(make_pair(labelOfArea[i], labelOfArea[j]));162 &#125;else if (enArea[i] &lt; stArea[j] - offset)163 &#123;164 // 为当前行下一个子区域缩小上一行的迭代范围165 firstAreaPrev = max(firstAreaPrev, j - 1);166 break;167 &#125;168 &#125;169 // 与上一行不存在相连170 if (labelOfArea[i] == 0)171 &#123;172 labelOfArea[i] = label++;173 &#125;174 &#125;175 &#125;176177178 // 并查集初始化179 void AreaMark::setInit(int n)180 &#123;181 for (int i = 0; i &lt;= n; i++)182 &#123;183 labelMap.push_back(i);184 labelRank.push_back(0);185 &#125;186 &#125;187188 // 查根189 int AreaMark::findRoot(int label)190 &#123;191 if (labelMap[label] == label)192 &#123;193 return label;194 &#125;195 else196 &#123;197 //路径压缩优化198 return labelMap[label] = findRoot(labelMap[label]);199 &#125;200 &#125;201202 // 合并203 void AreaMark::unite(int labelA, int labelB)204 &#123;205 labelA = findRoot(labelA);206 labelB = findRoot(labelB);207208 if (labelA == labelB)209 &#123;210 return;211 &#125;212 // 秩优化，秩大的树合并秩小的树213 if (labelRank[labelA] &lt; labelRank[labelB])214 &#123;215 labelMap[labelA] = labelB;216 &#125;217 else218 &#123;219 labelMap[labelB] = labelA;220 if (labelRank[labelA] == labelRank[labelB])221 &#123;222 labelRank[labelA]++;223 &#125;224 &#125;225 226 &#125;227228 // 等价对处理，标签重映射229 void AreaMark::replaceEqualMark()230 &#123;231 int maxLabel = *max_element(labelOfArea.begin(), labelOfArea.end());232 233 setInit(maxLabel);234 235 // 合并等价对，标签初映射236 vector&lt;pair&lt;int, int&gt;&gt;::iterator labPair;237 for (labPair = equalLabels.begin(); labPair != equalLabels.end(); labPair++)238 &#123;239 unite(labPair-&gt;first, labPair-&gt;second);240 &#125;241242 // 标签重映射，填补缺失标签243 int newLabel=0;244 vector&lt;int&gt; labelReMap(maxLabel + 1, 0);245 vector&lt;int&gt;::iterator old;246 for (old = labelMap.begin(); old != labelMap.end(); old++)247 &#123;248 if (labelReMap[findRoot(*old)] == 0)249 &#123;250 labelReMap[findRoot(*old)] = newLabel++;251 &#125;252 &#125;253 // 根据重映射结果修改标签254 vector&lt;int&gt;::iterator label;255 for (label = labelOfArea.begin(); label != labelOfArea.end(); label++)256 &#123;257 *label = labelReMap[findRoot(*label)];258 &#125; 259260 &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//自己写的：数组的四邻域#include&lt;iostream&gt;using namespace std; #define white 1#define black 0#define row 16#define col 16#define maxnum 1000#define offset 0 //0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15int bin_img[row][col] = &#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,// 0 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,// 1 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,// 2 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0,// 3 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0,// 4 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0,// 5 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 6 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 7 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 8 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,// 9 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,// 10 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 11 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,// 12 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,// 13 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,// 14 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0&#125;;// 15int area_start[maxnum];int area_end[maxnum];int area_row[maxnum];int num_area; void searchArea(void)&#123; int i,j; int ns=0,ne=0,nr=0; num_area = 0; for(i=0;i&lt;row;i++)&#123; if(bin_img[i][0]==white)&#123; num_area++; area_start[ns++]=0; &#125; for(j=1;j&lt;col;j++)&#123; if(bin_img[i][j-1]==black&amp;&amp;bin_img[i][j]==white)&#123; num_area++; area_start[ns++]=j; &#125;else if(bin_img[i][j]==black&amp;&amp;bin_img[i][j-1]==white)&#123; area_end[ne++]=j-1; area_row[nr++]=i; &#125; &#125; if(bin_img[i][col-1]==white)&#123; area_end[ne++]=col-1; area_row[nr++]=i; &#125; &#125;&#125;int area_label[maxnum];int equalLabels[maxnum][2];void markArea(void)&#123; int i,j; int nel=0; int label=1; int row_current=0; int index_currentFirstArea=0; int index_preFirstArea=0; int index_preLastArea=0; for(i=0;i&lt;num_area;i++)&#123; area_label[i]=0; &#125; for(i=0;i&lt;num_area;i++)&#123; //轮到下一行时，变量更新 if(row_current!=area_row[i])&#123; row_current = area_row[i]; index_preFirstArea = index_currentFirstArea; index_preLastArea = i-1; index_currentFirstArea = i; &#125; if(row_current!=area_row[index_preFirstArea]+1)&#123; //相邻行不存在子区域 area_label[i]=label++; &#125;else&#123; //当前行与上一行进行比较 for(j=index_preFirstArea;j&lt;=index_preLastArea;j++)&#123; if(area_start[i]&lt;=area_end[j]+offset&amp;&amp;area_end[i]&gt;=area_start[j]-offset)&#123; //相连的情况 if(area_label[i]==0)&#123; //没有标记情况 area_label[i]=area_label[j]; &#125;else if(area_label[i]!=area_label[j])&#123; //已经标记过，保存等价对 equalLabels[nel][0]=area_label[i]; equalLabels[nel++][1]=area_label[j]; &#125; &#125;else if(area_end[i]&lt;area_start[j]-offset)&#123; //不相连的情况 if(index_preFirstArea&lt;j-1) index_preFirstArea=j-1; j=index_preLastArea; &#125; &#125; &#125; //这一行循环完与上一行不存在联系 if(area_label[i]==0)&#123; area_label[i] = ++label; &#125; &#125; &#125;// 等价对处理，标签重映射int labelMap[maxnum];int labelRank[maxnum];void replaceEqualMark(void)&#123; int i,j; for(i=0;i&lt;num_area;i++)&#123; labelMap[i]=i; labelRank[i]=0; &#125;&#125;int main()&#123; int i,j; int s,e,r,l; searchArea(); markArea();// for(int i=0;i&lt;num_area;i++)&#123;// cout&lt;&lt;area_start[i]&lt;&lt;&quot; &quot;&lt;&lt;area_end[i]&lt;&lt;&quot; &quot;&lt;&lt;area_row[i]&lt;&lt;endl;//// cout&lt;&lt;area_label[i]&lt;&lt;&quot; &quot;&lt;&lt;equalLabels[i][0]&lt;&lt;&quot; &quot;&lt;&lt;equalLabels[i][1]&lt;&lt;endl;// &#125; for(i=0;i&lt;num_area;i++)&#123; r=area_row[i]; s=area_start[i]; e=area_end[i]; l=area_label[i]; for(j=s;j&lt;=e;j++)&#123; bin_img[r][j]=l; &#125; &#125; for(i=0;i&lt;row;i++)&#123; for(j=0;j&lt;col;j++)&#123; cout&lt;&lt;bin_img[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177//自己写的：改了一半的用链式指针的连通域#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define white 1#define black 0#define row 16#define col 16#define offset 0 //0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15int bin_img[row][col] = &#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,// 0 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,// 1 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,// 2 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0,// 3 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0,// 4 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0,// 5 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 6 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 7 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 8 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,// 9 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,// 10 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 11 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,// 12 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0,// 13 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,// 14 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0&#125;;// 15struct Node&#123; int data; struct Node *next;&#125;;struct Node *area_start,*area_end,*area_row,*area_label;int num_area;void Insert(struct Node *head,int data)&#123; struct Node *temp; temp=(struct Node*)malloc(sizeof(struct Node)); temp-&gt;data = data; temp-&gt;next = head-&gt;next; head-&gt;next = temp;&#125;void Display(struct Node *head)&#123; struct Node*p; p = head-&gt;next; while(p!=NULL) &#123; printf(&quot;%d &quot;,p-&gt;data); p=p-&gt;next; &#125;&#125;void Delete(struct Node *head)&#123; struct Node *p,*q; p = head-&gt;next; while(p!=NULL)&#123; q=p-&gt;next; free(p); p=q; &#125; head-&gt;next=NULL;&#125;void searchArea(void)&#123; int i,j; num_area=0; area_start=(struct Node*)malloc(sizeof(struct Node)); area_start-&gt;next=NULL; area_end=(struct Node*)malloc(sizeof(struct Node)); area_end-&gt;next=NULL; area_row=(struct Node*)malloc(sizeof(struct Node)); area_row-&gt;next=NULL; for(i=0;i&lt;row;i++)&#123; if(bin_img[i][0]==white)&#123; num_area++; Insert(area_start,0); &#125; for(j=1;j&lt;col;j++)&#123; if(bin_img[i][j-1]==black&amp;&amp;bin_img[i][j]==white)&#123; num_area++; Insert(area_start,j); &#125;else if(bin_img[i][j]==black&amp;&amp;bin_img[i][j-1]==white)&#123; Insert(area_end,j-1); Insert(area_row,i); &#125; &#125; if(bin_img[i][col-1]==white)&#123; Insert(area_end,col-1); Insert(area_row,i); &#125; &#125;&#125;void markArea(void)&#123; int i,j; int nel=0; int label=1; int row_current=area_row-&gt;next-&gt;data; struct Node *index_currentFirstArea=area_row-&gt;next; struct Node *index_preFirstArea=area_row-&gt;next; struct Node *index_preLastArea=area_row-&gt;next; area_label=(struct Node*)malloc(sizeof(struct Node)); area_label-&gt;next=NULL; struct Node *pr,*pr_pre,*pl,*ps,*pe; pr=area_row-&gt;next; pr_pre=area_row; ps=area_start-&gt;next; pe=area_end-&gt;next; for(i=0;i&lt;num_area;i++)&#123; Insert(area_label,0); &#125; pl=area_label-&gt;next; for(i=0;i&lt;num_area;i++)&#123; //轮到下一行时，变量更新 if(row_current!=pr-&gt;data)&#123; row_current = pr-&gt;data; index_preFirstArea = index_currentFirstArea; index_preLastArea = pr_pre; index_currentFirstArea = pr; &#125; if(row_current!=index_preFirstArea-&gt;data-1)&#123; //相邻行不存在子区域 pl-&gt;data= ++label; &#125;else&#123; //当前行与上一行进行比较 struct Node *t1,*t2; t1=index_preLastArea; t2=index_preFirstArea; while()&#123; if(ps-&gt;data&lt;=) &#125; for(j=index_preFirstArea;j&lt;=index_preLastArea;j++)&#123; if(area_start[i]&lt;=area_end[j]+offset&amp;&amp;area_end[i]&gt;=area_start[j]-offset)&#123; //相连的情况 if(area_label[i]==0)&#123; //没有标记情况 area_label[i]=area_label[j]; &#125;else if(area_label[i]!=area_label[j])&#123; //已经标记过，保存等价对 equalLabels[nel][0]=area_label[i]; equalLabels[nel++][1]=area_label[j]; &#125; &#125;else if(area_end[i]&lt;area_start[j]-offset)&#123; //不相连的情况 if(index_preFirstArea&lt;j-1) index_preFirstArea=j-1; j=index_preLastArea; &#125; &#125; &#125; //这一行循环完与上一行不存在联系 if(area_label[i]==0)&#123; area_label[i] = ++label; &#125; pr = pr-&gt;next; pr_pre = pr_pre-&gt;next; ps=ps-&gt;next; &#125; &#125;int main()&#123; searchArea();// printf(&quot;%d&quot;,ps-&gt;next); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//自己写的：竞速的四邻域 //0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15int bin_img[row][col] = &#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,// 0 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,// 1 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,// 2 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0,// 3 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0,// 4 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0,// 5 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 6 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 7 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 8 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,// 9 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,// 10 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 11 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0,// 12 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,// 13 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,// 14 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0&#125;;// 15int i,j; int point_count=0; int point_x,point_y; int left=0,right=0,top=0,bottom=0; int n=0; int point[col+20][2]; for(i=0;i&lt;row;i++)&#123; for(j=0;j&lt;col;j++)&#123; if(bin_img[i][j]==white)&#123; point_count++; &#125;else&#123; if(point_count&gt;=2)&#123; point_x = j-point_count/2; point_y = i; while((point_x-left)&gt;-1&amp;&amp;bin_img[point_y][point_x-left]==white)&#123; left++; &#125; while(bin_img[point_y][point_x+right]==white&amp;&amp;(point_x+right)&lt;col)&#123; right++; &#125; while(bin_img[point_y-top][point_x]==white&amp;&amp;(point_y-top)&gt;-1)&#123; top++; &#125; while(bin_img[point_y+bottom][point_x]==white&amp;&amp;(point_y+bottom)&lt;row)&#123; bottom++; &#125; if((left-right)&lt;3&amp;&amp;(right-left)&lt;3&amp;&amp;(top-bottom)&lt;3&amp;&amp;(bottom-top)&lt;3)&#123; if(!(top==bottom&amp;&amp;top==1&amp;&amp;bottom==1)||!(right==left&amp;&amp;right==1&amp;&amp;left==1))&#123; point[n][0]=point_x; point[n++][1]=point_y;// cout&lt;&lt;&quot;point_count=&quot;&lt;&lt;point_count&lt;&lt;endl; cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;top&lt;&lt;&quot; &quot;&lt;&lt;bottom&lt;&lt;endl; cout&lt;&lt;&quot;point_x=&quot;&lt;&lt;point[n-1][1]&lt;&lt;&quot; point_y=&quot;&lt;&lt;point[n-1][0]&lt;&lt;endl; &#125; &#125; left=0,right=0,top=0,bottom=0; &#125; point_count=0; &#125; &#125; &#125; 小车使用的最终改版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#define col MT9V03X_W //宽 120#define row MT9V03X_H //高 80#define maxnum 1000#define offset 0uint8 bin_img[row][col]; //二值化图 uint8 domains[row][col]; //连通域图uint8 area_start[maxnum];uint8 area_end[maxnum];uint8 area_row[maxnum];uint8 num_area; uint8 area_label[maxnum];uint8 point[col+20][2];int equalLabels[maxnum][2];//连通域void Connect_domains(void)&#123; uint16 i,j; uint8 s,e,r,l; searchArea(); markArea(); for(i=0;i&lt;num_area;i++)&#123; r=area_row[i]; s=area_start[i]; e=area_end[i]; l=area_label[i]; for(j=s;j&lt;=e;j++)&#123; domains[r][j]=l;// ips200_drawpoint(j,r,RED);// ips200_drawpoint(j+1,r,RED); &#125; &#125;&#125;void searchArea(void)&#123; uint8 i,j; uint16 ns=0,ne=0,nr=0; num_area = 0; for(i=0;i&lt;row;i++)&#123; if(bin_img[i][0]==white)&#123; num_area++; area_start[ns++]=0; &#125; for(j=1;j&lt;col;j++)&#123; if(bin_img[i][j-1]==black&amp;&amp;bin_img[i][j]==white)&#123; num_area++; area_start[ns++]=j; &#125;else if(bin_img[i][j]==black&amp;&amp;bin_img[i][j-1]==white)&#123; area_end[ne++]=j-1; area_row[nr++]=i; &#125; &#125; if(bin_img[i][col-1]==white)&#123; area_end[ne++]=col-1; area_row[nr++]=i; &#125; &#125;&#125;void markArea(void)&#123; uint8 i,j;// int nel=0; uint8 label=1; uint8 row_current=0; uint8 index_currentFirstArea=0; uint8 index_preFirstArea=0; uint8 index_preLastArea=0; for(i=0;i&lt;num_area;i++)&#123; area_label[i]=0; &#125; for(i=0;i&lt;num_area;i++)&#123; //轮到下一行时，变量更新 if(row_current!=area_row[i])&#123; row_current = area_row[i]; index_preFirstArea = index_currentFirstArea; index_preLastArea = i-1; index_currentFirstArea = i; &#125; if(row_current!=area_row[index_preFirstArea]+1)&#123; //相邻行不存在子区域 area_label[i]=label++; &#125;else&#123; //当前行与上一行进行比较 for(j=index_preFirstArea;j&lt;=index_preLastArea;j++)&#123; if(area_start[i]&lt;=area_end[j]+offset&amp;&amp;area_end[i]&gt;=area_start[j]-offset)&#123; //相连的情况 if(area_label[i]==0)&#123; //没有标记情况 area_label[i]=area_label[j]; &#125;// else if(area_label[i]!=area_label[j])&#123;// //已经标记过，保存等价对 // equalLabels[nel][0]=area_label[i];// equalLabels[nel++][1]=area_label[j];// &#125; &#125;else if(area_end[i]&lt;area_start[j]-offset)&#123; //不相连的情况 if(index_preFirstArea&lt;j-1) index_preFirstArea=j-1; j=index_preLastArea; &#125; &#125; &#125; //这一行循环完与上一行不存在联系 if(area_label[i]==0)&#123; area_label[i] = ++label; &#125; &#125; &#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"Markdown的语言","slug":"md的语言","date":"2022-04-19T09:57:35.322Z","updated":"2022-04-19T16:43:55.525Z","comments":true,"path":"2022/04/19/md的语言/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/19/md%E7%9A%84%E8%AF%AD%E8%A8%80/","excerpt":"","text":"修改字体 12345678910111213141516171819202122232425改变字体大小：&lt;font size=1&gt;字体大小size=1&lt;/font&gt; // size：规定文本的尺寸大小，取值范围为1~7 ，浏览器默认值是 3。注意，size=50也是可以显示的，但与7的字体大小一样改变字体颜色：&lt;font color=red&gt;红色&lt;/font&gt;、&lt;font color=#ff0000&gt;红色&lt;/font&gt;改变字体类型：&lt;font face=&quot;楷书&quot;&gt;楷书&lt;/font&gt;//注意，字体类型的设置只能在电脑上才能显示字体效果，在手机上无法显示字体类型上下标：html形式：下标：a&lt;sub&gt;2&lt;/sub&gt; ；上标：a&lt;sup&gt;2&lt;/sup&gt;首先使用$$形成公式框进行公式编写$$a_2$$$$a^2$$双下标(多个字符用&#123;&#125;括起来)：不会换行$$D_&#123;KB_A&#125;$x^p_ &#123;ij&#125;$$$ md公式 使用数学公式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556https://blog.csdn.net/jyfu2_12/article/details/79207643https://zhuanlan.zhihu.com/p/261750408矩阵：$$\\begin&#123;matrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end&#123;matrix&#125; \\tag&#123;1&#125;$$方程组、条件表达式：$$f(n) =\\begin&#123;cases&#125; n/2, &amp; \\text&#123;if &#125;n\\text&#123; is even&#125; \\\\3n+1, &amp; \\text&#123;if &#125;n\\text&#123; is odd&#125;\\end&#123;cases&#125;$$$$\\begin&#123;cases&#125;3x + 5y + z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\end&#123;cases&#125;$$多行等式对齐：$$\\begin&#123;aligned&#125;a &amp;= b + c \\\\ &amp;= d + e + f\\end&#123;aligned&#125;$$真值表：$$\\begin&#123;array&#125;&#123;cc|c&#125; A&amp;B&amp;F\\\\ \\hline 0&amp;0&amp;0\\\\ 0&amp;1&amp;1\\\\ 1&amp;0&amp;1\\\\ 1&amp;1&amp;1\\\\\\end&#123;array&#125;$$行列式：$$ \\begin&#123;vmatrix&#125; 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end&#123;vmatrix&#125;\\tag&#123;7&#125;$$ \\begin{matrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{matrix} \\tag{1} a2a_2 a​2​​ a2a^2 a​2​​ DKBAxijpD_{KB_A} x^p_ {ij} D​KB​A​​​​x​ij​p​​ f(n)={n/2,if n is even3n+1,if n is oddf(n) = \\begin{cases} n/2, &amp; \\text{if }n\\text{ is even} \\\\ 3n+1, &amp; \\text{if }n\\text{ is odd} \\end{cases} f(n)={​n/2,​3n+1,​​​if n is even​if n is odd​​ {3x+5y+z7x−2y+4z−6x+3y+2z\\begin{cases} 3x + 5y + z \\\\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{cases} ​⎩​⎪​⎨​⎪​⎧​​​3x+5y+z​7x−2y+4z​−6x+3y+2z​​ a=b+c=d+e+f\\begin{aligned} a &amp;= b + c \\\\ &amp;= d + e + f \\end{aligned} ​a​​​​=b+c​=d+e+f​​ \\begin{array}{cc|c} A&B&F\\\\ \\hline 0&0&0\\\\ 0&1&1\\\\ 1&0&1\\\\ 1&1&1\\\\ \\end{array} \\begin{vmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{vmatrix} \\tag{7} 公式对齐方式 需要对齐的内容以\\begin&#123;align&#125;和\\end&#123;aligned&#125;包围，在需要对齐的符号（如等号）前加&amp;来标记，用\\\\来换行。 1234567891011\\begin&#123;aligned&#125;KPI&amp;=(N+S)W \\\\&amp;=NW+SW\\end&#123;aligned&#125;\\begin&#123;aligned&#125;KPI&amp;=(N+S)W \\\\PI&amp;=N+S \\\\I&amp;=W\\end&#123;aligned&#125; KPI=(N+S)W=NW+SW\\begin{aligned} KPI&amp;=(N+S)W \\\\ &amp;=NW+SW \\end{aligned} ​KPI​​​​=(N+S)W​=NW+SW​​ KPI=(N+S)WPI=N+SI=W\\begin{aligned} KPI&amp;=(N+S)W \\\\ PI&amp;=N+S \\\\ I&amp;=W \\end{aligned} ​KPI​PI​I​​​=(N+S)W​=N+S​=W​​ 公式间加空格 123456789输入字符 aba\\, b a\\; b a\\ b a~b a\\space b a\\quad b a\\qquad b ab\\\\ a\\, b \\\\ a\\; b \\\\ a\\ b\\\\ a~b \\\\ a\\space b \\\\ a\\quad b\\\\ a\\qquad b \\\\ 注： Typora中的数学公式需要用两个“”括起来（行间公式），或者用两个“”括起来（块间公式） 使用数学符号 关于如何在markdown文本中书写数学符号和公式（Latex）_june_francis的博客-CSDN博客_markdown如何打出数学符号","categories":[],"tags":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"《应用密码学》——第四章 公钥密码体制","slug":"笔记/密码学/第四章 公钥密码体制","date":"2022-04-19T08:47:16.169Z","updated":"2022-04-19T16:50:53.991Z","comments":true,"path":"2022/04/19/笔记/密码学/第四章 公钥密码体制/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/19/%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/","excerpt":"","text":"概述 对称密码体制的缺点： 密钥管理的困难：n个用户彼此间进行保密通信就需要n(n-1)/2个密钥；当用户数量增加时，密钥的数量急剧增大，密钥管理量大。密钥的产生、分发、保存、撤销、更新等安全性问题解决困难复杂代价高。 系统的可拓展性和开放性差：每进来一个新用户都需要对已有的n个老用户进行通知，并添加一个新密钥。不能解决陌生人间的密钥传递问题，也就不能支持陌生人间的保密通信。 不能数字签名，抗抵赖性差：一旦发送方的消息产生更改，不能确认是否是发送方的行为。 对称密码体制的优点： ​ 加解密处理速度快、效率高；算法安全性高 ==》公钥密码体制弥补了对称密钥密码体制的缺点 Alice使用自己的私钥对信息m进行加密发送出去，收者Bob使用Alice的公钥进行解密。若m’和m一致则确定是Alice发送的，不一致则不是Alice发送的。(鉴别) -&gt; 抗抵赖性 因为人手一份公钥和私钥。公钥公开给发送方加密信息，私钥保存主人解密收到信息，机密性高，只有n的密钥管理，也可以用来公开信道上密钥的分发和协商。 当前状况： 公钥密码的基本思想 \\begin{aligned} 公&钥密码的加密变换E_{KU_B}(m)与解密变换D_{KR_B}(c)应满足下列要求：\\\\ &(1)D_{KR_B}(c)是E_{KU_B}(m)的逆变换，即对任意的明文M，均有：D_{KR_B}(c)=D_{KR_B}(E_{KU_B}(m))=m\\\\ &(2)已知加密和解密秘钥时，加解密是容易的\\\\ &(3)如果不知道私钥{KR}_B，那么即使知道公钥{KU}_B、具体加解密算法以及密文，确定明文计算上都是不可行的 \\end{aligned} 像这种不知道解密密钥，对密文进行逆变换得到正确明文在计算上是不可行。具有这种性质的函数称为单向陷门函数 目前人们主要基于如下数学上的困难问题来设计单向陷门函数和公钥密码体制： 大整数分解问题(RSA) 大素数 n=p·q p,q求n简单，但n求p,q难 (概率算法) 有限域上离散对数问题(EIGamal) y=gxmodpy=g^x\\;\\; mod\\;p y=g​x​​modp 通过x求y容易，但通过y求x不容易(与y对应的x太多，不知道是哪一个) 椭圆曲线上的离散对数问题(ECC) &lt;F , + , * &gt; 域 椭圆曲线上的点&lt;x , y&gt;构成的域&lt;F , +&gt; -&gt; 乘相当于x个相加 \\begin{aligned} P &= xG\\;\\; (mod\\;p)\\\\ 公钥 &=密钥*公共信息\\;\\;(取模) \\end{aligned} 单向陷门函数也存在天敌：量子计算机(速度极快)，如果量子计算机一旦问世并推广，信息加密的安全性问题面临大危机 --&gt; 应对：格Grid函数(量子计算机尚未由应对算法，线性代数离散向量空间：由n维组成的在横纵交线上的点) RSA公钥密码体制 古典密码技术 -&gt; 近代密码 ：1949年，香农奠基性论文《保密系统的通信理论》发表 近代密码 -&gt; 现代密码 ：1976年，迪菲和赫尔曼发表了《密码学新方向》，首次提出了公钥密码体制的概念和设计思想；1978年，美国的里维斯特R、沙米尔S、阿德勒曼A提出了一个较完整地公钥密码体制——RSA体制，是密码学史上地里程碑 RSA公钥密码体制的安全性建立在大整数因子分解的困难性之上，算法的数学基础是初等数论中的欧拉定理 密钥生成 （1）选择两个随机的大素数 p 和 q ，并计算 n=pq\\quad 和\\quad \\phi(n)=(p-1)(q-1)\\\\ 其中,\\phi(n)欧拉公式: 比n小的数中和n互素的数字个数;p,q为互异的素数(计算完就销毁) ϕ(n)=(n−1)−(q−1)−(p−1)=pq−q−p−1=(p−1)(q−1)\\begin{aligned} \\phi(n)&amp;=(n-1)-(q-1)-(p-1)\\\\ &amp;=pq-q-p-1\\\\ &amp;=(p-1)(q-1) \\end{aligned} ​ϕ(n)​​​​​=(n−1)−(q−1)−(p−1)​=pq−q−p−1​=(p−1)(q−1)​​ （2）选择一个随机数e，1&lt;e&lt;\\phi(n) 满足gcd(e,\\phi(n))=1，并计算 d=e^{-1}\\;\\;mod\\;(\\phi(n))\\\\ 其中，d,e为互素的乘法逆元。ed\\equiv1\\;mod\\;\\phi(n)，即ed=k\\phi(n)+1 （3）公钥为（e, n），私钥为 d 加密 对明文m&lt;n，其对应的密文为 c=memodnc = m^e\\;\\;mod\\;n c=m​e​​modn 快速计算a^m mod n \\begin{aligned} a^{10} \\;幂换成二进&制\\;a^{1010}\\\\ &=a^{b_32^3+b_22^2+b_12^1+b_02^0}\\\\ &=(((1\\times a^{b_3})^2 \\times a^{b_2})^2 \\times a^{b_1})^2 \\times a^{b_0}\\\\ 2^{100}\\;mod\\;n&=(2^{20}\\;mod\\;n)^5 \\end{aligned} 1 解密 疑问：公私密钥该有谁生成？ 由他人(可信度高，KGC)生成所有人的公私密钥 -&gt; 成为黑客的攻击目标；信息越多，自身价值越大（忧） 由自己生成自己的公私密钥 -&gt; 由于密钥生成都用到\\phi(n)，会导致知道公钥即可推出私钥，而可以伪造任何人的签名（不可取，忧忧忧） 所以RSA的一个缺陷就是由谁生成密钥都不安全","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"上位机配置(蓝牙)","slug":"智能车/两个蓝牙的配置","date":"2022-04-18T02:16:09.468Z","updated":"2022-07-17T08:37:13.500Z","comments":true,"path":"2022/04/18/智能车/两个蓝牙的配置/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/18/%E6%99%BA%E8%83%BD%E8%BD%A6/%E4%B8%A4%E4%B8%AA%E8%93%9D%E7%89%99%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"配蓝牙视频 https://www.bilibili.com/video/BV1zW411y7vq/?spm_id_from=333.788.recommend_more_video.-1（我比较偏爱这个英文版，看完了再看下面的） https://www.bilibili.com/video/BV1ii4y1s79z 设置从机（电脑端：接受） COM-CH-&gt;端口号 设置主机（小车：发送） XCOM-&gt;端口号 （usb转ttl接口和接收蓝牙引脚：tx接rx, rx接tx） （注意插在小车上的蓝牙和小车的插针/引脚是否也是tx接rx, rx接tx） UART4_RX_C11 UART4_TX_C10 以XCOM软件分别配置主从蓝牙为例 第一步：进入AT模式 按住蓝牙上黑色按钮将usb转ttl插在电脑上放下，显示结果：蓝牙每隔一秒亮一次 调好软件波特率和COM串口，打开串口 （蓝牙调试软件使用此默认波特率：38400） （串口查看：此电脑-&gt;右键菜单：管理-&gt;设备管理器-&gt;端口(COM和LPT)-&gt;USB-SERIAL CH340(COM x）) 发送框中输入AT：黑窗口有ok即成功，可以进行蓝牙配置 ！！！使用XCOM软件只能该行输入不能有回车,可以输完使用ctrl+enter！ 第二步：配置蓝牙 有两个usb转ttl时，能同时插在电脑上配置的情况： 恢复出厂设置AT+ORGL-&gt;获得配对码-&gt;主从模式-&gt;绑定从机地址(恢复出厂设置-&gt;使用和从机一致的配对码AT+PSWD-&gt;从机模式-&gt;查询地址-&gt;波特率)-&gt;设置波特率-&gt;确定波特率-&gt;连接地址 只有一个usb转ttl时，先配置从机（电脑）再配置主机（小车） -&gt;这里分开配置 第三步：配置从机 恢复默认设置：AT+ORGL 配置配对码：AT+PSWD=“0000”(主从机要一致） 配置为从机模式：AT+ROLE=0 查询从机的地址：AT+ADDR? （栗子：+ADDR:98d3:34:912ba8，主机绑定时要冒号变逗号） 设置波特率：AT+UART=115200,0,0 第四步：配置主机 恢复默认设置：AT+ORGL 配置配对码：AT+PSWD=“0000”(主从机要一致） 配置为从机模式：AT+ROLE=1 主机绑定从机地址：AT+BIND=98d3,34,912ba8 （注意把地址的冒号换成逗号） 设置波特率：AT+UART=115200,0,0 第五步：确定是否配置成功 重新插上，不按按钮，呈灯不断闪烁；然后等两蓝牙连接 连接成功是每秒闪一次，一次闪两下，两灯同时两同时灭 如果连接失败，重新配置一次。 PS：查询主从机 AT+ROLE? https://blog.csdn.net/DaMercy/article/details/102514684 https://blog.csdn.net/weixin_42417585/article/details/105232263 发送在黑窗口不显示：1.波特率配置错了 2.命令写错了，检查 3.是否多按了一个回车键 第六步：连接Visual Scope 菜单栏找到Setup 选择Communication Setup在界面里只更改波特率115200（根据蓝牙设置的波特率)和串口COM x（蓝牙的串口） 选择Communication Protocal勾选CRC16 配置完成 第七步：代码 初始化：uart_init(UART_4,115200,UART4_TX_C10,UART4_RX_C11);（在zf_uart.c中) UART_x根据硬件选择引脚(我们硬件选的C10和C11在zf_uart.h中找到就是UART_4) 在while或中断中调用data_conversion(int16 data1, int16 data2, int16 data3, int16 data4, uint8 *dat)函数（在SEEKFREE_VIRSCO.c中） 前四个是Visual Scope显示的自己选择放置，后面*dat改为virtual_scope_data（在SEEKFREE_VIRSCO.h中） 将data_conversion函数中**//uart_putbuff(UART_1,dat,10);** 取消注释(打开)并将UART_1更改为使用的UART_x 第八步：确定代码是否正确 下载程序，打开小车电源和电机电源（因为我观察的是电机PID） 点击Visual Scope中RUN按钮（右下角） 点击Visual Scope中RESUME按钮（左上角绿色三角） 若能看见线不断地变化（我给的变化量）则成功 不使用点击Visual Scope中STOP按钮 保存菜单栏File-&gt;Save 附录","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"总结","slug":"刷题/总结","date":"2022-04-06T02:26:51.915Z","updated":"2022-05-18T15:31:27.730Z","comments":true,"path":"2022/04/06/刷题/总结/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/06/%E5%88%B7%E9%A2%98/%E6%80%BB%E7%BB%93/","excerpt":"","text":"全排列\\DFS(深度优先搜索算法)\\堆排序算法 枚举法 C(m,n) 12345678910111213141516171819202122232425int n;//共计N个数int m;//选m个数vector&lt;int&gt; chosen;void calc(int x) &#123; if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝:超过m和选不够m return; if (x == n + 1) &#123; //选够了m个数输出 for (int i = 0; i &lt; chosen.size(); i++) printf(&quot;%d &quot;, chosen[i]); //也可以不输出，存放起来也是可以的，主要是看题目。 puts(&quot;&quot;); return; &#125; //选x calc(x + 1); chosen.push_back(x); //不选x calc(x + 1); chosen.pop_back();//消除痕迹&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; calc(1);&#125; A(m,n) 123456789101112131415161718192021222324252627282930int n; //共计N个数int order[20];bool chosen[20];void calc(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; order[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (chosen[i])//选过跳过 continue; order[k] = i; chosen[i] = 1;//标准搜索方式 calc(k + 1);//回溯并恢复现场 chosen[i] = 0; order[k] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; calc(1);&#125; 常用STL库 stack模板 12345678910111213141516171819top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。push(const T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。push(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。pop()：弹出栈顶元素。size()：返回栈中元素的个数。 vector容器 123456789#include &lt;vector&gt; //头文件vector&lt;int&gt; a; //定义了一个int类型的vector容器avector&lt;int&gt; b[100]; //定义了一个int类型的vector容器b组struct rec&#123; ···&#125;;vector&lt;rec&gt; c; //定义了一个rec类型的vector容器cvector&lt;int&gt;::iterator it; //vector的迭代器，与指针类似 123456789a.size() //返回实际长度（元素个数），O(1)复杂度a.empty() //容器为空返回1，否则返回0，O(1)复杂度a.clear() //把vector清空a.begin() //返回指向第一个元素的迭代器，*a.begin()与a[0]作用相同a.end() //越界访问，指向vector尾部，指向第n个元素再往后的边界a.front() //返回第一个元素的值，等价于*a.begin和a[0]a.back() //返回最后一个元素的值，等价于*--a.end()和a[size()-1]a.push_back(x) //把元素x插入vector尾部a.pop_back() //删除vector中最后一个元素 1234for ( vector&lt;int&gt;::iterator it=a.begin() ; it!=a.end() ; it++ )cout&lt;&lt;*iterator&lt;&lt;endl;for( int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; 队列 Queue 12queue&lt;string&gt; myqueue;queue&lt;int&gt; myqueue_int; 123456front()：返回 queue 中第一个元素的引用。back()：返回 queue 中最后一个元素的引用。push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。pop()：删除 queue 中的第一个元素。size()：返回 queue 中元素的个数。empty()：如果 queue 中没有元素的话，返回 true。 Map 映射 12map&lt;char, int&gt; mymap1;map&lt;string, int&gt; mymap2; 12345678910111213141516171819202122232425261.看容量int map.size();//查询map中有多少对元素bool empty();// 查询map是否为空2.插入map.insert(make_pair(key,value));//或者map.insert(pair&lt;char, int&gt;(key, value))//或者map[key]=value3.取值map&lt;int, string&gt; map;//如果map中没有关键字2233，使用[]取值会导致插入//因此，下面语句不会报错，但会使得输出结果结果为空cout&lt;&lt;map[2233]&lt;&lt;endl;//但是使用使用at会进行关键字检查，因此下面语句会报错map.at(2016) = &quot;Bob&quot;;4.遍历操作map&lt;string, string&gt;::iterator it;for (it = mapSet.begin(); it != mapSet.end(); ++it)&#123; cout &lt;&lt; &quot;key&quot; &lt;&lt; it-&gt;first &lt;&lt; endl; cout &lt;&lt; &quot;value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125;5.查找操作m.count(key)：//由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。m.find(key)：//返回迭代器，判断是否存在。 差分与前缀和 差分与前缀和是一对互逆的操作，常常用于处理区间问题，差分法是解决区间加减问题，前缀和是解决区间求和问题的常用办法。 差分法的应用主要是用于处理区间问题。当某一个数组要在很多不确定的区间，加上相同的一个数。 如果我们采用差分法，将数组拆分，构造出一个新的拆分数组，通过对数组区间的端点进行加减操作，最后将数组和并就能完成原来的操作。 b[1]=a[1] b[i] = a[i]-a[i-1] b[l,r] + N = b[l]+N, b[r+1]-N b[1]=b[1] b[i] = b[i]+b[i-1]; 前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和。 如果我们采用前缀和，构造出一个前缀和数组，通过对于端点的值的减法操作就能 O(1) 的求出 [l,r] 的和。然后 N 次查询的,就将复杂度降低为 O(n) a[1]=a[1]; sum[i] += sum[i-1]+a[i]; 或 a[i]+=a[i-1]; sum[l,r] = sum[r] - sum[l - 1] 哈希 12345678910111213141516const long long h = 999983;int b = 131;int Hx(string s)&#123; int n = s.size(); int sum1 = 0; for (int i = 0; i &lt; n; i++) &#123; sum1 = sum1 * 131 % h + (s[i] - &#x27;a&#x27; + 1) % h; &#125; return (sum1 + h) % h;&#125; 递推和递归 12345678910111213141516//递推开始:从尾部开始 for (int i=n-1; i&gt;=1; i--)//从最后一层逆推 &#123; for (int j=1; j&lt;=i; j++) &#123; if (a[i+1][j]&gt;=a[i+1][j+1]) a[i][j]+=a[i+1][j]; //路径选择 else a[i][j]+=a[i+1][j+1]; &#125; &#125; cout&lt;&lt;a[1][1]&lt;&lt;endl; 二分法 12345678910111213141516171819202122// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high)&#123; int mid = (low + high) / 2; if (a[mid] &gt;= x) high = mid; else low = mid + 1;&#125;// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high)&#123; int mid = (low + high + 1) / 2; if (a[mid] &lt;= x) low = mid; else high = mid - 1;&#125; 其他 123456789#include&lt;iomanip&gt; //用于浮点数输出cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l; //一般使用print //printf(&quot;%x.yf&quot;,n) //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0 //y是保留小数位数，不够补零 //printf(&quot;%.7f&quot;,l); 12345678910#include &lt;iostream&gt;#include &lt;numeric&gt;using namespace std;int main()&#123; int array[]=&#123;1,2,3,4,5,6,7,8,9&#125;;//定义数组array int sum = accumulate(array,array+size(array),0); cout &lt;&lt; &quot;数组的和 = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617181920#include&lt;string.h&gt;//数组全部置0memset(move, 0, sizeof(move));#include&lt;algorithm&gt;bool judge(Cach a,Cach b)&#123; return a.avg&gt;b.avg;&#125;sort(cash,cash+n,judge);#include&lt;iomanip&gt;cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l; //一般使用print //printf(&quot;%x.yf&quot;,n) //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0 //y是保留小数位数，不够补零 //printf(&quot;%.7f&quot;,l); 123//映射：对称的奇偶可以有一样的值from = (from - 1)/2;to = (to - 1)/2;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://zhang0224gz.github.io/tags/tips/"}]},{"title":"涉及的C/C++的知识点","slug":"刷题/编程知识点","date":"2022-04-03T04:00:52.435Z","updated":"2022-05-18T15:30:55.037Z","comments":true,"path":"2022/04/03/刷题/编程知识点/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/03/%E5%88%B7%E9%A2%98/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.二维数组作为函数参数传入 静态数组（维数确定） 二维数组作为函数的参数，实参可以直接使用二维数组名，在被调用函数中可以定义形参所有维数的大小，也可以省略以为大小的说明。例如： 12void find（char a[3][10]）;void find (char a[ ][10]); 也可以使用数组指针来作为函数参数，例如： 1void find （char (*p)[10]); 但是不能像下面这样使用，例如： 12void find（char a[ ][ ]）;void find (char a[3][ ]); 因为从实参传递来的是数组的起始地址，如果在形参中不说明列数，编译器将无法定位元素的的位置。 栗子： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;void range(char str[ ][100]);//传进二维数组int main(void)&#123; char str[8][100]; int i; for(i=0;i&lt;8;i++) gets(str[i]); range(str); for(i=0;i&lt;8;i++) printf(&quot;%s\\n&quot;,str[i]);&#125; void range(char str[ ][100])&#123; int i,j; char temp[100]; for(i=0;i&lt;8-1;i++) &#123; for(j=0;j&lt;8-i-1;j++) &#123; if(strcmp(str[j],str[j+1])&gt;0) &#123; strcpy(temp,str[j]); strcpy(str[j],str[j+1]); strcpy(str[j+1],temp); &#125; &#125; &#125; &#125; 动态数组（维数不确定） 如果不确定二维数组的维数的话，我们不能使用上面的方法，可以用下面的方法： 手工转变寻址方式 对于数组 int p[m][n]; 如果要取p[i][j]的值（i&gt;=0 &amp;&amp; m&lt;=0 &amp;&amp; j&gt;=0 &amp;&amp; n&lt;=0)，编译器是这样寻址的，它的地址为：p + (i*n + j) ; 二维数组的定义并非一个确定的值，也就是动态数组，这时候我们如果像之前那样进行函数调用就会报错，错误提示为: 1[Error] cannot convert &#x27;int (*)[N]&#x27; to &#x27;int**&#x27; for argument &#x27;2&#x27; to &#x27;int threeOrder_evaluation(int, int**)&#x27; 1void printf_int(int hhh[][Dim]); 所以我们只能这样来调用 1void printf_int(int** hhh); C++ Code:动态分配数组内存的六种方法 1、利用“malloc-free”动态分配一维数组： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;stdlib.h&gt; //该头文件为malloc必须 using namespace std;int main()&#123; int len; int *p; cout&lt;&lt;&quot;请输入开辟动态数组的长度：&quot;&lt;&lt;endl; cin&gt;&gt;len; //长度乘以int的正常大小，才是动态开辟的大小 p = (int*)malloc(len*sizeof(int)); cout&lt;&lt;&quot;请逐个输入动态数组成员：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; //此处不可以写成：cin&gt;&gt;*p[i] cin&gt;&gt;p[i]; &#125; cout&lt;&lt;&quot;您输入的动态数组为：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; //时刻记住：有malloc就要有free free(p); &#125; 2、利用“malloc-free”动态分配二维数组： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt; #include&lt;stdlib.h&gt; //该头文件为malloc必须 using namespace std; int main() &#123; int row,col; int **p; cout&lt;&lt;&quot;请输入开辟动态数组的行 &amp; 列：&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col; //开始开辟 p = (int**)malloc(row*sizeof(int*));//为数组的行开辟空间 for(int i=0; i&lt;row; ++i) &#123; *(p+i)=(int*)malloc(col*sizeof(int));//为数组的列开辟空间 &#125; //输入成员 cout&lt;&lt;&quot;请逐个输入动态数组 各行各列 成员：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; //此处不可以写成：cin&gt;&gt;*p[i] [j] cin&gt;&gt;p[i][j]; &#125; //输出成员 cout&lt;&lt;&quot;您输入的动态数组 各行各列 成员如下：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; cout&lt;&lt;p[i][j]; &#125; //时刻记住：有malloc就要有free for(int i=0; i&lt;row; ++i) &#123; free(*(p+i)); &#125; &#125; 3、利用“new-delete”动态分配一维数组： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int len; cout&lt;&lt;&quot;请输入开辟数组的长度：&quot;&lt;&lt;endl; cin&gt;&gt;len; int *p = new int [len]; //数据输入 cout&lt;&lt;&quot;请逐个输入数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; cin&gt;&gt;p[i]; &#125; //数据反馈 cout&lt;&lt;&quot;您分配的动态数组为：&quot;&lt;&lt;endl; for(int i=0; i&lt;len; ++i) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; //释放内存： delete []p; &#125; 4、利用“new-delete”动态分配二维数组： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main()&#123; int row,col; cout&lt;&lt;&quot;请输入开辟数组的行 &amp; 列：&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col; //行的开辟 int **p = new int*[row]; for(int i=0; i&lt;row; ++i) &#123; //列的开辟 p[i] = new int[col]; &#125; //数据输入 cout&lt;&lt;&quot;请逐个输入 各行各列 数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; cin&gt;&gt;p[i][j]; &#125; //数据反馈 cout&lt;&lt;&quot;您分配的动态数组为：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; ++j) &#123; cout&lt;&lt;p[i][j]&lt;&lt;&quot;&quot;; &#125; //释放内存： delete []p; &#125; 5、利用“new-delete”动态分配二维数组： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int row,col; cout&lt;&lt;&quot;请输入行 &amp; 列：&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col; //很复杂的结构：对于某些编译器，注意连空格都不可以忽略 vector&lt;vector&lt;int&gt; &gt; p(row,vector&lt;int&gt;(col)); //数据输入 cout&lt;&lt;&quot;请逐一输入 各行各列 数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; j++) &#123; cin&gt;&gt;p[i][j]; &#125; //数据输出 cout&lt;&lt;&quot;您输入的数据：&quot;&lt;&lt;endl; for(int i=0; i&lt;row; ++i) for(int j=0; j&lt;col; j++) &#123; cout&lt;&lt;p[i][j]&lt;&lt;&quot; &quot;; &#125; //该方法利用的是两重的vector而无需释放 &#125; 6、利用while的极其简单输入实现求和、求平均之类算法： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int sum=0,value=0; //实际上非数字就会结束循环 cout&lt;&lt;&quot;请输入求和数字，以*号作为结束；&quot; while(cin&gt;&gt;value) sum += value; cout&lt;&lt;&quot;您输入数据之和为：&quot;&lt;&lt;sum&lt;&lt;endl; &#125; ———————————————— 版权声明：本文为CSDN博主「Errors_In_Life」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/Errors_In_Life/article/details/78889951 2.求逆矩阵 行列式的计算方法 1.对角线法 对角线法也是三阶行列式计算使用最广泛的方法 ▍ 对角线法适用于二、三阶行列式，对于更高阶的行列式暂时未找到规律 2.代数余子式法 3.等价转化法 4.逆序法 总结 本文讲述了四种行列式的计算方法： ▍其中对角线法，是使用最简单、最广泛的方法 ▍代数余子式法和等价转化法，在特定情况下能极大程度上简便运算，但需要读者对行列式进行灵活地观察 ▍逆序数法，是一种更加基础的方法，使用起来比较复杂 3.函数返回一个数组，二维数组 与其他高级语言相比，c语言，c++ 最大的不方便之处就是 函数只能返回一个数值。若要返回一个数组，必须用到指针以及动态分配内存。 方法之一：返回一个结构体，结构体里面包括一个数组。 因为结构体运行效率略慢，这个方法我干脆不用了。 方法之二：利用指针函数，并结合动态内存。 1234567891011121314151617int *fun()&#123;声明一个动态数组 a;return a;&#125;void main()&#123;用指针调用函数 int *p=fun();释放该指针 free(p); (相当于释放了指针函数里面的动态数组)&#125; 举例：下面程序返回一个一维数组 123456789101112131415161718192021222324#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;int * Max(int *arr,int n)&#123; int *a=(int *)malloc(2*sizeof(int)); int maxNum=0,maxIndex,i; for (i=0;i&lt;n;i++) if (arr[i]&gt;maxNum) &#123;maxNum=arr[i];maxIndex=i+1;&#125; a[0]=maxNum;a[1]=maxIndex; return a;&#125;void main()&#123; int a[2]=&#123;5,2&#125;;//a[0]=5,a[1]=2; int *b=Max(a,2); int i; for(i=0;i&lt;2;i++) printf(&quot;b[%d]=%d\\n&quot;,i,b[i]); free(b);&#125; 这个程序中的max函数不仅能够返回一个数组的最大值，还能够显示这个最大值在数组中的位置。 下列程序返回一个二维数组，求出一个二维数组各行的最大值以及所在位置。 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;int **Max(int **arr,int n,int m)&#123; int **data; data=(int **)malloc(n*sizeof(int *)); for (int i=0;i&lt;n;i++) data[i]=(int *)malloc(2*sizeof(int)); for (int i=0;i&lt;n;++i) &#123; int maxNum=0; for (int j=0;j&lt;m;++j) &#123; //printf(&quot;arr[%d][%d]=%d &quot;,i,j,*((int *)arr+m*i+j)); if (*((int *)arr+m*i+j)&gt;maxNum) &#123; maxNum=*((int *)arr+m*i+j); data[i][0]=maxNum;data[i][1]=j; &#125; &#125; //printf(&quot;\\n&quot;); &#125; return data;&#125;void main()&#123; int a[2][3]=&#123;5,2,4,6,3,9&#125;; int **b=Max((int **)a,2,3); for (int i=0;i&lt;2;i++) &#123; printf(&quot;the maximum num for row %d is %d\\n&quot;,i+1,b[i][0]); printf(&quot;the maximum num for row %d is in %d&quot;,i+1,b[i][1]+1); printf(&quot;\\n&quot;); &#125; for(int i=0;i&lt;2;i++) free(b[i]); free(b);&#125; 4.头文件 #include&lt;stdlib.h&gt; #include&lt;math.h&gt; 1、 三角函数 double sin(double);正弦 double cos(double);余弦 double tan(double);正切 2 、反三角函数 double asin (double); 结果介于[-PI/2,PI/2] double acos (double); 结果介于[0,PI] double atan (double); 反正切（主值），结果介于[-PI/2,PI/2] double atan2 (double,double); 反正切（整圆值），结果介于[-PI,PI] 3 、双曲三角函数 double sinh (double); double cosh (double); double tanh (double); 4 、指数与对数 double frexp(double value,int exp);这是一个将value值拆分成小数部分f和（以2为底的）指数部分exp，并返回小数部分f，即f2^exp。其中f取值在0.5~1.0范围或者0。 double ldexp(double x,int exp);这个函数刚好跟上面那个frexp函数功能相反，它的返回值是x*2^exp double modf(double value,double *iptr);拆分value值，返回它的小数部分，iptr指向整数部分。 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x,double y);计算x的y次幂 float powf(float x,float y); 功能与pow一致，只是输入与输出皆为单精度浮点数 double exp (double);求取自然数e的幂 double sqrt (double);开平方根 5 、取整 double ceil (double); 取上整，返回不比x小的最小整数 double floor (double); 取下整，返回不比x大的最大整数，即高斯函数[x] 6 、绝对值 double fabs (double);求实型的绝对值 double cabs(struct complex znum);求复数的绝对值 7 、标准化浮点数 double frexp (double f,int *p); 标准化浮点数，f = x * 2^p，已知f求x,p (x介于[0.5,1]) double ldexp (double x,int p); 与frexp相反，已知x,p求f 8 、取整与取余 double modf (double,double*); 将参数的整数部分通过指针回传，返回小数部分 double fmod (double,double); 返回两参数相除的余数 9 、其他 double hypot(double x,double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x,int exponent);计算x*（2的指数幂） double poly(double x,int degree,double coeffs []);计算多项式 int matherr(struct exception *e);数学错误计算处理程序 5.关于模取余 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;3%2&lt;&lt;endl;//1 cout&lt;&lt;-3%2&lt;&lt;endl;//-1 cout&lt;&lt;3%-2&lt;&lt;endl;//1 cout&lt;&lt;-3%-2&lt;&lt;endl;//-1 return 0;&#125; 多重for循环优化，提升运行效率 在循环次数较少的时候一般不会发现for循环的写法会对效率产生多大问题，但一旦循环次数较多，比如说上万，循环层数较多，效率问题就非常明显了，我是在做一个数据量非常大有三层for循环的项目的时候，为显示曲线出来太花费时间，客户体验会非常不好，才研究这个情况的，事实证明，优化后的多重for循环提升了一大半的效率，是不是很神奇。 当然，本文也有借鉴其他同胞的方法。 实例化变量放在for循环外，减少实例化次数，尽量只实例化一次； 普通变量 改为 寄存器变量 i++ 改为 ++i 123int i=0, j;j=++i; //前置版本，运算对象先自增1，然后将改变后的对象作为求值结果，再赋值给j；j=i++; //后置版本，先赋值给j；再运算对象自增1，但求值结果是运算对象改变之前那个值的副本. C++Primer 中解释：前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。 for(int i = 0; i&lt;50; i++) 循环条件使用&lt;要快于&lt;=，&gt;和&gt;=同理; 把外层可以计算的尽可能放到外层，减少在内层的运算，有判断条件的语句和与循环不相关的操作语句尽量放在for外面； 应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数； 采用的是行优先访问原则，与元素存储顺序一致。 对于一个可结合和可交换的合并操作来说，比如整数的加法或乘法， 我们可以通过将一组合并操作分割成 2 个或更多的部分，并在最后合并结果来提高性能。 原理： 普通代码只能利用 CPU 的一个寄存器，分割后可以利用多个寄存器。 当分割达到一个数量时，寄存器用完，性能不再提升，甚至会开始下降。 用代码来描述，如下： 12345678910// 一般情况下的代码 for (i = 1; i &lt; n+1; i++)&#123; res = res OPER i;&#125;// 循环分割后代码for (i = 1; i &lt; n; i+=2)&#123; res1 = res1 OPER i; res2 = res2 OPER (i+1);&#125; int 整数加法，性能测试结果对比如下： 整数的加法，普通代码运行 26s，循环分割后，18s。 浮点数计算的性能提升，明显大于整数，乘法的性能提升，略大于加法。","categories":[],"tags":[{"name":"tips","slug":"tips","permalink":"https://zhang0224gz.github.io/tags/tips/"}]},{"title":"慎终追远(转载)","slug":"文化/句子/慎终追远","date":"2022-04-02T00:42:02.098Z","updated":"2022-04-03T06:20:33.191Z","comments":true,"path":"2022/04/02/文化/句子/慎终追远/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/02/%E6%96%87%E5%8C%96/%E5%8F%A5%E5%AD%90/%E6%85%8E%E7%BB%88%E8%BF%BD%E8%BF%9C/","excerpt":"","text":"谈谈对“慎终追远”的四种看法 曾子曰：慎终追远，民德归厚矣。 这句话大概有四种释义，每一种释义我都加入了自己的理解，相对来说，我更认同南老的观点。 释义一 **慎终：谨慎的思考人生于天地之间的意义。****追远：看看老祖宗们都留下了些什么，在自身与先贤之间做一个对比，应效法先古圣贤。**每个人都这样的去思考，人民的道德就自然敦厚了。 诚然，“谨慎的思考人生于天地之间的意义”与“看看老祖宗们都留下了些什么，在自身与先贤之间做一个对比，应效法先古圣贤”，可以使人的德行增加，但是这样的说法好像是针对于读书人而言的。 很多老百姓都是目不识丁的，不会去思考人生之意义，也不会与先贤去做对比，就像那个放牛娃的一生，“放牛、挣钱、娶媳妇、生娃、让娃放牛”，但如果每个人都可以像放牛娃一样活的简单，社会风气也是可以趋于厚道的呀。 在春秋时期，读书人只是小部分人，如果只针对小部分人说，那也太不普遍了吧。 释义二 宋儒的解释，这好像也是语文教科书上的解释。 终，人死；远，指祖先。慎终追远，慎重地办理父母丧事，虔诚地祭祀远代祖先。 宋儒是把这句话归于孝道，“圣朝以孝治天下”，我们向来都重视孝道。但慎重地办理父母丧事，虔诚地祭祀远代祖先真的能使风气趋于厚道？要慎重办理丧事，就意味着要找风水宝地，要算五行八卦，这难道不会形成攀比之分吗？虔诚祭祀祖先，因为相信列祖列宗在护佑、审视自己。我感觉这在某种程度上是使迷信之风越演越烈吧。 重视办理父母丧事，每年祭祀祖宗，民德就归厚了，就没人犯罪了？感觉有些牵强。 释义三 慎，害怕；终，结果；追远，指找当初的动机和原因。慎终追远的意思是说一个人要想好的结果，不如有好的开始。如果大家都能认识到这个道理，则“民德归厚矣”，社会道德的风气，自然都归于厚道严谨。佛家有言“菩萨畏因，凡夫畏果”，跟这句话是一个意思。这是南老对这句话的解释。 有人对南老的解释提出了异议，举了**反例，“有些人专门损人利己，干尽坏事，他总是思前顾后、深思熟虑的，要把每件坏事做得不露声色。这样能做到民德归厚吗？”**我觉得他的反例举的不对，他没有理解南老的意思，如果按他的说法，这些干尽坏事、深思熟虑的人都跟菩萨一样畏因了吗？他把因果弄错的，这些坏人畏的不是因，而是果。什么样的例子是畏因呢？ 我觉得孟母三迁其实就是一个畏因的例子，一般父母都畏果，比如最终孩子变成一个不学无术的人，这个后果来了他才怕。但**孟母害怕的是动机，这个动机是初因，比如孟母希望孟子能成为一个品德高尚的人，那么住在这里，是否是从这个初因出发的呢？如果不是，怎么可能有这个果呢？**如果每个人在开始的时候都很慎重，都是从善因出发，那么民德自然就会严谨厚重了呀。 释义四； 慎，谨慎。《礼记·中庸》：“天命之谓性，率性之谓道，修道之谓教。道也者，不可须臾离也；可离，非道也。是故君子戒慎乎其所不睹，恐惧乎其所不闻。莫见乎隐，莫显乎微，故君子慎其独也。” 这句话就是说，人如果能谨慎一生，就几乎接近了‘道’。这样的人必将会受到后人的景仰，如果每个人都可以谨慎一生，那自然就是一个厚德的人啦。 可是如果要每个人谨慎一生才能民德归厚的吧，那民德离厚应该远远不及吧，因为就连大家公认谨慎的诸葛孔明，也做不到谨慎一生吧，孔夫子虽然是圣人，也不可能一生谨慎呀。这个说法简直离谱。 作者：灰堆积木 链接：https://www.jianshu.com/p/91aae9b45104 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"语文","slug":"语文","permalink":"https://zhang0224gz.github.io/categories/%E8%AF%AD%E6%96%87/"}],"tags":[]},{"title":"摄像头--信标","slug":"智能车/摄像头","date":"2022-04-01T09:14:46.059Z","updated":"2022-05-19T16:15:58.430Z","comments":true,"path":"2022/04/01/智能车/摄像头/","link":"","permalink":"https://zhang0224gz.github.io/2022/04/01/%E6%99%BA%E8%83%BD%E8%BD%A6/%E6%91%84%E5%83%8F%E5%A4%B4/","excerpt":"","text":"// 清除摄像头采集完成标志位 如果不清除，则不会再次采集数据 信标车，摄像头处理部分 技术报告–摄像头处理 (2条消息) 智能车竞赛技术报告 | 节能信标组组 - 大连民族大学 - 粉红靓车队_卓晴的博客-CSDN博客_智能车信标灯算法 红外光虽然不可见，但却是最稳定的光源，除了受到自然光中红外光的干扰，不会受到其他光源的干扰，于是我们选择了通红外的170°广角摄像头。在国赛的比赛规则中，两个信标灯之间的距离最远有4.61米，本着减少算法复杂度的原则，我们通过加长摄像头支架的高度来解决视野问题，摄像头支撑加到了45cm 智能车竞赛技术报告 | 节能信标组-哈尔滨工业大学紫丁香五队-面包板社区 (eet-china.com) 本智能车采用的是2个逐飞的170度红外摄像头，前后分别一个。在单片机采集图像后需要对其进行处理，以提取主要的图像信息。对于节能信标组，需要提取的就是亮着的信标灯的坐标。十六届信标灯的灯罩是扁平的，距离较远时，接收到的光较弱，而且由于场地灯光和太阳光的存在，会存在杂点、光斑，对信标灯的识别有着很大的影响。因此，在软件上必须排除干扰因素，对图像进行精准识别，并尽可能提取出更多的信息以供控制使用。 在图像处理中，我们提取的信息主要包括：信标灯的坐标、信标灯的长、宽、面积、周长，以及信标灯距离。由于信标灯为扁平状，当距离较远时，接收到的光比较少，提取到的信标灯仅为一个像素点；距离较近时，形状近似为一个椭圆。 当场地光线足够理想时，通过固定阈值二值化，便可将场地与信标灯区分开，再通过连通域提取，即可精确地收集到信标灯的所有信息。当场地光线不够理想时，当信标灯的距离较近时，由于图像画面中信标灯占了很大一部分，所以直接提取面积最大的连通域作为信标灯即可；当信标灯距离较远时，由于信标灯在画面上仅为一个像素点，所以杂光会对信标灯的提取造成很大的困难，甚至一些杂光的亮度大于信标灯的亮度，仅通过固定阈值很难提取出真正的信标灯位置。我们尝试过了许多二值化方法，大津法、平均值法等等，但是效果都比较一般，因为较远处的信标灯只有一个像素点，全局二值化显然不太合适。最后还是采取了分段固定阈值法，主要思想就是距离远的部分给低阈值，距离近的部分给高阈值，这样通过二值化，即可滤掉比信标灯暗的部分。剩下来的就是在图像中滤除杂光干扰，我们采用的方法是通过计算信标灯的坐标和形状，来去除一些形状不可能是信标灯的连通域，通过这种方法，可以排除大部分干扰。剩下满足条件的连通域中，我们选取与上一张图信标灯最近的连通域作为信标灯的位置，来计算其各个信息。 上位机： 上位机指可以直接发送操作指令的计算机或单片机，一般提供用户操作交互界面并向用户展示反馈数据。 典型设备类型：电脑，手机，平板，面板，触摸屏 下位机： 下位机指直接与机器相连接的计算机或单片机，一般用于接收和反馈上位机的指令，并且根据指令控制机器执行动作以及从机器传感器读取数据。 典型设备类型：PLC，STM32，51，FPGA，ARM等各类可编程芯片 信标位置提取 首先通过前摄像头采集的图像进行图像处理，来判断前方是否有信标灯。如果正前方采集到了信标灯的信息，那么便通过这个信息提取出其坐标，以坐标为基础来控制车的运动。如果前摄像头采集到的图片中没有信标灯的信息，那么这时候对后摄像头进行图像处理，来判断信标灯和车的相对位置，从而确定转向方向。整体逻辑在状态机中体现。 智能车竞赛技术报告 | 节能信标组 - 兰州交通大学 - 先锋队_卓晴的博客-程序员宝宝_智能车信标组 - 程序员宝宝 (cxybb.com) 摄像头处理算法 我们采用总钻风摄像头来识别场地中的信标和障碍,总钻风摄像头采集回来 的图像是大小是188*120，以左上角为坐标原点向右下方为图像坐标正方向。在理想的图像中，应该只存在信标，但是由于环境光线，杂点，远处图像太小等因素干扰，图像效果难免会不理想。所以我们不仅通过调节、镜头焦距等方式来获得识别效果最佳的图像。通过图像膨胀对远处的图像进行膨胀操作；采用均值滤波，采用动态阈值二值化，忽略无效点等手段排除干扰因素，对赛场信息进行有效的识别。 寻灯算法实现 由于摄像头采集到的是一个188*120的图像矩阵，首先通过均值滤波对图像进行二值化，同时对图像图像有效像素点进行计数，如果有效点数过少则对图像进行膨胀操作，之后对于信标灯进行每一个像素点横坐标及纵坐标进行累加，以及像素点的个数进行累加，之后通过横纵坐标累加和除以像素点个数，即可得到信标灯的坐标。其中纵坐标为当前车模的方向，用信标灯的纵坐标与图像画面中轴线的纵坐标做差，得到小车车头朝向与信标灯方向的偏差，用此偏差放入PD控制器来控制舵机打角即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643■ 附录 程序源代码void Get_Bin_Image (unsigned char mode) &#123; unsigned short i = 0, j = 0; unsigned long tv = 0; //char txt[16]; if (mode == 0) &#123; Threshold = GetOSTU(mt9v03x_image); //大津法阈值 &#125; else if (mode == 1) &#123; //累加 for (i = 33; i &lt; MT9V03X_H; i++) &#123; for (j = 0 ; j &lt; Image_W; j++) &#123; tv += mt9v03x_image[i][j]; //累加 &#125; &#125; Threshold =(unsigned short)(tv / 87 / 120); //求平均值,光线越暗越小，全黑约35，对着屏幕约160，一般情况下大约100 Threshold = Threshold + lqv; //此处阈值设置，根据环境的光线来设定 &#125; else if (mode == 2) &#123; // Threshold = 110; //累加 for (i = 0; i &lt; MT9V03X_H; i++) &#123; for (j = 0; j &lt; MT9V03X_W; j++) &#123; tv += mt9v03x_image[i][j]; //累加 &#125; &#125; Threshold =(unsigned short)(tv / MT9V03X_H / MT9V03X_W); //求平均值,光线越暗越小，全黑约35，对着屏幕约160，一般情况下大约100 Threshold = Threshold + lqv; //此处阈值设置，根据环境的光线来设定//手动调节阈值 lq_sobel(mt9v03x_image, Bin_Image, (unsigned char) Threshold); return; &#125; else if (mode == 3) &#123; lq_sobelAutoThreshold(mt9v03x_image, Bin_Image); //动态调节阈值 return; &#125; white_1 = 0; /* 二值化 */ for (i = 33; i &lt; MT9V03X_H; i++) &#123; for (j = 0; j &lt; Image_W; j++) &#123; if (mt9v03x_image[i][j] &gt; Threshold) //数值越大，显示的内容越多，较浅的图像也能显示出来 &#123; Bin_Image[i][j] = 255; white_1++; //数出第一次二值化完后的白点数 white_1 &#125; else Bin_Image[i][j] = 0; &#125; &#125; &#125; short GetOSTU (unsigned char tmImage[MT9V03X_H][MT9V03X_W]) &#123; signed short i, j; unsigned long Amount = 0; unsigned long PixelBack = 0; unsigned long PixelshortegralBack = 0; unsigned long Pixelshortegral = 0; signed long PixelshortegralFore = 0; signed long PixelFore = 0; float OmegaBack, OmegaFore, MicroBack, MicroFore, SigmaB, Sigma; // 类间方差; signed short MinValue, MaxValue; signed short Threshold = 0; unsigned char HistoGram[256]; // for (j = 0; j &lt; 256; j++) HistoGram[j] = 0; //初始化灰度直方图 for (j = 0; j &lt; MT9V03X_H; j++) &#123; for (i = 0; i &lt; MT9V03X_W; i++) &#123; HistoGram[tmImage[j][i]]++; //统计灰度级中每个像素在整幅图像中的个数 &#125; &#125; for (MinValue = 0; MinValue &lt; 256 &amp;&amp; HistoGram[MinValue] == 0; MinValue++); //获取最小灰度的值 for (MaxValue = 255; MaxValue &gt; MinValue &amp;&amp; HistoGram[MinValue] == 0; MaxValue--); //获取最大灰度的值 if (MaxValue == MinValue) return MaxValue; // 图像中只有一个颜色 if (MinValue + 1 == MaxValue) return MinValue; // 图像中只有二个颜色 for (j = MinValue; j &lt;= MaxValue; j++) Amount += HistoGram[j]; // 像素总数 Pixelshortegral = 0; for (j = MinValue; j &lt;= MaxValue; j++) &#123; Pixelshortegral += HistoGram[j] * j; //灰度值总数 &#125; SigmaB = -1; for (j = MinValue; j &lt; MaxValue; j++) &#123; PixelBack = PixelBack + HistoGram[j]; //前景像素点数 PixelFore = Amount - PixelBack; //背景像素点数 OmegaBack = (float) PixelBack / Amount; //前景像素百分比 OmegaFore = (float) PixelFore / Amount; //背景像素百分比 PixelshortegralBack += HistoGram[j] * j; //前景灰度值 PixelshortegralFore = Pixelshortegral - PixelshortegralBack; //背景灰度值 MicroBack = (float) PixelshortegralBack / PixelBack; //前景灰度百分比 MicroFore = (float) PixelshortegralFore / PixelFore; //背景灰度百分比 Sigma = OmegaBack * OmegaFore * (MicroBack - MicroFore) * (MicroBack - MicroFore); //计算类间方差 if (Sigma &gt; SigmaB) //遍历最大的类间方差g //找出最大类间方差以及对应的阈值 &#123; SigmaB = Sigma; Threshold = j; &#125; &#125; return Threshold; //返回最佳阈值; &#125; /*! * @brief 基于soble边沿检测算子的一种边沿检测 * * @param imageIn 输入数组 * imageOut 输出数组 保存的二值化后的边沿信息 * Threshold 阈值 * * @return * * @note * * @example * * @date 2020/5/15 */ void lq_sobel (unsigned char imageIn[MT9V03X_H][MT9V03X_W], unsigned char imageOut[MT9V03X_H][MT9V03X_W], unsigned char Threshold) &#123; /** 卷积核大小 */ short KERNEL_SIZE = 3; short xStart = KERNEL_SIZE / 2; short xEnd = MT9V03X_W - KERNEL_SIZE / 2; short yStart = KERNEL_SIZE / 2; short yEnd = MT9V03X_H - KERNEL_SIZE / 2; short i, j, k; short temp[4]; for (i = yStart; i &lt; yEnd; i++) &#123; for (j = xStart; j &lt; xEnd; j++) &#123; /* 计算不同方向梯度幅值 */ temp[0] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i - 1][j + 1] //&#123; &#123; -1, 0, 1&#125;, - (short) imageIn[i][j - 1] + (short) imageIn[i][j + 1] // &#123; -1, 0, 1&#125;, - (short) imageIn[i + 1][j - 1] + (short) imageIn[i + 1][j + 1]; // &#123; -1, 0, 1&#125;&#125;; temp[1] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j - 1] //&#123; &#123; -1, -1, -1&#125;, - (short) imageIn[i - 1][j] + (short) imageIn[i + 1][j] // &#123; 0, 0, 0&#125;, - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j + 1]; // &#123; 1, 1, 1&#125;&#125;; temp[2] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j - 1] // 0, -1, -1 - (short) imageIn[i][j + 1] + (short) imageIn[i + 1][j] // 1, 0, -1 - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j - 1]; // 1, 1, 0 temp[3] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j + 1] // -1, -1, 0 - (short) imageIn[i][j - 1] + (short) imageIn[i + 1][j] // -1, 0, 1 - (short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j + 1]; // 0, 1, 1 temp[0] = abs(temp[0]); temp[1] = abs(temp[1]); temp[2] = abs(temp[2]); temp[3] = abs(temp[3]); /* 找出梯度幅值最大值 */ for (k = 1; k &lt; 4; k++) &#123; if (temp[0] &lt; temp[k]) &#123; temp[0] = temp[k]; &#125; &#125; if (temp[0] &gt; Threshold) &#123; imageOut[i][j] = 255; &#125; else &#123; imageOut[i][j] = 0; &#125; &#125; &#125; &#125; /*! * @brief 基于soble边沿检测算子的一种自动阈值边沿检测 * * @param imageIn 输入数组 * imageOut 输出数组 保存的二值化后的边沿信息 * * @return * * @note * * @example * * @date 2020/5/15 */ void lq_sobelAutoThreshold (unsigned char imageIn[MT9V03X_H][MT9V03X_W], unsigned char imageOut[MT9V03X_H][MT9V03X_W]) &#123; /** 卷积核大小 */ short KERNEL_SIZE = 3; short xStart = KERNEL_SIZE / 2; short xEnd = MT9V03X_W - KERNEL_SIZE / 2; short yStart = KERNEL_SIZE / 2; short yEnd = MT9V03X_H - KERNEL_SIZE / 2; short i, j, k; short temp[4]; for (i = yStart; i &lt; yEnd; i++) &#123; for (j = xStart; j &lt; xEnd; j++) &#123; /* 计算不同方向梯度幅值 */ temp[0] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i - 1][j + 1] //&#123; &#123; -1, 0, 1&#125;, - (short) imageIn[i][j - 1] + (short) imageIn[i][j + 1] // &#123; -1, 0, 1&#125;, - (short) imageIn[i + 1][j - 1] + (short) imageIn[i + 1][j + 1]; // &#123; -1, 0, 1&#125;&#125;; temp[1] = -(short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j - 1] //&#123; &#123; -1, -1, -1&#125;, - (short) imageIn[i - 1][j] + (short) imageIn[i + 1][j] // &#123; 0, 0, 0&#125;, - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j + 1]; // &#123; 1, 1, 1&#125;&#125;; temp[2] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j - 1] // 0, -1, -1 - (short) imageIn[i][j + 1] + (short) imageIn[i + 1][j] // 1, 0, -1 - (short) imageIn[i - 1][j + 1] + (short) imageIn[i + 1][j - 1]; // 1, 1, 0 temp[3] = -(short) imageIn[i - 1][j] + (short) imageIn[i][j + 1] // -1, -1, 0 - (short) imageIn[i][j - 1] + (short) imageIn[i + 1][j] // -1, 0, 1 - (short) imageIn[i - 1][j - 1] + (short) imageIn[i + 1][j + 1]; // 0, 1, 1 temp[0] = abs(temp[0]); temp[1] = abs(temp[1]); temp[2] = abs(temp[2]); temp[3] = abs(temp[3]); /* 找出梯度幅值最大值 */ for (k = 1; k &lt; 4; k++) &#123; if (temp[0] &lt; temp[k]) &#123; temp[0] = temp[k]; &#125; &#125; /* 使用像素点邻域内像素点之和的一定比例 作为阈值 */ temp[3] = (short) imageIn[i - 1][j - 1] + (short) imageIn[i - 1][j] + (short) imageIn[i - 1][j + 1] + (short) imageIn[i][j - 1] + (short) imageIn[i][j] + (short) imageIn[i][j + 1] + (short) imageIn[i + 1][j - 1] + (short) imageIn[i + 1][j] + (short) imageIn[i + 1][j + 1]; if (temp[0] &gt; temp[3] / 12.0f) &#123; imageOut[i][j] = 255; &#125; else &#123; imageOut[i][j] = 0; &#125; &#125; &#125; &#125; void Bin_Image_Filter (void) &#123; sint16 nr; //行 sint16 nc; //列 for (nr = 33; nr &lt; MT9V03X_H - 1; nr++) &#123; for (nc = 1; nc &lt; Image_W - 1; nc = nc + 1) &#123; if ((Bin_Image[nr][nc] == 0)//黑点 &amp;&amp; (Bin_Image[nr - 1][nc] + Bin_Image[nr + 1][nc] + Bin_Image[nr][nc + 1] + Bin_Image[nr][nc - 1] &gt; (2*255)))//若黑点上下右三方向有大于两个白点 &#123; Bin_Image[nr][nc] = 255;//将该黑点置为白点 &#125; else if ((Bin_Image[nr][nc] == 255)//白点 &amp;&amp; (Bin_Image[nr - 1][nc] + Bin_Image[nr + 1][nc] + Bin_Image[nr][nc + 1] + Bin_Image[nr][nc - 1] &lt; (2*255)))//若白点上下右三方向有小于两个白点 &#123; Bin_Image[nr][nc] = 0;//将该白点置为黑点 &#125; &#125; &#125; &#125; void Bin_Image_Filter_peng(void) &#123; sint16 nr; //行 sint16 nc; //列 for (nr = 33; nr &lt; MT9V03X_H - 1; nr++) &#123; for (nc = 31; nc &lt; Image_W - 1; nc = nc + 1) &#123; if ((dilation_Image[nr][nc] == 0)//黑点 &amp;&amp; (dilation_Image[nr - 1][nc] + dilation_Image[nr + 1][nc] + dilation_Image[nr][nc + 1] + dilation_Image[nr][nc - 1] &gt; (2*255)))//若黑点上下右三方向有大于两个白点 &#123; dilation_Image[nr][nc] = 255;//将该黑点置为白点 &#125; else if ((dilation_Image[nr][nc] == 255)//白点 &amp;&amp; (dilation_Image[nr - 1][nc] + dilation_Image[nr + 1][nc] + dilation_Image[nr][nc + 1] + dilation_Image[nr][nc - 1] &lt; (2*255)))//若白点上下右三方向有小于两个白点 &#123; dilation_Image[nr][nc] = 0;//将该白点置为黑点 &#125; &#125; &#125; &#125; void Seek_Road (void) &#123; sint16 nr; //行 sint16 nc; //列 sint16 temp = 0; //临时数值 //for(nr=1; nr&lt;MAX_ROW-1; nr++) temp = 0; for (nr = 8; nr &lt; 24; nr++) &#123; for (nc = MAX_COL / 2; nc &lt; MAX_COL; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; ++temp; &#125; &#125; for (nc = 0; nc &lt; MAX_COL / 2; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; --temp; &#125; &#125; &#125; OFFSET0 = temp; temp = 0; for (nr = 24; nr &lt; 40; nr++) &#123; for (nc = MAX_COL / 2; nc &lt; MAX_COL; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; ++temp; &#125; &#125; for (nc = 0; nc &lt; MAX_COL / 2; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; --temp; &#125; &#125; &#125; OFFSET1 = temp; temp = 0; for (nr = 40; nr &lt; 56; nr++) &#123; for (nc = MAX_COL / 2; nc &lt; MAX_COL; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; ++temp; &#125; &#125; for (nc = 0; nc &lt; MAX_COL / 2; nc = nc + 1) &#123; if (Bin_Image[nr][nc]) &#123; --temp; &#125; &#125; &#125; OFFSET2 = temp; return; &#125; /***********通过边沿提取找到灯的重心点********/ void Seek_Beacon(void) &#123; uint8 nr=0; //行 uint8 nc=0; //列 dotcnt=0; y_sum = 0; x_sum = 0; for (nr = x_zuobiao; nr &lt; MT9V03X_H - 1; nr++)//7.22 nr=1 &#123; for (nc = 1; nc &lt;Image_W - 1; nc++) &#123; if ((Bin_Image[nr - 1][nc] + Bin_Image[nr + 1][nc] + Bin_Image[nr][nc + 1] + Bin_Image[nr][nc - 1] &gt; 255))//若该点上下左右有大于一个白点，记录坐标信息 &#123; y_sum += nc; x_sum += nr; dotcnt++; &#125; &#125; &#125; dotcnt_new = dotcnt; x_sum_new = x_sum; y_sum_new = y_sum; &#125; void Seek_Beacon_peng (void) &#123; uint8 nr=0; //行 uint8 nc=0; //列 dotcnt=0; y_sum = 0; x_sum = 0; for (nr = 33; nr &lt; MT9V03X_H - 1; nr++)//7.24-30 &#123; for (nc = 0; nc &lt; Image_W - 1; nc++) &#123; // if ((dilation_Image[nr - 1][nc] + dilation_Image[nr + 1][nc] + dilation_Image[nr][nc + 1] + dilation_Image[nr][nc - 1] &gt; (1*255)))//若该点左右下有大于一个白点，记录坐标信息 if(dilation_Image[nr][nc]) &#123; y_sum += nc; x_sum += nr; dotcnt++; &#125; &#125; &#125; dotcnt_new = dotcnt; x_sum_new = x_sum; y_sum_new = y_sum; return; &#125;//膨胀运算void dilation(unsigned char *data, uint8 width, uint8 height)&#123; uint8 i, j, flag; for(i = 1;i &lt; height - 1;i++) &#123; for(j = 1;j &lt; width - 1;j++) &#123; flag = 1; for(int m = i - 1;m &lt; i + 2;m++) &#123; for(int n = j - 1; n &lt; j + 2;n++) &#123; //自身及领域中若有一个为255 //则将该点设为255 if(data[i * width + j] == 255 || data[m * width + n] == 255) &#123; flag = 0; break; &#125; &#125; if(flag == 0) &#123; break; &#125; &#125; if(flag == 0) &#123; dilation_Image[i][j] = 255; &#125; else &#123; dilation_Image[i][j] = 0; &#125; &#125; &#125;&#125;void select_pengzhang(void)&#123; if(white_1 &gt;= 0 &amp;&amp; white_1 &lt; 35) &#123; dilation(&amp;Bin_Image[0][0], MT9V03X_W, MT9V03X_H); Bin_Image_Filter_peng(); Seek_Beacon_peng (); &#125; if(white_1 &gt;= 35) &#123; // Bin_Image_Filter(); Bin_Image_Filter(); Seek_Beacon(); &#125;&#125;void getspeed(void) &#123; Pulses_l = gpt12_get(GPT12_T2);//左轮速度 Pulses_r = -gpt12_get(GPT12_T6);//右轮速度 gpt12_clear(GPT12_T2); gpt12_clear(GPT12_T6); speed_ave_now = (Pulses_l + Pulses_r) / 2; // 总速度 占空比与速度对应关系3000--44,10000--145 &#125;/********位置式PID********/float pid_pos(float *err, float *PID_pos, float now, float target)&#123; float pe, ie, de; float out; err[1] = err[0]; err[0] = target - now; if(err[0] &lt; 10) err[2] += err[0] * PID_pos[1]; //积分误差 err[2] = (err[2] &gt; PID_pos[3]) ? PID_pos[3] : err[2]; //限幅保护 err[2] = (err[2] &lt; -PID_pos[3]) ? -PID_pos[3] : err[2]; pe = err[0]; ie = err[2]; de = err[0] - err[1]; out = pe * PID_pos[0] + de * PID_pos[2] + ie; return out;&#125;/******增量式PID******/float pid_increase(float *err, float *PID_inc, float now, float target)&#123; float pe, ie, de; float out; err[2] = err[1]; err[1] = err[0]; err[0] = target - now; pe = err[0] - err[1]; ie = err[0]; de = err[0] - 2 * err[1] + err[2]; out = pe * PID_inc[0] + ie * PID_inc[1] + de * PID_inc[2]; return out;&#125; csdn-- 摄像头处理 (1条消息) 节能信标组：让我们一起来内卷_卓晴的博客-CSDN博客 (1条消息) 十三届智能汽车竞赛 信标对抗组 思路参考 程序参考（二）图像处理_ZZM丶的博客-CSDN博客 有了图像矩阵之后，就可以进行处理了，最终找出信标灯中心在画面中的坐标。信标灯在亮起时会以一定频率闪烁，发出一定频率范围的红光和红外光。摄像头镜头使用了红外滤光片，环境光线比较好的情况下，当信标灯亮起时，其红外光能够很明显在图像上显示为一个光斑，我们则通过逐行扫描图像矩阵的方式来求出这个光斑在画面中的像素坐标，具体操作如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/************************找坐标***************************/void find_LR(void) &#123; unsigned int i,j; unsigned char lside=80,rside=0; for(i=0;i&lt;DATALINE;i++) &#123; lside=80,rside=0; for(j=0;j&lt;80-1;j++) &#123; if(!image_dec[i][j]&amp;&amp;!image_dec[i][j+1]) //同一行中连续两个像素点亮 &#123; if(lside==80) lside=j; //定左边缘 rside=j+1; //定又边缘 &#125; &#125; if(lside&lt;rside) PianCha[i]=(lside+rside)/2; //最大为80 else PianCha[i]=0xff; &#125;&#125;void find_XY(void)&#123; int i=0,k=0,p=0,g=0,m=0,q=0; float Xx=0; for(i=0;i&lt;DATALINE-1;i++) &#123; if((PianCha[i]!=0xff)&amp;&amp;(PianCha[i+1]!=0xff)) //连续四个点表示确定为信标灯而不是噪点 &#123; if(g==0) &#123; k=i; g=1; &#125; if(m==0) p++; &#125; else if(g==1) m=1; &#125; for(q=0;q&lt;p-1;q++) Xx+=PianCha[k+q]; x_MID=Xx/(p-1); y_MID=(k+(p&gt;&gt;1)); //右移一位相当于除以二 而运算速度更快&#125; 在某些光线条件比较差（比如存在阳光、带红外光的灯管等）的情况下，阳光中有红外光的分量，带红外光的灯管直接发出红外光。图像中的光斑就不仅仅是信标灯发出的红外光了了，恶劣时甚至被大片的光干扰淹没，此时想要克服或者减弱这个影响，就需要利用到一个点：信标灯的红外光是以一定频率闪烁的而其他的红外光是常亮的。利用这个特性，可以对相邻的或一定帧间隔内的两张或多张图像之间做 差 或者做 异或 操作，能将常亮的红外光滤除掉，信标灯又能清晰的出现在图像中了： 在某些光线条件比较差（比如存在阳光、带红外光的灯管等）的情况下，阳光中有红外光的分量，带红外光的灯管直接发出红外光。图像中的光斑就不仅仅是信标灯发出的红外光了了，恶劣时甚至被大片的光干扰淹没，此时想要克服或者减弱这个影响，就需要利用到一个点：信标灯的红外光是以一定频率闪烁的而其他的红外光是常亮的。利用这个特性，可以对相邻的或一定帧间隔内的两张或多张图像之间做 差 或者做 异或 操作，能将常亮的红外光滤除掉，信标灯又能清晰的出现在图像中了： 1234567891011121314151617181920/************************闪烁识别***************************/void SHANSHUOSHIBIE(void)&#123; int q,w; Image_Decompression((uint8 *)ADdata,(uint8 *)image_dec[0]); //解压图像 if(shan&gt;0) &#123; shan=0; for(q=0;q&lt;60;q++) &#123; for(w=0;w&lt;80;w++) &#123; shanshuo[q][w]=copy[q][w]^image_dec[q][w]; //两幅图像对应位置像素异或操作 copy[q][w]=image_dec[q][w]; &#125; &#125; &#125; shan++;&#125; (1条消息) 十六届智能车信标组的浅析_wuxing4550的博客-CSDN博客_智能车信标 (1条消息) 浅谈全国大学生智能车竞赛-摄像头组图像处理及控制算法_Q792499178的博客-CSDN博客_智能车摄像头图像处理 初学图像处理的人，一般首先熟悉图像格式，图像存储方式，8位灰度图，24位彩色图等基础知识，然后接触到的图像算法一般都是图像直方图、图像二值化处理等基础算法。二值化算法作为图像处理入门级算法，在很多场合都有应用。常用的二值化算法是固定阈值二值化，算法本身很简单，机器视觉处理的很多都是8位灰度图像，灰度值从0到255,。所谓二值化就是给定一个阈值，让小于这个阈值的灰度值为0，大于等于这个阈值的设为255，这样在图像上显示出来就是一幅黑白图像。 threshold(src, dst, 100, 255, 0); 第一个参数是输入图像，第二个是输出图像，第三个是阈值，第四个是指将大于等于阈值的灰度值设置为多大的值，最后一个参数是二值化方式 如果直接用大律法进行二值化，实际效果并不是很好，因为这是全局阈值，比较好的二值化方法应该用局部阈值，毕竟图像上每个地方的灰度值差别是比较大的。所以，opencv里面有提供了一个局部自适应二值化函数adaptiveThreshold。这个函数的效果比较好，但是，很多人用这个函数的时候，却不知道参数怎么设置比较好，结果往往出来的效果不理想，反而认为算法不好。其实，就算固定阈值二值化算法，在很多时候都能得到很好的效果，只不过我们很多人不是很清楚算法怎么配合使用而已。 (2条消息) 二值化_初探图像二值化_twxy的博客-CSDN博客 二值图像即为每个像素只有两个可能值的数字图像，常出现在图像掩码，图像分割，二值化和dithering。 其将大于某个临界灰度值的像素灰度设为灰度极大值，小于这个值的为灰度极小值，从而实现二值化 根据域值，二值化分为固定阈值和自适应阈值。比较常用的二值化方法有：双峰法，P参数法，迭代法和OTSU法等。 直方图是图像的重要特质，它可以帮助我们分析图像中的灰度变化。因此，如果物体与背景的灰度值对比明显，直方图就会包含双峰(bimodal histogram)，它们分别为图像的前景和背景。而它们之间的谷底即为边缘附近相对较少数目的像素点，一般来讲，这个最小值就为最优二值化的分界点，通过这个点可以把前景和背景很好地分开。 算法 中值滤波 (4条消息) 图像处理——中值滤波_lixiao0314的博客-CSDN博客_图像中值滤波 (4条消息) 数字图像处理------中值滤波_ranjiewen的博客-CSDN博客_数字图像处理中值滤波算法 突变的噪声 核心思路： 当数据出现很大的跳变时，均值滤波会有很大的影响，中值滤波没有，消去阶跃性噪声 中位数更加能反应数据所处的位置 原图： 进入干扰数据： 均值滤波能反映数据的变化 可以适应数据整体上升，也随之上升 12//中值滤波核心：快而准的排序 (7条消息) 节能信标组：让我们一起来内卷_卓晴的博客-CSDN博客 (7条消息) 智能车图像处理-阳光算法_长风弦歌的博客-CSDN博客_阳光算法 最后还是采取了分段固定阈值法，主要思想就是距离远的部分给低阈值，距离近的部分给高阈值，这样通过二值化，即可滤掉比信标灯暗的部分。剩下来的就是在图像中滤除杂光干扰，我们采用的方法是通过计算信标灯的坐标和形状，来去除一些形状不可能是信标灯的连通域，通过这种方法，可以排除大部分干扰。剩下满足条件的连通域中，我们选取与上一张图信标灯最近的连通域作为信标灯的位置，来计算其各个信息。","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"模块一 教育基础知识和基本原理——第二章 教育与社会发展","slug":"教资/模块一 教育基础知识和基本原理/第二章 教育与社会发展","date":"2022-03-28T16:00:07.273Z","updated":"2022-04-03T06:24:23.941Z","comments":true,"path":"2022/03/29/教资/模块一 教育基础知识和基本原理/第二章 教育与社会发展/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/29/%E6%95%99%E8%B5%84/%E6%A8%A1%E5%9D%97%E4%B8%80%20%E6%95%99%E8%82%B2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%95%99%E8%82%B2%E4%B8%8E%E7%A4%BE%E4%BC%9A%E5%8F%91%E5%B1%95/","excerpt":"","text":"第一节：教育与人口 1.人口功能： ①提高人口素质 ②控制人口增长 ③改善人口结构 2.人口对教育的反作用 ①人口数量、速度——教育的发展规模、速度 ②就业结构——内部结构 ③地域分布——布局和办学形式 ④人口流动 第二节：教育与生产力【选择】 1.经济功能： ①再生产劳动力——“我们” ②再生产科学技术知识——“知识变为生产力“ ③生产新的科学技术知识——“旧知识变为新知识” 2.生产力对教育的决定作用（根本作用） ①教育发展的规模和速度 ②教育结构的变化 ③教育的内容和手段 ④教育目的 速归（规）借（结）木（目）手内 3.教育对科技进步和经济发展的贡献 人力资本理论——舒尔茨 （人所拥有的可以为社会创造价值） 第三节：教育与社会政治经济制度【简答】 1.政治功能（社会民主需要政治人才的思想舆论） ①教育通过年轻一代的政治社会化和培养政治人才为政治服务 ②教育通过思想传播、制造舆论为政治经济制度服务 ③教育是促进社会民主化的重要力量 2.社会政治经济制度决定教育的社会性质（两权一目的） ①教育的领导权 ②受教育的权利 ③教育目的的性质和思想品德教育的内容 第四节：教育与文化【简答】 1.教育的文化功能 ①教育具有筛选、整理、传递和保存文化的作用 ②教育具有传播和交流文化的作用 ③教育具有更新和创造文化的作用 传递：前 后（时间） 传播：空间的扩大 第一节人的身心发展及其规律 1.顺序性 人的身心发展过程由低级到高级，具有一定的顺序性 （举例：三躺六坐八爬，机械记忆到意义记忆，具体思维到抽象思维） 关键词：教育要循序渐进，不能“揠苗助长” 2.阶段性 个体在不同年龄阶段表现出不同的总体特征和主要矛盾，面临着不同的发 展任务 关键词：量变—质变、一刀切、一锅煮（针对个人） 3.不平衡性 ①同一因素在不同时期有不同表现（举例:身高） ②不同因素在同一时期有不同表现（举例：身体发育和心智发育） 关键词：抓住关键期 4.个别差异性 ①不同群体之间 ②不同个体之间 关键词：长善救失、因材施教 5.互补性 ①身身互补 ②身心互补 第二节 影响人身心发展的主要因素 1.遗传（辨析、简答） 概念：遗传素质，是指从上代继承下来的、与生俱来的生理解剖上的特点。 作用： ①是人的身心发展的物质基础和生物前提，为个体的身心发展提供了可能性。 ②遗传素质的个别差异为人的身心发展的个别差异提供了最初的可能 ③遗传素质的成熟机制制约着人的身心发展水平和阶段 ④不宜夸大遗传素质的作用 2.环境（选择） ①为个体发展提供了多种可能 ②环境制约个体的发展水平，决定人的身心发展方向、水平、速度和个别差异 ③通过人的内部因素实现 ④有积极和消极之分 3.学校教育在人的身心发展中起主导作用（简答、辨析） （1）原因（三有一训练，控制很全面） ①有目的有计划有组织地培养人地活动 ②通过受专门训练的老师来进行 ③有效地控制和协调影响学生发展的各种因素 ④给人的影响比较全面 、系统和深刻 （2）表现 ①对个体发展做出社会性规范 ②加速个体发展的特殊功能 ③对个体发展的影响具有即时和延时的价值 ④具有开发个体特殊才能和发展个性的功能 4.个体主观能动性起决定作用（选择） ①个体的能动性是人在活动中产生和表现出来的 ②个体的能动性是人发展的内在动力 ③个体的能动性影响人的自我设计和自我奋斗 第二节 关于人身心发展的典型观点 1.遗传决定论（内发论）： ①高尔顿 ②霍尔：一两的遗传胜过一吨的教育 ③格塞尔：双生子爬梯实验 ④孟子：仁义礼智非由外铄我也，我固有之也 2.环境决定论（外铄论）： ①荀子：性恶论 ②洛克：白板说 ③华生：教育万能论 ④斯金纳：行为主义强化论 3.调和论 ①伍德沃斯：遗传和环境的乘积 ②斯特恩：内部性质和外部环境的合并 材料分析题答题思路 ①先读问题，明确考察的知识点 ②回忆并呈现知识点 ③阅读材料与知识点一一对应 ④整理答案，知识点+材料的形式 ⑤总结 第四章第一节 我国现代学制的沿革 1.教育制度的含义【选择】 广义的教育制度：国民教育制度 狭义的教育制度：一个国家各级各类学校的系统及其管理规则（总体系） 2.学制是现代教育制度的核心 3.一个国家学制建立的主要依据【简答】 ①社会生产力发展的水平和科学技术发展情况 ②社会制度的制约 ③人口状况 ④儿童的年龄特征 ⑤原有和外国学制的经验 4.旧中国的学制 （壬颁布，癸实施，资本主义丑男女，六三三制美长戌） ①1902年“壬寅学制”《钦定学堂章程》 首次颁布第一个现代学制 日本 只颁布，未实行 ②1904年“癸卯学制” 《奏定学堂章程》首次得到实施 中学为体，西学为用 不允许男女同校 ③1912年“壬子癸丑学制” 男女同校 资产阶级 ④1922年 “壬戌学制”=“六三三制” 美国 小学6年初中3年高中3年","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"教育知识与能力","slug":"教育知识与能力","permalink":"https://zhang0224gz.github.io/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/"}]},{"title":"《应用密码学》——第二章 古典密码技术","slug":"笔记/密码学/第二章 古典密码技术","date":"2022-03-28T15:48:59.635Z","updated":"2022-04-06T13:45:01.765Z","comments":true,"path":"2022/03/28/笔记/密码学/第二章 古典密码技术/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/28/%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/","excerpt":"","text":"2.1 替代密码 单表替代密码 一般单表替代密码 a b c d e f g h i j k l m n o p q i s t u v w x y z q w e r t y u i o p a s d f g h j k l z x c v b n m 明文根据转化表将明文字母转换为密文字母(a -&gt; q)，密钥是键盘字母的排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; string table_c = &quot;qwertyuiopasdfghjklzxcvbnm&quot;;string table_m = &quot;abcdefghijklmnopqrstuvwxyz&quot;;int N = 26; int index(char x)&#123; for(int i=0;i&lt;N;i++) &#123; if(table_c[i]==x)return i; &#125;&#125;string pi_1(string c)&#123; string temp_m = &quot;&quot;; int n; for(int i=0;i&lt;N;i++) &#123; n = index(c[i]); temp_m += table_m[n]; &#125; return temp_m;&#125;string pi(string m)&#123; string temp_c=&quot;&quot;; int n; for(int i=0;i&lt;N;i++) &#123; n = m[i]-&#x27;a&#x27;; temp_c += table_c[n]; &#125; return temp_c;&#125;int main()&#123; string m = &quot;abcdefghijklmnopqrstuvwxyz&quot;; string c = &quot;qwertyuiopasdfghjklzxcvbnm&quot;; cout&lt;&lt;pi(m)&lt;&lt;endl; cout&lt;&lt;pi_1(c)&lt;&lt;endl; return 0;&#125; 移位密码 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; string c = &quot;efghijklmnopqrstuvwxyzabcd&quot;;string m = &quot;abcdefghijklmnopqrstuvwxyz&quot;;int n = 26;string pi_1(string c)&#123; string temp_m = &quot;&quot;; int k_1 = 4; for(int i=0;i&lt;n;i++) &#123; temp_m += (c[i]-&#x27;a&#x27;-k_1+26)%26 + &#x27;a&#x27;; &#125; return temp_m;&#125;string pi(string m)&#123; string temp_c = &quot;&quot;; int k = 4; for(int i=0;i&lt;n;i++) &#123; temp_c += (m[i]-&#x27;a&#x27;+ k)%26 + &#x27;a&#x27;; &#125; return temp_c;&#125;int main()&#123; cout&lt;&lt;pi(m)&lt;&lt;endl; cout&lt;&lt;pi_1(c)&lt;&lt;endl; return 0; &#125; 仿射密码 这边写错了，k1=7,取模的26不是k2，而且只有7,26互质(最大公因数为1)才能解密:ax-by=1 扩展欧几里德变换求a逆： 欧几里得算法非递归求逆密钥 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; string Atoa(string x);string E(string x);//a指进行乘法逆元的密钥，b指的模的那个数int gcd(int a,int b);//欧几里德算法求公约数int bianli(int a,int b);//暴力计算int ex_gcd(int a,int b,int &amp;x,int &amp;y);//扩展欧几里德算法递归求逆密钥int gcd_1(int a,int b,int &amp;x,int &amp;y)；//欧几里得算法非递归求逆密钥string D(string x); int main()&#123; string m,c; cout&lt;&lt;&quot;请输入明文m:&quot;; cin&gt;&gt;m; //m = &quot;China&quot;; //c = &quot;UnwPc&quot;; //cout&lt;&lt;Atoa(m)&lt;&lt;endl; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; //cout&lt;&lt;gcd(9,26)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; cin&gt;&gt;c; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125; string Atoa(string x)&#123; string temp=&quot;&quot;; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; if(x[i]&gt;&#x27;Z&#x27;) temp += x[i]; else temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; return temp;&#125;string E(string x)&#123; x = Atoa(x); string temp=&quot;&quot;; int k1=9,k2=2,m=26; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; temp += (k1*(x[i]-&#x27;a&#x27;)+k2)%m+&#x27;a&#x27;; &#125; return temp;&#125;int gcd(int a,int b)&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int bianli(int a,int b)&#123; int x; for(int i=1;i&lt;=b;i++) &#123; x = (a*i)%b; if(x==1)return i; &#125;&#125;string D(string x)&#123; x = Atoa(x); string temp=&quot;&quot;; int k1=9,k2=2,m=26,n,k1_1; int flag=gcd(k1,m); if(flag!=1) &#123; cout&lt;&lt;&quot;k1与m不互质，无法解密！&quot;&lt;&lt;endl; return temp; &#125; else &#123; //k1_1=bianli(k1,m); int x0=0,y0=0; k1_1 = gcd_1(k1,m,x0,y0); n = x.size(); for(int i=0;i&lt;n;i++) &#123; temp += k1_1*(x[i]-&#x27;a&#x27;-k2)%m +&#x27;a&#x27;; &#125; return temp; &#125;&#125;int ex_gcd(int a,int b,int &amp;x,int &amp;y)//扩展欧几里德变换ax+by=gcd(a,b)&#123; if(b==0) &#123; x=1; y=0; //cout&lt;&lt;k++&lt;&lt;&quot; dao di le&quot;&lt;&lt;endl; return a; &#125; int res = ex_gcd(b,a%b,x,y); //通过证明得，如何获得上一层x,y //x1=y2,y1=x2-(a/b)*y2 int temp=x; x = y; y = temp-(a/b)*y; //cout&lt;&lt;k++&lt;&lt;&quot; &quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl; return x;&#125;int gcd_1(int a,int b,int &amp;x,int &amp;y)//欧几里得算法非递归求逆密钥&#123; int X1=1,X2=0,X3=b; int Y1=0,Y2=1,Y3=a; int T1,T2,T3; int Q; while(1) &#123; if(Y3==0)return X2; if(Y3==1)return Y2; Q=X3/Y3; T1=X1-Q*Y1; T2=X2-Q*Y2; T3=X3-Q*Y3; X1=Y1;X2=Y2;X3=Y3; Y1=T1;Y2=T2;Y3=T3; &#125;&#125; 密钥短语密码 选用一个英文单词或单词串作为密钥。去掉重复字母的到一个字符串排在首端将字母表其余字母依次写入。其他类似一般单表替代密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;using namespace std; string Table_m=&quot;&quot;;char Table_c[26]; void creatTable(char letter[]);string Atoa(string x);string E(string x);string D(string x); int main()&#123; string m,c; char letter[26]; m = &quot;China&quot;; c = &quot;yfgmk&quot;; for(int i=0;i&lt;26;i++) &#123; letter[i]=&#x27;a&#x27;+i; &#125; creatTable(letter); //cout&lt;&lt;Table&lt;&lt;endl; cout&lt;&lt;&quot;请输入明文m:&quot;; cin&gt;&gt;m; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; cin&gt;&gt;c; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;void creatTable(char letter[])&#123; string k=&quot;key&quot;; Table_m += k; int n=k.size(),index; for(int i=0;i&lt;n;i++) &#123; index = k[i]-&#x27;a&#x27;; letter[index]=&#x27;0&#x27;; &#125; for(int i=0;i&lt;26;i++) &#123; if(letter[i]!=&#x27;0&#x27;) Table_m += letter[i]; &#125; for(int i=0;i&lt;26;i++) &#123; index = Table_m[i]-&#x27;a&#x27;; Table_c[index]=letter[i]; &#125;&#125;string Atoa(string x)&#123; string temp=&quot;&quot;; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; if(x[i]&gt;&#x27;Z&#x27;) temp += x[i]; else temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; return temp;&#125;string E(string x)&#123; int n=x.size(),index; string temp=&quot;&quot;; x = Atoa(x); for(int i=0;i&lt;n;i++) &#123; index=x[i]-&#x27;a&#x27;; temp += Table_m[index]; &#125; return temp;&#125;string D(string x)&#123; int n=x.size(),index; string temp=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; index = x[i]-&#x27;a&#x27;; temp += Table_c[index]; &#125; return temp;&#125; 多表替代密码 维吉尼亚密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string Atoa(string x);string E(string x);string D(string x);int main()&#123; string m,c; //m = &quot;appliedcryptosystem&quot;; //c = &quot;cxesmvfkgftkqanzxvo&quot;; cout&lt;&lt;&quot;请输入明文m:&quot;; getline(cin,m); cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; getline(cin,c); cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;string Atoa(string x)&#123; string temp=&quot;&quot;; int n = x.size(); for(int i=0;i&lt;n;i++) &#123; if(x[i]==&#x27; &#x27;)continue; if(x[i]&gt;&#x27;Z&#x27;) temp += x[i]; else temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; &#125; return temp;&#125;string E(string x)&#123; string k=&quot;chipher&quot;; k=Atoa(k); string temp=&quot;&quot;; int index; x = Atoa(x); int n=x.size(); for(int i=0;i&lt;n;i++) &#123; index=i%6; temp += (k[index]-&#x27;a&#x27;+x[i]-&#x27;a&#x27;)%26+&#x27;a&#x27;; &#125; return temp;&#125;string D(string x)&#123; string k=&quot;chipher&quot;; k=Atoa(k); string temp=&quot;&quot;; int index; int n=x.size(); for(int i=0;i&lt;n;i++) &#123; index=i%6; temp += (x[i]-k[index]+26)%26+&#x27;a&#x27;; &#125; return temp;&#125; 希尔(Hill)密码 密钥是一个矩阵，解密是其逆矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277/*后期还要观摩别人的代码将思路进行优化。我觉得我的思路还是比较暴力的，而且有些地方代码重复性比较高，比如加解密矩阵相乘得结果是一样的步骤可以合并，求逆矩阵可以再封成一个函数但现在我还是把他直接写在解密函数里。感觉求解|A|可以利用三阶那个函数迭代……相关知识点转看博客：涉及的C/C++的知识点*/#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;using namespace std;//以密钥矩阵可逆，加解密成功为前提条件int threeOrder_evaluation(int N,int **K);//三阶行列式|A|求值(对角线方法只适用于二、三阶) int Evaluation_of_Determinant(int N,double **K);//n阶行列式求值 / 判断矩阵是否可逆|A|?=0 double **Adjoint_Matrix(int N,double **K);//求伴随矩阵A* string E(string x);string D(string x); int main()&#123; string c,m; m = &quot;good&quot;; c = &quot;wmwl&quot;; cout&lt;&lt;&quot;E(m) = &quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;D(c) = &quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;string D(string x) &#123; int n=x.size(),N=2; int K[N][N]=&#123;&#123;11,8&#125;,&#123;3,7&#125;&#125;;//53 //int K[N][N]=&#123;&#123;1,1,1&#125;,&#123;0,1,3&#125;,&#123;2,2,5&#125;&#125;;//3 //int K[N][N]=&#123;&#123;3,1,1,1&#125;,&#123;1,3,1,1&#125;,&#123;1,1,3,1&#125;,&#123;1,1,1,3&#125;&#125;;//48 int evaluation;//|A| int K_1[N][N]; int M[N],C[N]; string temp=&quot;&quot;; //创建动态二维数组 double **Key;//密钥A double **BanSui;//伴随矩阵 Key = (double **)malloc(N*sizeof(double *));//行开辟空间 for(int i=0;i&lt;N;i++)//列开辟空间 *(Key+i)=(double*)malloc(N*sizeof(double)); //*(BanSui+i)=(double*)malloc(N*sizeof(double)); for(int i=0;i&lt;N;i++)//将值输入动态数组 for(int j=0;j&lt;N;j++) Key[i][j]=K[i][j]; //求A* BanSui = Adjoint_Matrix(N,Key); //求|A| evaluation = Evaluation_of_Determinant(N,Key)%26; //求A逆 for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) K_1[i][j]=((int(BanSui[i][j])/evaluation)+26)%26; //解密 for(int i=0;i&lt;n;i++) &#123; M[i%N]=x[i]-&#x27;a&#x27;; if(i%N==N-1) &#123; for(int j=0;j&lt;N;j++) &#123; C[j]=0; for(int k=0;k&lt;N;k++) &#123; C[j] += M[k]*K_1[j][k]; &#125; temp += C[j]%26 + &#x27;a&#x27;; &#125; &#125; &#125; for(int i=0;i&lt;N;i++)//释放空间：行 &#123; free(*(Key+i)); free(*(BanSui+i)); &#125; return temp;&#125;double **Adjoint_Matrix(int N,double **K)&#123; double **adjoint,**cofactor;//伴随矩阵，代数余子式 int m,n; int temp[N][N]; //创建动态数组 adjoint = (double **)malloc(N*sizeof(double)); for(int i=0;i&lt;N;i++) adjoint[i] = (double *)malloc(N*sizeof(double)); cofactor = (double **)malloc(N*sizeof(double)); for(int i=0;i&lt;N;i++) cofactor[i] = (double *)malloc(N*sizeof(double)); //求n=2阶伴随矩阵 if(N==2) &#123; m=0,n=0; for(int i=N-1;i&gt;-1;i--) &#123; for(int j=N-1;j&gt;-1;j--) &#123; adjoint[m++][n]=pow(-1,i+j)*K[i][j]; &#125; m=0; n++; &#125; return adjoint; &#125; //求n&gt;2阶伴随矩阵 for(int i=0;i&lt;N;i++) &#123; m=0,n=0; for(int k=0;k&lt;N;k++) &#123; if(k==i)continue; for(int l=0;l&lt;N;l++) &#123; temp[m][n++]=K[k][l]; &#125; m++; n=0; &#125; for(int j=0;j&lt;N;j++) &#123; m=0,n=0; for(int l=0;l&lt;N;l++) &#123; if(l==j)continue; for(int k=0;k&lt;N-1;k++) &#123; cofactor[m++][n]=temp[k][l]; //cout&lt;&lt;m-1&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;temp[k][l]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;endl; &#125; n++; m=0; //cout&lt;&lt;endl; &#125; //伴随矩阵 adjoint[j][i]=pow(-1,i+j)*K[i][j]*Evaluation_of_Determinant(N-1,cofactor); &#125; &#125; return adjoint;&#125;string E(string x)&#123; int n=x.size(),N=2; int K[N][N]=&#123;&#123;11,8&#125;,&#123;3,7&#125;&#125;; int M[N],C[N]; string temp=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; M[i%N]=x[i]-&#x27;a&#x27;; if(i%N==N-1) &#123; for(int j=0;j&lt;N;j++) &#123; C[j]=0; for(int k=0;k&lt;N;k++) &#123; C[j] += M[k]*K[j][k]; &#125; temp += C[j]%26 + &#x27;a&#x27;; &#125; &#125; &#125; return temp;&#125;int threeOrder_evaluation(int N,int **K)//三阶矩阵求值(对角线方法只适用于二、三阶) &#123; int k,sum=0; int Temp[N][2*N-1]; //第一步：形成对称矩阵 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;2*N-1;j++) &#123; Temp[i][j]=K[i][j%N]; cout&lt;&lt;Temp[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; //第二步：求出每个ai*aj*ak*al int cunzhi1[N],cunzhi2[N]; for(int i=0;i&lt;N;i++) &#123; cunzhi1[i]=1; k=0; for(int j=i;j&lt;i+N;j++) &#123; cunzhi1[i] *= Temp[k++][j]; cout&lt;&lt;cunzhi1[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; for(int i=0;i&lt;N;i++) &#123; cunzhi2[i]=1; k=0; for(int j=N+i-1;j&gt;N+i-4;j--) &#123; cunzhi2[i] *= Temp[k++][j]; cout&lt;&lt;cunzhi2[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; //第三步：求出矩阵的值 for(int i=0;i&lt;N;i++) &#123; sum += cunzhi1[i]-cunzhi2[i]; &#125; return sum; &#125; int Evaluation_of_Determinant(int N,double **K)//n阶行列式求值&#123; float z,ji=1,sum=1; int p=0; for(int i=0;i&lt;N-1;i++)//列 &#123; z = K[i][i]; //这块解决当为&#123;&#123;0,1&#125;,&#123;2,3&#125;&#125;这样矩阵时的情况 while(z==0) &#123; p++; for(int k=0;k&lt;N;k++) &#123; K[i][k]+= K[i+p][k]; &#125; z=K[i][i]; &#125; p=0; ji *= z; //cout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;ji&lt;&lt;endl; for(int k=i;k&lt;N;k++) &#123; K[i][k] /= z; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;K[i][k]&lt;&lt;endl; &#125; for(int j=i+1;j&lt;N;j++)//行 &#123; z = K[j][i]; if(z==0)continue; //cout&lt;&lt;z&lt;&lt;endl; for(int k=i;k&lt;N;k++) &#123; K[j][k] -= z*K[i][k]; //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;K[j][k]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;K[i][k]&lt;&lt;endl; &#125; &#125; &#125; for(int i=0;i&lt;N;i++) &#123; sum *= K[i][i]; //cout&lt;&lt;sum&lt;&lt;&quot; &quot;; &#125; //cout&lt;&lt;endl; return sum*ji;&#125; 一次一密密码(One Time Pad) Playfair 密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;iostream&gt;#include&lt;string&gt;using namespace std; char keyTable[6][6];string key; void Modify_key(string k);//密钥创建+内容修改string Modify_m(string x);//明文格式内容修改string Modify_c(string x);void Init();int index(char x);string E(string x);string D(string x); int main()&#123; string m,c; //m=&quot;playfair cipher&quot;; //c=&quot;layfpyrsmramcd&quot;; Init(); cout&lt;&lt;&quot;请输入明文m:&quot;; getline(cin,m); cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;请输入密文c:&quot;; getline(cin,c); cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125; string Modify_c(string x)&#123; string temp=&quot;&quot;; int n=x.size(); char k=&#x27;x&#x27;; for(int i=0;i&lt;n;i++) &#123; if(x[i]==x[i+2]&amp;&amp;x[i+1]==k) &#123; temp+=x[i]; temp+=x[i+2]; i += 2; continue; &#125; if(x[n-1]==k)continue; temp += x[i]; &#125; return temp;&#125;string D(string x)&#123; int n=x.size(),N1,N2,x1,x2,y1,y2; string temp=&quot;&quot;; for(int i=0;i&lt;n;i+=2) &#123; N1=index(x[i]); N2=index(x[i+1]); x1=N1/5;y1=N1%5; x2=N2/5;y2=N2%5; if(x1==x2) &#123; y1=(y1+4)%5; y2=(y2+4)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else if(y1==y2) &#123; x1=(x1+4)%5; x2=(x2+4)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else &#123; temp+=keyTable[x1][y2]; temp+=keyTable[x2][y1]; &#125; &#125; temp=Modify_c(temp); return temp;&#125; string Modify_m(string x)&#123; int n=x.size(); char k=&#x27;x&#x27;; string temp=&quot;&quot;,temp1=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; if(x[i]==&#x27; &#x27;)continue; temp1+=x[i]; &#125; n=temp1.size(); for(int i=0;i&lt;n;i+=2) &#123; temp+=temp1[i]; if(x[i]==x[i+1]) &#123; temp+=k; i--; continue; &#125; temp+=temp1[i+1]; &#125; n=temp.size(); if(n%2!=0)temp+=k; return temp;&#125;void Modify_key(string k)&#123; int n=k.size(),index,flag=1; int x=0,y=0; char letter[26]; string temp=&quot;&quot;;//关于去重：可以创建一个顺序的字母数组，循环的时候当key中第一次出现该字符将索引值下内容改为‘0’，下一次再遇到该值因为为‘0’所以就不管啦 for(int i=0; i&lt;26; i++) &#123; letter[i]=&#x27;a&#x27;+i; &#125; for(int i=0; i&lt;n; i++) &#123; if(k[i]==&#x27; &#x27;)continue; else &#123; index = k[i]-&#x27;a&#x27;; if(k[i]==letter[index]) &#123; temp += k[i]; letter[index]=&#x27;0&#x27;; if(k[i]==&#x27;i&#x27;||k[i]==&#x27;j&#x27;)flag=0; &#125; &#125; &#125; for(int i=0; i&lt;26; i++) &#123; if(flag==1&amp;&amp;(k[i]==&#x27;i&#x27;||k[i]==&#x27;j&#x27;)) &#123; temp+=letter[i]; flag = 0; &#125; if(letter[i]!=&#x27;0&#x27;&amp;&amp;k[i]!=&#x27;i&#x27;&amp;&amp;k[i]!=&#x27;j&#x27;) &#123; temp += letter[i]; &#125; if(letter[i]==&#x27;w&#x27;)temp+=letter[i];//不知道为啥w就是判断不了QAQ &#125; key = temp; for(int i=0;i&lt;25;i++) &#123; keyTable[x][y]=temp[i]; y++; if(y%5==0) &#123; x++; y=0; &#125; &#125;&#125;int index(char x)&#123; int i; for(i=0;i&lt;26;i++) &#123; if(key[i]==x)break; &#125; return i;&#125;string E(string x)&#123; string temp=&quot;&quot;; x=Modify_m(x); int n=x.size(),N1,N2,x1,x2,y1,y2; for(int i=0;i&lt;n;i+=2) &#123; N1=index(x[i]); N2=index(x[i+1]); x1=N1/5;y1=N1%5; x2=N2/5;y2=N2%5; if(x1==x2) &#123; y1=(y1+1)%5; y2=(y2+1)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else if(y1==y2) &#123; x1=(x1+1)%5; x2=(x2+1)%5; temp+=keyTable[x1][y1]; temp+=keyTable[x2][y2]; &#125; else &#123; temp+=keyTable[x1][y2]; temp+=keyTable[x2][y1]; &#125; &#125; return temp;&#125;void Init()&#123; string k=&quot;playfair is a digram cipher&quot;; Modify_key(k);&#125; 2.2 置换密码 周期置换密码 给予的明文必须是以密钥k的倍数形式（因为要以k个字母为一组进行每组置换） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;string E(string x)；string D(string x)；int main()&#123; string m,c; m = &quot;cryptographycry&quot;; c = &quot;ytcoprahgypr&quot;; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125;string E(string x)&#123; int k=6; int k_m[k]=&#123;2,4,0,5,3,1&#125;; int n=x.size(),index,flag=0; string temp1=&quot;&quot;,temp2=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; temp1 += x[i]; if(i%k==5) &#123; for(int i=0;i&lt;6;i++) &#123; index = k_m[i]; temp2+= temp1[index]; &#125; temp1 = &quot;&quot;; &#125; &#125; return temp2;&#125;string D(string x)&#123; int k=6; int k_m[k]=&#123;2,4,0,5,3,1&#125;; int k_c[k]; for(int i=0;i&lt;k;i++) &#123; for(int j=0;j&lt;k;j++) &#123; if(k_m[j]==i) &#123; k_c[i]=j; // cout&lt;&lt;j&lt;&lt;endl; break; &#125; &#125; &#125; int n=x.size(),index; string temp1=&quot;&quot;,temp2=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; temp1 += x[i]; if(i%k==5) &#123; for(int i=0;i&lt;6;i++) &#123; index = k_c[i]; temp2+= temp1[index]; //cout&lt;&lt;index&lt;&lt;temp2&lt;&lt;endl; &#125; temp1 = &quot;&quot;; &#125; &#125; return temp2;&#125;/*1 2 3 4 5 63 5 1 6 4 21 2 3 4 5 63 6 1 5 2 4*/ 列置换密码 原本解密想不用数组的……但没写出比较好的QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;using namespace std; string Modify_m(string x);string E(string x);string D(string x); int main()&#123; string m,c; m = &quot;This boy is a worker Th&quot;; //c = &quot;sioriywehoaktbsr&quot;; c = &quot;sioriywehoakhtbsrt&quot;; cout&lt;&lt;&quot;E(m)=&quot;&lt;&lt;E(m)&lt;&lt;endl; cout&lt;&lt;&quot;D(c)=&quot;&lt;&lt;D(c)&lt;&lt;endl; return 0;&#125; string Modify_m(string x)&#123; int n=x.size(); string temp=&quot;&quot;; for(int i=0;i&lt;n;i++) &#123; if(x[i]==&#x27; &#x27;)continue; if(x[i]&lt;&#x27;a&#x27;) temp += x[i]-&#x27;A&#x27;+&#x27;a&#x27;; else temp += x[i]; &#125; return temp;&#125;string E(string x)&#123; x = Modify_m(x); int n=x.size(),k=4,index; int k_m[k]=&#123;3,2,1,0&#125;; string temp0=&quot;&quot;,temp1=&quot;&quot;,temp2=&quot;&quot;; if(n%k!=0) &#123; for(int i=0;i&lt;k-n%k;i++) x += &#x27;?&#x27;; n += k-n%k; &#125; for(int i=0;i&lt;n;i++) &#123; temp0 += x[i]; if(i%k==3) &#123; for(int i=0;i&lt;k;i++) &#123; index = k_m[i]; temp1 += temp0[index]; &#125; temp0=&quot;&quot;; &#125; &#125; for(int i=0;i&lt;k;i++) &#123; for(int j=i;j&lt;n;j+=k) &#123; if(temp1[j]==&#x27;?&#x27;) continue; else temp2 += temp1[j]; &#125; &#125; return temp2;&#125;string D(string x)&#123; int n=x.size(),k=4,m=n/4+1,p=0; int k_m[k]=&#123;3,2,1,0&#125;,k_c[k]; string temp=&quot;&quot;; char table[m][k]; for(int i=0;i&lt;k;i++) &#123; for(int j=0;j&lt;k;j++) &#123; if(k_m[j]==i) &#123; k_c[i]=j; break; &#125; &#125; &#125; if(n%4==0)m=n/4; for(int i=0;i&lt;k;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(j==m-1&amp;&amp;k_m[i]&gt;(n-1)%4) &#123; table[j][i]=&#x27;?&#x27;; p++; &#125; else table[j][i]=x[i*m+j-p]; //cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i*m+j-p&lt;&lt;&quot; &quot;&lt;&lt;table[j][i]&lt;&lt;endl; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;k;j++) &#123; p=k_c[j]; if(table[i][p]==&#x27;?&#x27;)continue; else temp += table[i][p]; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;table[i][p]&lt;&lt;endl; &#125; &#125; return temp;&#125; 2.3 转轮机密码 艾尼格玛，多表替代，密钥：三个轮子的初态","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"《计算机网络》——第三章 数据链路层","slug":"笔记/计算机网络/第三章 数据链路层","date":"2022-03-28T15:40:41.892Z","updated":"2022-03-28T15:48:54.628Z","comments":true,"path":"2022/03/28/笔记/计算机网络/第三章 数据链路层/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/28/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《计算机网络》——第二章 物理层","slug":"笔记/计算机网络/第二章 物理层","date":"2022-03-28T15:40:41.892Z","updated":"2022-04-03T06:16:10.678Z","comments":true,"path":"2022/03/28/笔记/计算机网络/第二章 物理层/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/28/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"通信、难处理 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流（传输媒体本身并不属于物理层的范围） 物理层的作用是尽可能地屏蔽传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到差异，使其只需要考虑如何完成本层协议和服务。 物理层的协议，常称为物理层规程（使用更早的原因） 物理层的主要任务 BIOS/POST 通电自检，确保硬件是否准备好 串行传输和并行传输 数据在计算机内部多采用并行传输方式。但数据在通信线路(传输媒体)上的传输方式一般都是串行传输(经济)，即逐个比特按照时间顺序传输。因此，物理层还要完成传输方式的转换。 PC数字信号(离散，失真小)，电话模拟信号(连续)–&gt;有空查一下 数据通信 数据通信系统模型 术语 -&gt; 数据、信号、码元 通信的目的就是传送消息(message)。话音、文字、图像、视频等都是消息 数据(data)：运送消息的实体 数据是信息的载体，信息是有用的数据 信号：数据的电子的/电磁的表现 模拟信号(用户线)、数字信号(中继线) 物质、能量和信息是构成客观世界的三要素 1.消息、信息、信号的区别 消息的定义：是指包含信息的语言，文字和图像等，可表达客观事物和主观思维活动的状态 信号：是把消息变换成电信号，声信号等适合信道传输的物理量 那什么是信息呢? 1）指事物中包含的内容 2）是事物在运动状态或存在形式上的不确定性的描述（即不确定性越大，信息越多） 信息与消息的关系是什么？ 消息是信息的载体，包含关系 消息与信号的联系是什么？ 信号是把消息转换成电信号等，然后在信道上面传输，所以信号是消息的运载工具 数据和信息之间是相互联系的。数据是反映客观事物属性的记录，是信息的具体表现形式。数据经过加工处理之后，就成为信息；而信息需要经过数字化转变成数据才能存储和传输。 数据=信息+数据冗余 码元(code)：一个时间域(时间段)表示离散数值的基本波型(表示数字信号的基本模型) &lt;-- 数字信号 码元是数据的载体（一个码元可以携带1bit，多个码元也可以携带1bit，1个码元也可以携带多个bit） 数据上存在上限（受物理介质的限制(数据传输速率)、受码元携带数据的限制(通信:码元 &lt;- 调制解调；计算机:数据–&gt;理想：一个码元带更多的数据)） 波的类型：高电平1、低电平0（2类码元) 一共有7个码元（4个低电平，3个高电平） 芯片：负逻辑(高电平0、低电平1)–&gt;减耗(高电平多费电：功耗) 数据是信息的载体，码元是数据的载体 信道的概念 -&gt; 基带调制/带通调制， 信道(channel)：一般用来表示向某一个方向传送信息的媒体，与电路并不等同 ​ （一条通信电路包含：一条发送信道和一条接收信道） 通信双方信息交互的三种基本方式 单向通信/单工通信：一个方向的通信，无反向交互（电视广播） 双向交替通信/双工通信：可双方交互，但不能同时发送/接收 （！注意：“单工电台”指的是双向交替通信） 双向同时通信/全双工通信：双方可同时发送和接收 信源的信号常称为基带信号(基本频带信号，高低电平) --&gt; 计算机输出的代表各种文字图像文件的数据信号 ​ 基带信号包含许多的低频分量和直流分量，而许多信道并不能传输这些分量 --&gt; 对基带信号进行调制 调制分类： 基带调制： 由于是把数字信号转换为另一种形式的数字信号，又叫做编码 仅对基带信号的波形进行变换 --&gt; 与信道特征相适应，信号仍为基带信号 带通调制： 使用载波(carrier) 进行调制，把基带信号的频率范围搬移到较高的频段，并转为模拟信号 --&gt; 更好在模拟信道传输 ​ （频带变宽，使用的频带窄） 有没有相位移动 二元调制法：只有两个状态 多元调制法：正交振幅调制QAM（一个码元携带更多的二进制位） ​ 如图，由于4bit编码共有16种不同的组合，因此这16个点中的每一个点可对应于一种4bit的编码 ​ 若每一个码元可表示的比特数越多，则在接收端进行解调时，要正确识别每一种状态就越困难。 信道的极限容量（上界/上限） 寻找提高数据传输速率的途径 只要从失真的波形中能够识别出来原来的信号，那么失真对通信质量可视为无影响。 非理想信道：码元传输的速率越高，信号传输的距离越远，噪声干扰越大或传输媒体质量越差，在接收端的波形的失真就越严重。 限制码元在信道上的传输速率的因素： 信道能够通过的频率范围 码间串扰：具体的信道所能通过的频率范围总是有限的，而信道中存在许多的高频分量不能通过信道。如果信号中的高频分量在传输中衰减，导致不能区分每个码元之间的所占清晰时间界限。–&gt; 一串码元模糊而无法识别 为了避免码间串扰，码元的传输速率存在上限值。–&gt; 奈氏准则 奈氏准则： ​ 理想低通信道的最高码元传输速率 = 2W（Baud） ​ 理想带通信道的最高码元传输速率 = W（Baud） ​ W是带宽，Baud是单位：波特（一秒传x个码元） 如何判断理想低通信道？ ​ 人的说话的信道（300-3400Hz），其他都是理想带通信道 不能单依靠带宽判断，还要看其高低频 ​ 1MHz 带通 ​ 2kHz : 0.001M或0.003M 要分情况（没太懂……） 线限制了带宽，限制其1秒能跑多少码元 人关心的是信息的传输速率（1秒传了多少比特） 信噪比","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"蓝桥云课","slug":"刷题/蓝桥知识点","date":"2022-03-21T15:53:18.427Z","updated":"2022-05-18T15:31:06.945Z","comments":true,"path":"2022/03/21/刷题/蓝桥知识点/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/21/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"STL 中 link 容器 数据结构基础-链表 实验介绍 我们这门课是算法，这里所讲的数据结构倾向于实战，大家不要拘泥于具体的写法，而重在学习原理，和使用方式，我们所需要的是简洁、实用和快速。我们这节课主要目标学会三种链表的原理与实现，学会灵活地运用，能够不依赖于模板根据题目独立写出各类链表。 我们不是数据结构教程，经典的数据结构采用 C 或 C++ 采用模板类进行编写，但是非常不适合竞赛使用，几行代码硬是能写成十几行，提高了复用性但是浪费了书写时间。所以并不适合竞赛，竞赛追求效率、accept 和简洁。 知识点 单链表实现原理与应用 双向链表实现原理与应用 循环链表实现原理与应用 为什么使用链表 相信大家在这之前已经学过数组，无论是 C++,Java,Python 还是其它语言大都会有数组这一概念，好用吗？很好用，所谓数组其实就是线性表的顺序存储形式的原理，我们来看一下链表的定义并对比一下链式存储与顺序存储的存储方式。 什么是链表 链表是线性表的链式存取的数据结构，是一种链式存取的数据结构，是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：数据域（数据元素的映象）+ 指针域（指示后继元素存储位置），数据域就是存储数据的存储单元，指针域就是连接每个结点的地址数据。 相比于线性表顺序结构，操作复杂。 似乎定义是有些晦涩难懂，我们用两张图来对比一下数组也就是线性表的顺序存储结构和链表在内存中存储 1-9 号元素的形式： 顺序存储 链式存储 思考一下： 线性表的数据存储方式的内存地址是顺序的，链式存储的数据的内存地址的有什么规律呢？ 事实上链式存储的内存地址的是随机分配的，他们每个节点地址之间是没有任何关联的。而且在每个新的节点在产生之前，我们都是不知道他的地址的。 链表初体验 通过上面的介绍，大家可能还是不太能理解为什么要使用链表或者还不懂什么是链表，我们用一个题目来引入。 小王子有一天迷上了排队的游戏，桌子上有标号为 1-10 按顺序摆放的 10 个玩具，现在小王子想将它们按自己的喜好进行摆放。小王子每次从中挑选一个好看的玩具放到所有玩具的最前面。已知他总共挑选了 M 次，每次选取标号为 X 的玩具放到最前面，求摆放完成后的玩具标号。 给出一组输入，M=8 共计排了 8 次，这 8 次的序列为 9，3，2，5，6，8，9，8。 求最终玩具的编号序列。 我们首先梳理一下基本的模拟方法的思路，这个题该怎么去解答： 首先我们要开一个长度为 11 的数组，因为下标要从 1 开始所以 0 — 10 共计 11 个元素。 1a[11]=&#123;0,1,2,3,4,5,6,7,8,9,10&#125; 然后根据题意我们要写一个查找函数： 123456789//伪代码形式int Funciton 查找(X)&#123; range i in(1, 10) //循环从x位置到2号位置 if data[i] == x : //找到X返回 return i end if end range&#125; 我们简单描述一下这个过程: 首先是步进查找比如查找值为 5 元素的下标： 找到元素后返回下标，值为 5。 最后我们找到元素后要进行插入操作。 123456789101112void Function 移动(L)&#123; //移动函数 //拿走了X,X在L位置,所以将L-1向后移动到L,依次向后移动空处最前面的位置 temp = data[L] range i in(L, 2) //循环从L位置到2号位置 data[i] = data[i - 1] //向后移动 end range data[i] = temp&#125; 我们还是以 5 为例，要把 5 移到到首位，肯定不是把 5 放到第一位就行。 讲到这里，大部分同学肯定会写出如下代码： 123456789101112131415161718192021222324252627282930313233//伪代码形式int Funciton 查找(X)&#123; range i in (1,10) //循环从x位置到2号位置 if data[i]==x : //找到X返回 return i end if end range&#125;void Function 移动(L)&#123; //移动函数 //拿走了X,X在L位置,所以将L-1向后移动到L,依次向后移动空处最前面的位置 temp=data[L] range i in (L,2) //循环从L位置到2号位置 data[i]=data[i-1] //向后移动 end range data[i]=temp&#125;void Main()&#123; 输入 M range in (1,M) //循环M次 输入 X L=查找(X) 移动(L) end range&#125; 这样每次调用移动函数即可，M=8 调用 8 次函数，每次传入 X 找到位置后,即可得到正确答案。 如果我们规定每次循环的时间复杂度为 1 的话，这次花费了我们多少时间呢？ X=9 查找 9 循环了 9 次 移动花费了 9 次 此时序列为 9,1,2,3,4,5,6,7,8,10 X=3 查找 3 循环了 4 次 移动花费了 4 次 此时序列为 3,9,1,2,4,5,6,7,8,10 我们看到每次都花费了大量时间去移动。如果我们采用链表去存储呢，会是什么样子呢。 我们来模拟一下过程: 这是初始序列 第一次输入 X=9: 执行查询操作: 执行删除操作 给 9 前面结点的指针赋值为 9 的指针，再将 9 删除。 执行插入操作： 新建一个结点, data 部分为 9 ,将结点插入链表的首部 相比之下后者执行的操作更少，速度更快，那我们给出该题目的一个标准的答案及详细解析。 题目解析 我们学了前面那么多的知识点，我们来动手解答一下小王子的问题了。 首先，我们使用链表的话，要先给出结点的定义，上面讲到链表的形式。 结点定义： 12345struct Node&#123; int data; Node *next;&#125; 第二步，我们要先构成一个这样的链表：head-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 123456789101112131415161718192021222324252627282930Node * head=new Node; //先生成头结点void init() &#123; head-&gt;next = nullptr; //形成空链，由上文已知单链表最后一个结点的指针为空。 for (int i = 10; i &gt;= 1; i--) &#123; Node *temp = new Node; temp-&gt;data = i; temp-&gt;next = head-&gt;next; head-&gt;next = temp; &#125; &#125; //由于我们后边会用到插入函数，其实我们可以写成插入函数的形式 void insert(int x) &#123; Node* temp=new Node; temp-&gt;data=x; temp-&gt;next=head-&gt;next; head-&gt;next=temp; &#125; void init()&#123;//为了美观，我们写个初始化函数 head-&gt;next=nullptr; //无论用什么方式，都不能省略该语句，不然无法正常使用。 for(int i=10;i&gt;=1;i--) insert(i);//从10开始插入 &#125; 第三步，我们要写一个插入函数 12345678void insert(int x)&#123; Node *temp = new Node; //新建一个结点 temp-&gt;data = x; //把数据域赋值为x temp-&gt;next = head-&gt;next; head-&gt;next = temp; //将节点加入到链表中&#125; 第四步我们要写一个删除函数，通过遍历链表删掉想要的数字 123456789101112131415161718void del(int x)&#123; Node *Befor = head; //用于存放当前节点的前驱，因为单链表单向遍历，我们不能从下一个找到上一个 for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; if (T-&gt;data == x) //找到要的那个数了 &#123; Node *temp = T; //先临时保存结点 Befor-&gt;next = T-&gt;next; //将节点从链表上摘除 delete temp; //从内存中删除结点。 return; //删除结束后，结束函数。 &#125; Befor = T; //前驱改变 &#125;&#125; 第五步我们写一个遍历输出函数，形式接近于删除函数 123456789void show(int i)&#123; cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 最后一步我们编写主函数 12345678910111213141516int main()&#123; init(); show(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; 我们带入之前的样例进行测试：N=8 X= 9 3 2 5 6 8 9 8。 完整代码如下： C++写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;Node *head = new Node; //先生成头结点void init()&#123; head-&gt;next = nullptr; //形成空链，由上文已知单链表最后一个结点的指针为空。 for (int i = 10; i &gt;= 1; i--) &#123; Node *temp = new Node; temp-&gt;data = i; temp-&gt;next = head-&gt;next; head-&gt;next = temp; &#125;&#125;void del(int x)&#123; Node *Befor = head; //用于存放当前节点的前驱，因为单链表单向遍历，我们不能从下一个找到上一个 for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; if (T-&gt;data == x) //找到要的那个数了 &#123; Node *temp = T; //先临时保存结点 Befor-&gt;next = T-&gt;next; //将节点从链表上摘除 delete temp; //从内存中删除结点。 return; //删除结束后，结束函数。 &#125; Befor = T; //前驱改变 &#125;&#125;void insert(int x)&#123; Node *temp = new Node; temp-&gt;data = x; temp-&gt;next = head-&gt;next; head-&gt;next = temp;&#125;void show(int i)&#123; cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; //提交代码时删掉这一行 for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; init(); show(0);//提交代码时删掉这一行 int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; Python 写法 Java 写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Node: def __init__(self, value, next=None): self.value = value self.next = nextdef createLink(): root = Node(0) tmp = root for i in range(1, 11 ): tmp.next = Node(i) tmp = tmp.next tmp.next = None return rootdef insert(x, linkedroot): tmp = Node(x) tmp.next = root.next root.next = tmpdef delete(x, root): tmp = tmp1 = root while tmp != None: if tmp.value == x: tmp1.next = tmp.next tmp1 = tmp tmp = tmp.nextdef show(root): tmp = root.next while tmp.next != None: print(tmp.value, end=&quot; &quot;) tmp = tmp.next print(&quot;&quot;)if __name__ == &#x27;__main__&#x27;: n = int(input()) root = createLink() # show(root) for i in range(n): x = int(input()) delete(x, root) insert(x, root) show(root) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Scanner;public class Main &#123; static class Node &#123; int data; Node next; Node(int v) &#123; data = v; &#125; &#125;//成员类，代表节点，类似于C++语言中的结构体 static Node head = new Node(1);//头节点单列出来 static void init() &#123; Node x = head; for (int i = 1; i &lt;= 10; i++) x = (x.next = new Node(i));//建立单向链表 x.next = null; &#125; static void del(int x) &#123; Node Befor = head; //用于存放当前节点的前驱，因为单链表单向遍历，我们不能从下一个找到上一个 for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; if (T.data == x) //找到要的那个数了 &#123; Node temp = T; //先临时保存结点 Befor.next = T.next; //将节点从链表上摘除 return; //删除结束后，结束函数。 &#125; Befor = T; //前驱改变 &#125; &#125; static void insert(int x) &#123; Node temp = new Node(x); temp.next = head.next; head.next = temp; &#125; static void show(int i) &#123; // System.out.println(&quot;这是第&quot; + i + &quot;次操作&quot;);//提交代码时删掉这一行 for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; System.out.print(T.data + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; public static void main(String[] args) &#123; int N; Scanner in = new Scanner(System.in); init(); N = in.nextInt(); // show(0);//提交代码时删掉这一行 for (int i = 0; i &lt; N; i++) &#123; int x = in.nextInt(); del(x); insert(x); show(i); &#125; &#125;&#125; 以上为带有头结点的单链表，相应的还有没有头结点的单链表，有兴趣的同学可以自行查阅资料。在比赛中我们常用 STL 中 link 容器而很少会去定义和使用，这一章节我们主要是学会原理和使用，原理学会之后无论是什么样的链表都是可以设计出来的。 头结点： 如果链表有头节点，则链式结构中的第一个节点称为头结点，其数据域可以存储一些附加信息，如链表长度；其指针域指向链表中的第一个节点。 经过上面对小王子这个题的讲解，相信大家都对这个链表的有点有了一个初步的认识，我们看到链表的使用确实很方便，在我们不需要随机访线性表里面的元素时，使用链表确实要方便很多，无论是时间复杂度还是空间复杂度都十分优秀。下面我们对线性表的两种存储方式的对比。 链表与顺序表优缺点对比 经过上面的讲解，大家应该都已经对线性表存储数据有了一定的了解，线性表是编写程序中的最常见数据结构，对于顺序和链式两种存储结构我们到底该在何时选择哪一种存储方式? 我们对两种存储方式做一个对比。 顺序表 优点: 无需为表示结点间的逻辑关系而增加额外的存储空间（因为逻辑上相邻的元素其存储的物理位置也是相邻的）； 可方便地随机存取表中的任一元素: 由于顺序表每个元素的大小相等，且知道第几个元素就可以通过计算得到任意元素的地址，既可以随机存取任一元素。 缺点: 插入或删除运算不方便： 除表尾的位置外，在表的其它位置上进行插入或删除操作都必须移动大量的结点，其效率较低； 如在 8、9 之 间插入 X 元素，那我们为了保证其顺序性需要把 8 和 9 向后移动一位，再将 X 放到 8 的位置。 这样的存储方式增加了处理器和 IO 资源的消耗代价，这是我们不愿意看到的，至于删除其原理相同，我们不再进行赘述。 难以匹配存储规模： 由于顺序表要求占用连续的存储空间，存储分配只能预先进行静态分配，因此当表长变化较大时，难以确定合适的存储规模。 时间复杂度 查找操作为 O(1)，插入和删除操作为 O(n)。 时间复杂度的计算： 时间复杂度不是一个具体的数字，而是一个量级。 常见的时间复杂度量级如下： 常数阶 O(1) &lt; 对数阶 O(log2n) &lt; 线性阶 O(n) &lt; 线性对数阶 O(n log_{2}n)O(nlo**g2n) &lt; 平方阶 O(n^{2})O(n2) &lt; 方阶 O(n^{3})O(n3) &lt; k 次方阶 O(n^{K})O(n**K) &lt; 指数阶 O(2^{n})O(2n) &lt; 阶乘阶O(n!)O(n!) &lt; O(n^{n})O(n**n) 具体的计算方法其他章节会进行讲述，这里大家简单知道时间复杂度量级的大小即可。 链表 优点: 插入和删除速度快，保留原有的物理顺序，在插入或者删除一个元素的时候，只需要改变指针指向即可； 没有空间限制, 存储元素无上限, 只与内存空间大小有关； 动态分配内存空间，不用事先开辟内存； 使内存的利用率变高。 缺点: 占用额外的空间以存储指针，比较浪费空间，不连续存储，Malloc 函数开辟空间碎片比较多； 查找速度比较慢，因为在查找时，需要循环遍历链表。 时间复杂度: 查找操作为 O(n), 插入和删除操作为 O(1)。 使用循环链表解决约瑟夫环问题 将单链表或者双链表的头尾结点链接起来，就是一个循环链表。不增加额外存储花销，却给不少操作带来了方便从循环表中任一结点出发，都能访问到表中其他结点。 循环链表的组成 特点： 首尾相接的链表。 可以从任一节点出发，访问链表中的所有节点。 判断循环链表中尾结点的特点：q-&gt;next==first 通过观察不难发现，循环链表与单链表的差别就是最后的指针一个为空一个与 First 相等，其他的都没有什么变化，也就是多了一个循环遍历的过程。 约瑟夫环问题 设有 n 个人围坐在圆桌周围，现从某个位置 k(1≤k≤n) 上的人开始报数，报数到 m 的人就站出来。下一个人，即原来的第 m+1 个位置上的人，又从 1 开始报数，再报数到 m 的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这 n 个人的出列顺序。 要求一：采用循环链表解决 要求二：可以使用模拟法，模拟循环链表 要求三：可以不使用循环链表类的定义使用方式 大家可以先思考一下如何实验，在 OJ 或者右侧的环境中动手完成。 具体实验步骤 思路分析 首先要通过循环链表模拟一整个过程，然后再寻找删除位置。 删除位置的计算： 从线性表中起始位置 index 出发开始计数，当计数到 m 时（间隔 m-1 个数据），删除该位置上的元素；同时该位置又是下一次计数的起始位置：index=(index+k-1) 代码编写 C++解法： 第一步：定义循环链表的结点结构体 123456789//头文件与命名空间#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *pNext;&#125;; 第二步：定义主函数直接进行解题： 信息输入，和所续变量的声明 123int n, k, m, i; //n个人从k位置开始报数，数到m出列struct Node *p, *q, *head;cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; 依据题目构造循环链表，可以看出我们直接把插入的函数，拿到了这里来使用。 1234567891011first = (Node *)new Node;p = first;first-&gt;data = 1;for (i = 2; i &lt;= n; i++)&#123; q = new Node; q-&gt;data = i; p-&gt;pNext = q; p = p-&gt;pNext;&#125;p-&gt;pNext = first; 寻找报数的起点 123p = first;for (i = 1; i &lt;= k - 1; i++) p = p-&gt;pNext; 按照顺序依次出链表 123456789101112131415while (p != p-&gt;pNext) //只剩下一个结点的时候停止&#123; for (i = 1; i &lt; m - 1; i++) &#123; p = p-&gt;pNext; &#125; q = p-&gt;pNext; //q为要出队的元素 cout &lt;&lt; q-&gt;data &lt;&lt; endl; p-&gt;pNext = q-&gt;pNext; delete q; p = p-&gt;pNext;&#125;cout &lt;&lt; p-&gt;data &lt;&lt; endl; //输出最后一个元素&#125; 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//头文件与命名空间#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *pNext;&#125;;int main()&#123; int n, k, m, i; //n个人从k位置开始报数，数到m出列 Node *p, *q, *head; cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; Node * first = (Node *)new Node; p = first; first-&gt;data = 1; for (i = 2; i &lt;= n; i++) &#123; q = new Node; q-&gt;data = i; p-&gt;pNext = q; p = p-&gt;pNext; &#125; p-&gt;pNext = first; p = first; for (i = 1; i &lt;= k - 1; i++) // p = p-&gt;pNext; while (p != p-&gt;pNext) //只剩下一个结点的时候停止 &#123; for (i = 1; i &lt; m - 1; i++) &#123; p = p-&gt;pNext; &#125; q = p-&gt;pNext; //q为要出队的元素 cout &lt;&lt; q-&gt;data &lt;&lt; endl; p-&gt;pNext = q-&gt;pNext; delete q; p = p-&gt;pNext; &#125; cout &lt;&lt; p-&gt;data &lt;&lt; endl; //输出最后一个元素 return 0;&#125; Java 解法 Python 解法 双向链表再求解小王子问题 单链表的主要不足之处是 link 字段仅仅指向后继结点，不能有效地找到前驱。双链表弥补了上述不足之处，增加一个指向前驱的指针 。 由于在双向链表中既有前向链又有后向链，寻找任一个结点的直接前驱结点与直接后继结点变得非常方便。设指针 p 指向双链表中某一结点，则有下式成立： 1p-&gt; llink-&gt;rlink = p = p-&gt;rlink-&gt;llink 双向链表的实现 还记得我们在小王子那一题目中所定义前驱变量吗? 因为单链表只能单向遍历所以我们要定义临时变量，如果我们改成双向链表这个题目这里就可以进行优化。 首先，我们使用链表的话，要先给出结点的定义，上面讲到链表的形式。 123456struct Node&#123; int data; Node *next; Node *before;&#125; 第二步，我们要先构成一个这样的链表：head &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5 &lt;-&gt; 6 &lt;-&gt; 7 &lt;-&gt; 8 &lt;-&gt; 9 &lt;-&gt; 10 1234567891011121314151617181920void insert(int x)&#123; Node *temp = new Node; temp-&gt;data = x; temp-&gt;next = head-&gt;next; head-&gt;next = temp; temp-&gt;before = head; if (temp-&gt;next) temp-&gt;next-&gt;before = temp;&#125;Node *head = new Node; //先生成头结点void init()&#123; //为了美观，我们写个初始化函数 head-&gt;next = nullptr; //无论用什么方式，都不能省略该语句，不然无法正常使用。 head-&gt;before = nullptr; for (int i = 10; i &gt;= 1; i--) insert(i); //从10开始插入&#125; 第三步我们要写一个删除函数，通过遍历链表删掉想要的数字 12345678910111213void del(int x)&#123; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; if (T-&gt;data == x) &#123; //找到要的那个数了 T-&gt;before-&gt;next = T-&gt;next; //双向链表，就是如此简单方便。 T-&gt;next-&gt;before=T-&gt;before; return; //删除结束后，结束函数。 &#125; &#125;&#125; 第四步我们写一个遍历输出函数，形式接近于删除函数 123456789void show(int i)&#123; cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; 最后一步我们编写主函数 12345678910111213141516int main()&#123; init(); show(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; 我们带入之前的样例进行测试：N=8 X= 9 3 2 5 6 8 9 8。 我们可以看到这里的删除非常简单，这么写的话大大简化删除了过程，所以在不同题目下灵活地选取链表能够使得解题变得简单。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next; Node *before;&#125;;Node* head = new Node; //先生成头结点void insert(int x)&#123; Node* temp=new Node; temp-&gt;data=x; temp-&gt;next=head-&gt;next; head-&gt;next=temp; temp-&gt;before=head; if(temp-&gt;next) temp-&gt;next-&gt;before=temp;&#125;void init() //为了美观，我们写个初始化函数&#123; head-&gt;next=nullptr; //无论用什么方式，都不能省略该语句，不然无法正常使用。 head-&gt;before=nullptr; for(int i=10; i&gt;=1; i--) insert(i); //从10开始插入&#125;void del(int x)&#123; for(Node*T=head-&gt;next; T!=nullptr; T=T-&gt;next) //链表的遍历常用写法 &#123; if(T-&gt;data==x) //找到要的那个数了 &#123; T-&gt;before-&gt;next=T-&gt;next;//双向链表，就是如此简单方便。 T-&gt;next-&gt;before=T-&gt;before; return; //删除结束后，结束函数。 &#125; &#125;&#125;void show(int i)&#123; // cout &lt;&lt; &quot;这是第&quot; &lt;&lt; i &lt;&lt; &quot;次操作&quot;; for (Node *T = head-&gt;next; T != nullptr; T = T-&gt;next) //链表的遍历常用写法 &#123; cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; init(); // show(0); int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) &#123; int x; cin &gt;&gt; x; del(x); insert(x); show(i); &#125;&#125; Java 解法： Python 解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485iimport java.util.Scanner;public class Main&#123; static class Node &#123; int data; Node next; Node before; Node(int v) &#123; data = v; &#125; &#125; //成员类，代表节点，类似于C++语言中的结构体 static Node head = new Node(1); //头节点单列出来 static void init() &#123; Node x = head; for (int i = 1; i&lt;= 10; i++) &#123; x.next = new Node(i); //建立双向链表 x.next.before = x; x = x.next; &#125; x.next = null; &#125; static void del(int x) &#123; for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; if (T.data == x) //找到要的那个数了 &#123; T.before.next = T.next; //将节点从链表上摘除 T.next.before=T.before; return; //删除结束后，结束函数。 &#125; &#125; &#125; static void insert(int x) &#123; Node temp = new Node(x); temp.next = head.next; temp.next.before = temp; head.next = temp; &#125; static void show(int i) &#123; // System.out.println(&quot;这是第&quot; + i + &quot;次操作&quot;); for (Node T = head.next; T != null; T = T.next) //链表的遍历常用写法 &#123; System.out.print(T.data + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; public static void main(String[] args) &#123; int N; //n个人从k位置开始报数，数到m出列 Scanner in = new Scanner(System.in); init(); N = in.nextInt(); // show(0); for (int i = 0; i &lt; N; i++) &#123; int x = in.nextInt(); del(x); insert(x); show(i); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Node: def __init__(self, value, next=None): self.value = value self.next = nextdef createLink(): root = Node(0) tmp = root for i in range(10): tmp.next = Node(i+1) tmp = tmp.next tmp.next = None return rootdef insert(x, linkedroot): tmp = Node(x) tmp.next = root.next root.next = tmpdef delete(x, root): tmp = tmp1 = root while tmp != None: if tmp.value == x: tmp1.next = tmp.next tmp1 = tmp tmp = tmp.nextdef show(root): tmp = root.next while tmp != None: print(tmp.value, end=&quot; &quot;) tmp = tmp.next print(&quot;&quot;)if __name__ == &#x27;__main__&#x27;: n = int(input()) root = createLink() # show(root) for i in range(n): x = int(input()) delete(x, root) insert(x, root) show(root) 实验总结 关于链表的定义方式，在各种教科书上和网站都有着各个不同版本的定义方式，我们应该学习的实现原理，具体实现都是大同小异，通常在算法中我们只定义结点，在 Main 函数中直接使用结点组成新的链表而不去写链表的结构体，这样可以减少代码量的使用，提高编程的速度，在程序竞赛中的使用的比较多，但是相应的也降低了代码的复用性，不适合用于项目开发中，还需大家理解差异。不要拘泥于写法，注重的是应用和原理，我们学习这门课的目的是为了 accept 题目，而不是写一堆无用的代码浪费时间。 本次实验，我们学习了三种最常见的链表的原理与使用方式，诚然链表的种类是千变万化的，像是循环链表与双向链表的结合形成的双向循环链表，存储图的十字链表等，我们学好这基础的三种链表，以不变应万变才是正确的面对方式。作者在早期学习链表的时侯只会单链表，在比赛的时候临场写出了双向链表，成功 AC 题目，其实链表的类的定义方式也是我在上文写的是最复杂的一种方式，将每种功能封装，诚然这样的代码复用性会很高，当作模板可以，但是在赛场上的时候，我们没有那么多时间去写代码，都是用什么功能再去写什么功能直接在主函数中完成，追求简洁高效。 刷题1 「约瑟夫环」 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;struct Node&#123; int num; Node *next;&#125;;int main()&#123; int n,k,m; cin&gt;&gt;n&gt;&gt;k&gt;&gt;m; Node *first,*tailer=new Node,*temp; Node *p1,*p2; first = tailer; for(int i=1;i&lt;=n;i++) &#123; temp = new Node; temp-&gt;num = i; tailer-&gt;next = temp; tailer = temp; &#125; tailer-&gt;next = first-&gt;next; first = first-&gt;next; while(--k) &#123; first = first-&gt;next; tailer = tailer-&gt;next; &#125; p1 = tailer; p2 = first; k = 1; while(p1!=p2) &#123; if(k%m==0) &#123; temp=p2; p1-&gt;next = temp-&gt;next; cout&lt;&lt;temp-&gt;num&lt;&lt;endl; p2 = p2-&gt;next; delete temp; k++; continue; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; k++; &#125; cout&lt;&lt;p1-&gt;num&lt;&lt;endl; return 0;&#125; 「小王子双链表」 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;struct Node&#123; int num; Node *pfront; Node *pback;&#125;;int main()&#123; int M,X; cin&gt;&gt;M; Node *first,*tailer=new Node,*temp,*p,*p1; first = tailer; for(int i=1;i&lt;=10;i++) &#123; temp=new Node; temp-&gt;num = i; temp-&gt;pfront=tailer; tailer-&gt;pback=temp; tailer=temp; &#125; tailer-&gt;pback=NULL; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;X; p = first-&gt;pback; while(p!=NULL) &#123; if(p-&gt;num==X) &#123; temp=p; temp-&gt;pfront-&gt;pback=temp-&gt;pback; temp-&gt;pback-&gt;pfront=temp-&gt;pfront; temp-&gt;pback = first-&gt;pback; first-&gt;pback-&gt;pfront = temp; first-&gt;pback = temp; temp-&gt;pfront = first; break; &#125; p=p-&gt;pback; &#125; p = first-&gt;pback; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;num&lt;&lt;&quot; &quot;; p = p-&gt;pback; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; STL 中的 queue 容器 数据结构基础-队列 实验介绍 我们这门课主要是深入算法，这里所讲的数据结构倾向于实战，大家不要拘泥于具体的写法，而重在学习原理和使用方式，我们所需要的是简洁、实用和快速。这节课主要目标学会两种队列的原理与实现，学会灵活地运用，能够不依赖于模板，可以直接据题目独立写出各类队列。 经典的数据结构通常采用 C 或 C++ 模板类进行编写，非常不适合竞赛使用，代码复用性高但是浪费了书写时间。竞赛追求效率、AC 和简洁。本节课程，我们主要讲解基本数据结构的队列这一部分，虽然这一部分相对简单但非常重要。 知识点 普通队列实现原理与应用 循环队列实现原理与应用 为什么使用队列 我们之前已经学过数组和链表，相信对数据的存储方式也有了新的认知，但是数据的组织方式远不止一种，我们今天要讲一种数据组织方式，常用于特殊题目的模拟中。在后续相对高级的算法中，队列将是一种不可或缺的工具，单独使用次数可能不多，但是在其他算法的实现中，不借助队列的逻辑可能会导致一些算法的实现变得复杂。 什么是队列 如果说链表和顺序表是对数据的存取位置的组织方式，那么队列就是一种对于存取方式限制的组织方式。换一种方式描述的话就是，队列既可以采用链表来表示，也可以采用数组（线性表）来表示，我们限制的是对于存放数据的存取方式。 似乎定义是有些晦涩难懂，我们来用图来介绍一下队列，什么是队列。队列如其名，就是按照队列的方式来存取，什么是队列呢，我们举一张打饭的图作为例子。 很显然我们对数据的组织也是以这种方式进行的。当然数据存储方式还是有两种，一种是顺序存储，一种是链式存储。 顺序存储 链式存储 思考一下： 为什么链式存储的方式的队列首尾指针与链表头尾刚好相反,是什么原因呢？ 其实我们知道链表的表头是用来插入数据的，表尾处的数据才是最先插入的，先入先出原则，所以表尾出的数据最先出列，也就是队列的头啦！听到这里，可能有人迷糊了，什么头什么尾的？链表是数据存储的组织方式，他只是决定了数据在内存中怎么存储，而队列是说我们是按照什么顺序存储。可以理解为一群人排队，队列告诉他们先来的先吃饭，后来的得排队，而链表或顺序表是说，你可以站着排队蹲着排队等等。 我们再复习一下单链表，上一节中我们已经学习过这张图： 我们这节课不讲链式存储的队列，只用掌握顺序存储的队列，后边的课程中会讲解 C++ 的 STL、Java 的实列和 Python 的 Queue 包，大家到时候就不用再自己写这些数据结构了，这节课我们主要理解原理即可。 队列初体验 通过上面的介绍，大家已经基本了解了队列的原理，下面我们用一个题目来体验如何使用“队列”。 银行排队问题，CLZ 银行只有两个接待窗口，VIP 窗口和普通窗口，VIP 用户进入 VIP 用户窗口，剩下的进入普通窗口排队。 现在有以下输入： 123456789101112131415161718192021222324252627282930第一行 M 次操作（M&lt;1000）第二行 到 第M+1行 输入操作格式： IN name V OUT V IN name2 N OUT N 即 第一个字符串为操作 是IN进入排队和OUT 出队 IN 排队 跟着两个字符串为姓名和权限V或N OUT 为出队即完成操作，V和N代表那个窗口完成了操作输出：M次操作后V队列和N队列中姓名，先输出V队列后输出N队列。样例：输入：5IN xiaoming NIN Adel VIN laozhao NOUT NIN CLZ V输出：AdelCLZlaozhao 我们先分析一下这道题目的思路： 第一步，创建两个队列，以及两个队列的首尾指针 1234567V队列V队列首指针V队列尾指针N队列N队列首指针N队列尾指针 第二步，我们要写入队函数： 按照队列的定义使用尾指针模拟即可 还要设置 Type 位来表示是哪一个队列 12345in(Name ,type)&#123; Type为V,那么Name进入V队列； Type为N,那么Name进入N队列；&#125; 第三步，我们要写出队函数： 按照队列的定义使用头指针模拟即可 仍需设置 Type 位来表示是哪一个队列 12345out(type)&#123; Type为V,那么V队列出队，如果队列为空则不能出队； Type为N,那么N队列出队，如果队列为空则不能出队；&#125; 第四步，写出获取队头元素的代码，队列我们只关心谁排在第一个 按照队列的定义使用头指针模拟即可 仍需设置 Type 位来表示是哪一个队列 12345getHead(type)&#123; Type为V,那么取V队列首元素； Type为N,那么取N队列首元素；&#125; 第五步：主函数代码 1234567891011121314151617输入M循环M次:// 输入OP OP为IN，则输入name和Type OP为Out，则输入Type 根据执行OP执行in或out操作若队列V不为空，执行以下操作： 输出队首元素，队首出队 直到为空为止若队列N不为空，执行以下操作： 输出队首元素，队首出队 直到为空为止 给大家演示一下样例，大家是不是觉得非常简单。 队列 相信大家已经都学会了，开始偷笑这节课比上节课简单多了，那现在我们正式开始讲解相关的定义和知识了。 队列的逻辑结构 队列：只允许在一端进行插入操作，而另一端进行删除操作的线性表。 空队列：不含任何数据元素的队列。 允许插入（也称入队、进队）的一端称为队尾，允许删除（也称出队）的一端称为队头。 队列的操作特性：先进先出(FIFO)，后入后出(LILO)。 时间复杂度 getHead() 查找操作时间复杂度为 O(1) in() 入队操作时间复杂度为 O(1) out() 出队操作时间复杂度为 O(1) 题目解析 分析完了基本思路，也了解了相关的知识，下面我们尝试动手解决一下 CLZ 银行的问题，如果已经提前写完代码了，大家可以跟着下面的解题步骤，对一下答案。 第一步 首先我们要先建存放队列数据结构，我们这里采用顺序表，因为主要存放的数据是名字，也就是常说的字符串，我们可以按照如下方式，进行构建： 1234567String Vqueue[1005]; //V队列int Vhead=0; //首指针int Vtail=0; //尾指针String Nqueue[1005]; //N队列int Nhead=0; //首指针int Ntail=0; //尾指针 你会发现，这和数组很像。对，我们确实采用线性表进行存放的，看起来很简单，但是原理是比较复杂的。 第二步 我们要写入队函数： 按照队列的定义使用尾指针模拟即可； 还需要设置 Type 位来表示是哪一个队列。 123456789101112void in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; Vqueue[Vtail]=name; Vtail++; &#125; else &#123; Nqueue[Ntail]=name; Ntail++; &#125;&#125; 第三步 我们要写出队函数： 按照队列的定义使用头指针模拟即可； 仍需设置 Type 位来表示是哪一个队列 123456789101112131415161718192021222324bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if(Vhead==Vtail) &#123; //队伍没有人不能在出队了。 return false ; &#125; else&#123; Vhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125; else &#123; if(Nhead==Ntail) &#123; //队伍没有人不能在出队了。 return false; &#125; else&#123; Nhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125;&#125; 第四步 写出获取队头元素的代码，队列我们只需要关心谁排在第一个： 按照队列的定义使用头指针模拟即可； 仍需设置 Type 位来表示是哪一个队列。 12345678910string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; return Vqueue[head]; &#125; else &#123; return Nqueue[head]; &#125;&#125; 第五步 主函数代码： 123456789101112131415161718192021222324252627282930313233int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; in(name,type); &#125; else &#123; cin&gt;&gt;type; out(type); &#125; &#125; string s=getHead(&quot;V&quot;); while(out(&quot;V&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;V&quot;); &#125; string s=getHead(&quot;N&quot;); while(out(&quot;N&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;N&quot;); &#125;&#125; 完整代码 下面我们将会给出本题三种语言实现的完整代码。 C++ 写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;using namespace std;string Vqueue[1005]; //V队列int Vhead=0; //首指针int Vtail=0; //尾指针string Nqueue[1005]; //N队列int Nhead=0; //首指针int Ntail=0; //尾指针void in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; Vqueue[Vtail]=name; Vtail++; &#125; else &#123; Nqueue[Ntail]=name; Ntail++; &#125;&#125;bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if(Vhead==Vtail) &#123; //队伍没有人不能在出队了。 return false ; &#125; else&#123; Vhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125; else &#123; if(Nhead==Ntail) &#123; //队伍没有人不能在出队了。 return false; &#125; else&#123; Nhead++;//head前的数据都是无效数据，无需删除，逻辑明确即可。 return true; &#125; &#125;&#125;string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; return Vqueue[Vhead]; &#125; else &#123; return Nqueue[Nhead]; &#125;&#125;int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; in(name,type); &#125; else &#123; cin&gt;&gt;type; out(type); &#125; &#125; string s=getHead(&quot;V&quot;); while(out(&quot;V&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;V&quot;); &#125; s=getHead(&quot;N&quot;); while(out(&quot;N&quot;)) &#123; cout&lt;&lt;s&lt;&lt;endl; s=getHead(&quot;N&quot;); &#125;&#125; 运行结果如下图所示： Python 写法Vqueue = [] Vhead = 0 Vtail = 0 Nqueue = [] Nhead = 0 Ntail = 0 def inque(name, type): global Vhead, Vtail, Nhead, Ntail,Vqueue ,Nqueue if (type == ‘V’): Vqueue.append(name) Vtail += 1 else: Nqueue.append(name) Ntail += 1 # print(Vqueue) def getHead(type): global Vhead, Vtail, Nhead, Ntail,Vqueue ,Nqueue if (type == ‘V’): # print(Vhead) return Vqueue[Vhead] else: # print(Nhead) return Nqueue[Nhead] def outque(type): global Vhead, Vtail, Nhead, Ntail,Vqueue ,Nqueue if (type == ‘V’): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vhead == Vtail): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: s = getHead(&lt;span class=&quot;hljs-built_in&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;type&lt;/span&gt;) Vhead += &lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; s else: &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Nhead == Ntail): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: s= getHead(&lt;span class=&quot;hljs-built_in&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;type&lt;/span&gt;) Nhead += &lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; s if name == ‘main’: M = 0 M = int(input()) while M &gt; 0: M -= 1 op = input().split() &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(op[0])&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;'IN'&lt;/span&gt;: inque(op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;], op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;2&lt;/span&gt;]) &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print('in')&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: outque(op[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;]) &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print('out')&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(&quot;VVVVV&quot;,Vqueue)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(&quot;NNNN&quot;,Nqueue)&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;# print(M)&lt;/span&gt; s = outque(‘V’) while s!=None: print(s) s = outque(‘V’) s = outque(‘N’) while s != None: print(s) s = outque(‘N’) 运行结果如下图所示： Java 写法import java.util.Scanner; public class Main &#123; static String Vqueue[] = new String[1000]; // V队列 static int Vhead = 0; // 首指针 static int Vtail = 0; // 尾指针 static String Nqueue[] = new String[1000]; // N队列 static int Nhead = 0; // 首指针 static int Ntail = 0; // 尾指针 static void in(String name, String type) &#123; if (type.contains( “V”)) &#123; Vqueue[Vtail] = name; Vtail++; &#125; else &#123; Nqueue[Ntail] = name; Ntail++; &#125; &#125; static boolean out(String type) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (type.contains( &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vhead == Vtail) &#123; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// 队伍没有人不能在出队了。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Vhead++;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// head前的数据都是无效数据，无需删除，逻辑明确即可。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Nhead == Ntail) &#123; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// 队伍没有人不能在出队了。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Nhead++;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// head前的数据都是无效数据，无需删除，逻辑明确即可。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; } static String getHead(String type) { &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (type.contains( &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Vqueue[Vhead]; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Nqueue[Nhead]; &#125; } public static void main(String[] args) { int M; Scanner in=new Scanner(System.in); M=in.nextInt(); while(M&gt;0) // { M–; String op,name,type; op=in.next(); // System.out.println(“op”+op); if(op.contains(“IN”)) { name=in.next(); type=in.next(); in(name,type); // System.out.println(“name:”+name+“type:”+type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Vqueue);&lt;/span&gt; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; type=in.next(); out(type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(&quot;type&quot;+type);&lt;/span&gt; &#125; &#125; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Nhead);&lt;/span&gt; String s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &#125; s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &#125; } } 运行结果如下图所示： 以上是带有顺序表结构的队列，相应的还有链表所对应的序列，有兴趣的同学可以自行查阅资料。在比赛时我们常用 STL 中的 queue 容器，很少会去自己单独定义和使用队列。 这一节我们主要是学习原理和如何使用，在掌握原理之后，其实无论是什么样的队列都是可以自己设计出来的，同学们也可以自己尝试使用上一章链表的知识设计一个队列并完成上面的题目。 使用循环队列解决 CLZ 银行的问题 我们上面讲解了队列的定义及使用，会发现一个很大的问题，就是“随着不断地入队出队，我们的队列的容量会不断降低”，如下图所示： 可以看到，队头和队尾是单调向后移动的，因为之前我们的容量足够大所以不需要判定是否队列满，但是当所需入队的数据很大时，我们空间一定时，那么普通队列对空间的低效率利用就显得很蹩脚，所以提出了循环队列的方式。（链式队列就没有这个缺点，所以后续课程中我们讲的容器或者类都采用链式队列的方式实现。 下面我们用一张动图来展示普通队列在不断出队入队时，空间利用效率低这一缺点： 可以看到经过出队后，图中打叉位置的元素已经访问不到，存储单元也浪费掉了，为了很好的解决这个问题，将会使用循环队列。 循环队列的组成 逻辑上是首尾相连的数组，可是在数组中其实不存在这样的数组，所以在物理实现上是不存在的，那么我们需要怎么做呢？ 其实对于不存在物理上实现的循环结构，我们可以用软件方法实现（采用求模方式）: tail=（tail＋1）% MAXSIZE head=(head+1) % MAZSIZE 出现了几个关于循环队列所必须解决的问题： 如何判断循环队列队为空？ 队空：head == tail 跟之前一样。 如何判断循环队列队为满 队满：(tail+1) mod QueueSize==head 如何获得队列中的元素数量 1length=(tail-head+QueueSize)%Queuesize 由于顺序存储队列必须预先确定一个固定的长度，所以存在存储元素个数的限制和空间浪费的问题。 现在让我们尝试使用循环队列完成上面 CLZ 银行 的题目。 思路分析 思路跟之前的解法一样，假如现在队列中最多同时存在 10000 个元素，需要我们采用循环队列进行解答。 先要说明的是，我们在 Python 中的是是采用 List 实现的，所以它的空间可以近似的看作无限的。那么 Python 的代码中只需要加一个删除即可达最大利用率，我们利用 C++ 和 Java 完成题目时，采用循环队列去解决，Python 采用优化写法。 第一步，我们先编写队列定义的代码 123456789int QueueSize=10005;string Vqueue[QueueSize];int Vhead;int Vtail;string Nqueue[QueueSize];int Nhead;int Ntail; 第二步，进行编写入队代码 我们先写一个普通循环队列的入队代码。如下所示： 123456789101112131415string queue[QueueSize];int head;int tail;bool in(string s)&#123; if ((tail+1) % QueueSize ==head) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; tail=(tail+1) % QueueSize; queue[tail]=s; return true; //入队成功，返回成功； &#125;&#125; 然后我们结合题目改写我们刚刚写的入队代码，如下所示： 12345678910111213141516171819202122bool in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; if ((Vtail+1) % QueueSize ==Vhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Vtail=(Vtail+1) % QueueSize; Vqueue[Vtail]=name; return true; &#125; &#125; else &#123; if ((Ntail+1) % QueueSize ==Nhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Ntail=(Ntail+1) % QueueSize; Nqueue[Ntail]=name; return true; &#125; &#125;&#125; 第三步，进行出队函数的编写 同样，我们还是先写普通循环队列的代码: 123456789bool out()&#123; if (tail==head) return false; //空队列不能出队列了 else &#123; head=(head+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; 然后结合题目，改写上面的代码: 1234567891011121314151617181920212223242526bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return false; //空队列不能出队列了 else &#123; Vhead=(Vhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125; else &#123; if (Ntail==Nhead) return false; //空队列不能出队列了 else &#123; Nhead=(Nhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125;&#125; 第四步，编写获取队头元素的代码 照例，我们还是先写普通循环队列的代码: 1234567string getHead()&#123; if (tail==head) return &quot;&quot;;//空队列返回空 else &#123; return queue[head]; &#125;&#125; 然后结合题目改写代码: 1234567891011121314151617string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return &quot;&quot;;//空队列返回空 else &#123; return Vqueue[Vhead]; &#125; &#125; else &#123; if (Ntail==Nhead) return &quot;&quot;;//空队列返回空 else &#123; return Nqueue[Nhead]; &#125; &#125;&#125; 好了，基本的代码我们已经完成了，大家试试先不看后面的完整代码答案，尝试自己动手把写好的代码组织起来。 完整代码编写 C++解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;using namespace std;const int QueueSize=10005;string Vqueue[QueueSize];int Vhead;int Vtail;string Nqueue[QueueSize];int Nhead;int Ntail;bool in(string name,string type)&#123; if(type==&quot;V&quot;)&#123; if ((Vtail+1) % QueueSize ==Vhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Vtail=(Vtail+1) % QueueSize; Vqueue[Vtail]=name; return true; &#125; &#125; else &#123; if ((Ntail+1) % QueueSize ==Nhead) return false; //队列以达到容量上限满了，所以不能再插入了返回错误； else&#123; Ntail=(Ntail+1) % QueueSize; Nqueue[Ntail]=name; return true; &#125; &#125;&#125;bool out(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return false; //空队列不能出队列了 else &#123; Vhead=(Vhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125; else &#123; if (Ntail==Nhead) return false; //空队列不能出队列了 else &#123; Nhead=(Nhead+1) % QueueSize; //不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。 return true; &#125; &#125;&#125;string getHead(string type)&#123; if(type==&quot;V&quot;)&#123; if (Vtail==Vhead) return &quot;&quot;;//空队列返回空 else &#123; return Vqueue[Vhead+1]; &#125; &#125; else &#123; if (Ntail==Nhead) return &quot;&quot;;//空队列返回空 else &#123; return Nqueue[Nhead+1]; &#125; &#125;&#125;int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; in(name,type); &#125; else &#123; cin&gt;&gt;type; out(type) ; &#125; &#125; while(getHead(&quot;V&quot;)!=&quot;&quot;) &#123; cout&lt;&lt;getHead(&quot;V&quot;)&lt;&lt;endl;; out(&quot;V&quot;); &#125; while(getHead(&quot;N&quot;)!=&quot;&quot;) &#123; cout&lt;&lt;getHead(&quot;N&quot;)&lt;&lt;endl; out(&quot;N&quot;); &#125;&#125; Java 解法import java.util.Scanner; public class Main &#123; static int QueueSize=10005; static String Vqueue[] = new String[QueueSize]; // V队列 static int Vhead = 0; // 首指针 static int Vtail = 0; // 尾指针 static String Nqueue[] = new String[QueueSize]; // N队列 static int Nhead = 0; // 首指针 static int Ntail = 0; // 尾指针 static boolean in(String name, String type) &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(type.contains(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;))&#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; ((Vtail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize ==Vhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//队列以达到容量上限满了，所以不能再插入了返回错误；&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;&#123; Vtail=(Vtail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; Vqueue[Vtail]=name; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; ((Ntail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize ==Nhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//队列以达到容量上限满了，所以不能再插入了返回错误；&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;&#123; Ntail=(Ntail+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; Nqueue[Ntail]=name; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; } static boolean out(String type) { &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(type.contains(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;))&#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vtail==Vhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列不能出队列了&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Vhead=(Vhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Ntail==Nhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列不能出队列了&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; Nhead=(Nhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;) % QueueSize; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//不是空队列，但是因为是循环的，如果到了数组末尾也要调整到前面去。&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;true&lt;/span&gt;; &#125; &#125; } static String getHead(String type) { &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(type.contains(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;))&#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Vtail==Vhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列返回空&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Vqueue[Vhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;]; &#125; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt; (Ntail==Nhead) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;//空队列返回空&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; Nqueue[Nhead+&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;1&lt;/span&gt;]; &#125; &#125; } public static void main(String[] args) { int M; Scanner in=new Scanner(System.in); M=in.nextInt(); while(M&gt;0) // { M–; String op,name,type; op=in.next(); // System.out.println(“op”+op); if(op.contains(“IN”)) { name=in.next(); type=in.next(); in(name,type); // System.out.println(“name:”+name+“type:”+type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Vqueue);&lt;/span&gt; &#125; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt; &#123; type=in.next(); out(type); &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(&quot;type&quot;+type);&lt;/span&gt; &#125; &#125; &lt;span class=&quot;hljs-comment&quot; style=&quot;box-sizing: border-box; color: rgb(117, 113, 94);&quot;&gt;// System.out.println(Nhead);&lt;/span&gt; String s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;V&quot;&lt;/span&gt;); &#125; s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;while&lt;/span&gt;(out(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;)) &#123; System.out.println(s); s=getHead(&lt;span class=&quot;hljs-string&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;&quot;N&quot;&lt;/span&gt;); &#125; } } Python 解法Python 的是在原来基础上进行优化：Vqueue = [] Nqueue = [] def inque(name, type): global Vqueue ,Nqueue if (type == ‘V’): Vqueue.append(name) else: Nqueue.append(name) def outque(type): global Vqueue ,Nqueue if (type == ‘V’): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot; style=&quot;box-sizing: border-box; color: rgb(230, 219, 116);&quot;&gt;len&lt;/span&gt;(Vqueue)==&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;): &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;else&lt;/span&gt;: s=Vqueue[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;] Vqueue.remove(Vqueue[&lt;span class=&quot;hljs-number&quot; style=&quot;box-sizing: border-box; color: rgb(174, 129, 255);&quot;&gt;0&lt;/span&gt;]) &lt;span class=&quot;hljs-keyword&quot; style=&quot;box-sizing: border-box; color: rgb(249, 38, 114);&quot;&gt;return&lt;/span&gt; s else: if (len(Nqueue)==0): return None else: s = Nqueue[0] Nqueue.remove(Nqueue[0]) return s if name == ‘main’: M = 0 M = int(input()) while M &gt; 0: M -= 1 op = input().split() # print(op[0]) if op[0] == ‘IN’: inque(op[1], op[2]) # print(‘in’) else: outque(op[1]) # print(‘out’) # print(“VVVVV”,Vqueue) # print(“NNNN”,Nqueue) # print(M) s = outque(‘V’) while s!=None: print(s) s = outque(‘V’) s = outque(‘N’) while s != None: print(s) s = outque(‘N’) 关于队列的定义方式，跟链表一样在各种教科书上和网站都有着各个不同版本的定义方式，具体实现都是大同小异。本次课程，我们主要对标大赛，注意把握其中的实现原理，追求更简单高效的解答问题方式。 实验总结 本次实验，我们学习了普通队列和循环队列两种队列的实现方式，了解了队列的原理与基本的实现方式。随着我们课程的深入，我们只需要掌握原理即可，这些工具和数据结构，我们都不会再自己定义使用，而是直接使用各类编程语言已经写好的库模板。 另外，大家从我们上面写过的代码可以看出，其中设置了很多输出，用于调试代码，满是代码调试的痕迹。其实每个人写代码都不是一蹴而就的，在后续的学习中，希望大家在觉得复杂困难的部分，要想办法解决，不要因为困难就放弃。 刷题2 「CLZ 的银行普通队列」 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;string V[1010];string N[1010];int main()&#123; int M; string behave,name,id; int vfirst=0,vtailer=0,nfirst=0,ntailer=0; cin&gt;&gt;M; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;behave; if(behave==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;id; if(id==&quot;V&quot;) &#123; V[vtailer++]=name; &#125; else &#123; N[ntailer++]=name; &#125; //cout&lt;&lt;&quot;IN&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; else &#123; cin&gt;&gt;id; if(id==&quot;V&quot;) &#123; vfirst++; &#125; else &#123; nfirst++; &#125; //cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; &#125; while(vfirst!=vtailer) &#123; cout&lt;&lt;V[vfirst++]&lt;&lt;endl; &#125; while(nfirst!=ntailer) &#123; cout&lt;&lt;N[nfirst++]&lt;&lt;endl; &#125; return 0;&#125; 「CLZ 的银行循环队列」 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;using namespace std;#define maxsize 1010string V[maxsize];string N[maxsize];int main()&#123; int M; string behave,name,id; int vfirst=0,vtailer=0,nfirst=0,ntailer=0,n; cin&gt;&gt;M; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;behave; if(behave==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;id; if(id==&quot;V&quot;) &#123; n = (vtailer+1)%maxsize; if(n!=vfirst) &#123; V[vtailer]=name; vtailer=(vtailer+1)%maxsize; &#125; else cout&lt;&lt;&quot;队列已满&quot;&lt;&lt;endl; &#125; else &#123; n = (ntailer+1)%maxsize; if(n!=nfirst) &#123; N[ntailer]=name; ntailer=(ntailer+1)%maxsize; &#125; else cout&lt;&lt;&quot;队列已满，不能输入&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;&quot;IN&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; else &#123; cin&gt;&gt;id; if(id==&quot;V&quot;) &#123; if(vfirst!=vtailer) vfirst=(vfirst+1)%maxsize; else cout&lt;&lt;&quot;队列为空，不能输出&quot;&lt;&lt;endl; &#125; else &#123; if(nfirst!=ntailer) nfirst=(nfirst+1)%maxsize; else cout&lt;&lt;&quot;队列为空，不能输出&quot;&lt;&lt;endl; &#125; //cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; &#125; while(vfirst!=vtailer) &#123; cout&lt;&lt;V[vfirst]&lt;&lt;endl; vfirst=(vfirst+1)%maxsize; //cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; while(nfirst!=ntailer) &#123; cout&lt;&lt;N[nfirst]&lt;&lt;endl; nfirst=(nfirst+1)%maxsize; // cout&lt;&lt;&quot;OUT&quot;&lt;&lt;vfirst&lt;&lt;&quot; &quot;&lt;&lt;vtailer&lt;&lt;&quot; &quot;&lt;&lt;nfirst&lt;&lt;&quot; &quot;&lt;&lt;ntailer&lt;&lt;endl; &#125; return 0;&#125; stack 堆栈 数据结构基础-栈 实验介绍 我们这门课所讲的数据结构倾向于实战，大家不要拘泥于具体的写法，而重在学习原理，和使用方式，我们所需要的是简洁、实用和快速。本次实验主要目标是学会栈的原理与实现，学会灵活地运用，能够不依赖于模板根据题目独立写出各类栈。 我们本次讲解数据结构栈这一部分，这一部分比队列要少很多，但是会在后面的搜索等算法中使用，即使这一部分简单，但也是同等重要。还是要提及的一点，不管你在你的数据结构课上怎么背的你的代码，在我们这门课，我们不再追求复用性，我们要的是你学会原理，追求效率。 知识点 栈的实现原理与应用 为什么使用栈 我们在这之前已经学过了部分数据结构，相信对数据的存储方式也有了新的认知，但是数据的组织方式我们只学习了队列这一种，我们今天要讲另外一种数据组织方式，同样常用于特殊题目的模拟中，诚然在后续相对高级的算法中，栈是一种不可或缺的工具，单独使用可能不会太多次数，当然这一实验会比队列简单，还是希望大家能够好好学习。 什么是栈 我们之前学过了队列这一种对于存取方式的限制的组织方式，我们今天要讲另一种，同样栈既可以采用链表来表示，也可以采用数组（顺序表）来表示，我们限制的是对于存放数据的存取方式。 如果觉得看不懂定义，我们来用图来介绍一下栈，什么是栈，栈如其名，就是按照栈的方式来存取，什么是栈呢，我们举一张糖葫芦的图作为例子。 很显然我们对数据的组织也是以这种方式进行的。当然数据存储方式还是有两种，一种是顺序存储，一种是链式存储。而我们常用的存储方式还是顺序表因为方便简单，在语言自带的程序中用的是链式存储，但是实现相对复杂，我们后期课程中会教大家直接使用，所以我们没必要学会去实现，有余力的同学可以自行实现，使用第一次课的知识加上本次可得知识，即可轻松实现，相应的他也有优点就是节省空间。 顺序存储 链式存储 思考一下： 为什么链式存储的方式的栈栈顶指针与队列队头的指针相反,是什么原因呢？ 其实我们知道链表的表头是用来插入数据的，表头处的数据才是最后插入的，先入后出原则，所以表头处的数据最先出栈，也就是栈的顶啦！听到这里，有人迷糊了，什么头什么尾的，队列跟栈傻傻分不清… 链表是数据存储的组织方式，他只是决定了数据在内存中怎么存储，而栈和队列是说我们是按照什么方式存储。栈可以理解为整理衣服，先放进箱子里的，要想拿出来得把后放进箱子里的衣服先拿出来。而链表或顺序表是说，我究竟是放进了箱子还是放进了衣柜还是放进了异度空间。 我们再复习一下单链表，就放个图给你们吧，省的你们回上一讲去翻。 当然大家不会也没有关系，因为我们这节课不讲链式存储的栈，顺序存储的栈足够用，而且后边的课程中会讲 C++ 的 STL、Java 的实列和 Python 的 Stack 包，大家到时候就不用在自己写这些数据结构了，这节课我们主要是理解原理即可。 栈的初体验 通过上面的介绍，大家已经基本了解了栈的原理，关于栈的使用我们也要必须学会，我们用一个题目来引入。 小邋遢的衣橱 小邋遢 MS.Jinlin 是个爱打扮的公主，他有很多晚礼服如&quot;LALA&quot; “NIHAOMA”、“WOBUHAO”、&quot;NIHAOBUHAO&quot;等众多衣服，可是由于衣服太多他要把它们装进箱子，但是作为公主，肯定是会突发奇想觉得哪件衣服好看，就把他拿了出来，当然那件衣服上面的衣服也被拿出来了，而且会弄乱了，小邋遢在经过几次的叠衣服和取衣服后，他想知道箱子里最上面的衣服是哪一件，如果箱子为空的话，就告诉她 Empty ，如果有多件一样的衣服，肯定是取走最上面的那一件啦。 输入： 123456789第 1 行，输入N，代表共计进行了几次操作第 2 行至第 N+1 行，进行in out 操作in 为 放入衣服out 为 取出衣服格式： in name1 out name2 现在有以下样例输入： 样例 1： 12345678910111213输入：6in AMDYESin INTELNOin USBADin CNYESout INTELNOin MDICN输出：MDICN 样例 2： 1234567891011输入：5in AMDYESin INTELNOin USBADin CNYESout AMDYES输出：Empty 先说思路，答案在后边公布。 第一步： 创建一个栈，以及一个栈的栈顶指针 12顺序栈 栈 1栈顶指针 指针 1 第二步： 我们要声明并定义入栈函数： 按照栈的定义使用栈顶指针模拟即可 需要传入一个参数来表示放什么数据 12345in(Name)&#123; 栈不满，Name 进入栈； 栈满，返回 False；&#125; 第三步： 我们声明并定义判空函数： 通过栈顶指针大小即可判断。 12345isEmpty()&#123; 1. 如果栈为空返回True 2. 不为空返回False&#125; 第四步： 我们要声明并定义出栈函数： 按照栈的定义使用栈顶指针模拟即可 返回一个数据表示出栈元素。 12345out()&#123; 如果栈为空则不能出栈，返回False； 不为空，则出栈。&#125; 第五步： 我们声明并定义取栈顶函数： 只需要将栈顶元素取出即可 先判断是否为空 12345string getTop()&#123; 如果栈为空则不能取栈顶，返回null； 不为空，则返回栈顶。&#125; 第六步： 主函数代码： 12345678输入N循环N次:// 输入OP，输入name 根据执行OP执行in或out操作 判空，取栈顶输出答案 给大家演示一下样例，大家是不是觉得非常简单。 栈 相信大家已经都学会了，开始偷笑这节课比上节课简单多了，那现在我开始给大家讲以下正式的定义和知识了。 栈的逻辑结构 栈：只允许在一端进行插入、删除操作的线性表。 空栈：不含任何数据元素的栈。 允许插入（也称进栈、压栈、入栈）、删除（也称出栈）的一端称为栈顶。 时间复杂度 isEmpty() 查找操作时间复杂度为 O(1) in() 入队操作时间复杂度为 O(1) out() 出队操作时间复杂度为 O(1) 题目解析 学完了知识我们要亲自动手解决一下小邋遢的衣橱的问题了，提前写完代码的同学们也要对对答案了。 第一步： 首先我们要先建存放栈数据结构，我们这里采用顺序表。 因为主要存放数据为名字即字符串，我们可以如下构建： 12String stack[1005]; //栈int Top=0; //栈顶指针 你会发现，这好像就是数组，又好像长得像是队列，他就是这么简单，难的是原理！ 第二步： 我们要声明并定义入栈函数： 按照栈的定义使用栈顶指针模拟即可 需要传入一个参数来表示放什么数据 123456789bool in(string name)&#123; if(Top&gt;=maxsize) return 0; else &#123; Mystack[Top++]=name; return 1; &#125;&#125; 第三步： 我们声明并定义判空函数： 通过栈顶指针大小即可判断。 1234bool isEmpty()&#123; if(Top!=0) return 0; else return 1;&#125; 第四步： 我们要声明并定义出栈函数： 按照栈的定义使用栈顶指针模拟即可 返回一个数据表示出栈元素。 12345678bool out()&#123; if(isEmpty()) return 0; else&#123; Top--; return 1; &#125;&#125; 第五步： 我们声明并定义取栈顶函数： 只需要将栈顶元素取出即可 先判断是否为空 12345string getTop()&#123; if(isEmpty()) return &quot;&quot;; else return Mystack[Top];&#125; 第六步： 主函数代码： 12345678910111213141516171819int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) in(name); else &#123; while(getTop()!=name)&#123; out(); &#125; out(); &#125; &#125; if(isEmpty) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;getTop()&lt;&lt;endl;&#125; 完整代码如下： C++写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int maxsize=100005;string Mystack[maxsize]; //栈int Top=0; //栈顶指针bool in(string name)&#123; if(Top&gt;=maxsize) return 0; else &#123; Mystack[++Top]=name; return 1; &#125;&#125;bool isEmpty()&#123; if(Top!=0) return 0; else return 1;&#125;bool out()&#123; if(isEmpty()) return 0; else&#123; Top--; return 1; &#125;&#125;string getTop()&#123; if(isEmpty()) return &quot;&quot;; else return Mystack[Top];&#125;int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) in(name); else &#123; while(getTop()!=name) &#123; out(); &#125; out(); &#125; &#125; if(isEmpty()) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;getTop()&lt;&lt;endl;&#125; 以上为带有顺序表结构的栈，相应的还有链表所对应的栈，但是因为实现复杂，如果在比赛中使用这种解法，会花费更多的时间，失去了我们提高解题效率的初衷，所以我们就不再赘述了，有兴趣的同学可以自行查阅资料。 下面我们就来介绍如何使用 C++、Java、Pyhton 中定义好的内置栈模版进行解答，从而提高解题效率，实现更加快捷方便的解题。 C++ 的内置栈模板 我们先看一下 C++ 中栈的定义及相应的函数内容. LIFO stack 堆栈，它是一种容器适配器，专门设计用于在 LIFO 上下文（后进先出）中操作，其中元素仅从容器的一端插入和提取。 stack 被实现为容器适配器 它们是使用特定容器类的封装对象作为其类底层容器的 ，提供一组特定的成员函数来访问其元素。元素推入 / 弹出 从 的 “后面” 特定容器 ，这被称为 的顶部堆栈。 底层容器可以是任何标准容器类模板或一些其他专门设计的容器类。 容器应支持以下操作： 以上引用自 C++的 API，当然现在大家理解起来可能有些困难，不用担心，下面我们将会教大家如何定义，并且如何调用相关的函数。 在 C++ 的 stack 模板定义了如下操作： top()： 返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。 push(const T&amp; obj)： 可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。 push(T&amp;&amp; obj)： 以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。 pop()： 弹出栈顶元素。 size()： 返回栈中元素的个数。 大家看的有点迷糊也没有问题，看名字的话大家也都能猜出是什么意思，在上文中，我也都给大家讲了，所以大家对照着看一下。接下来我们采用 C++ 定义好的模板类给大家改写上面的 C++程序,让大家好好学习一下。 第一步： 引入模板类，并定义声明一个栈类 1234#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;string&gt; myStack; 第二步： 我们要声明并定义入栈函数： 按照栈的定义使用栈顶指针模拟即可 需要传入一个参数来表示放什么数据 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第三步： 我们声明并定义判空函数： 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第四步： 需要要声明并定义出栈函数： 按照栈的定义使用栈顶指针模拟即可 返回一个数据表示出栈元素。 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第五步： 我们声明并定义取栈顶函数： 只需要将栈顶元素取出即可 先判断是否为空 这里我们 C++ 的 stack 模版中已经为我们声明并定义好了，所以我们不需要写，这一步可以省略。 第六步： 主函数代码： 1234567891011121314151617181920int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) myStack.push(name); else &#123; while(myStack.top()!=name)&#123; myStack.pop(); &#125; myStack.pop(); &#125; &#125; if(myStack.empty()) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;myStack.top()&lt;&lt;endl;&#125; 完整代码如下，你会发现十分简单，就是直接拿来用的，非常方便，但是建议大家也还是要学会自己写，这样使用起来会更加熟练。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;string&gt; myStack;int main ()&#123; int N; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) &#123; string op,name; cin&gt;&gt;op&gt;&gt;name; if(op==&quot;in&quot;) myStack.push(name); else &#123; while(myStack.top()!=name)&#123; myStack.pop(); &#125; myStack.pop(); &#125; &#125; if(myStack.empty()) cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; else cout&lt;&lt;myStack.top()&lt;&lt;endl;&#125; Java 的内置栈类 我们先看一下 Java 中栈的定义及相应的函数. 栈是 Vector 的一个子类，它实现了一个标准的后进先出的栈，至于什么是 Vector，大家可以理解为能力超强的数组，在后面的课程中，我们会进行讲解。 堆栈定义了默认构造函数，用来创建一个空栈。 大家可能理解起来有困难，不必担心，咱们现阶段知道如何定义，并且如何调用函数后，之后在不断的实践中，就会慢慢理解了。 在 Java 的 stack 模板定义了如下操作流程： push(): 执行 push 时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 peek(): 执行 peek 时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 pop(): 执行 pop 时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。 empty(): 继承于 Vector，返回是否为空 size(): 继承 Vector,返回元素的个数。 那么若使用 Java 的内置栈类，我们的实现流程会有什么不同呢： 我们只需引入模板类，并定义声明一个栈类： 1234567import java.util.Scanner;import java.util.Stack;public class Main &#123; static Stack Mystack =new Stack();&#125; 主函数代码： 12345678910111213141516171819202122232425public static void main(String[] args)&#123; int N; Scanner in=new Scanner(System.in); N=in.nextInt(); for(int i=0;i&lt;N;i++) &#123; String op,name; op=in.next(); name=in.next(); // System.out.println(op+&quot; &quot;+name); if(op.contains(&quot;in&quot;) ) Mystack.push(name); else &#123; while(!Mystack.peek().equals(name))&#123; // System.out.println(getTop()); Mystack.pop(); &#125; Mystack.pop(); &#125; &#125; if(Mystack.empty()) System.out.println(&quot;Empty&quot;); else System.out.println(Mystack.peek());&#125; 可以看到，使用 Java 的内置栈类，可以帮我们省略以下流程： 声明并定义入栈函数 声明并定义入判空函数 声明并定义出栈函数 声明并定义出取栈顶函数 使用起来非常方便，我们再看一下整体的代码。 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;import java.util.Stack;public class Main &#123; static Stack Mystack =new Stack(); public static void main(String[] args) &#123; int N; Scanner in=new Scanner(System.in); N=in.nextInt(); for(int i=0;i&lt;N;i++) &#123; String op,name; op=in.next(); name=in.next(); // System.out.println(op+&quot; &quot;+name); if(op.contains(&quot;in&quot;) ) Mystack.push(name); else &#123; while(!Mystack.peek().equals(name))&#123; // System.out.println(getTop()); Mystack.pop(); &#125; Mystack.pop(); &#125; &#125; if(Mystack.empty()) System.out.println(&quot;Empty&quot;); else System.out.println(Mystack.peek()); &#125;&#125; Python 的实现 由于 Python 没有现成的栈的定义，要想使用，我们只能进行自己模拟，模拟方法大家可以使用我上面使用的方法，也可以看一下我下面讲的高级点的方法，声明并定义一个栈类的方法，推荐使用下面的方法，上面的代码还是主要讲理论使用。 第一步： 声明一个类，并设置一个类型为 list 的元素来保存数据。 123class MyStack: def __init__(self): self._data = [] # 使用list存储栈元素 第二步： 我们要声明并定义入栈函数： 12def push(self, elem): self._data.append(elem) 第三步： 我们声明并定义判空函数： 12def is_empty(self): return self._data == [] 第四步： 我们要声明并定义出栈函数： 123456def pop(self): if self._data == []: raise Warning (&quot;此栈为空，错误操作&quot;); return self._data.pop() 第五步： 我们声明并定义取栈顶函数： 12345def top(self): if self._data == []: raise Warning(&quot;此栈为空，错误操作&quot;); return self._data[-1] 第六步： 主函数代码： 123456789101112131415161718192021222324if __name__==&#x27;__main__&#x27;: N=int (input()) Stack =MyStack() while N&gt;0: N-=1 op=input().split() if(op[0]==&#x27;in&#x27;): Stack.push(op[1]) else : while(Stack.top()!=op[1]): Stack.pop() Stack.pop() if(Stack.is_empty()) : print(&quot;Empty&quot;) else: print(Stack.top()) 完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MyStack: def __init__(self): self._data = [] # 使用list存储栈元素 def is_empty(self): return self._data == [] def push(self, elem): self._data.append(elem) def pop(self): if self._data == []: raise Warning (&quot;此栈为空，错误操作&quot;); return self._data.pop() def top(self): if self._data == []: raise Warning(&quot;此栈为空，错误操作&quot;); return self._data[-1]if __name__==&#x27;__main__&#x27;: N=int (input()) Stack =MyStack() while N&gt;0: N-=1 op=input().split() if(op[0]==&#x27;in&#x27;): Stack.push(op[1]) else : while(Stack.top()!=op[1]): Stack.pop() Stack.pop() if(Stack.is_empty()) : print(&quot;Empty&quot;) else: print(Stack.top()) 实验总结 关于栈的定义方式，跟前面两讲一样在各种教科书上和网站都有着各个不同版本的定义方式，我们主要是学习该数据结构的实现原理，虽然实现可能千奇百怪但是我们理解原理就好，对于实现我们还是要追求简单高效即可。 本次实验，我们学习了栈的实现方式，了解了栈的原理与基本的实现方式，学有余力的同学们可以使用链表自己声明并定义链式栈，但是我们后续用不到，可以当作对自己编码能力的提升。随着我们课程的深入这些工具数据结构我们都不会再自己定义使用了，各类编程语言都给了现成的库模板等，我们都可以拿来直接而用，非常方便,这里给大家讲了，使用各语言的特性简化了自己写的代码，非常方便。 刷题3 「小邋遢的衣橱」 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int main()&#123; int N; string behave,clothes; string trunk[1010]; int top=0; cin&gt;&gt;N; for(int i=0; i&lt;N; i++) &#123; cin&gt;&gt;behave&gt;&gt;clothes; if(behave==&quot;in&quot;) &#123; trunk[++top]=clothes; &#125; else &#123; while(trunk[top]!=clothes) top--; top--; &#125; &#125; if(top) cout&lt;&lt;trunk[top]&lt;&lt;endl; else cout&lt;&lt;&quot;Empty&quot;&lt;&lt;endl; return 0;&#125; 选取最接近表长且小于等于表长的最大素数 b 常用 131，h 常用 1e9+7=999983 C++ 中有一个 UnorderedMap，可以方便我们的解题过程； 数据结构基础-散列表(Hash) 实验介绍 我们本次实验主要目标是学会散列表（hash 算法）的原理与实现，学会灵活的运用，能够不依赖于模板根据题目独立写出各类散列表。数据结构 Hash 属于查找算法中的一部分，在比赛中通常也会占据一定的比例，相对较难也比较重要，大家一定要认真学习哦。 知识点 Hash 的概念 构造方法 冲突处理 为什么使用哈希表 我们上面所提到的查找算法，简单来说，就是判断现有数据集合中是否有这个元素，或者是否有满足条件的元素。 其中的 Hash 算法则可以帮助我们判断是否有这个元素，虽然功能简单，但是其 O(1) 时间复杂度是具有高性能的。通过在记录的存储地址和它的关键码之间建立一个确定的对应关系。这样，不经过比较，一次读取就能得到所查元素的查找方法。相比普通的查找算法来说，仅仅在比较的环节，就会大大减少查找或映射所需要的时间。 什么是哈希表（散列表） 我们采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间即称为散列表。下面用一张图给大家展示一下散列表的实现过程： 如果还是不太明白的话，我们可以理解为数学函数，Y=F(X)，X 为自变量也就是这里的 Key, F( ) 对应图中的 H( )，也就是一个映射关系，Y 因变量也就是对应的值的 存放位置，此处一定要注意哦。 此处让我们思考一下： 散列技术仅仅是一种查找技术吗？ 应该说，散列既是一种查找技术，也是一种存储技术。 散列是一种完整的存储结构吗？ 散列只是通过记录的关键码定位该记录，没有完整地表达记录之间的逻辑关系，即通过关键码能推出 Key 值，但是通过关键码对应的值（即位置处的值）不能推出关键码，所以散列存储的关键码和值之间并不对称，因此散列主要是面向查找的存储结构。 散列表的初体验 通过上面的介绍，大家已经基本了解了散列表的原理。下面我们就来学习一下关于散列表的使用方式，下面我们用一个题目来引入。 弗里的语言 小发明家弗里想创造一种新的语言，众所周知，发明一门语言是非常困难的，首先你就要克服一个困难就是，有大量的单词需要处理，现在弗里求助你帮他写一款程序，判断是否出现重复的两个单词。 要求：有重复的单词，就输出重复单词，没有重复单词，就输出 NO，多个重复单词输出最先出现的。 输入输出如下面示例所示： 首先输入： 12345678第 1 行，输入 N，代表共计创造了多少个单词第 2 行至第 N+1 行，输入 N 个单词格式如下： fjsdfgdfsg fdfsgsdfg bcvxbxfyres 现在有以下样例输入。 样例 1： 12345678910111213输入：61fagas dsafa32jlkiuopybncvhfgdjytrcncxfgsdhrest输出：NO 样例 2： 12345678910111213输入：5sdfggfdsfgsdhsdfdsfhsdhrsdfhdfhsdfggfds输出：sdfggfds 下面我们来分析一下解题思路，请大家跟着下面的思路一步一步实现，然后再对比后面给出的答案。 第一步，首先我们需要创建一个散列表和一个公共溢出区。 12散列表公共溢出区 即使你现在不知道什么是散列表和溢出区，没关系！我们后边会做详细的讲解。 第二步，需要定义插入散列表函数。 按照散列表的映射方式设计即可 需要传入一个参数来表示放什么数据 12345in(Name)&#123; 1. 无冲突 2. 冲突处理&#125; 第三步：定义查询函数。 12345isAt()&#123; 1. 如果散列表查询成功返回 True 2. 不为成功返回 False&#125; 4. 第四步，定义散列表映射函数。 此处我们采用除留余数法即可，不了解这个方法的同学别担心，后面在写解题代码的时候，我会具体为大家介绍。 123456int out(string s)&#123; 处理字符串 s 生成对应的 Key 值&#125; 第五步，编写主函数代码。 12345678910输入 N循环 N 次:// 输入 word； 先查询，有相同的单词有就设置 flag 为 1，ans = word 没有的话，就执行插入操作根据 flag 决定输出什么。 大致的代码逻辑就是这样，相信大家已经都学会了。可能有的小伙伴已经在嘀咕了“这有什么难的”，先别急，咱们继续往下看。 这道题的代码思路其实并不难，但是代码应该如何来写呢，大家是否还摸不着头脑？在比赛中我们为了追求高效率，必须熟知咱们所使用到的每一个函数的优缺点，做到“扬长避短”，所以在写代码前，我们先来聊聊散列表的优缺点。前面咱们已经了解到了，散列表具有高性能，查找效率高等优点，下面就主要了解一下它的缺陷。 散列表的缺陷 散列表并不是适用于所有的需求场景，那么哪些情况下不适合使用呢？ 散列技术一般不适合在允许多个记录有同样关键码的情况下使用。 因为这种情况下，通常会有冲突存在，将会降低查找效率，体现不出散列表查找效率高的优点。 并且如果一定要在这个情况下使用的话，还需要想办法消除冲突，这将花费大量时间，那么就失去了 O(1) 时间复杂度的优势，所以在存在大量的冲突情况下，我们就要弃用散列表。 散列方法也不适用于范围查找，比如以下两个情况。 查找最大值或者最小值 因为散列表的值是类似函数的，映射函数一个变量只能对应一个值，不知道其他值，也不能查找最大值、最小值，RMQ(区间最值问题）可以采用 ST 算法、树状数组和线段树解决。 也不可能找到在某一范围内的记录 比如查找小于 N 的数有多少个，是不能实现的，原因也是映射函数一个变量只能对应一个值，不知道其他值。 散列技术的关键问题 在使用散列表的时候，我们有两个关键的技术问题需要解决： 散列函数的设计，如何设计一个简单、均匀、存储利用率高的散列函数？ 冲突的处理，如何采取合适的处理冲突方法来解决冲突。 如何设计实现散列函数 在构建散列函数时，我们需要秉持两个原则： 简单 散列函数不应该有很大的计算量，否则会降低查找效率。 均匀： 函数值要尽量均匀散布在地址空间，这样才能保证存储空间的有效利用并减少冲突。 散列函数实现三种方法 1. 直接定址法。 散列函数是关键码（Key）的映射的线性函数，形如： H(key) = a * key + bH(key)=a∗key+b 来看一个小案例： 如果关键码的集合已知且为 [11,22,33,66,88,44,99] H(key) = \\frac{1}{11} * key + 0H(key)=111∗key+0 如图： 缺点： 我们是看到了这个集合，然后想到他们都是 11 的倍数才想到这 Hash 函数。我们在平常的使用中一般不会提前知道 Key 值集合，所以使用较少。 适用范围： 事先知道关键码，关键码集合不大且较为连续而不离散。 2. 除留余数法。 H(key)=key \\ mod \\ pH(key)=key mod p 来个小例子： H(key)=key \\ mod \\ 21H(key)=key mod 21 会发现产生了很多相同的 H(K)，这就是发生冲突，因为一个位置只能放一个数，有两个值对应这里一个位置，是不可以的。 这种方法是最常用的方法，这个方法的关键在于如何选取 P，使得利用率较高并且冲突率较低，一般情况下，我们会选取最接近表长且小于等于表长的最大素数。 缺点： P 选取不当，会导致冲突率上升。 适用范围： 除留余数法是一种最简单、也是最常用的构造散列函数的方法，并且不要求事先知道关键码的分布。 这个方法非常常用，我们后面题目的展开就是使用的这个方法。在大部分的算法实现中也都是选取的这一种方式。 代码实现： 123456789101112131415161718192021222324C++ const int MOD=P; int Hx(int n) &#123; return n%MOD; &#125;Java final Integer MOD=P; Integer Hx(int n) &#123; return n%MOD; &#125; python MOD=P #由于Python不含常量，我们这里就不做修饰 Hx(n): global MOD return n%MOD 3. 数字分析法。 比如我将我的集合全部转化为 16 进制数，根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址。或者将 N 位 10 进制数，观察各各位的数字分布，选取分布均匀的散列地址。 举个小例子： 首先我们考虑一位作为散列函数，发现都是很多冲突，选取两位时，百位和十位组合最适宜，分布均匀且没有冲突。 当然，我们说的是这一方法的一个具体实列，既然叫做数字分析法，那么只有对于不同数据的不同分析，才能写出更是适配的 H(x)。 另外还有两种平时使用极少的方法，分别是平方取中法和折叠法，我们就不再做过多的讲解，感兴趣的小伙伴可以在网上自行查找相关的资料了解哦。 冲突的处理方法 开散列方法： open hashing 也称为拉链法，separate chaining 称为链地址法，简单来说，就是由关键码得到的散列地址一旦产生了冲突，就去寻找下一个空的散列地址，并将记录存入。 寻找下一个空的散列地址的方法： 线性探测法 当发生冲突时，从冲突位置的下一个位置起，依次寻找空的散列地址。 对于键值 key，设 H(key)=d，闭散列表的长度为 m，则发生冲突时，寻找下一个散列地址的公式为： Hi=(H(key)＋di)\\ MOD \\ m（di=1，2，… ，m-1）H**i=(H(key)＋d**i) MOD m（d**i=1，2，…，m−1） 堆积现象： 在处理冲突的过程中出现的非同义词之间对同一个散列地址争夺的现象。 例子： Key 集合为 47, 7, 29, 11, 27, 92, 22, 8, 3。 P 值为 11，进行 Hash 映射，采用线性探测法处理冲突。 二次探测法 即当发生冲突时，寻找下一个散列地址的公式为： H_i=(H(key)＋d_i)% mH**i=(H(key)＋d**i) 其中（ d_i=12，－12，22，－22，… ，q2，－q2 且 q≤m/2）其中（d**i=12，－12，22，－22，…，q2，－q2且q≤m/2） 随机探测法 当发生冲突时，下一个散列地址的位移量是一个随机数列，即寻找下一个散列地址的公式为： Hi=(H(key)+round)% mH**i=(H(key)+round) 其中 round 为随机数其中round为随机数 再 hash 法 注意：用开放定址法处理冲突得到的散列表叫闭散列表。 闭散列方法 closed hashing 也称为开地址方法，open addressing 开放地址法，开放地址法中涵盖了以下两种实现方式； 拉链法（链地址法） 将所有散列地址相同的记录即 Key 值相同的项目，坠成一个链表，每个链表的头指针存放位置为 Key 值对应的位置。 举一个小例子： 建立公共溢出区 散列表包含基本表和溢出表两部分（通常溢出表和基本表的大小相同），将发生冲突的记录存储在溢出表中。 查找时，如果在基本表里找的到就返回成功，没找到就在溢出区顺序查找，注意这里不再是映射而是顺序查找，放置时也是按照顺序的方式。 算法流程 假设给定的值为 K，根据所设定的散列函数 h，计算出散列地址 h(K)； 如果将该地址中的值与 K 比较，若相等则检索成功，跳转到第 5 步； 否则，按建表时设定的处理冲突方法查找探查序列的下一个地址,反复执行并检查 如果某个地址空间未被占用（查找不成功，可以插入），跳转到第 5 步； 如果关键码比较相等（有重复记录，不需要插入）为止 ，跳转到第 5 步； 如果探测完整个 hash 表，都没有进行插入或查找失败，跳转到第 5 步； end 算法结束。 虽然在解题过程中，如果依据表长质数 h 设置得当，则很少会出现冲突情况，但是基本的解决方法我们也须得掌握，根据笔者的实战经验来看，公共溢出区的方式更加简洁高效率（在冲突次数远小于元素数量时），所以本节实验中，我们主要掌握如何设置公共溢出区的方法。 至此我们已经学完了散列表的相关知识，下面我们结合建立公共溢出区的方式，亲自动手解决一下“弗里的语言”这个问题。 题目解析 第一步，我们需要创建一个散列表和一个公共溢出区： 1234const long long h=1e8+7;string Value[h+5];string UpValue[h+5]; 第二步，我们要定义散列表映射函数： 我们这里介绍一种在算法竞赛中特别常用的字符串映射成数字的方式。 实现原理： 将字符串中的每一个字母都看做是一个数字（例：从 a-z ，视为 1-26 ）； 选取两个合适的互质常数 b 和 h，其中 h 要尽可能的大一点，为了降低冲突的概率。b 常用 131，h 常用 1e9+7，这里我们需要设置公共溢出区所以，我们需要随便找一个 string 数组能开出来的数字，这里选取 999983。 定义哈希函数： 处理方式： C 代表一个字符串，用 C =c1 c2 c3 c4…cm 表示该字符串，其中 ci 表示从前向后数的第 i 个字符； C 当做 b 进制数 来处理，b 是基数； 关于对 h 取模，若 b、h 有公因子，那么不同的字符串取余之后的结果发生冲突的几率将大大大增加（冲突：不同的字符串但会有相同的 hash 值）。 举一个例子： 现在有一字符串 S=s_1s_2s_3s_4s_5s1s2s3s4s5 h a s h[ 1 ] = s 1 has**h[1]=s1 h a s h [ 2 ] = s 1 ∗ p + s 2has**h[2]=s1∗p+s2 h a s h [ 3 ] = s 1 ∗ p 2 + s 2 ∗ p + s 3has**h[3]=s1∗p2+s2∗p+s3 h a s h [ 4 ] = s 1 ∗ p 3 + s 2 ∗ p 2 + s 3 ∗ p + s 4has**h[4]=s1∗p3+s2∗p2+s3∗p+s4 h a s h [ 5 ] = s 1 ∗ p 4 + s 2 ∗ p 3 + s 3 ∗ p 2 + s 4 ∗ p + s 5has**h[5]=s1∗p4+s2∗p3+s3∗p2+s4∗p+s5 所以 S 的哈希值为 Hash[5] 实现 123456789101112131415const long long h = 999983;int Hx(string s)&#123; int n = s.size(); int sum1 = 0; for (int i = 0; i &lt; n; i++) &#123; sum1 = sum1 * 131 % h + (s[i] - &#x27;a&#x27; + 1) % h; &#125; return (sum1 + h) % h;&#125; 在比赛按此方法设计 Hash 函数一般不需要设置冲突的公共溢出区，这里我们为了方便讲解，才进行设置，在比赛中我们不用设置溢出区，所以可以设置很大的 h，避免出现冲突。 第三步，我们定义查询函数： 通过散列表顶指针大小即可判断。 123456789101112131415161718bool isAt(string s)&#123; int n=Hx(s); if(Value[n]==&quot;&quot;) return false; else if(Value[n]==s) return true; else &#123; for(int i=0;i&lt;UpValueCount;i++) if(UpValue[n]==s) return true; return false; &#125;&#125; 第四步，定义插入散列表函数： 按照散列表的映射方式设计即可； 需要传入一个参数来表示放什么数据。 12345678910111213141516bool in(string s)&#123; int n=Hx(s); if(Value[n]==&quot;&quot;) &#123; Value[n]=s; return true; &#125; else if(Value[n]==s) return false; else &#123; for(int i=0;i&lt;UpValueCount;i++) if(UpValue[n]==s) return false; UpValue[UpValueCount++]=s; return true; &#125;&#125; 第五步，编写主函数代码： 主函数代码我们有三种定义方式 法一 中规中矩定义法，设置 flag 变量用于跳过找到答案后的输入处理。 1234567891011121314151617181920212223242526int main()&#123; int n; bool flag = 0; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (flag) continue; if (isAt(word)) &#123; flag = 1; ans = word; &#125; else &#123; in(word); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 法二 由于我们设置的插入函数也具有查询功能，插入成功即为没有重复值，插入失败即为有重复值，我们这里不存在单独查询的操作，所以我们可以将查询省略。 12345678910111213141516171819202122int main()&#123; int n; bool flag = 0; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (flag) continue; if (!in(word)) &#123; flag = 1; ans = word; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 法三 在法二的基础上，利用 OJ 的特性，OJ 是判定输出的答案是否与答案相同进行判定，当我们知道答案之后直接输出，结束程序那么就会使得程序运行时间大幅度减少。 12345678910111213141516171819int main()&#123; int n; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (!in(word)) &#123; cout &lt;&lt; word &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 完整解题代码 C++实现方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int h = 999983;string Value[h];string UpValue[h];int UpValueCount = 0;int Hx(string s)&#123; int n = s.size(); int sum1 = 0; for (int i = 0; i &lt; n; i++) &#123; sum1 = sum1 * 131 % h + (s[i] - &#x27;a&#x27; + 1) % h; &#125; return (sum1 + h) % h;&#125;bool isAt(string s)&#123; int n = Hx(s); if (Value[n] == &quot;&quot;) return false; else if (Value[n] == s) return true; else &#123; for (int i = 0; i &lt; UpValueCount; i++) if (UpValue[n] == s) return true; return false; &#125;&#125;bool in(string s)&#123; int n = Hx(s); if (Value[n] == &quot;&quot;) &#123; Value[n] = s; return true; &#125; else if (Value[n] == s) return false; else &#123; for (int i = 0; i &lt; UpValueCount; i++) if (UpValue[n] == s) return false; UpValue[UpValueCount++] = s; return true; &#125;&#125;int main()&#123; int n; string ans = &quot;NO&quot;; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string word; cin &gt;&gt; word; if (!in(word)) &#123; cout &lt;&lt; word &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 最后总结给大家一个小窍门，在解题过程中可以使用： C++ 中有一个 UnorderedMap，可以方便我们的解题过程； Python 和 Java 中都有提前定义好的 Hash 函数，也可以直接使用。 实验总结 本次实验，我们学习了散列表的实现方式，了解了散列表的原理与基本的实现方式，学了各种的冲突处理方式和散列函数的构造方式，我们还讲了一种竞赛常用的字符串 hash 的方式，我们都要多加练习并熟练使用。 刷题4 「弗里的的语言」 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int h=999983;const int b=131;struct Node&#123; string word; int flag=1; Node *next;&#125;;Node *Store = new Node [h];int main()&#123; int N,flag0=1; Node *temp,*first,*p; string word; cin&gt;&gt;N; for(int i=0; i&lt;N; i++) &#123; int N,index=0,n; cin&gt;&gt;word; n = word.size(); for(int j=0; j&lt;n; j++) &#123; index=index*b%h+(word[j]-&#x27;a&#x27;+1)%h; &#125; index = (index+h)%h; //cout&lt;&lt;index&lt;&lt;endl; first = &amp;Store[index]; int flag=1; p = first-&gt;next; while(p!=NULL) &#123; //cout&lt;&lt;&quot;ENTER1&quot;&lt;&lt;endl; if(p-&gt;word==word) &#123; if(p-&gt;flag) &#123; cout&lt;&lt;word&lt;&lt;endl; p-&gt;flag=0; flag=0; flag0 = 0; &#125; &#125; p=p-&gt;next; &#125; if(flag) &#123; //cout&lt;&lt;&quot;ENTER1&quot;&lt;&lt;endl; temp=new Node; temp-&gt;word = word; temp-&gt;next = first-&gt;next; first-&gt;next = temp; &#125; &#125; if(flag0) &#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125; 指针数组和数组指针 c语言，c++函数返回一个数组，二维数组 数据结构之排序算法 实验介绍 信息获取后通常需要进行处理，处理后的信息其目的是便于人们的应用。信息处理方法有多种，通常有数据的排序、查找、插入、删除等操作。本章主要介绍几种简单的数据排序算法和高效的排序算法. 在比赛中，排序算法是必不可少的。虽然我们可能会直接使用 sort 等函数直接进行排序，但在有些特殊题目中，我们仍需使用到排序算法。 知识点 选择排序的原理以及代码编写 冒泡排序的原理以及代码编写 桶排序的原理以及代码编写 插入排序的原理以及代码编写 理解希尔排序 快速排序 归并排序的原理 时间复杂度分析 我们本节实验先学习所有的排序算法以及他们的实现，再结合做题目实战。 简单排序算法 简单排序算法包括选择排序、冒泡排序、桶排序和插入排序，本节重点介绍以上四种简单排序算法。 选择排序 基本思想 每一趟从待排序的数据元素中选出最小（或最大）的一个元素，按照顺序放在待排序的数列的最前，直到全部待排序的数据元素排完。 排序过程 例如: 123456789初始：[5 4 6 8 7 1 2 3]第一趟排序后 1 [4 6 8 7 5 2 3]第二趟排序后 1 2 [6 8 7 5 4 3]第三趟排序后 1 2 3 [8 7 5 4 6]第四趟排序后 1 2 3 4 [7 5 8 6]第五趟排序后 1 2 3 4 5 [7 8 6]第六趟排序后 1 2 3 4 5 6 [8 7]第七趟排序后 1 2 3 4 5 6 7 [8]最后排序结果 1 2 3 4 5 6 7 8 对应代码 C++ 实现 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void select_Sort(int *a,int len)&#123; for (int i=0;i&lt;len;i++) &#123; int k=i; for(int j=i+1;j&lt;len;j++) &#123; if(a[j]&lt;a[k]) k=j; &#125; if(k!=i) swap(a[i],a[k]); &#125;&#125;int main ()&#123; int a[] = &#123;5 ,4 ,6 ,8 ,7, 1, 2 ,3&#125;; select_Sort(a,8); for(auto i: a) cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125; Java 实现 Python 实现 冒泡排序 基本思想 所谓冒泡排序就是依次将两个相邻的数进行比较，大的在前面，小的在后面。 即先比较第一个数和第二个数，大数在前，小数在后，然后比较第 2 个数和第 3 个数，直到比较最后两个数 第一趟排序结束后，最小数的数一定在最后 第二趟排序在第一趟的基础上重复上述操作 由于排序过程中总是大数在前，小数在后，相当于气泡上升，所以叫冒泡排序。 大数在前，小数在后排序后得到的是降序 小数在前，大数在后排序后得到的是升序结果 排序过程(降序) 1234567891011初始数据：4 5 6 1 2 3第一趟：比较前两个数， 4比5小，交换位置 5 4 6 1 2 3比较第2第3个数， 4比6小，交换位置 5 6 4 1 2 3比较第3第4个数， 5比1大，位置不变 5 6 4 1 2 3比较第4第5个数， 1比2小，交换位置 5 6 4 2 1 3比较最后两个数， 1比3小，交换位置 5 6 4 2 3 1第一趟结束第二趟重复第一趟过程得到 6 5 4 3 2 1排序完毕。 可以发现，第二趟排序结束后，所有数据已经排好序了。实际上，我们在对于一组数据进行冒泡排序时，假如需要排列的数据个数为 n 个，那么 n-1 趟一定能排好序，比如因为第 2 趟都会有前 2 个小的数排序好，n-1 趟前 n-1 小的数已排好序，最后一个数自然也排好序了。 对应代码: C++ 实现： 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void BubbleSort(int arr[], int n)&#123; for(int i = 0; i &lt; n - 1; i++) &#123; for(int j = 0; j &lt; n - i - 1; j++) &#123; if(arr[j] &gt; arr[j+1]) swap(arr[j],arr[j+1]); &#125; &#125;&#125;int main ()&#123; int a[6] = &#123;4, 5, 6, 1, 2, 3&#125;; BubbleSort(a,6); for(auto i: a) cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125; Java 实现 Python 实现 桶排序 基本思想 桶排序的思想是，若待排序的记录的关键字在一个明显有限范围内时，可设计有限个有序桶，每个桶只能装与之对应的值，顺序输出各桶的值，将得到有序的序列。简单来说，在我们可以确定需要排列的数组的范围时，可以生成该数值范围内有限个桶去对应数组中的数，然后我们将扫描的数值放入匹配的桶里的行为，可以看作是分类，在分类完成后，我们需要依次按照桶的顺序输出桶内存放的数值，这样就完成了桶排序。 例如，要求我们输入 n 个 0~9 之间的整数，由小到大排序输出，我们可以准备 10 个桶依次编号为 0~9。那么，输入的数 0 则入 0 号桶，1 入 1 号桶，依次类推。 如图所示 如上图琐事，我们已准备好 10 个空桶并编号。 下面我们依次输入 8 个整数，分别是 2，5，6，8，5，2，9，6，我们每输入一个数值就将其放入对应的桶。 输入完毕后桶内数据如图所示： 桶排序过程： 如上图所示，2 号桶内有两个数字 2，5 号桶内有两个数字 5，6 号桶内有两个数字 6，8 号桶内有一个数字 8，9 号桶内有一个数字 9 然后我们按桶编号从小到大的顺序将桶内数字输出，得到 2，2，5，5，6，6，8，9，至此桶排序完成。 注意，桶排序需要注意适用范围，在已知所需排序数据的范围下可以使用，另外本次课程我们只讨论整型的情况，其他数据类型的情况下如何使用，感兴趣的小伙伴可以当作课外内容，自行了解哦。 实现代码 C++ 实现方式： 1234567891011121314151617181920int maxN=10; //题目出现的数据的最大值int a[maxN];int n;cin&gt;&gt;nfor(int i=0;i&lt;n;i++)&#123; int key; cin&gt;&gt;key; a[key]++; &#125;for(int i=0;i&lt;maxN;i++)&#123; for(int j=0;j&lt;a[i];j++) &#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;; &#125;&#125; Java 实现方式 Python 实现方式 插入排序 基本思想 插入排序是一种简单的排序方法，时间复杂度为 O(n*n)，适用于数据已经排好序，插入一个新数据的情况。其算法的基本思想是，假设待排序的数据存放在数组 a[1…n] 中，增加一个节点 x 用于保存当前数据，进行比较，a[1]即作为有序区，a[2…n] 作为无序区。 从 i=2 起直至 i=n 为止，通过循环遍历，将 a[i] 放在恰当的位置，使 a[1…i] 数据序列有序 12345678910111213x=a[i] 将 x 与前 i-1 个数比较j=i-1while(x&lt;a[j]) j-= 1, 将 a 数组的元素从 j 位置开始向后移动：for k in range(j,i+1,-1): a[k]=a[k-1] a[j]=x生成包含 n 个数据的有序区 例如，我们现在有一个数组 a=[3 2 4 1 6 5 2 7]，需要使用插入排序进行排列。 排序过程： 12345678第0步：[3] 2 4 1 6 5 2 7第1步：[2 3] 4 1 6 5 2 7第2步：[2 3 4] 1 6 5 2 7第3步：[1 2 3 4] 6 5 2 7第4步：[1 2 3 4 6] 5 2 7第5步：[1 2 3 4 5 6] 2 7第6步：[1 2 2 3 4 5 6] 7第7步：[1 2 2 3 4 5 6 7] 实现代码 C++ 实现 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;void insert_Sort(int *a,int len)&#123; for (int i=0; i&lt;len; i++) &#123; int x = a[i]; int j = i - 1; while( j&gt;=0&amp;&amp;x &lt; a[j]) &#123; a[j + 1] = a[j]; j -= 1; &#125; a[j + 1] = x; &#125;&#125;int main ()&#123; int a[9] = &#123;0, 3, 2, 4, 1, 6, 5, 2, 7&#125;; insert_Sort(a,9); for(auto i: a) cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125; Java 实现 Python 实现 高效排序算法 前面，我们介绍了简单的排序算法，但在实际应用中，简单的排序算法很难达到效率的要求，所以本节介绍了两种高效的排序算法，使排序时间复杂度大大减少。 快速排序 基本思想 快速排序是一种采用分治法解决问题的一个典型应用，也是冒泡排序的一种改进。它的基本思想是，通过一轮排序将待排记录分割成独立的两部分，其中一部分均比另一部分小，则可分别对这两部分继续进行排序，已达到整个序列有序。排序的时间复杂度为 O(nlogn)，相比于简单排序算法，运算效率大大提高。 算法步骤 从序列中取出一个数作为中轴数； 将比这个数大的数放到它的右边，小于或等于他的数放到它的左边； 再对左右区间重复第二步，直到各区间只有一个数。 例如，对以下 10 个数进行快速排序： 16 1 2 7 9 3 4 5 10 8 以第一个数为基准数，在初始状态下，数字 6 在序列的第 1 位，我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k 。 现在就需要寻找这个 k ，并且以第 k 位为分界点，左边的数都≤6，右边的数都≥6。那么如何找到这个位置 k 呢？ 我们要知道，快速排序其实是冒泡排序的一种改进，冒泡排序每次对相邻的两个数进行比较，这显然是一种比较浪费时间的。 而快速排序是分别从两端开始”探测”的，先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j ，分别指向序列最左边和最右边。 我们为这两个变量起个好听的名字哨兵 i 和哨兵 j。 我们首先让哨兵 i 指向序列的最左边，指向数字 6；让哨兵 j 指向序列的最右边，指向数字 8，如下图所示。 首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要。 哨兵 j 一步一步地向左挪动，直到找到一个小于 6 的数停下来 然后哨兵 i 再一步一步向右挪动，直到找到一个数大于 6 的数停下来 最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前，如下图所示： 现在交换哨兵 i 和哨兵 j 所指向元素的值，交换之后的序列如下： 到此，第一次交换结束。接下来开始哨兵 j 继续向左挪动（再友情提醒，每次必须是哨兵 j 先出发）。他发现了 4&lt;6，停下来。哨兵 i 也继续向右挪动的，他发现了 9&gt;6，停下来。此时再次进行交换，交换之后的序列如下 第二次交换结束。哨兵 j 继续向左挪动，他发现了 3&lt;6，又停下来。 哨兵 i 继续向右移动，此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。 说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。 到此第一轮“探测”真正结束。 现在基准数 6 已经归位，此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。 现在我们将第一轮“探测”结束后的序列，以 6 为分界点拆分成两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列，因为 6 左边和右边的序列目前都还是混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6 左边和右边的序列即可。 实际上快速排序的每一轮处理其实就是将这一轮的基准数归为，直到所有的数都归为为止，排序就结束了。 实现代码 C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int tem[10000];void part(int l, int r, int *a);void qSort(int *a, int len)&#123; part(0, len - 1, a);&#125; void part(int l, int r, int *a)&#123; if(l&gt;=r) return ; int r1 = r, l1 = l; while (l1 &lt; r1) &#123; while (a[r1] &gt;= a[l1]&amp;&amp;l1 &lt; r1) r1--; if (l1 &lt; r1) swap(a[l1], a[r1]); else break; while (a[l1] &lt;= a[r1]&amp;&amp;l1 &lt; r1) l1++; if (l1 &lt; r1) swap(a[l1], a[r1]); else break; &#125; part(l,l1-1,a); part(l1+1,r,a);&#125;int main()&#123; int a[1000]; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; qSort(a, n); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125; Java 实现 Python 实现 归并排序 基本思想 归并排序是由递归实现的，主要是分而治之的思想，也就是通过将问题分解成多个容易求解的局部性小问题来解开原本的问题的技巧。 归并排序在合并两个已排序数组时，如果遇到了相同的元素，只要保证前半部分数组优先于后半部分数组， 相同元素的顺序就不会颠倒。所以归并排序属于稳定的排序算法。 每次分别排左半边和右半边，不断递归调用自己，直到只有一个元素递归结束，开始回溯，调用 merge 函数，合并两个有序序列，再合并的时候每次给末尾追上一个最大 int 这样就不怕最后一位的数字不会被排序。 排序过程 代码实现 C++ 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #include &lt;iostream&gt;using namespace std;#define MAX 10000int tem[MAX];void merge(int newArray[], int array[], int array_left, int array_right, int end) &#123; /* * array[] 一个待排序数组 * newArray[] 排序后的新数组 * array_left 待排序数组的左半部分的起点的index * array_right 待排序数组的又半部分的起点的index * end 数组的末尾 * * [] [] [] [] [] [] [] [] [] [] [] [] [] [] [] * ↑ ↑ ↑ * array_left array_right end * * */ int l = array_left, r = array_right, p = array_left; /* * 当l &lt;r说明左数组还有没有进排序的数字 * 当r &lt; end说明右数组还有没有进排序的数字 */ while (l &lt; array_right &amp;&amp; r &lt; end) &#123; //左右数组都没排完时情况的处理 if (array[l] &gt; array[r]) newArray[p++] = array[r++]; else newArray[p++] = array[l++]; &#125; while (l &lt; array_right)//右数组还有没有进排序的数字 newArray[p++] = array[l++]; while (r &lt; end) //左数组还有没有进排序的数字 newArray[p++] = array[r++]; for (int i = array_left; i &lt; end; i++) &#123; //将排序生成的新数组写回原来的位置 array[i] = newArray[i]; // cout&lt;&lt;array[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void merge_sort(int l, int r, int a[]) &#123; if (l &gt;= r - 1) return; int mid = (r + l) / 2; merge_sort(l, mid, a); merge_sort(mid, r, a); merge(tem, a, l, mid, r);&#125;int main() &#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; merge_sort(0, n, a); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125; Java 实现 Python 实现 希尔排序 基本思想 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法，同时也突破了之前内排序算法复杂度为 O(n2)的限制。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率. 插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 该方法的基本思想是： 先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。 其中增量序列的选择是非常关键的，但通常我们取步长为 n/2（数组长度的一般）然后一直取半直到 1。 实现代码： C++ 实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;void ShellSort(int array[], int n) //希尔排序函数&#123; int i, j, step = n / 2; while (step &gt; 0) //这里的step步长是根据10个元素这种情况定义的 &#123; for (i = 0; i &lt; step; i++) //i是子数组的编号 &#123; for (j = i + step; j &lt; n; j = j + step) //数组下标j，数组步长下标j+step &#123; if (array[j] &lt; array[j - step]) &#123; int temp = array[j]; //把数组下标j的值放到temp中 int k = j - step; while (k &gt;= 0 &amp;&amp; temp &lt; array[k]) &#123; array[k + step] = array[k]; //把大的值往后插入 k = k - step; &#125; array[k + step] = temp; //把小的值往前插入 &#125; &#125; &#125; step = step / 2; &#125;&#125;int main(void) //主程序&#123; int array[1000], n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; array[i]; &#125; ShellSort(array, n); for (int i = 0; i &lt; n; i++) cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; return 0;&#125; Java 实现 Python 实现 练习 在我们编译语言中，都是预先设置好排序算法的，我们只需要直接调用即可。但是有些情况是不能调用排序算法的，比如特殊的结构体排序而且要求是稳定的这种情况，所以需要我们在上面各种排序算法的原理的基础上进行改写。大部分情况下我们都是可以直接调用的。 下面我们通过一道题目练习一下上面所学到的知识。 排序初步 12345678910111213141516题目： 对一组无序的整数用排序算法进行排序，方法不限。输入 第一行为数列的总个数，第二行为待排序的数列输出 排序后的数列样例输入 8 10 4 6 3 8 2 5 7样例输出 2 3 4 5 6 7 8 10 C++ 实现 我们将使用 sort 函数解决该问题，由于 sort 在 algorithm 头文件里面，所以使用前先要调入头文件。 用法 sort(首地址，尾地址后面一个位置) 尾地址后面一个位置，即首地址+长度 比如我想排序 a 的第五个元素到第八个元素，共四个元素 那么首地址为 a+5,尾地址后面的一个地址为 a+5+4 尾地址后面一个位置这么描述是为了好理解，其实很多函数都是这么定义的，先这样记住就行,后边就写成 sort(a,a+n)。 或者是 sort(a,a+n,cmp) ,其中 cmp 是比较函数可以根据所比较的数据类型写出比较函数。返回值为 bool 值即可。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 10000 int main()&#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125; 我们自己写一个比较函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 10000 bool cmp(int a,int b) &#123; return a&lt;b;&#125;int main()&#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n,cmp); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125;题目通过代码：#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 500005int main()&#123; int n, a[MAX]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a,a+n); for (int i = 0; i &lt; n; i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for (int i = n-1; i &gt;=0; i--) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125;&#125; Java 实现 Python 实现 Python 的cmp对象在Python 3 中已经删除了，所以如果我们需要对类对象排序，不能使用cmp函数，最简单的方式就是重载类对象的lt(selfm,other)函数 123456789101112131415class student(): def __init__(self, index, name): self.index = index self.name = name def __lt__(self, other): if self.index == other.index: return self.name &lt; other.name else: return self.index &lt; other.indexl = [student(9, &quot;A&quot;), student(4, &quot;B&quot;), student(7, &quot;C&quot;), student(1, &quot;D&quot;), student(7, &quot;E&quot;)]l.sort()print([(e.index,e.name) for e in l]) 实验总结 本次实验，我们学习了各种排序的实现方式，了解了各种排序方式的原理与基本的实现方法，在最后，我们还讲讲解了一种简单快捷的排序的方式。本次实验中我们提到的排序方式，大家都需要多加练习，并学会熟练使用 刷题5 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; int N,mini; cin&gt;&gt;N; int a[N]; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;N-1;i++) &#123; mini=i; for(int j=i+1;j&lt;N;j++) &#123; if(a[mini]&gt;a[j])mini=j; &#125; if(mini!=i)swap(a[mini],a[i]); &#125; for(int i=0;i&lt;N;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for(int i=N-1;i&gt;-1;i--) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return 0; &#125; 内置模板 我们前面讲了很多数据结构相关的知识，本节课程，我们主要讲解怎么不自己定义，而是使用我们所使用的编程语言中，已经定义好的数据结构。 之前我们在栈那一节已经讲过栈的内置数据结构的使用，我们本章就不再进行讲解，我们这节课仍然采用那种方式进行讲解。 知识点 迭代器讲解 线性表的使用 队列的使用 集合（set）的使用 映射（map）的使用 迭代器（Iterator） 首先，明确一点迭代器是 C++ 的知识，并不适用于 Java 和 Python 这两种语言，但是下面讲容器就要用到这一点，所以我们必须要提前讲一下。迭代器的知识点很复杂，了解即可，当然有余力可以深究，了解就能做题，实现方式看容器讲解。 对于数组我们可以采用指针进行访问，但是对于其他的存储空间连续的数据结构或者说是存储单元我们就需要找到另一种方式来替代指针的行为作用，从而达到对于非数组的数据结构的访问和遍历，于是我们定义了一种新的变量叫做迭代器。 定义： 迭代器是一种检查容器内元素并遍历元素的数据类型。 迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。 迭代器和指针的区别： 容器和 string 有迭代器类型同时拥有返回迭代器的成员。 如：容器有成员 .begin() 和 .end(),其中 .begin() 成员复制返回指向第一个元素的迭代器，即指向第一个元素的“地址”，而 .end() 成员返回指向容器尾元素的下一个位置的迭代器。 即 .begin() 指向的是第一个合法元素的位置，.end() 指向是容器后第一个不合法元素的地址。 相应的还有容器反向迭代器成员 .rbegin() .rend(), .rbegin() 返回容器的元素前最后一个不合法的地址，rend() 返回容器的最后一个合法地址。 容器迭代器的使用 每种容器类型都定义了自己的迭代器类型： 1如 vector：vector&lt; int&gt;:: iterator iter;//定义一个名为iter的变量 数据类型是由 vector&lt; int&gt; 定义的 iterator 类型。简单说就是容器类定义了自己的 iterator 类型，用于访问容器内的元素。每个容器定义了一种名为 iterator 的类型，这种类型支持迭代器的各种行为。 我么们先讲一下各种迭代器的类型，在讲容器所用的迭代器类型，就可以明白怎么操作。 容器 写在前面，由于 Python 的语言的特点，所有的数据结构大部分都需要自己实现，但是其 List 功能较强，用起来比较简单，当然我们也会再说一遍怎么实现。 在 Java 中各种数据结构都是继承于 list，所以 Java 的 list 功能也很强，它的功能有很多，由于篇幅原因我们会挑比较重要的讲解，其他的还需要同学们多去使用。 Vector 容器（类） 线性表中有 Vector 和 list，两者作用比较相似。 Vector 的主要作用就是可变长度的数组，就把他当成数组使用即可。 至于为甚我们我选择讲 Vector 而不是 List，因为 Vector 可以当作数组使用，用起来非常简单，也非常方便。 我们先讲解一下 c++ 的 Vector 使用： 123456789#include &lt;vector&gt; //头文件vector&lt;int&gt; a; //定义了一个int类型的vector容器avector&lt;int&gt; b[100]; //定义了一个int类型的vector容器b组struct rec&#123; ···&#125;;vector&lt;rec&gt; c; //定义了一个rec类型的vector容器cvector&lt;int&gt;::iterator it; //vector的迭代器，与指针类似 具体操作如下： 123456789a.size() //返回实际长度（元素个数），O(1)复杂度a.empty() //容器为空返回1，否则返回0，O(1)复杂度a.clear() //把vector清空a.begin() //返回指向第一个元素的迭代器，*a.begin()与a[0]作用相同a.end() //越界访问，指向vector尾部，指向第n个元素再往后的边界a.front() //返回第一个元素的值，等价于*a.begin和a[0]a.back() //返回最后一个元素的值，等价于*--a.end()和a[size()-1]a.push_back(x) //把元素x插入vector尾部a.pop_back() //删除vector中最后一个元素 遍历的方式有两种： 迭代器使用与指针类似，可如下遍历整个容器。 12for ( vector&lt;int&gt;::iterator it=a.begin() ; it!=a.end() ; it++ )cout&lt;&lt;*iterator&lt;&lt;endl; 当成数组使用。 1for( int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; 上面我们讲解了 C++ 的实现方式，下面我们了解一下 java 的。 12345678//第一种构造方法创建一个默认的向量，默认大小为 10：Vector()//第二种构造方法创建指定大小的向量。Vector(int size)//第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。Vector(int size,int incr)//第四种构造方法创建一个包含集合 c 元素的向量：Vector(Collection c) 以下为 Java Vector 的 Api。 修饰符和类型 方法和说明 boolean add(E e)将指定的元素附加到此 Vector 的末尾。 void add(int index, E element)在此 Vector 的指定位置插入指定元素。 boolean addAll(Collection&lt;? extends E&gt; c)将指定集合中的所有元素追加到末尾 这个向量，按照它们由指定的返回的顺序 集合的迭代器。 boolean addAll(int index, Collection&lt;? extends E&gt; c)将指定 Collection 中的所有元素插入到此 指定位置的向量。 void addElement(E obj)将指定的组件添加到此向量的末尾， 将其大小增加一。 int capacity()返回此向量的当前容量。 void clear()从此 Vector 中删除所有元素。 Object clone()返回此向量的克隆。 boolean contains(Object o)退货 true 如果此向量包含指定的元素。 boolean containsAll(Collection&lt;?&gt; c)如果此 Vector 包含所有元素，则返回 true 指定的集合。 void copyInto(Object[] anArray)将此向量的分量复制到指定的数组中。 E elementAt(int index)返回指定索引处的组件。 Enumeration elements()返回此向量的组件的枚举。 void ensureCapacity(int minCapacity)如有必要，增加此向量的容量，以确保它至少可以容纳由指定的组件数量最小容量参数。 boolean equals(Object o)比较指定的 Object 与此 Vector 是否相等。 E firstElement()返回第一个组件（索引处的项目 0） 的这个向量。 E get(int index)返回此 Vector 中指定位置的元素。 int hashCode()返回此 Vector 的哈希码值。 int indexOf(Object o)返回指定元素第一次出现的索引 在此向量中，如果此向量不包含该元素，则为 -1。 int indexOf(Object o,int index)返回指定元素第一次出现的索引这个向量，从 index, 或返回 -1 如果 未找到该元素。 void insertElementAt(E obj, int index)将指定对象作为组件插入此向量中的 指定的 index. boolean isEmpty()测试此向量是否没有组件。 Iterator iterator()以适当的顺序返回此列表中元素的迭代器 E lastElement()返回向量的最后一个组件。 int lastIndexOf(Object o)返回指定元素最后一次出现的索引在此向量中，如果此向量不包含该元素，则为 -1。 int lastIndexOf(Object o, int index)返回指定元素最后一次出现的索引这个向量，从 index, 或返回 -1 如果 未找到该元素。 ListIterator listIterator()返回此列表中元素的列表迭代器（在适当的顺序）。 ListIterator listIterator(int index)返回此列表中元素的列表迭代器（在适当的序列），从列表中的指定位置开始。 E remove(int index)移除此 Vector 中指定位置的元素。 boolean remove(Object o)移除此 Vector 中第一次出现的指定元素如果 Vector 不包含该元素，则它保持不变。 boolean removeAll(Collection&lt;?&gt; c)从此 Vector 中删除其包含在指定的集合。 void removeAllElements()从此向量中删除所有组件并将其大小设置为零。 boolean removeElement(Object obj)删除参数的第一个（最低索引）出现从这个向量。 void removeElementAt(int index)删除指定索引处的组件。 protected void removeRange(int fromIndex, int toIndex)从此列表中删除索引介于两者之间的所有元素 fromIndex，包括在内，和 toIndex， 独家的。 boolean retainAll(Collection&lt;?&gt; c)仅保留此 Vector 中包含在指定的集合。 E set(int index, E element)将此 Vector 中指定位置的元素替换为指定的元素。 void setElementAt(E obj,int index)将组件设置在指定的位置 index 这个的向量是指定的对象。 void setSize(int newSize)设置此向量的大小。 int size()返回此向量中的组件数。 List subList(int fromIndex,int toIndex)返回此列表中 fromIndex 之间的部分的视图 Object[] toArray()返回一个包含此 Vector 中所有元素的数组以正确的顺序。 T[] toArray(T[] a)返回一个包含此 Vector 中所有元素的数组正确的顺序; 返回数组的运行时类型指定数组。 String toString()返回此 Vector 的字符串表示形式，包含 每个元素的字符串表示。 void trimToSize()将此向量的容量修剪为向量的电流 尺寸。 遍历 Vector 123Enumeration vEnum = v.elements();while (vEnum.hasMoreElements()) System.out.print(vEnum.nextElement() + &quot; &quot;); Python 中，我们直接使用 list 即可来实现。 题目解析 快递员需要对快递进行分拣，现在小李是一名快递员，他想要你帮他设计一个程序用于快递的分拣，按城市分开。 现在有以下输入： 1234567单号 省份请你将单号按照城市分开，并输出。城市按照输入顺序排序单号按照输入顺序排序 样例如下： 12345678910111213141516171819202122232425262728293031323334输入10 10124214 北京12421565 上海sdafasdg213 天津fasdfga124 北京145252 上海235wtdfsg 济南3242356fgdfsg 成都23423 武汉 23423565f 沈阳1245dfwfs 成都输出北京 210124214fasdfga124上海 212421565145252天津 1sdafasdg213济南 1235wtdfsg成都 23242356fgdfsg 1245dfwfs 武汉 123423沈阳 123423565f 下面我们来分析一下解题思路。 首先我们要知道中国城市肯定在 1000 个以内，但是单号我们不确定，我们不可能每个数组开 10000 个，那样内存不够，所以这时候我们就用到了我们的 vector，他的容量是动态申请的，在比赛中我们可以理解为无限制。 第一步：我们创建一个 vector 用于保存地址 1vector&lt;string&gt; city; 第二步：我们创建一个 vector 组用于存放单号 1vector&lt;string&gt; dig[1000]; 第三步：我们定义一个映射函数，因为你的城市可能会再次出现，你需要知道之前有没有。 第四步：我们开始读入操作并按照顺序进行存放 完整代码 C++ 解题代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;string&gt; city;vector&lt;string&gt; dig[1000];int Myfind(string s)&#123; for(int i=0;i&lt;city.size();i++) &#123; if(city[i]==s) return i; &#125; return -1;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; string d,c; cin&gt;&gt;d&gt;&gt;c; int flag=Myfind(c); if(flag==-1)&#123; city.push_back(c); dig[city.size()-1].push_back(d); &#125; else dig[flag].push_back(d); &#125; for(int i=0;i&lt;city.size();i++) &#123; cout&lt;&lt;city[i]&lt;&lt;&quot; &quot;&lt;&lt;dig[i].size()&lt;&lt;endl; for(int j=0;j&lt;dig[i].size();j++) cout&lt;&lt;dig[i][j]&lt;&lt;endl; &#125;&#125; Java 解题代码 Python 实现方式 队列 Queue 队列的讲解在之前的课程中已经讲过了，忘记的快回去复习。 我们直接开始看操作吧。 C++ 中的队列 定义方式：在 C++ 里所有容器的定义方式基本一致。 12queue&lt;string&gt; myqueue;queue&lt;int&gt; myqueue_int; 成员函数: front()：返回 queue 中第一个元素的引用。 back()：返回 queue 中最后一个元素的引用。 push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 Java 中的队列 Python 中的队列 题目回顾 CLZ 的银行。 123456789101112131415161718192021222324252627282930第一行 M 次操作（M&lt;1000）第二行 到 第M+1行 输入操作格式： IN name V OUT V IN name2 N OUT N 即 第一个字符串为操作 是IN进入排队和OUT 出队 IN 排队 跟着两个字符串为姓名和权限V或N OUT 为出队即完成操作，V和N代表那个窗口完成了操作输出：M次操作后V队列和N队列中姓名，先输出V队列后输出N队列。样例：输入：5IN xiaoming NIN Adel VIN laozhao NOUT NIN CLZ V输出：AdelCLZlaozhao 具体的题目讲解，我们之前就已经讲解过了，这里我们主要是来看一下预置代码的方便性。 完整代码 C++实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;queue&lt;string&gt; V;queue&lt;string&gt; N;int main()&#123; int M; cin&gt;&gt;M; while(M--) // &#123; string op,name,type; cin&gt;&gt;op; if(op==&quot;IN&quot;) &#123; cin&gt;&gt;name&gt;&gt;type; if(type==&quot;V&quot;) V.push(name); else N.push(name); &#125; else &#123; cin&gt;&gt;type; if(type==&quot;V&quot;) V.pop(); else N.pop(); &#125; &#125; while(V.size()) &#123; cout&lt;&lt;V.front()&lt;&lt;endl; V.pop(); &#125; while(N.size()) &#123; cout&lt;&lt;N.front()&lt;&lt;endl; N.pop(); &#125;&#125; Java 实现 Python 实现 Map 映射 在之前我们学习散列表的时候我们就接触过了映射，这里我们要讲的是一种类似的数据结构。 map 是一个关联容器，它提供一对一的 hash。 第一个可以称为关键字(key)，每个关键字只能在 map 中出现一次 第二个可能称为该关键字的值(value) map 以模板（泛型）方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map 主要用于资料一对一映射（one-to-one）的情況，map 在 C++ 的內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在 map 内部所有的数据都是有序的。 比如，像是管理班级内的学生，Key 值为学号，Value 放其他信息的结构体或者类。 C++ 中的 map 定义方式： 12map&lt;char, int&gt; mymap1;map&lt;string, int&gt; mymap2; 一般用法： 看容量。 12int map.size();//查询map中有多少对元素bool empty();// 查询map是否为空 插入。 12345map.insert(make_pair(key,value));//或者map.insert(pair&lt;char, int&gt;(key, value))//或者map[key]=value 取值。 12345678map&lt;int, string&gt; map;//如果map中没有关键字2233，使用[]取值会导致插入//因此，下面语句不会报错，但会使得输出结果结果为空cout&lt;&lt;map[2233]&lt;&lt;endl;//但是使用使用at会进行关键字检查，因此下面语句会报错map.at(2016) = &quot;Bob&quot;; 遍历操作 123456map&lt;string, string&gt;::iterator it;for (it = mapSet.begin(); it != mapSet.end(); ++it)&#123; cout &lt;&lt; &quot;key&quot; &lt;&lt; it-&gt;first &lt;&lt; endl; cout &lt;&lt; &quot;value&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;&#125; 查找操作 12m.count(key)：//由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。m.find(key)：//返回迭代器，判断是否存在。 Java 中的 map Python 字典 题目演练 《弗里石的的语言》 小发明家弗里想创造一种新的语言，众所周知，发明一门语言是非常困难的，首先你就要克服一个困难就是，有大量的单词需要处理，现在弗里求助你帮他写一款程序，判断是否出现重复的两个单词。 有重复就输出重复单词，重复就输出 NO，多个重复输出最先出现的哪一个。 输入： 123456789第 1 行，输入N，代表共计创造了多少个单词第 2 行至第 N+1 行，输入 N 个单词格式： fjsdfgdfsg fdfsgsdfg bcvxbxfyres 现在有以下样例输入： 样例 1 12345678910111213输入：61fagas dsafa32jlkiuopybncvhfgdjytrcncxfgsdhrest输出：NO 样例 2 123456789101112输入：5sdfggfdsfgsdhsdfdsfhsdhrsdfhdfhsdfggfds输出：sdfggfds 这个题的思路在前面我们已经讲过了，这里我们换一种方式解题。 使用映射和字典解题，是的原来的代码减少了超过一半，但是思路还是一样，可以说是非常的巧妙且省力。 C++ 解法 12345678910111213141516171819202122232425 #include &lt;iostream&gt; #include &lt;map&gt; using namespace std;map&lt;string,bool&gt; mp;int main ()&#123; int n; string ans=&quot;NO&quot;; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; string word; cin&gt;&gt;word; if(mp.count(word))&#123; ans=word; break; &#125; else mp[word]=1; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Java 解法 Python 解法 打表法和模拟法 模拟法是比赛中最常用的方法，使用各种算法大都离不开模拟，而对于一些只是需要结果的题目来说打表法是一个非常好的解决方案，而且对于数论等其他需要找规律的题目来说，打表法是一个非常有用的方法。 模拟法和打表法，经常会同时出现，因为打表就要按照题目的意思去模拟。今天我们就从蓝桥杯的真题出发，给大家讲解一下，打表法和模拟法的应用。 知识点 打表法的使用与简单举例 模拟法的使用与简单举例 算式问题 这是 2012 年蓝桥杯国赛 的一道问题。 123456789101112131415161718192021222324252627题目描述：本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。看这个算式：☆☆☆ + ☆☆☆ = ☆☆☆如果每个五角星代表 1 ~ 9 的不同的数字。这个算式有多少种可能的正确填写方法？173 + 286 = 459295 + 173 = 468173 + 295 = 468183 + 492 = 675以上都是正确的填写法！注意：111+222=333 是错误的填写法！因为每个数字必须是不同的！也就是说：1 ~ 9 中的所有数字，每个必须出现且仅出现一次！注意：不包括数字 “0”。注意：满足加法交换率的式子算两种不同的答案。 所以答案肯定是个偶数！运行限制： 1. 最大运行时间：1s 2. 最大运行内存: 128M 题目分析 首先我们能了解到这道题只需要答案，那么对于时间要求就等于无限，那我们可以使用模拟方法，因为只需要输出答案即可，只要能够在比赛的时长里跑出来即可。 接下来我们将采用模拟法进行问题的求解，注意既然我们不需要考虑时间问题和代码问题，我们一定要将代码设计的具有较高的逻辑性和准确性。 这个题的正解是搜索算法，但是既然只要答案我们求快、求简单，在这里我们使用另一种方式进行解答。 这里有三个数字 我们称 A + B = C 且各个位上的数字不同。 我们这里借助桶排序的思想来判断 1-9 这些数字有没有占用。 所以我们定义一个判断函数，用于判断 A B C 三个数字是否符合要求。 然后暴力枚举： A 从 123 到 987 开始枚举 有很多同学开始抬杠 111-999 岂不是更简单，因为 123 是最小的符合要求的数字，可以减少枚举的次数，987 是最大的符合要求的数字。 B 从 123 到 987-A 枚举 这时候又会有很多同学来问，为什么不直接枚举与 A 不一样的数字呢，那么又得考虑每一位的问题，这样的模拟已经不是暴力法了，我们要做的就是在不改变完成难度的情况下，减少复杂度。所以要分清注次。 C = A + B 这时候只要检查 A B C 是否符合要求即可。 代码解答 C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int flag[11];int check(int a,int b,int c)&#123; for(int i=0;i&lt;10;i++) flag[i]=0; flag[0]=1; while(a!=0) &#123; if(flag[a%10]==1) return 0; else flag[a%10]=1; if(flag[b%10]==1) return 0; else flag[b%10]=1 ; if(flag[c%10]==1) return 0; else flag[c%10]=1 ; a=a/10; b=b/10; c=c/10; &#125; return 1;&#125;int main()&#123; int ans=0; for(int a=123;a&lt;=987;a++) for(int b=123;b&lt;=987-a;b++) &#123; int c=a+b; if(check(a,b,c)) &#123; ans++; cout&lt;&lt;a&lt;&lt;&quot; + &quot;&lt;&lt;b&lt;&lt;&quot; = &quot;&lt;&lt;c&lt;&lt;endl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 运行结果： 1234567891011121314151617181920212223242526272829303132124 + 659 = 783125 + 739 = 864127 + 359 = 486127 + 368 = 495128 + 367 = 495128 + 439 = 567129 + 357 = 486129 + 438 = 567129 + 654 = 783129 + 735 = 864134 + 658 = 792135 + 729 = 864138 + 429 = 567138 + 654 = 792139 + 428 = 567139 + 725 = 864142 + 596 = 738142 + 695 = 837…………………754 + 182 = 936762 + 183 = 945763 + 182 = 945782 + 154 = 936782 + 163 = 945783 + 162 = 945784 + 152 = 936336Process returned 0 (0x0) execution time : 0.360 sPress any key to continue. 注意 题目要求是只输出答案，我们讲模拟的代码提交是一分不得的，所以按照题目要求，以下才是正确答案。 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;336&lt;&lt;endl; return 0;&#125; 有的题目是让你输出答案，有的是让你填空，所以务必审清题目，减少不必要的丢分。 Python 解法 Java 解法 求值 这是 蓝桥杯 2019 国赛 的一道题目。 1234567891011121314题目描述：本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。学习了约数后，小明对于约数很好奇，他发现，给定一个正整数 t，总是可以找到含有 t 个约数的整数。小明对于含有 t 个约数的最小数非常感兴趣，并把它定义为 St。例如 S1=1,S2=2,S3=4,S4=6，⋅⋅⋅现在小明想知道，当 t=100 时，S100 是多少？运行限制： 1. 最大运行时间：1s 2. 最大运行内存：128M 题目分析 这道题乍一看，是一道数论题目，实际上他确实一道数论题目，但是由于是道填空题，所以我们采用模拟法打表做。 题目中的描述是找约数，那我们定义个找约束个数的函数，然后枚举即可。 这样不考虑时间复杂度，我们采取暴力法，尽快完成题目，让程序去跑答案，节省下时间来去做其他的题目。 我们可以这样暴力写约束计数函数。 c++ 与 java 写法相同： 1234567int cnt(int a)&#123; int ans = 0; for (int j = a; j &gt; 0; j--) if (a % j == 0) ans++; return ans;&#125; Python 解决方法 约数函数定义完成之后，就可以开始枚举了，反正是个很大的数，从几开始都无所谓，300、500 都行，当然也可以从 1 开始。 代码解答 C++ 解题代码： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int cnt(int a)&#123; int ans = 0; for (int j = 1; j &lt;= a; j++) if (a % j == 0) ans++; return ans;&#125;int main()&#123; for(int i=1;1;i++) &#123; cout&lt;&lt;cnt(i)&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; if(cnt(i)==100) break; &#125;&#125; 运行代码部分： 1234567891011121314151617181920212223242526272829303132333435363738......8 4532710 453282 4532916 453308 4533112 4533216 453338 453344 4533516 453362 453374 4533816 4533912 453402 4534124 453422 4534324 453448 4534516 453464 4534712 453484 4534912 453506 453518 4535216 453538 453548 4535524 453568 453574 453584 45359100 45360Process returned 0 (0x0) execution time : 21.628 sPress any key to continue. 提交代码： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;45360&lt;&lt;endl; return 0;&#125; Java 解题代码 Python 解题代码 在实测中 C++ 跑的最快，其次是 Java，最慢的是 Python 跑了约 30s，大家要耐心等待一下。 既约分数 这是 2020 年省赛 的一个题目。 12345题目描述：本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。如果一个分数的分子和分母的最大公约数是 1，这个分数称为既约分数。 例如 \\frac{3}{4} ,\\frac{1}{8} ,\\frac{7}{1}43,81,17， 都是既约分数。 12345请问，有多少个既约分数，分子和分母都是 1 到 2020 之间的整数（包括 1 和 2020）？运行限制 1. 最大运行时间：1s 2.最大运行内存：128M 题目解析 我们看到这种题，现在一眼就知道只是到纯暴力的题目，即暴力枚举然后依据题目要求模拟即可。 但是这种简单题在比赛中是来送分的，我们要花很少的时间做完，才有时间做其他的题目，这就要求我们对这种题目的熟练度极高，要做到，看到题目，想到思路手里能直接写出来才可以。 这里有一个巧妙的方法是因为分子与分母是对称的我们可以少枚举一半，不过有些同学可能没想明白，没关系，我们用普通的办法，只要能够快速的编程并找到答案，思路正确性能够保证的话，其他的都是可有可无的。 这题目我们首先要两个数是否互质，即最小公约数为 1，我们就定义一个 GCD() 求最小公约数的算法，这里我们采用的是递归的方法。 一般我们按照如下写法，方便。 1234int GCD(int a,int b)&#123; return a%b?GCD(b,a%b):b;&#125; 也可以同义的替换成一下写法： 1234567891011int GCD(int a,int b)&#123; if(a%b==0) return b; //如果a%b==0 代表可以被整除，那么b就是最大公约数 else return GCD(b,a%b) // 如果不能被整除，那么就先取余数，代码会保证左侧是大的，右侧是小的数字，所以使用时不必进行大小检查，即使a&lt;b也会再一次递归后变成b，a在进行计算。 //这样就能按照辗转相除法求解。（小学五年级的课程吧）&#125; 当让也可以按照算法的字面意思进行编写： 123456789101112int gcd(int a,int b)&#123; int temp; while(b) &#123; /*利用辗除法，直到b为0为止*/ temp = b; b = a % b; a = temp; &#125; return a;&#125; 然后这个题目我们就可以进行枚举了。 外层循环为 a，假设是分母，内层循环是 b 这样就可以进行枚举 a 和 b 都是 1 到 2020 那这个题，就非常简单了 代码解答 C++ 实现： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int gcd(int a,int b)&#123; int temp; while(b) &#123; /*利用辗除法，直到b为0为止*/ temp = b; b = a % b; a = temp; &#125; return a;&#125;int main()&#123; int ans=0; for(int a=1;a&lt;=2020;a++) &#123; for( int b=1;b&lt;=2020;b++) &#123; if(gcd(a,b)==1) ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 提交代码： 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;2481215&lt;&lt;endl; return 0;&#125; Java 解题代码 Python 解题代码 天干地支 这个题目是 2020 国赛的模拟题。 12345678910111213141516171819202122232425262728293031323334353637383940414243题目描述：古代中国使用天干地支来记录当前的年份。天干一共有十个，分别为：甲（jiǎ）、乙（yǐ）、丙（bǐng）、丁（dīng）、戊（wù）、己（jǐ）、庚（gēng）、辛（xīn）、壬（rén）、癸（guǐ）。地支一共有十二个，分别为：子（zǐ）、丑（chǒu）、寅（yín）、卯（mǎo）、辰（chén）、巳（sì）、午（wǔ）、未（wèi）、申（shēn）、酉（yǒu）、戌（xū）、 亥（hài）。将天干和地支连起来，就组成了一个天干地支的年份，例如：甲子。2020 年是庚子年。每过一年，天干和地支都会移动到下一个。例如 2021 年是辛丑年。每过 60 年，天干会循环 6 轮，地支会循环 5 轮，所以天干地支纪年每 60 年轮回一次。例如 1900 年，1960 年，2020 年都是庚子年。给定一个公元纪年的年份，请输出这一年的天干地支年份。输入描述：输入一行包含一个正整数，表示公元年份。其中有 ，输入的公元年份为不超过 9999 的正整数。输出描述：输入一行包含一个正整数，表示公元年份。输入输出样例：输入2020输出gengzi运行限制 1. 最大运行时间：1s 2. 最大运行内存: 128M 题目解析 这个题目是模拟法中最讨厌也最常见的一种，可能还有比这更复杂的，但这道题，已经初具代表性。 他的种类比较多，天干就有 10 种 ，地支有 12 种 现在我们知道了 2020 年是庚子年，我们这里既可以是除留余数来判断 N 年是什么天干和什么地支，我们也可以直接暴力使用循环做，这样的话 9999 的复杂度也跑不了多久。实现起来很简单，我们讲这个比较难的。 我们先判断 0000 年的天干 和地支 。 根据题意 0000 年 距 2020 年 早了 2020 年 。 已知天干 有 10 个， 那么 2020%10=0 剩下的都是整个轮回，即到了 0000 年 是庚 X 年，即天干是 庚 。 再按照这个方法算地支 是 2020%12=4 及还要向前推四年 地支为申。 即 0000 年为庚申年，那么根据模拟法可知。 N%10=0 时 天干为庚 N%10=1 时 天干为辛 … 以此类推 N%12=0 时 地支为申 N%12=1 时 地支为酉 … 以此类推： 那我们很容易就能实现判断代码的编写： 123456string tg(int n)&#123; n=n%10; if(n==0) return &quot;geng&quot;; .....&#125; 这样写谁都会写，但是写起来过于太复杂了。我们换一种优雅的实现方式。 代码解答 C++ 方式： 123456789101112#include &lt;iostream&gt;using namespace std;string tg[10] = &#123;&quot;geng&quot;, &quot;xin&quot;, &quot;ren&quot;, &quot;gui&quot;, &quot;jia&quot;, &quot;yi&quot; , &quot;bing&quot;, &quot;ding&quot;, &quot;wu&quot;, &quot;ji&quot;&#125;;string dz[12] = &#123;&quot;shen&quot;, &quot;you&quot;, &quot;xu&quot;, &quot;hai&quot;, &quot;zi&quot;, &quot;chou&quot;, &quot;yin&quot;, &quot;mou&quot;, &quot;chen&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;wei&quot;&#125;;int main()&#123; int year; cin &gt;&gt; year; cout&lt;&lt;tg[year%10]&lt;&lt;dz[year%12]&lt;&lt;endl;&#125; Java 解题代码 Python 解题代码 总结 对于这种简单的模拟题，不需要借助算法，只要暴力的题目，我们都可以打表模拟，然后提交答案，在比赛时有的是输出答案，填空，比赛时注意分辨。 这章难度较低，但是对于熟练度要求较高。 多做简单的思维题，进行训练才能为后期的算法学习打下良好的基础，无论你学了多厉害的算法，如果思维训练不够，到了考场也是两眼一黑，手足无措。 而那些思维很好的同学，即使某一道题的算法我不会，但是我会有新的想法能接触这道题，我们现在所接触的所有算法，不都是某一个大牛，在不经意间发现，经过各种优化到我们手里的吗。 算法是工具，思维才是最重要的，我们这门课程不仅讲算法，还希望能够让各位提高思维能力。 递推法与递归法 递推法： 递推法是一种非常重要的数学方法，不仅在数学领域有着广泛的运用，在其他领域也有着较高的实用性。在计算机中，递推法是用于数值求解的一个重要算法。 知识点 递推算法 递归算法 递推算法的特点 一个问题的求解需要大量重复计算，在已知的条件和所求问题之间总存在着某种相互联系的关系，在计算时，我们需要找到这种关系，进行计算（递推关系式）。 即递推法的关键，就是找到递推关系式，这种处理方式能够将复杂的计算过程，转化为若干步骤的简单重复运送，充分利用计算机运行程序时的时间局部性和空间局部性。 递推算法的思想： 首要问题是先找到各个相邻数据项之间的递推关系； 递推关系避开了求通项公式的麻烦，且有些题目的通项公式很难求，或者不能进行求解； 将复杂问题分解为若干步骤的简单运算； 一般来说递推算法就是一种特殊的迭代算法。 递推算法解题的基本思路： 将复杂计算转换为简单重复运算； 通过找到递推关系式进行简化运算； 利用计算机的特性，减少运行时间。 递推算法的一般步骤： 根据题目确定数据项，并找到符合要求的递推关系式； 根据递推关系式设计递推程序； 根据题目找到递推的终点； 单次查询可以不进行存储，多次查询都要进行存储； 按要求输出答案即可。 递归算法： 递归算法是一种从自顶向下的算法，实际上是通过不停的直接调用或者间接的调用自身的函数，通过每次改变变量完成多个过程的重复计算，直到到达边界之后，结束调用。 与递推法相似的是，递归与递推都是将一个复杂过程分解为几个简单重复步骤进行计算。 递归算法的实现的核心是分治策略，即分而治之，将复杂过程分解为规模较小的同类问题，通过解决若干个小问题，进而解决整个复杂问题。 递归算法的思想： 将复杂计算过程转换为简单重复子过程； 找到递归公式，即能够将大问题转化为小问题的公式； 自上而下计算，在返回完成递归过程。 递归算法设计的一般步骤： 根据题目设计递归函数中的运算部分； 根据题目找到递归公式，题目可能会隐含给出，也可能需要自己进行推导； 找到递归出口，即递归的终止条件。 递归法的和递推法的思路也给大家讲的差不多了，我们结合真实大赛题目给大家进行讲解。 斐波纳契数列 fibonacci 问题 在一定情况下，同一个问题可以使用用递归也可以使用递推解答。一般一个问题的递推关系和递归关系都好求的话就都可以解题。 当然如果题目只有一个关系好求，那就最好采用关系好求的办法。 题目描述: 1234567斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）请求出该数列中第n个数字（n从1开始计数）是多少。 样例: 123456789101112131415输入样例样例1输入6样例2输入4输出样例样例1输出8样例2输出3 对于上面的样例我们进行了如下计算； 12345678910111213[0]=0[1]=1[2]=0+1[3]=1+1=2[4]=1+2=3[5]=2+3=5[6]=5+3=8 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 这个题给出递推式 F(n) = F(n-1) + F(n-2) 转化为可用的递推关系，即 F(n) + F(n+1) = F(n+2) 这一通过从 n=1 开始循环即可完成递推，当然也可以使用递归法。 首先我们写找出递归式，F(n)= F(n-1) + F(n-2)。 1234F(n)= F(n-1) + F(n-2) = F(n-2)+F(n-3)+F(n-3)+F(n-4)//重复调用 这样我们找到了递归式，然后我们应该找到递归出口。 我们可以知道 F(n)=0 n=0 ,F(n)=1 n=1 这就是递归出口，能让递归停止的条件。 递归算法的通用框架如下： 1234567891011121314151617181920212223do(a,b,c...)&#123; //递归终止条件，即出口 if(a==? ,b==? ,....) return //递归条件 if(条件1) do(参数1) else(条件2) do(参数2)&#125;如本题，各子式间存在计算关系，可以化为：do(a)&#123; if(a==0) return 0; if(a==1) return 1; return do(a-1)+do(a-2);&#125; 这道题不是多次询问问题，不需要存储直接计算的复杂度是最低的。 答案解析 C++ 代码： 递推算法代码 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int n; //第几个数 int x=0; //F(n) int y=1; //F(n+1) int ans; //F(n+2） cin&gt;&gt;n; if(n==0) ans=0; else if(n==1) ans=1; else &#123; for(int i=2;i&lt;=n;i++) &#123; ans=x+y; x=y; y=ans; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 递归算法代码 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int fn(int n)&#123; //递归出口1 if(n==0) return 0; //递归出口2 else if(n==1 ) return 1; else return fn(n-1)+fn(n-2); //递归关系式&#125;int main()&#123; int n; //第几个数 int ans; cin&gt;&gt;n; ans=fn(n); cout&lt;&lt;ans&lt;&lt;endl;&#125; Python 解题代码 Java 解题代码 存储型的递推与递归 我们在开始就讲过题目十分存储和非存储的，上面那个题目就是此询问，如果改为多次询问我们该怎么办，我们会采用存储的方式，存储的方式适用于大部分的的多次查询问题。 我们看一下修改后的题目。 题目描述： 123456789斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）。我们将进行M次查询，每次输入一个N，其中n小于30。请求出该数列中第n个数字（n从1开始计数）是多少? 样例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445输入样例样例1输入：64278810样例2输入：81323141724161011输出样例样例1输出：3113212155样例2输出：233286573771597463689875589 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 这道题跟上面一道题的算法原理相同，只是增加了多次查询的复杂度，所以仅需修改这一点即可。 再有的是有的同学担心自己的输入输出是在一个屏幕上的，评测的时候会不会出现问题。 类似这样的情况，这一点是不用担心的，只要不是交互题，评测机的输入与输出是分开的，只有你的输出会用来跟答案比较，所以我们只用关心我们的输出即可。 比如有一道题让你计算 x+y 的值，如果你知道每答案，就可以直接输出，都不用进行读入。 然后我们来看一下需要多次询问的题目该怎么解决。 答案解析 C++ 代码： 递推算法代码 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int F[35];void init()&#123; F[0]=0; F[1]=1; for(int i=2;i&lt;=30;i++) &#123; F[i]=F[i-1]+F[i-2]; &#125;&#125;int main()&#123; int m; //m次查询 int n; //第几个数 init(); cin&gt;&gt;m; while(m&gt;0)&#123; m-=1; cin&gt;&gt;n; cout&lt;&lt;F[n]&lt;&lt;endl; &#125;&#125; 存储答案的递推法，才是最常使用的递推法。 递归算法代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int F[35];int fn(int n)&#123; //递归出口1 if(n==0) &#123; F[0]=0; return 0; &#125; //递归出口2 else if(n==1 ) &#123; F[1]=1; return 1; &#125; else &#123; F[n]=fn(n-1)+fn(n-2); return F[n]; //递归关系式 &#125;&#125;int main()&#123; int m; //m次查询 int n; //第几个数 fn(30); cin&gt;&gt;m; while(m&gt;0)&#123; m-=1; cin&gt;&gt;n; cout&lt;&lt;F[n]&lt;&lt;endl; &#125;&#125; Python 解题代码 Java 解题代码 数字三角形问题 题目描述: 123456789如图数字三角形。如下所示为一个数字三角形。请编一个程序计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。 1. 一步可沿左斜线向下或右斜线向下走；2. 三角形行数小于等于 100；3. 三角形中的数字为 0，1，…，99； 测试数据通过键盘逐行输入。如上例数据应以样例所示格式输入： 样例: 1234567891011输入：573 88 1 02 7 4 44 5 2 6 5输出：30 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目分析: 解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。 我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第 i 层，正向着 i+1 层前进， 两条可行路径中我们肯定会选择最大的方向前进，为此我们可以采用递推中的反向递推，即逆推的方式解决，设 a[i][j] 存放从 i,j 出发到达第 n 层的最大值。 我们可以写出递推式： 1a[i][j] = max&#123;a[i][j]+a[i+1][j]，a[i][j]+a[i+1][j+1]&#125; 则 逆推到出发点 a[1][1] 为题目所求答案，即第一层到第 N 层的最大值。 答案解析 C++ 代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int main()&#123; int n; //n层 int a[101][101]; //路径矩阵 cin&gt;&gt;n; //输入数字三角形的值 for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=i; j++) &#123; cin&gt;&gt;a[i][j]; //输入原始数据 &#125; &#125; //递推开始 for (int i=n-1; i&gt;=1; i--)//从最后一层逆推 &#123; for (int j=1; j&lt;=i; j++) &#123; if (a[i+1][j]&gt;=a[i+1][j+1]) a[i][j]+=a[i+1][j]; //路径选择 else a[i][j]+=a[i+1][j+1]; &#125; &#125; cout&lt;&lt;a[1][1]&lt;&lt;endl;&#125; Python 解题代码 Java 解题代码 总结 我们这节课讲了递推与递归的知识点，并且也讲了何时采用递归设计程序，何时采用递推设计程序。对于多次询问的题目，也为大家展示了一种解决方法。 对于递推算法，我们覆盖了正推和逆推两种方式。无论是递推和递归的关键在于找到关系式。 希望同学能够独立完成题目进行练习。并且在后面的学习中会多次用到递归与递推设计其他算法。 枚举法 之前的课，给大家讲解过打表法与模拟法的暴力方式，说到暴力，我们大家最先想到一定是枚举，但是枚举真的是一门技术，怎么样把所有情况一个不落下的枚举出来是比较难的，所以我们这节课给大家讲解一下枚举法。 知识点 简单型枚举 组合型枚举 排列型枚举 指数型枚举 枚举法 枚举算法的思想： 将问题的所有可能成为答案的解一一列举，然后根据问题所给出的条件判断此解是否合适，如果合适就保留，反之则舍弃。 枚举算法解题的基本思路： 确定枚举解的范围，以及判断条件 选取合适枚举方法，进行逐一枚举，此时应注意能否覆盖所有的可能的解 在枚举时使用判断条件检验，留下所有符合要求的解。 枚举算法的一般步骤： 根据题目确定枚举的范围，并选取合适的枚举方式，不能遗漏任何一个真正解，同时避免重复。 为了提高解决问题的效率，看题目是否存在优化，将可能成为解的答案范围尽可能的缩小。 根据问题找到合理并、准确好描述并且好编码的验证条件。 枚举并判断是否符合第三步确定的的条件，并保存符合条件的解。 按要求输出枚举过程中留下的符合条件的解。 枚举法也是有很多技巧和方法的，这节课我们将从如下几种方法为大家进行讲解。 简单型枚举 简单型枚举就是可以通过简单的 for 循环嵌套就可以解决的问题。我们之前的课讲的题目都算是简单型枚举的范畴，所以简单型枚举是比较简单，也是大家接触最多的一种枚举方式。 这种枚举方式没有特定的固定枚举方式，而且都比较简单，按照题目的要求进行设计代码即可完成解题。 我们用一个题复习一下。 42 点问题 题目描述: 123456789众所周知在扑克牌中，有一个老掉牙的游戏叫做24点，选取4张牌进行加减乘除，看是否能得出24这个答案。现在小蓝同学发明了一个新游戏，他从扑克牌中依次抽出6张牌，注意不是一次抽出，进行计算，看是否能够组成 42 点，满足输出YES，反之输出 NO。最先抽出来的牌作为第一个操作数，抽出牌做第二个操作数，运算结果在当作第一个操作数，继续进行操作。除不尽的情况保留整数。请设计一个程序对该问题进行解答。 样例: 1234567输入：K A Q 6 2 3 输出：YES 对于上面的样例我们进行了如下计算； 123451. K*A=K 即 13*1=132. 13/12=1 保留整数3. 1+6=74. 7*2=145. 14*3=42 运行限制: 12最大运行时间：1s最大运行内存: 128M 题目解析： 这个题目我们可以依次枚举数字，然后在枚举数字间的符号即可。由于到结果之间进行了三步计算，所以我们这里需要进行一个递归操作，利用了上节课讲解的知识。 两重循环即可解决问题，伪代码如下： 1234567891011121314op1 赋值为 第一个数op(op[1] op[2])&#123; for op in [+ - * /] ans = 第一个操作数op1 操作 第二个操作数op2 如果是第六个操作数，就检验是否符合要要求 ==42？ 如果是就返回True 如果op(ans , op[3]) 返回 True，就返回True 因为找到了答案，否则就继续进行 没有找到答案返回False&#125; 但是这样写，思路感觉很清晰，写起来却非常的复杂，我们使用我们讲过的 Vector 来优化这个枚举方式。 我们创建 5 个 Vector ，分别用来存放 1-5 次的运算结果，非常简单。我们答案就采用这种方式。 答案解析 C++ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int a[10];vector &lt;int&gt; ans[10];int main()&#123; for(int i=0; i&lt;6; i++) &#123; char c; cin&gt;&gt;c; if(c==&#x27;A&#x27;) a[i]=1; else if(c==&#x27;J&#x27;) a[i]=11; else if(c==&#x27;Q&#x27;) a[i]=12; else if(c==&#x27;K&#x27;) a[i]=13; else a[i]=(c-&#x27;0&#x27;); //cout&lt;&lt;a[i]&lt;&lt;endl; &#125; ans[0].push_back(a[0]); for(int i=1; i&lt;=5; i++) &#123; for(int j=0; j&lt;ans[i-1].size(); j++) &#123; ans[i].push_back(ans[i-1][j]+a[i]); ans[i].push_back(ans[i-1][j]-a[i]); ans[i].push_back(ans[i-1][j]*a[i]); ans[i].push_back(ans[i-1][j]/a[i]); &#125; &#125; //cout&lt;&lt;ans[5].size()&lt;&lt;endl; int flag=0; for(int i=0; i&lt;ans[5].size(); i++) &#123; if(ans[5][i]==42) &#123; flag=1; break; &#125; &#125; if(flag==1) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; Python 解题代码 Java 解题代码 组合型枚举 排列组合相信大家都学习过，组合型枚举就是让你在 n 个中，随机选出 m 个，问你有多少种方案，而且每一种方案选择了哪 m 个，这就是组合型枚举。 即组合型枚举就是寻找 cnmc_{n}^mcnm 问题。 组合型枚举有固定的流程，即有着固定的算法模板，这个需要大家去记忆一下。 1234567891011121314151617181920212223int n;//共计N个数int m;//选m个数vector&lt;int&gt; chosen;void calc(int x) &#123; if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝 return; if (x == n + 1) &#123; //选够了m个数输出 for (int i = 0; i &lt; chosen.size(); i++) printf(&quot;%d &quot;, chosen[i]); //也可以不输出，存放起来也是可以的，主要是看题目。 puts(&quot;&quot;); return; &#125; calc(x + 1); chosen.push_back(x); calc(x + 1); chosen.pop_back();//消除痕迹&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; calc(1);&#125; Python 写法 Java 写法 大家有个疑虑，我这里全是数字而且是从 1 开始的能好用吗，我题目要是字母怎么办，那么请看下面的题目。 公平抽签 题目描述: 1234567891011小A的学校，蓝桥杯的参赛名额非常有限，只有m个名额，但是共有n个人报名，其中m&lt;=n。作为老师非常苦恼，他不知道该让谁去，他在寻求一个绝对公平的方式。于是他准备让大家抽签决定，即m个签是去，剩下的是不去。小A非常想弄明白最后的抽签结果是什么样子的，到底有多少种结果。请设计一个程序帮助小A。最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。第一行 输入 N M第二行 到 第 N+1 行 共输入 N 个人名每种情况输出 M 个人名，空格隔开。 样例: 1234567891011输入：3 2xiaowangxiaoAxiaoli输出：xiaowang xiaoAxiaowang xiaolixiaoA xiaoli 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 实际上还是组合型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，直接输出即可。 答案解析 C++ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; //共计N个数int m; //选m个数vector&lt;string&gt; name;vector&lt;string&gt; ans;vector&lt;int&gt; chosen;void calc(int x)&#123; if (chosen.size() &gt; m || chosen.size() + (n - x + 1) &lt; m) //剪枝 return; if (x == n + 1) &#123; //选够了m个数输出 string ansTem = &quot;&quot;; for (int i = 0; i &lt; chosen.size(); i++) ansTem += name[chosen[i] - 1] + &quot; &quot;; ans.push_back(ansTem); return; &#125; calc(x + 1); chosen.push_back(x); calc(x + 1); chosen.pop_back(); //消除痕迹&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; name.push_back(s); &#125; calc(1); for (int i = ans.size() - 1; i &gt;= 0; i--) cout &lt;&lt; ans[i] &lt;&lt; endl;&#125; Python 解题代码 Java 解题代码 排列型枚举 上面说过，组合型枚举就是让你在 n 个中，随机选出 m 个 ，问你有多少种方案，而且每一种方案选择了哪 m 个，这就是组合型枚举。 而排列型枚举相对组合型枚举就简单了一点，就是 n 个的全排列，即从 n 个中选取 n 个但是关心内部的顺序。 相比较组合只关心有多少个集合，而排列是关心集合内的排列方式。即排列型枚举就是寻找 A_{n}^nAnn 问题。 而且排列型枚举也是有着比较成熟的模板需要大家进行记忆。 123456789101112131415161718192021222324252627282930int n; //共计N个数int order[20];bool chosen[20];void calc(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; order[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (chosen[i]) continue; order[k] = i; chosen[i] = 1; calc(k + 1); chosen[i] = 0; order[k] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; calc(1);&#125; Python 写法 Java 写法 不少同学问我 20 够不够，排列问题是阶乘阶的时间复杂度，如果超过这个复杂度，那么这个题也就不用做了，算不出来。 所以肯定够用。 1234567891011121314151617181920212223242541 2 3 41 2 4 31 3 2 41 3 4 21 4 2 31 4 3 22 1 3 42 1 4 32 3 1 42 3 4 12 4 1 32 4 3 13 1 2 43 1 4 23 2 1 43 2 4 13 4 1 23 4 2 14 1 2 34 1 3 24 2 1 34 2 3 14 3 1 24 3 2 1 4 的排列就已经这么多了，大家可以尝试跑一下 10。 同样，我们再来看一个的问题来进行加深理解。 座次问题 题目描述: 12345678910小 A 的学校，老师好不容易解决了蓝桥杯的报名问题，现在老师又犯愁了。现在有 N 位同学参加比赛，但是老师想给他们排座位，但是排列方式太多了。老师非常想弄明白最后的排座次的结果是什么样子的，到底有多少种结果。请设计一个程序帮助老师。最后输出各种情况的人名即可，一行一种情况，每种情况的名字按照报名即输入顺序排序。第一行 输入 N；第二行 到 第N+1 行 共输入 N 个人名。由于小 A 学校承办能力实在有限，所以其中 N 小于等于 10 人。 样例: 1234567891011121314输入：3xiaowangxiaoAxiaoli输出：xiaowang xiaoA xiaolixiaowang xiaoli xiaoAxiaoA xiaowang xiaolixiaoA xiaoli xiaowangxiaoli xiaowang xiaoAxiaoli xiaoA xiaowang 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 实际上还是排列型枚举，但是输出元素为人名，我们可以将人名存起来，输出的时候，根据数字下标找到提前存好的人名，就是按照上一道题的方式处理即可。 答案解析 C++ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; //共计N个数vector&lt;string&gt; name;int order[20];bool chosen[20];void calc(int k)&#123; if (k == n + 1) &#123; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; name[order[i] - 1] &lt;&lt; &quot; &quot;; puts(&quot;&quot;); return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (chosen[i]) continue; order[k] = i; chosen[i] = 1; calc(k + 1); chosen[i] = 0; order[k] = 0; &#125;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; name.push_back(s); &#125; calc(1);&#125; Python 解题代码 Java 解题代码 实验总结 我们讲了三种的枚举方式，普通枚举和排列组合枚举，其实还是有其他的枚举方式，可以借助我们排列组合进行组合实现，并且在后面的课程中我们将进行搜索的讲解，搜索算法能够作为补充进行其他的枚举。 基本所有的枚举情况我们都涵盖到了，希望大家多加练习，熟练运用。 差分与前缀和 差分与前缀和是一对互逆的操作，常常用于处理区间问题，差分法是解决区间加减问题，前缀和是解决区间求和问题的常用办法。 知识点 差分算法 前缀和算法 差分法 差分法的应用主要是用于处理区间问题。当某一个数组要在很多不确定的区间，加上相同的一个数。我们如果每个都进行加法操作的话，那么复杂度 O(nm) 是平方阶的，非常消耗时间。 如果我们采用差分法，将数组拆分，构造出一个新的拆分数组，通过对数组区间的端点进行加减操作，最后将数组和并就能完成原来的操作。 这样处理后，时间复杂度降低为 O(N)，虽然感觉操作变得更加复杂了，但是只用对边界操作确实比操作一整个区间的方法要优秀的多。 听到这里也是吊足了胃口，那到底怎么对区间操作呢，请大家跟随我的讲解，慢慢理解。 差分法的特点： 将对于区间的加减操作转化为对于端点的操作； 时间复杂度为 O(n)； 用于维护区间的增减但不能维护乘除； 差分后的序列比原来的数组序列多一个数。 差分算法解题的基本思路： b[1]=a[1]； 从第 2 项到 n 项，利用 b[i]=a[i]-a[i-1]b[i]=a[i]−a[i−1] 差分式； 对于区间端点操作加减； 差分还原(前缀和)。 注意是从1开始，从0开始还有讨论i=0 的情况，使用1的话 b[1]=a[1]-a[0]=a[1]-0; 递推算法的一般步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102首先假设有一个数组：a[]=&#123;1 2 3 4 5 7 2&#125;差分后：b[]=&#123;1 1 1 1 1 2 -5&#125;一般应用场景：让你对区间 [l,r] 加减操作 N 次如：从第二个元素到第五个元素每个+3从第二个元素到第四个元素每个-2从第一个元素到第三个元素每个+1....这里我们先演示前三个：对于每个 [l,r] 区间的加减操作都转化为对端点 l,r+1 的操作从第二个元素到第五个元素每个+3：转化为：[l]+3 并且 [r+1]-3那么原序列变成了：1 1 1 1 1 2 -51 4 1 1 1 -1 -5然后我们按照 b[i]=b[i]+b[i-1] 复原：1 5 6 7 8 7 2去掉最后一项，跟原序列对比：1 2 3 4 5 7 21 5 6 7 8 7 2确实是都加上了 3。我们继续操作：从第二个元素到第四个元素每个-2转化为：[l]-2 并且 [r+1]+2那么序列变成了： 1 4 1 1 1 -1 -51 2 1 1 3 -1 -5然后我们按照b[i]=b[i]+b[i-1] 复原1 3 4 5 8 7 2与上次复原后对比：1 5 6 7 8 7 21 3 4 5 8 7 2 确实是按照操作执行了。注意 Warning：不用每次都复原，只用最后一次复原即可，这里我是演示给大家看。我们最后直接做三次，最后还原：从第二个元素到第五个元素每个+3从第二个元素到第四个元素每个-2从第一个元素到第三个元素每个+1a[]=&#123;1 2 3 4 5 7 2&#125;原序列差分后：b[]=&#123;1 1 1 1 1 2 -5&#125;2 号元素 + 3 6 号元素 - 32 号元素 - 25 号元素 + 21 号元素 + 1 4 号元素 - 1差分序列变成：2 2 1 0 3 -1 -5复原后：2 4 5 5 8 7 5与原序列对比：1 2 3 4 5 7 22 4 5 5 8 7 5所以还是非常方便快捷的。 差分与前缀和是逆操作，常在一起出现，但是先做差分还是先做前缀和就是两种不同的算法，做不做另一种操作也决定了算法不同，所以大家要根据题目分析，具体学会使用。 大学里的树木要打药 题目描述: 1234567891011教室外有 N 棵树，根据不同的位置和树种，学校要对其上不同的药。因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。树的编号从 0-N-1 且 N&lt;1e6。对于树的药是成区间分布，比如 3 - 5 号的树靠近下水道，所以他们要用驱蚊虫的药， 20 - 26 号的树，他们排水不好，容易涝所以要给他们用点促进根系的药。诸如此类，每种不同的药要花不同的钱。现在已知共有 M 个这样的区间，并且给你每个区间花的钱，请问最后，这些树木花了多少药费。 输入: 123456789101112131415161718192021输入描述:每组输入的第一行有两个整数 N（1 &lt;= N&lt;= 1000000）和 M（1 &lt;= M &lt;= 100000）。N 代表马路的共计多少棵树，M代表区间的数目，N 和 M 之间用一个空格隔开。接下来的 M 行每行包含三个不同的整数，用一个空格隔开，表示一个区域的起始点 L 和终止点 R 的坐标，以及花费。输入样例:500 3150 300 4100 200 20470 471 19输出描述:输出包括一行，这一行只包含一个整数，所有的花费。输出样例:2662 样例: 123456789101112131415输入样例3000 8150 1130 21020 1200 3 470 2071 11123 211 612 222 213 23 2 1 213 41232 2523 6输出样例2662 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 利用b[i]=a[i]-a[i-1]b[i]=a[i]−a[i−1] 差分式。 这里由于开始时都是 0，可以用，但是用完都还是 0，所以没有意义，所以直接跳过即可。 依次读入区间的值，然后将对于区间的操作转化为对于区间端点操作加减。 由于我们从1开始，所以数目整体区间要右移1位。 对于每个 [l,r] 区间的加减操作都转化为对端点 l,r+1 的操作。 差分还原(前缀和)。 123for (int i = 1; i &lt; n; i++)b[i] = a[i] - a[i - 1] 差分算法解决区间加减问题通用框架如下： 1234567891011121314151617181920212223242526//读入原始数据 n,m,a输入n,mfor(int i=1;i&lt;=n;i++)&#123; 输入a[i]&#125;//差分for(int i=1;i&lt;=n;i++) b[i]=a[i]-a[i-1] //区间操作while(m--)&#123; 输入l,r,value b[l]+value b[r+1]-value&#125;//前缀和还原for(int i=1;i&lt;n;i++) b[i]=b[i]+b[i-1] 答案解析 C++ 代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int b[100005];int main()&#123; int n; //n层 int m; // m个区间 cin &gt;&gt; n &gt;&gt; m; while (m--) &#123; int l, r, value; cin &gt;&gt; l &gt;&gt; r &gt;&gt; value; b[l+1] += value; b[r + 1+1] -= value; &#125; for (int i = 1; i &lt;= n; i++) b[i] = b[i] + b[i - 1]; int sum = 0; for (int i = 1; i &lt;= n; i++) sum += b[i]; /* 也可以一次性搞定 int sum=b[1]; for(int i=1; i&lt;=n; i++)&#123; b[i]=b[i]+b[i-1]; sum+=b[i] &#125; */ cout &lt;&lt; sum &lt;&lt; endl;&#125; Python 解题代码 Java 解题代码 前缀和 前缀和法的应用主要也是用于处理区间问题。 前缀和是指某序列的前 n 项和，可以把它理解为数学上的数列的前 n 项和。当对于某一数组区间进行多次询问，[L,r] 的和时，如果正常处理，那么我们每次都要 [l,r]。查询 N 次，那么时间复杂度也是 O(nm) 也是平方阶的。 如果我们采用前缀和，构造出一个前缀和数组，通过对于端点的值的减法操作就能 O(1) 的求出 [l,r] 的和。然后 N 次查询的,就将复杂度降低为 O(n) 同差分一样，感觉操作变得更加复杂了，但是只用对端点值的操作确实比一整个区间相加的方法要优秀的多。听到这里大家很期待了，我们接着进行讲解。 前缀和的特点： 将对于区间的求和操作转化为对于端点值的减法的操作； 区间求和操作的时间复杂度为 O(1)； 数组存放时要从 1 开始； 前缀和数组比原来的数组序列多一个数，第 0 个 前缀和算法解题的基本思路： 利用 sum[i]=a[i]+sum[i-1]sum[i]=a[i]+sum[i−1] 差分式； 从第 1 项到 n 项，且第 0 项无数据默认为 0； 对于区间求和的操作转化为端点值相减。 前缀和的一般解题过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556首先假设有一个数组：1 2 3 4 5 7 2前缀和后：0 1 3 6 10 15 22 24一般应用场景：让你对区间 [l,r] 求和操作N次如：从第二个元素到第五个元素的和从第二个元素到第四个元素的和从第一个元素到第三个元素的和....这里我们先演示前三个：对于每个 [l,r] 区间的求和操作转化为区间端点的加减操作sum[l,r] =[r]-[l-1]从第二个元素到第五个元素的和：转化为：[5]-[1]那么Sum[2,5]=[5]-[1]=14且 2+3+4+5=14确实是相等的，就是这么神奇。我们继续操作：从第二个元素到第四个元素的和转化为：[4]-[1]那么Sum[2,4]=[4]-[1]=9且 2+3+4=9我们继续操作：从第一个元素到第三个元素的和转化为：[3]-[0]那么Sum[1,3]=[3]-[0]=6且 1+2+3=6符合题意，验证结束，咱么做个题目看一看 大学里的树木要维护 题目描述: 12345678910111213141516171819202122232425262728293031教室外有 N 棵树，根据不同的位置和树种，学校已经对其进行了多年的维护。因为树的排列成线性，且非常长，我们可以将它们看作一条直线给他们编号。树的编号从 1-N 且 N&lt;1e6。由于已经维护了多年，每一个树都由学校的园艺人员进行了维护费用的统计。每棵树的前期维护费用各不相同，但是由于未来需要要打药，所以有些树木的维护费用太高的话，就要重新种植。由于维护费用也称区间分布，所以常常需要统一个区间里的树木的维护开销。现在园艺人员想知道，某个区间内的树木维护开销是多少。共计 M 个区间需要查询。输入描述:每组输入的第一行有两个整数 N（1 &lt;= N&lt;= 1000000）和 M（1 &lt;= M &lt;= 100000）。N 代表马路的共计多少棵树，M 代表区间的数目，N 和 M 之间用一个空格隔开。接下来的一行，包含 N 个数，每个数之间用空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点L和终止点R的坐标。输入样例:10 37 5 6 4 2 5 0 8 5 31 52 63 7输出描述: 输出包括M行，每一行只包含一个整数，所有的花费。输出样例:242217 样例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263输入样例30 28172 723 580 822 718 798 941 625 450 716 540 252 16 666 115 679 274 323 875 233 99 538 881 486 610 462 319 878 930 7356 227 213 167 209 170 2113 277 1910 232 1421 2215 176 1316 2321 2111 155 129 118 2210 163 815 275 164 80 274 87 2120 21输出样例81406804791867053708106176576647262077847637106843383902991589504017066401298444845894651639041391339046804332 运行限制: 121. 最大运行时间：1s2. 最大运行内存：128M 题目解析： 利用sum[i]=a[i]+sum[i-1]sum[i]=a[i]+sum[i−1] 前缀和式在输入时求出前缀和； 依次读入区间的值，然后将对于区间的求和操作转化为对于区间端点操作加减，对于每个 [l,r] 区间的求和操作都转化为对端点[r]-[l-1]的操作。 输出答案。 前缀和一般解题过程： 12345678910111213输 入 N 和 M 输入 N 个值 并计算前缀和for( int i=1;i&lt;=N;i++) 输入a[i] 并计算sum[i]=sum[i-1]+a[i]输入 M 个区间，计算结果while(M) M-=1 输入 L , R 计算 [r]-[l-1]，并输出 答案解析 C++ 代码： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int a[100005];int sum[100005];int main()&#123; int n; int m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; sum[i] = a[i] + sum[i - 1]; &#125; while (m &gt; 0) &#123; m -= 1; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; endl; &#125;&#125; 这个代码有个问题，虽然是能通过的，但是他是一个输入对应一个输出的，我们之前讲过，这对大部分的测评机是没问题。 终端输出： 123456789101110 37 5 6 4 2 5 0 8 5 31 5242 6223 717Process returned 0 (0x0) execution time : 1.741 sPress any key to continue. 但是如果有想要规规矩矩的处理，或者说题目要求必须全部读入后输出。我们可这样操作。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int sum[100005];vector&lt;int&gt;ss;int main()&#123; int n ; int m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; sum[i]=a[i]+sum[i-1]; &#125; while(m&gt;0) &#123; m-=1; int l,r; cin&gt;&gt;l&gt;&gt;r; ss.push_back(sum[r]-sum[l-1]); &#125; for(auto sss:ss) cout&lt;&lt;sss&lt;&lt;endl;&#125; 终端输出： 123456789101110 37 5 6 4 2 5 0 8 5 31 52 63 7242217Process returned 0 (0x0) execution time : 6.235 sPress any key to continue. 都可以，大家看自己需求和心情选择即可。 Python 解题代码 Java 解题代码 实验总结 我们这节课讲了差分和前缀和的知识点，并且也讲了怎样使用差分，怎样使前缀和，也讲了差分和前缀和最常见的两种情况。 差分和前缀和是很多思维题的解题技巧，必须要掌握熟练才能拿到简单题目的全部分数。 二分查找算法 知识点 二分查找原理讲解 在单调递增序列 a 中查找 x 或 x 的后继 在单调递增序列 a 中查找 x 或 x 的前驱 二分查找算法讲解 枚举查找也就是顺序查找。 实现原理就是逐个比较 a[0:n-1] 中的元素，直到找出元素 x 或搜索遍整个数组后确定 x 不在其中，或者说符合要求的元素在不在数组中。 最坏的情况下需要比较 N 次，时间复杂度是 O(n) 线性阶。 二分查找也就是折半查找。折半查找是将 N 个元素分成大致相同的两部分。选取中间元素与查找的的元素比较，或者与查找条件相比较，找到或者说找到下一次查找的半区。每次都将范围缩小至\\frac{1}{2}21 所以时间复杂度是 O(log2n），但是二分查找的前提是有序的，一般是从小到排列。 折半查找的基本思想： 在有序表中（low,high,low&lt;=high），取中间记录即 [(high+low)/2] 作为比较对象。 若给定值与中间记录的关键码相等，则查找成功 若给定值小于中间记录的关键码，则在中间记录的左半区继续查找 若给定值大于中间记录的关键码，则在中间记录的右半区继续查找 不断重复上述过程，直到查找成功，或所查找的区域无记录，查找失败。 二分查找的特征： 答案具有单调性； 二分答案的问题往往有固定的问法，比如：令最大值最小（最小值最大），求满足条件的最大（小）值等。 折半查找一般过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Step 1:假设存在一有序数组：下标[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ]数据[ 7 14 18 21 23 29 31 35 38 42 46 49 52 ] ↑ ↑ low=0 high=12 mid=(low+high)/2 mid=(0+12)/2 mid=6 [mid]=31&gt;14 所以选择左半部分操作： 此时令low不变，high=mid-1=5Step 2:下标[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ]数据[ 7 14 18 21 23 29 31 35 38 42 46 49 52 ] ↑ ↑ low=0 high=5 mid=(low+high)/2 mid=(0+6)/2 mid=3 [mid]=21&gt;14 所以选择左半部分操作： 此时令low不变，high=mid-1=2Step 3:下标[ 0 1 2 3 4 5 6 7 8 9 10 11 12 ]数据[ 7 14 18 21 23 29 31 35 38 42 46 49 52 ] ↑ ↑ low=0 high=2 mid=(low+high)/2 mid=(0+2)/2 mid=1 [mid]=14=14 找到答案操作： 返回下标 整数二分法常用算法模板 C++ 语言描述 12345678910111213141516171819202122// 在单调递增序列a中查找&gt;=x的数中最小的一个（即x或x的后继）while (low &lt; high)&#123; int mid = (low + high) / 2; if (a[mid] &gt;= x) high = mid; else low = mid + 1;&#125;// 在单调递增序列a中查找&lt;=x的数中最大的一个（即x或x的前驱）while (low &lt; high)&#123; int mid = (low + high + 1) / 2; if (a[mid] &lt;= x) low = mid; else high = mid - 1;&#125; Python 语言描述 Java 语言描述 此处我们先分整数的二分查找法的常用模版，关于实数的部分，我们后面再讲。 下面可能会有同学会疑问道：为什么采用这一套代码的而不是采用查找等于的 X？ 是因为这样的适用范围更广，当有 X 时这套代码就返回 X 的位置。如果没有 X，就返回 &lt;=x 的数中最大的一个或者 &gt;=x 的数中最小的一个。 分巧克力 2017 年省赛真题链接。 题目描述: 12345678儿童节那天有 K 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。切出的巧克力需要满足：1. 形状是正方形，边长是整数;2. 大小相同;例如一块 6x5 的巧克力可以切出 6 块 2x2 的巧克力或者 2 块 3x3 的巧克力。当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 要求输入: 1234567输入描述:第一行包含两个整数 N,K (1≤N,K≤1e5）。以下 N 行每行包含两个整数 Hi Wi (1≤Hi,Wi≤1e5)。输入保证每位小朋友至少能获得一块 1x1 的巧克力。 要求输出： 123输出描述:输出切出的正方形巧克力最大可能的边长。 样例: 123456789输入样例2 106 55 6输出样例2 运行限制: 12345678最大运行时间：1s最大运行内存：256M注意：1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…”的多余内容。2. 不要调用依赖于编译环境或操作系统的特殊函数。3. 所有依赖的函数必须明确地在源文件中4. 不能通过工程设置而省略常用头文件。 题目分析 简单思路，边长的最大规模为 100000；我们可以枚举出所有的情况。按从大到小的顺序进行切割，直到找到满足要求的巧克力边长。 在判断边长是否满足条件时：求一块长方形（h * w）最多被分成的正方形（len * len）巧克力个数为： 1cnt = (h / len) \\* (w / len) 但是使用朴素算法枚举时间复杂度 O(n)*O(n) =O(n2) 会超时，所以改用 2 分查找法，这找到符合要求的最大的一个。 即用在单调递增序列 a 中查找 &lt;=x 的数中最大的一个（即 x 或 x 的前驱）即可，原本这里的条件是 &lt;=x ，我们将其换成验证即可。 代码解答 C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100010;int n,k;int h[MAXN],w[MAXN];bool pd(int l)&#123; int sum=0; for(int i=0; i&lt;n; i++) &#123; sum+=(h[i]/l)*(w[i]/l); if(sum&gt;=k) &#123; return true; &#125; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0; i&lt;n; i++) cin&gt;&gt;h[i]&gt;&gt;w[i]; //找到二分查找的上界 int high=0; for(int i=0; i&lt;n; i++) &#123; high=max(high,h[i]); high=max(high,w[i]); &#125; // 二分下届由题意可得至少为1 int low=1; // 由于本题目就是求符合要求的Mid 值所以要将mid定义在二分查找外边 int mid=0; while(low&lt;high) &#123; mid = (low + high+1) / 2; if(pd(mid)) low=mid; else high = mid - 1;// cout&lt;&lt;low&lt;&lt;&quot; &quot;&lt;&lt;high&lt;&lt;endl; &#125; //因为low=high所以输出哪一个都一样 cout&lt;&lt;low; return 0;&#125; 查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。 Python 实现 Java 实现 M 次方根 题目描述: 123456789101112131415小A最近在学高等数学，他发现了一道题，求三次根号下27。现在已知，小 A 开始计算，1 的三次方得1，2 的三次方得 8，3 的三次方得 27，然后他很高兴的填上了 3。接着他要求 5 次根号下 164。然后他开始 1 的三次方得 1，2 的三次方得 8，3 的三次方得27...直到他算到了秃头，也没有找到答案。这时一旁的小 B 看不下去了，说这题答案又不是个整数。小 A 震惊，原来如此。作为程序高手的小 A，打算设计一个程序用于求解 M 次跟下N的值。但是由于要考虑精度范围，答案必须要保留 7 位小数，连三次根号下 27 都要掰手指的小 A 又怎么会设计呢。请你帮小 A 设计一个程序用于求解 M 次根号 N。数据范围：1&lt;= N &lt;= 1e5 1&lt;= M &lt;= 100且 M&lt;N 要求输入: 123输入描述:第一行输入整数 N 和 M，数据间用空格隔开。 要求输出： 123输出描述:输出一个整数，并保留 7 位小数。 样例: 1234567输入样例：27 3输出样例：3.000000 运行限制: 12345678最大运行时间：1s最大运行内存: 256M注意：1. 请严格按要求输出，不要画蛇添足地打印类似：“请您输入…” 的多余内容。2. 不要调用依赖于编译环境或操作系统的特殊函数。3. 所有依赖的函数必须明确地在源文件中。4. 不能通过工程设置而省略常用头文件。 题目分析 前面讲的都是整数二分，其实二分法还是可以用于实数。这个题目比较难，很多同学可能想不明白，想不明白就多读题，写写画画理解一下。这个题还有很多解法，现在告诉你了这道理用二分可以解答，请设计一个二分程序。 首先是这道题我们怎么下手： 根据前面的知识，我们要找到一个具有单调性的数列，去二分。这个题的关键是我们要去二分什么，这里可以二分的是 a^M 中的 a，所以我们要先想办法设计出用于处理实数二分的代码。 这里给大家两个模板，都可以大家选择一个使用即可： C++ 模版： 1234567891011121314151617181920212223242526272829//模版一：实数域二分，设置eps法//令 eps 为小于题目精度一个数即可。比如题目说保留4位小数，0.0001 这种的。那么 eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。//一般为了保证精度我们选取精度/100 的那个小数，即设置 eps= 0.0001/100 =1e-6while (l + eps &lt; r)&#123; double mid = (l + r) / 2; if (pd(mid)) r = mid; else l = mid;&#125;//模版二：实数域二分，规定循环次数法//通过循环一定次数达到精度要求，这个一般 log2N &lt; 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给 N 乘一个系数使得精度更高。 for (int i = 0; i &lt; 100; i++)&#123; double mid = (l + r) / 2; if (pd(mid)) r = mid; else l = mid;&#125; Python 模版 Java 模版 模板讲完了，然后我们就要考虑判定条件了，怎样判定是否存在满足大于平均值的区间。当然这个题你可以使用语言中自带开方软件，但是我们还是联系一下实数的二分代码。 关于判定条件，我们应该设计一个代码用于比较 a^m 和 N 的大小关系。 在我们代码中： 1234if (pd(mid)) r = mid;else l = mid; pd 成功的情况，一定是 pd 的 mid 符合条件，且小于 mid 的一定符合条件。因此我们要在大于 mid 中继续查找，找到更大的 mid。 所以我们可以设计出如下判定条件: 12345678910111213double pd(double a,int m)&#123; double c=1; while(m&gt;0) &#123; c=c*a; m--; &#125; if(c&gt;=n) return true; else return false;&#125; 代码解答 C++ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;iomanip&gt; //用于浮点数输出using namespace std;double n,l,r,mid;double eps=1e-8;bool pd(double a,int m)&#123; double c=1; while(m&gt;0) &#123; c=c*a; m--; &#125; if(c&gt;=n) return true; else return false;&#125;int main()&#123; int m; cin&gt;&gt;n&gt;&gt;m;//设置二分边界 l=0,r=n;//实数二分 while (l + eps &lt; r) &#123; double mid = (l + r) / 2; if (pd(mid,m)) r = mid; else l = mid; &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;l; //一般使用print //printf(&quot;%x.yf&quot;,n) //其中X是固定整数长度，小数点前的整数位数不够，会在前面补0 //y是保留小数位数，不够补零 //printf(&quot;%.7f&quot;,l); return 0;&#125; 查找上界这里可以直接输入的时候查询，这道题实际上是可以少次操作的，代码如下。 Python 实现 Java 实现 实验总结 二分的题目主要是必须要求是单调的，一般会有条件等字眼。做这种题目主要还是找到递增或者递减的序列，然后关于序列的判定条件。或者通过观察时间复杂度来看是否可以使用二分，二分法的题目相对来说比较明显，设计起来也比较简单，模板不用死记硬背，理解一下，很快就可以独立写出来。 贪心算法 贪心算法（Greedy algorithm），又称贪婪算法。是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而使得问题得到全局最优解。 贪心的算法的设计就是要遵循某种规则，不断地选取当前最优解的算法设计方法。这节实验将会通过多个问题的来讲解贪心算法。 知识点 贪心算法的基本概念 贪心算法的适用范围 贪心算法的设计步骤 贪心算法的题目讲解 贪心算法基本概念 贪心算法与枚举法的不同之处在于每个子问题都选择最优的情况，然后向下继续进行，且不能回溯，枚举法是将所有情况都考虑然后选出最优的情况。 贪心算法，在对问题求解时，不从整体考虑，而是采用一叶障目的选择方式，只选择某种意义上的局部最优解。并且，贪心算法是没有固定的模板可以遵循的，每个题目都有不同的贪心策略，所以算法设计的关键就是贪心策略的选择。 贪心算法有一个必须要注意的事情。贪心算法对于问题的要求是，所有的选择必须是无后效性的，即当前的选择，不能影响后续选择对于结果的影响。 贪心算法主要适用于最优化问题，如：MST 问题。有时候贪心算法并不能得到最优答案，但是能得到精确答案的近似答案。有时可以辅助其他算法得到不是那么精确的结果。 适用范围 符合贪心策略： 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。 所谓的贪心选择性质就是，该问题的每一步选择都在选择最优的情况下能够导致最终问题的答案也是最优。 或者说是无后效性，如果该问题的每一步选择都对后续的选择没有影响，就可以是应用贪心算法。 贪心算法的设计步骤 按照定义设计： 证明原问题的最优解之一可以由贪心选择得到。 将最优化问题转化为这样一个问题，即先做出选择，再解决剩下的一个子问题。 对每一子问题一一求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解 伪代码： 关于 Question Q： 1234567while(Q.hasNextStep)&#123; Select(Q.nowBestSelect); Q.NextStep&#125;Select(Q.nowBestSelect); 贪心相关题目讲解 我们在正式将题目前，聊一个大家都懂的常见的知识，也是一个常见的题目。 找零问题 题目如下： 12345假设商店老板需要找零 n 元钱。钱币的面额有：100 元、50 元、20 元、5 元、1 元、如何找零使得所需钱币的数量最少？注意：n 可能为 0，也能为几百元（别问，问就是来着里微信提现来了） 输入: 123456789输入解法:在第一行给出测试例个数 N。代表需要找零的钱数。输入样例：365 输出： 1234567891011输出解法 有 5 行输出数据，每一行输出数据输出找零的金额与数量，详情看样例。输出样例：100:350:120:05:31:0 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 关于这个题，如果是正常人都知道从大的钱开始找钱。这就是一种贪心的思想，将大问题转化为一个个小的子问题，每次选择最大的钱数使得总量最小。 其实再生活中贪心思想的例子还有很多，像是“自助餐“这种的都是贪心算法的印证。贪心算法其实离我们很近，掌握不会很困难的。 我们先看一下上一道题目的代码题解是什么。 答案解析： C++ 解法： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;//面值int t[5]=&#123;100, 50, 20, 5, 1&#125;;//张数int m[5];void change(int n)&#123; for(int i=0;i&lt;5;i++) &#123; m[i]=n/t[i]; n=n%t[i]; //print(&quot;%d&quot;,n); &#125;&#125;int main()&#123; int N; cin&gt;&gt;N; change(N); for(int i=0;i&lt;5;i++) &#123; printf(&quot;%d:%d\\n&quot;,t[i],m[i]); &#125;&#125; Python 解法 Java 解法 活动选择型问题之小 B 的宿舍 题目如下: 123456789101112131415161718192021小 B 的宿舍楼沿着走廊南北向的两边各有 200 个房间。如图所示：[房间1][房间3][房间5][房间7][房间9 ]...[房间399]---------------------------------------------- 走廊----------------------------------------------[房间2][房间4][房间6][房间8][房间10]...[房间400]最近，由于转专业和专业分流的原因，宿舍将迎来新的调整，以便组成新的班级后方便管理。但是由于走廊狭窄，走廊里只能通过两个搬运的物品（可以同向也可以反向），因此必须指定高效的搬运计划。老师给了每位同学下达了以下要求，让同学们体现收拾好行李，然后给每位同学 10 分钟的时间搬运。当房间 i 搬运行李到 j 时，i 与 j 之间的走廊都会被占用，但是可以容纳两个不同同学同时搬运。所以，10 分钟之内同一段走廊最多两个人同时搬运，不重叠的走廊也可以同时搬运。小 B 的老师是个数学老师，经过运筹学一通计算他得到了最优的搬运计划。虽然计划不唯一，但是最优值唯一，请问这个最短时间是多少？ 输入: 123456789101112131415161718192021输入解法:输入数据有 T 组测试例，在第一行给出测试例个数 T。每个测试例的第一行是一个整数 N（1≤N≤200)，表示要搬运行李的人数。接下来 N 行，每行两个正整数 s 和 t，表示一个人，将行李是从房间号码 s 移到到房间号码 t。输入样例:3410 2030 4050 6070 8021 32 200310 10020 8030 50 输出： 123456789输出解法 每组输入都有一行输出数据，为一整数 T，表示完成任务所花费的最小时间。输出样例:101020 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 该题属于贪心算法，因为它尽可能使搬运行李同时进行，以便使单独安排的搬运次数最少。这样用的时间最少，即所用最少时间为不能同时搬运行李的次数，进而转化为寻找某一段走廊使用次数最多（贪心标准），由于走廊可以同行 2 人，所以除 2，有余数再加 1 即可，即使最多的搬运次数，再乘以 10，即为最少搬运时间。 首先将二维问题转化成一维问题。 不难发现，相对应的两个房间其实是占用一段走廊的，我们可以将将房间号映射为走廊号，然后再考虑上面的解析。 答案解析： C++ 解法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int move[200];//搬运次数 int N;//每次搬运的起点和终点 int from, to; int maxAns=0; int T; cin&gt;&gt;T; while(T--) &#123; scanf(&quot;%d&quot;, &amp;N); memset(move, 0, sizeof(move)); for(int i = 0; i &lt; N; i++) &#123; scanf(&quot;%d%d&quot;, &amp;from, &amp;to);//将房间号映射为走廊号 from = (from - 1)/2; to = (to - 1)/2;//确保from&lt;to，C++使用：swap(from, to) if(from &gt; to) &#123; int temp = from; from = to; to = temp; &#125;//统计占用走廊情况，并统计最大值 for(int j = from; j &lt;= to; j++) &#123; move[j]++; maxAns=max(maxAns,move[j]); &#125; &#125; if(maxAns%2==1) maxAns=maxAns/2+1; else maxAns&gt;&gt;=1; //等价于/2 cout&lt;&lt;maxAns*10&lt;&lt;endl; &#125;&#125; Python 解法 Java 解法 可拆分背包问题之贪心的自助餐 题目如下: 123456789101112131415161718192021222324小 B 同学呢，想去吃自助餐，但是他是那种比较节俭的的人，既不想浪费食物，又想尽可能吃的贵一点，他于是私下里做了调查。小蓝餐厅的自助餐有 n 种食材，每种食材都有它的价格。而且也能估计出每一份的重量，所以他列了一个表格。红烧牛肉 30元 300g油闷大虾 8元 5g四喜丸子 4元 8g三文鱼 5元 3g排骨 18元 200g麻辣兔头 20元 120g高汤海参 40元 70g扇贝粉丝 8元 32g牛排 79元 240g...现在小 B 想知道在他到底最多吃多少钱的菜品。假设自助餐厅的菜品供应同样的菜品每个人只能取一份。小B的饭量假设为 C，单位为 g。现在请你设计一个程序帮助小 B 计算他的最多吃了多少钱。 输入: 1234567891011121314151617181920212223242526272829303132333435输入解法第一行输入 n C（0&lt;=n&lt;=1000）（0&lt;=C&lt;=10000）其中 n 为菜品数量，C 为小 B 的肚子容量。第二行输入两个数 V，W 第一个数 V[i] 是第 i 个菜品的价值（0&lt;=v[i]&lt;=10000） 第二个数 V[i] 是第 i 个菜品的质量（0&lt;=w[i]&lt;=10000）输入样例:20 10001 222 43123 21412 2123 43221 22322 1677 4934 7834 943 67721 3423 2312 56332 5621 99123 545389 3312 99923 88 输出： 1234567输出解法 输出一行数据，表示最大的价值，保留三位小数。输出样例：1204.114 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 可拆分背包的一般解法为： 这里有 n 种不同值 v[i] 和权重 w[i] 的对象（如果选择该对象的 w[i] 可以获得值 v[i]）。 你有一个容器来挑选它们。你可以根据自己的需要把它们分成任意大小的碎片。可以拾取的对象的最大重量给定为 w。请计算您能得到的最大值。 就像是这个题目，要想吃回本就要捡着贵的吃，但是贵只是一方面，人会饱，所以用价格除以质量所获的价格商才是贪心准则，应按照价格商优先进行选取。 于是这个题，就要用的我们之前学的知识了。这里因为要整体排序，所以要先创建一个类，然后自定义 cmp 函数，在使用 sort 排序。 答案解析： C++ 解法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;iomanip&gt;using namespace std;//需要一个结构体，通过性价比，能够查找到重量和价值。//做一个排序，需要将性价比由高到底排序，排序的过程中重量和（价值）要对应上struct Food&#123; double w; double v; double aver;&#125;;//C++一般用 struct，因为默认都是public的bool cmp(Food a, Food b)&#123; return a.aver &gt; b.aver; //助记大于号就是从大到小排序，小于号就是从小到大排序&#125;int main()&#123; Food foods[1009]; int n; double C; double Value = 0; cin &gt;&gt; n &gt;&gt; C; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; foods[i].v&gt;&gt;foods[i].w; //求性价比 foods[i].aver = foods[i].v / foods[i].w; //cout &lt;&lt; foods[i].aver &lt;&lt; endl; &#125; //性价比排序 sort(foods, foods + n, cmp); //当背包（肚子）能装下所有物品（菜）时，直接输出所有的物品（菜品）价值之和 // int sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += foods[i].w; &#125; if (sum &lt;= C) &#123; for (int j = 0; j &lt; n; j++) Value += foods[j].v; //V = floor(V * 1000.0) / 1000.0; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt;Value &lt;&lt; endl; return 0; &#125; //当背包（肚子）不能装下所有物品时应该由性价比的顺序，选择装入的物品 for (int i = 0; i &lt; n; i++) &#123; if (foods[i].w &lt;= C) &#123; Value =Value + foods[i].v; C = C - foods[i].w; &#125; else &#123; //直接将剩余的C加入即可 Value =Value + C * foods[i].aver; C = 0; &#125; if (C == 0) break; &#125; //V = floor(V * 1000.0) / 1000.0; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt;Value &lt;&lt; endl; return 0;&#125; Python 解法 Java 解法 实验总结 贪心算法的最主要的特征就是无后效性，就像是自助餐那个题目，如果说吃了某一样食物，就不能吃另一个食物了，那么这就有了后效性，那就不能使用贪心算法进行解决问题了。 本节课举了三个贪心算法的例子进行讲解，贪心算法是算法竞赛中最入门的算法。没接触过感觉很深奥，接触过了也就那样，简单的贪心伸伸手就可以写出来，其实非常简单，大家也不要过分的担心。 蓝桥杯真题精讲之一 在前面实验中，我们为了快速提高对每一个实验的知识点快速理解，所做的实战题目都是使用对应知识点解答的题目，导致题目知识点或者说用到的算法比较单一，实战意义还不充足。 本节实验主要是融汇贯穿前面我们学习过的知识点，通过 4 道蓝桥杯真题进行实战讲解，带领大家学以致用。 知识点 2020 年蓝桥杯国赛真题–答疑 2012 年蓝桥杯省赛真题–鲁卡斯队列 2015 年蓝桥杯模拟真题–金币 最大化股票交易的利润 答疑 本题出自于 2020 年蓝桥杯国赛真题。 题目链接 题目描述 123456789101112有 n 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。 一位同学答疑的过程如下： 首先进入办公室，编号为 i的同学需要 si 毫秒的时间。 然后同学问问题老师解答，编号为 i 的同学需要 ai 毫秒的时间。 答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可 以忽略。 最后同学收拾东西离开办公室，需要 ei 毫秒的时间。一般需要 10 秒、20 秒或 30 秒，即 ei 取值为 1000，20000 或 30000。一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群 里面发消息的时刻之和最小。 输入 1234567891011121314输入描述:输入第一行包含一个整数 n，表示同学的数量。接下来 n 行，描述每位同学的时间。其中第 i 行包含三个整数 si, ai, ei，意义如上所述。其中有 ，1≤n≤1000，1≤si≤60000，1≤ai≤106，ei∈10000,20000,30000。即 ei 一定是 10000、20000、30000之一。输入样例:310000 10000 1000020000 50000 2000030000 20000 30000 输出 1234567输出描述:输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。输出样例:280000 运行限制 12最大运行时间：1s最大运行内存: 128M 题目解析 本题是一个贪心问题，要想使得所有的时刻之和最小，就要使得每一个时刻尽可能少，根据题目我们可以得到每位同学的时刻=每位同学的等待时间+进门时间+答疑时间。 由于答疑时间是已知的，要使得每位同学的时刻最小，那么就要使得每位同学的等待时间最小。如何使得等待时间最小的呢？ 如果这么考虑这道题是做不出来的，我们应该考虑的是使得每位同学等待的时间和最小。 123每位同学的时刻 = 每位同学的等待时间 + 进门时间 + 答疑时间 = 前一位同学的等待时间 + 前一位同学的进门时间 + 前一位同学的答疑时间 + 前一位同学的收拾东西的时间 + 进门时间 + 答疑时间 设第 i 位同学的等待时间为 Ti，则有： 第一位同学等待时间 S1=T1=0 -----（1） 第二位同学等待时间 S2=T1+T2=T2 -----（2） 第三位同学等待时间 S3=T1+T2+T3=T2+T3 -----（3） … 那么第 N 位同学等待时间 Sn=T1+T2+T3+T4+T5+…+Tn-1 -----（n） 将 1 到 n-1 式带入 n 式得， 1Sn=T1*n+T2\\*(n-1)+T3\\*(n-1)+....+Tn 由此可知前面的系数是最大的，所以要使前面的时间最小，于是得出了贪心策略进而解决问题。 使用贪心算法后，我们可以得出结论是，每位同学的等待时间（前一位同学的等待时间 + 前一位同学的进门时间 + 答疑时间 + 前一位同学的收拾东西的时间）最小。 但是如果相同的时候，两者前后关系是什么？ 因为是答疑结束后就发消息，而不是出门之后发消息，所以两者存在前后关系，谁先答疑结束谁就先执行。 我们还要进一步考虑，如果进门时间+答疑时间相同，即答疑同时结束，既然答疑同时结束，那么谁先谁后结果是相同的，所以不用继续考虑，到此，贪心策略完整的生成。 即：我们选取最小的进门时间+答疑时间+收拾东西时间之和最小的人在前，且当进门时间 + 答疑时间 + 收拾东西时间的和相同时，选择最小的进门时间 + 答疑时间。 答案解析 C++ 描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n;struct Stu&#123; int inD; //进门所需时间 int answQ; //答疑所需时间 int outD; //收拾东西所需时间 int sum1; //贪心准则1=进门时间+答疑时间+收拾东西时间 int sum2; //贪心准则2=进门时间+答疑时间+收拾东西时间&#125; stu[N];//贪心准则bool cmp(Stu st1, Stu st2)&#123; if(st1.sum1 != st2.sum1) return st1.sum1 &lt; st2.sum1; else return st1.sum2 &lt; st2.sum2;&#125;int main()&#123; //输入数据 scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i ++ ) &#123; scanf(&quot;%d%d%d&quot;, &amp;stu[i].inD, &amp;stu[i].answQ, &amp;stu[i].outD); //标准生成 stu[i].sum1= stu[i].inD + stu[i].answQ+stu[i].outD; stu[i].sum2 = stu[i].inD + stu[i].answQ; &#125; //贪心过程及结果计算 sort(stu, stu + n, cmp); long long res = 0, t = 0; for(int i = 0; i &lt; n; i ++ ) &#123; t += stu[i].sum2; res += t; t += stu[i].outD; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; Python 描述 Java 描述 鲁卡斯队列 本题出自 2012 年蓝桥杯省赛真题。 题目链接 题目描述: 123456789101112131415本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。黄金分割数 0.618 与美学有重要的关系。舞台上报幕员所站的位置大约就是舞台宽度的 0.618 处，墙上的画像一般也挂在房间高度的 0.618 处，甚至股票的波动据说也能找到 0.618 的影子....黄金分割数是个无理数，也就是无法表示为两个整数的比值。0.618 只是它的近似值，其真值可以通过对 5 开方减去 1 再除以 2 来获得，我们取它的一个较精确的近似值：0.618034 。有趣的是，一些简单的数列中也会包含这个无理数，这很令数学家震惊！1 3 4 7 11 18 29 47.... 称为“鲁卡斯队列”。它后面的每一个项都是前边两项的和。如果观察前后两项的比值，即：1\\3 3\\4 4\\7 7\\11 11\\18...会发现它越来越接近于黄金分割数！你的任务就是计算出从哪一项开始，这个比值四舍五入后已经达到了与 0.618034 一致的精度。请写出该比值。格式是：分子/分母。比如：29/47。 输入: 1234567输入描述:无输入样例:无 输出： 1234567输出描述:输出一个整数，表示该比值。格式是：分子/分母。比如：29/4729/4729/47。输出样例:无 运行限制: 12最大运行时间：1s最大运行内存: 128M 题目解析： 这道题是基于前缀和的模拟题，我们按照要求进行模拟即可。 答案解析： C++ 描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;double a[51] = &#123; 1,3 &#125;;void init()&#123; for (int i = 2; i &lt; 50; i++) &#123; a[i] = a[i - 1] + a[i - 2]; &#125;&#125;string comp()&#123; for (int i = 0; i &lt; 50; i++) &#123; double b = a[i] / a[i + 1]; if (abs(b - 0.618034) &lt;= 0.000001) &#123; stringstream s1; s1 &lt;&lt; a[i] &lt;&lt; &quot;/&quot; &lt;&lt; a[i + 1]; string s; s1&gt;&gt;s; return s; &#125; &#125;&#125;int main()&#123; init(); string ans=comp(); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; stringstream 类： 这里给出的 C++ 代码描述，会写的相对繁琐一些，目的是为了给大家讲一种新的字符串使用技巧。C++ stringstream 类是一种十分有用的类，特别是当我们需要在程序中使用字符串和数字数据互相转换的时候。 要想在程序中使用 stringstream 类，我们需要在源程序文件中包含头文件include&lt;sstream&gt;。 stringstream 对象的使用方法与 cout 对象和 cin 的使用方法基本相同。&gt;&gt; 这个符号就很形象，比如： cin&gt;&gt;a 可以理解为将数据流流入到 a 中 cout&lt;&lt;a 则是将数据流流入到 cout 中，归根结底还是数据流 可能对于底层的描述不太恰当，但是大家记住 &gt;&gt; 指向谁，则是将数据给到谁，stringstream 当成 cin cout 用即可。在我上面给出的代码中，大家可以看到我还将数据还进行了转化处理，在 C++ 中数据类型的转化使用 stringstream 也是不错的选择。 Python 描述 Java 描述 金币 本题出自 2015 年蓝桥杯模拟真题。 题目链接 题目描述: 12345678910111213国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币......；这种工资发放模式会一直这样延续下去：当连续 N 天每天收到 N 枚金币后，骑士会在之后的连续 N+1 天里，每天收到 N+1 枚金币。请计算在前 K 天里，骑士一共获得了多少金币。 输入: 1234567输入描述:输入只有 1 行，包含一个正整数 K （1≤K≤104），表示发放金币的天数。输入样例:6 输出： 1234567输出描述:输出只有 1 行，包含一个正整数，即骑士收到的金币数。输出样例:1000 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 这道题是前缀和的变种，变种的方式可以通过模拟解决，时间复杂度为 O(N2)，但是题目的范围为 1e4，不超时方法可行。 答案解析 C++ 描述： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int comp(int n)&#123; int sum = 0; int day = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; sum += i; day += 1; if (day == n) return sum; &#125; &#125; return sum;&#125;int main()&#123; int n; cin&gt;&gt;n; int ans=comp(n); cout&lt;&lt;ans;&#125; Python 描述 Java 描述 最大化股票交易的利润 本题是来自蓝桥云课题库中的模拟题。 -题目链接 题目描述: 1234567实现一个算法寻找最大化股票交易利润的策略。介绍如下：- 股票价格每天都在变化，以数组的索引表示交易日，以数组的元素表示每天的股票价格。- 可以通过买入和卖出获得利润。一天只能进行一次买入或卖出操作，一次买入加卖出操作称为一次交易次数。- 你只能交易一次，求使得利润最大的交易策略。 输入: 123456789101112输入描述:第一行为数字 N，表示共有 N 天。第二行为 N 个数字 Ai，表示每天的股票价格。其中，1≤N,Ai≤1e4。输入样例:82 5 6 1 4 3 1 3 输出： 1234567输出描述:输出一行，为交易一次的最大利润（有可能利润为负）。输出样例:4 运行限制: 12最大运行时间：1s最大运行内存: 128M 题目解析： 这个题目是个模拟题目，按照题目要求即可。 这个题目获得最大利润的方式，就是存在 A，B 两天，A 在 B 前一天，使得 B—A 的值最大。 答案解析： C++ 描述 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int a[100005]; int n; cin&gt;&gt;n; int mini=-0x3f3f3f3f;//一个常用的极小值 for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0; i&lt;n-1; i++) &#123; for(int j=i+1; j&lt;n; j++) &#123; int t=a[j]-a[i]; if(mini&lt;t) &#123; mini=t; &#125; &#125; &#125; cout&lt;&lt;mini; return 0;&#125; Python 描述 Java 描述 实验总结 我们复习了之前的讲的几个知识点，然后我们又讲了几道题目，希望大家能够发散思维，不要局限方式方法，能做出来即可。 蓝桥杯真题精讲之二 实验介绍 本节实验，我们将延续上一节实验的真题精讲，继续继续分析蓝桥杯真题，通过精讲，让大家对学过的知识点达到学以致用。 知识点 2021 年蓝桥杯模拟赛真题-谈判 优先队列 2008 年 NOIP 普及组真题-排座椅 谈判 题目链接 题目描述: 1234567题目描述在很久很久以前，有 n 个部落居住在平原上，依次编号为 1 到 n。第 i 个部落的人数为 ti。有一年发生了灾荒。年轻的政治家小蓝想要说服所有部落一同应对灾荒，他能通过谈判来说服部落进行联合。每次谈判，小蓝只能邀请两个部落参加，花费的金币数量为两个部落的人数之和，谈判的效果是两个部落联合成一个部落（人数为原来两个部落的人数之和）。 输入: 12345输入的第一行包含一个整数 nnn，表示部落的数量。第二行包含 nnn 个正整数，依次表示每个部落的人数。其中，1≤n≤1000，1≤ti≤1e4。 输出： 1输出一个整数，表示最小花费。 输入输出样例 123456789示例 1输入49 1 3 5输出31 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 这题是一个贪心问题，要想使得花费金额之和最小，就要使得每一次的花费尽可能少。 根据题目我们可以得到，合成的新部落的花费=人数为原来两个部落的人数之和。 如何使得等待时间最小的呢？ 如果这么考虑这道题是做不出来的，应该考虑的是使得每位同学等待的时间和最小。我们回忆一下答疑拿到题目： 12345678910111213141516171819第一位同学等待时间 S1=T1=0 -----（1）第二位同学等待时间 S2=T1+T2=T2 -----（2）第三位同学等待时间 S3=T1+T2+T3=T2+T3 -----（3）......第 N 位同学等待时间 Sn=T1+T2+T3+T4+T5+...+Tn-1 -----（n）将 1 到 n-1 式带入 n 式得Sn=T1*n+T2\\*(n-1)+T3\\*(n-1)+....+Tn由此可知前面的系数是最大的，所以要使前面的时间最小。于是得出了贪心策略进而解决问题。此时贪心的除了结论是每位同学的等待时间(前一位同学的等待时间+前一位同学的进门时间+答疑时间+前一位同学的收拾东西的时间)最小。 这道题目还是按照人数排序吗，然而不是这样的，我们看一组样例： 1234567891011121314151617181920212223242526272829303132333435363743 4 5 6如果按照顺序组合的话：3+4=77 5 67+5=1414 614+6=20最终花费：7+14+20=41其实答案应该是：3 4 5 63+4=77 5 6再次排序5 6 75+6=1111 711+7=18最终花费为 7+11+18=36 所以这里贪心原则是维护最小的值，但是每次都会进行更新，每次更新后就要重新排序，时间复杂度是 Nlog(n) 的复杂度，这里是可以通过的，当然我们也可以使用优先队列解题。 优先队列的使用方式跟队列是一模一样的，优先队列会自动进行排序而已。 普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出（first in, largest out）的行为特征。通常采用堆数据结构来实现。 C++中的优先队列： 首先要包含头文件 #include&lt;queue&gt;，他和 queue 不同的就在于我们可以自定义其中数据的优先级，让优先级高的排在队列前面，优先出队。 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。 常用的成员函数: top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) emplace 原地构造一个元素并插入队列 pop 弹出队头元素 swap 交换内容 队列的定义有两种： 1234//升序队列，小顶堆priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列，大顶堆priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q; Python 优先队列 Java 优先队列 简单排序答案 这个题我们会采取两种解题策略，一种是简单的多次排序，另一种就是上面讲的优先队列。 C++ 描述： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int cnt=0,k; vector&lt;int&gt; t; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;k; t.push_back(k); &#125; while(t.size()&gt;1) &#123; //排序 sort(t.begin(),t.end()); //取出前两个值 int k=t[0]+t[1]; //答案求和 cnt+=k; //删除前两个利用过的值 t.erase(t.begin()); t.erase(t.begin()); //将产生的新值加入集合 t.push_back(k); &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; Python 描述 Java 描述 优先队列答案 C++ 描述： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int n,cnt=0; priority_queue&lt;int&gt;pq; //默认是大顶堆，从大到小排序 cin&gt;&gt;n; for(int i=0; i&lt;n; ++i) &#123; int a; cin&gt;&gt;a; pq.push(-a); //存入负值，从小大排序 &#125; if(pq.size()==1) &#123; cout&lt;&lt;-pq.top(); &#125; else &#123; while(pq.size()!=1) &#123; int x=pq.top(); pq.pop(); int y=pq.top(); pq.pop(); pq.push(x+y); cnt+=-x-y; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125; Python 描述 Java 描述 这道题的做法，变成了一种数据结构叫做哈夫曼树，后面的课程我们会讲到。 排座椅 题目链接 题目描述: 123456789上课的时候总有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 D 对同学上课时会交头接耳。同学们在教室中坐成了 M 行 N 列，坐在第 i 行第 j 列的同学的位置是（i，j），为了方便同学们进出，在教室中设置了 K 条横向的通道，L 条纵向的通道。于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了两个会交头接耳的同学，那么他们就不会交头接耳了。请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生对数最少。 输入: 12345输入第一行，有 5 各用空格隔开的整数，分别是 M，N，K，L，D（2≤N，M≤1000，0≤K&lt;M，0≤L&lt;N，D≤2000）。接下来 D 行，每行有 4 个用空格隔开的整数，第 i 行的 4 个整数 Xi，Yi，Pi，Qi，表示坐在位置 (Xi,Yi)与 (Pi,Qi) 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。输入数据保证最优方案的唯一性。 输出： 12345输出共两行。第一行包含 K 个整数，a1,a2,⋯aK，表示第 a1a_1a1 行和 a1+1a_1+1a1+1 行之间、第 a2 行和第 a2+1行之间、…、第 aK 行和第 aK+1 行之间要开辟通道，其中 ai&lt;ai+1，每两个整数之间用空格隔开（行尾没有空格）。第二行包含 L 个整数，b1,b2,⋯bk，表示第 b1 列和 b1+1 列之间、第 b2 列和第 b2+1 列之间、…、第 bL 列和第 bL+1 列之间要开辟通道，其中 bi&lt;bi+1，每两个整数之间用空格隔开（行尾没有空格）。 输入输出样例： 12345678910111213示例 1输入4 5 1 2 34 2 4 32 3 3 32 5 2 4 输出22 4 运行限制: 12最大运行时间：1s最大运行内存：128M 题目解析： 样例说明： 上图中用符号 *、※、+ 标出了 3 对会交头接耳的学生的位置，图中条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。 首先这道题是说前后左右有交头接耳的同学，我们通过设置设置了 K 条横向的通道，L 条纵向的通道使得交头接耳的同学组数最少。 本题的主要算法为贪心，要使上课时交头接耳的学生对数最少，每条通道的划分应该使得分开的交头接耳同学的对数最多。 因此我们可以使用桶排序解决这个问题，通过定义一系列的桶来记录每条通道的交头接耳的学生对数。 关于桶排序的过程： 我们先定义两个数组 x,y。 x[1] 表示如果在第一列与第二列中间划分过道能够分开几组说话的同学，x[2] 则是第二列与第三列… 直到 x[n-1]。 同理，y[1] 表示第一行与第二行，y[2] 表示第二行与第三行，直到 y[m-1]。 如果纵坐标相同，即这两个同学在一列，那么设两个同学横坐标分别为 a,b。 a 和 b 之间一定存在着大小关系，如果 a\\&lt;b 那么根据题目可以知道 a+1=b，那么 a 与 b 之间通道的编号就是 a。 同理,如果横坐标相同，即这两个同学在一行，那么设两个同学纵坐标分别为 a,b。 那么，a 和 b 之间一定存在着大小关系，如果 a\\&lt;b 那么根据题目可以知道 a+1=b，那么 a 与 b 之间通道的编号就是 a。 这样我们就能进行桶排序，并且经过排序过后，就可以在横向通道和纵向通道中找到前 K 和前 L 个即可，最后输出答案。 需要注意的是， 123第一行包含 K 个整数，a1,a2,⋯aK，表示第 a1a_1a1 行和 a1+1a_1+1a1+1 行之间、第 a2 行和第 a2+1 行之间、…、第 aK 行和第 aK+1 行之间要开辟通道，其中 ai&lt;ai+1，每两个整数之间用空格隔开（行尾没有空格）。第二行包含 L 个整数，b1,b2,⋯bk，表示第 b1 列和 b1+1 列之间、第 b2 列和第 b2+1 列之间、…、第 bL 列和第 bL+1 列之间要开辟通道，其中 bi&lt;bi+1，每两个整数之间用空格隔开（行尾没有空格）。 所以输出需划分的通道时，要先将通道按编号由小到大排序后再输出 。 答案解析： C++ 描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;const int MAXN= 1001;int x[MAXN]; //横坐标桶int y[MAXN]; //纵坐标桶int c[MAXN];int o[MAXN]; int main()&#123; int M, N, K, L, D; cin &gt;&gt; M &gt;&gt; N &gt;&gt; K &gt;&gt; L &gt;&gt; D; int xi, yi, pi, qi; while (D--) &#123; cin &gt;&gt; xi &gt;&gt; yi &gt;&gt; pi &gt;&gt; qi; if (xi == pi) //横坐标相同 &#123; y[min(yi, qi)]++; &#125; else //纵坐标相同 &#123; x[min(xi, pi)]++; &#125; &#125; //两重循环找出前K大的横坐标值 for (int i = 1; i &lt;= K; i++) &#123; int maxn = -1; int p; for (int j = 1; j &lt; M; j++) &#123; if (x[j]&gt;maxn) &#123; maxn = x[j]; p = j; &#125; &#125; x[p] = 0; c[p]++; &#125; //两重循环找出前L大的横坐标值 for (int i = 1; i &lt;= L; i++) &#123; int maxn = -1; int p; for (int j = 1; j &lt; N; j++) &#123; if (y[j]&gt;maxn) &#123; maxn = y[j]; p = j; &#125; &#125; y[p] = 0; o[p]++; &#125; for (int i = 0; i&lt;MAXN; i++) &#123; if (c[i]) printf(&quot;%d &quot;, i); &#125; printf(&quot;\\n&quot;); for (int i = 0; i&lt;MAXN; i++) &#123; if (o[i]) printf(&quot;%d &quot;, i); &#125; return 0;&#125; Python 描述 Java 描述 实验总结 这节课我们围绕着贪心展开，讲了排序，用到了 Vector、桶排序，可见在真正的竞赛中，像这样各种知识的混着出题，才是常见的。单一知识点出题，我们称作签到题，就是所有人都会做的。当然在蓝桥杯省赛中，能够将前面的知识学会学好，省二是没有问题，想要冲击更高的奖项，基础篇只是打好了基础，后面的课程会带你认识更多的算法，体验算法之美。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[]},{"title":"模块一 教育基础知识和基本原理——第一章 教育与教育学","slug":"教资/模块一 教育基础知识和基本原理/第一章 教育与教育学","date":"2022-03-20T12:36:20.872Z","updated":"2022-05-18T15:33:29.302Z","comments":true,"path":"2022/03/20/教资/模块一 教育基础知识和基本原理/第一章 教育与教育学/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/20/%E6%95%99%E8%B5%84/%E6%A8%A1%E5%9D%97%E4%B8%80%20%E6%95%99%E8%82%B2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%99%E8%82%B2%E4%B8%8E%E6%95%99%E8%82%B2%E5%AD%A6/","excerpt":"","text":"教育的含义 广义的教育指：凡是增进人们的知识和技能，影响人们的思想和品德的活动，广义的教育包括学校教育、家庭教育和社会教育 狭义的教育指：教育者根据一定的社会或阶级要求，遵循受教育者身心发展的规律，有目的、有计划、有组织地对受教育者身心施加影响，把他们培养成一定社会或阶级需要的人的活动，狭义的教育指“学校教育” 辨析题步骤 1.判断对错 2.分析题干中关键词的含义 3.分析关键词中的逻辑关系（冲突点）并加以分析解释 教育的属性 教育的本质属性 教育是有目的地培养人的社会活动，是教育区别于其他事物现象的根本特征，是教育的质的规定性 教育的社会属性 历史性：古今不同 ； 继承性：古今相同 永恒性：与人类社会共始终； 长期性：十年树木，百年树人 生产性：教育与生产劳动相结合 阶级性：教育要反应社会阶级的内容 教育的相对独立性 教育具有自身的继承关系（独立） 教育要受其他社会意识形态的影响（相对） 教育与政治经济发展不平衡（百家争鸣、文革） 教育的功能 教育的个体功能 促进功能：个体社会化和个体化 个体谋生和享用功能 个体发展的负向功能（应试教育） 教育的社会功能 社会流动功能：社会成员通过教育能够在不同的社会区域、层次、岗位、组织之间调动，以充分发挥特长，展现才能，实现抱负 文化传递功能：教育作为培养人的活动，以文化为中介，通过教育者和受教育者的共同活动实现文化传承 社会改造功能：教育是改造社会和推进社会进步的重要手段 人口控制功能：教育对社会人口数量和质量的提高所具有的作用 教育的起源 神话起源说 —— 不老神话朱熹（不正确最古老；神话起源说；朱熹） 生物起源说 —— 本能生利息(西)（生存竞争的本能就是教育的基础；生物起源说；利托尔诺和沛西·能） 心理起源说 —— 心理仿孟禄（心理起源说；儿童对成人无意识的模仿；孟禄） 劳动起源说 —— 米凯爱劳动（米丁斯基和凯洛夫；中国认为最科学合理；劳动起源说） 学校产生的条件 社会生产力水平的提高 脑力劳动和体力劳动的分离 国家机器的产生 文字的产生和发展 古代教育发展 中国古代教育的发展 夏学校，周六艺 战国兴百家，仲舒兴儒术 隋科举，宋理学 四书五经成经典，明代迂腐八股文 科举清末已废除 原始社会：教育和劳动相结合（打猎、生火……） 奴隶社会：夏学校 封建社会：春秋战国开始–&gt;秦大一统 世界古代教育发展 古埃及：宫廷学校、职官学校、文士学校 —— 以僧为师、以吏为师 印度：寺院学府 希腊：雅典 —— 政治家和商人；斯巴达 —— 军人和武士 西欧中世纪：教会学校(七艺)、骑士教育和宫廷学校 七艺：文法、修辞、辩证法、算数、几何、天文、音乐 古代的教学思想 中国古代教育思想 《论语》 孔子及其弟子的言论记录 教育对象：有教无类 教育目的：学而优则仕 教育方法：启发诱导（“不愤不启，不悱不发”，“学而不思则罔，思而不学则殆”） 教育内容：六艺六经 师生关系：尊师爱生 因材施教 《学记》 世界上最早的教育学专著 “教学相长”的教学原则 “启发诱导”的教学原则（“道而弗牵，强而弗抑，开而弗达”） 循序渐进（“学不躐lie等”，”不陵节而施“）–&gt; 遵循学生心理发展水平 长善救失（优点弥补缺点） 藏息相辅（不能死记硬背，要将课堂上老师讲的和自己的理解相结合） 师生关系：师严而道尊 西方古代教育思想 苏格拉底：问答法（产婆术） 柏拉图：“知识即回忆”，《理想国》 亚里士多德：“教育要遵循自然”，《政治学理论》 昆体良：《论演说家的教育》(《雄辩术原理》) --&gt; 西方第一部最早的教育学专著 教育学的产生和发展 教育学的独立 培根首提出，纽斯来实现，康德首讲授，巴特去规范，杜威来改变 培根首次提出将教育学作为独立的学科 夸的独立大班泛，教学直系巩自力 夸美纽斯认为“教师是太阳底下最光辉的职业”，教育学之父 《大教学论》是教育学走上独立发展道路的标志 《大教学论》 泛智主义、班级授课制 教学原则：直观性、系统性、量力性、巩固性 教育要适应自然 洛克：《教育漫话》，“白板说”，绅士教育 --&gt; 绅士洛克话白板 卢梭：《爱弥儿》，倡导自然教育和儿童本位的教育 康德：教育学作为课程在大学中讲授 斐斯泰洛奇：“教育心理学化” 规范教育学的形成与发展 赫的普教传规范，一原则二基础三中心四阶段 赫尔巴特：传统教育学派代表人(应试教育)，现代教育学之父 《普通教育学》 《普通教育学》标志着规范教育学的建立 一原则二基础三中心四阶段 教育性教学原则 建立在心理学和伦理学基础上 以教师、教材、课堂三中心 明了、联想、系统、方法(巩固) 杜威： 《民主主义与教育》(素质教育) 新三中心：学生/儿童、经验、活动 教育的本质：教育即生活…… 教育原则：在做中学（实践出真知） 教育学在当代的新发展 姆有掌握目标，纳来发现结构，瓦根找范例，高度赞发展，巴班最优化，全面和谐是斯基 苏联 赞可夫 “高难度，高速度”教学 赞可夫 《教育与发展》以一般发展为出发点 美国 布卢姆 掌握学习理论 《教育目标分类学》 教学目标：认识、情感和动作机能 布鲁纳 发现学习理论(心理学) 结构主义教学理论 《教育过程》 苏霍姆林 全面和谐的教育思想 著作被称为活的教育学 瓦根·舍因 范例教学理论 巴班斯基 《教学过程最优化》 马克思主义教育学 克鲁普斯卡娅：《国民教育和民主主义》是世界上第一位运用马克思主义观点探讨教育问题的教育家 加里宁：《论共产主义教育和教学》“教师是人类灵魂的工程师” 马卡连柯：《论共产主义教育》、《教育诗》(集体主义教育思想) 凯洛夫：《教育学》世界公认的第一部马克思主义的教育专著，也是我国首次采用的教育学用书；劳动起源说 中国近代教育家的思想 蔡元培：提倡美育(“以美育代宗教”) 陶行知：教学做合一 杨贤江：《新教育大纲》我国第一部用马克思主义观点分析教育问题的著作 《国民教育和民主主义》是世界；《新教育大纲》是中国","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"教育知识与能力","slug":"教育知识与能力","permalink":"https://zhang0224gz.github.io/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/"}]},{"title":"《计算机网络》——第一章 概述","slug":"笔记/计算机网络/第一章 概述","date":"2022-03-07T14:44:31.675Z","updated":"2022-04-03T06:15:11.501Z","comments":true,"path":"2022/03/07/笔记/计算机网络/第一章 概述/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/07/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/","excerpt":"","text":"21世纪的重要特征：数字化、网络化、信息化；21世纪是一个以网络为核心的信息时代。 三大类网络：电信网络、有线电视网络、计算机网络 Internet中文译名：因特网、互联网(Internet是由数量极大的各种计算机网络互联起来的) 互联网的基本特点：连通性和共享 “互联网+”是一种新的经济形态：互联网+各个传统行业 负面影响：计算机病毒、恶意攻击 互联网概述 -&gt; 计算机网络、互联网、主机 计算机网络(简称网络)是由若干**节点(node)和连接这些节点的链路(link)**组成 把分布在不同地理位置的独立自主的计算机系统用通信线路连接起来。在通行协议控制下实现资源共享的新型计算机系统 组成：若干主机、一个通信子网、一系列协议 互联网(网络的网络network of network)有多个网络通过一些路由器相互连接起来，构成一个覆盖范围更大的计算机网络，即将原本孤立的网络联结起来 主机(host)是与网络相连的计算机 --&gt; 边缘部分，给用户提供服务(终端：使用服务，像手机) 网络把许多计算机连接在一起，而互联网则把许多网络通过一些路由器(路由器是特殊的计算机，但它不是主机)连接在一起。 主机在边缘部分是为用户进行信息处理的，和其他主机通过网络交换信息；路由器是用来转发分组，即进行分组交换的 互联网基础结构三个发展阶段 -&gt; internet/Internet、ISP 单个网络ARPANET(美国DOD国防部)同互联网发展的过程 internet互连网是一个通用名词，泛指由多个计算机网络互联而成的计算机网络。通行协议是任意的。 Internet互联网/因特网是一个专用名词，指当前全球最大、最开放的、由众多网络相互连接而成的特定互连网。通行协议是TCP/IP协议族，其前身是美国ARPANET 建成三级结构的互联网：主干网、地区网、校园网/企业网 全球范围的多层次ISP结构的互联网 ISP互联网服务提供商(Internet Service Provider)，如中国电信、联通、移动，从互联网管理机构申请到许多IP地址，且拥有通信线路以及路由器等连网设备。用户需向ISP缴纳费用租用IP地址进行上网。 IXP互联网交换点(Internet eXchange Point)，为更快的转发分组和高效利用网络资源 WWW万维网(World Wide Web)，方便广大非网络专业人员对网络的使用 互联网的标准化工作 互联网在指定其标准的最大特点是面向公众，所有标准都是以RFC的形式在互联网上发表 RFC请求评论(Request For Comments) 工程部和学术部通过收集对协议的评论 --&gt; 标准 -&gt; RFC 互联网的组成 -&gt; 边缘部分(客户-服务器方式、P2P) 边缘部分 ：由所有连接在互联网上的主机组成，用户直接使用/接触的(向用户提供服务的)，用来进行通信和资源共享 计算机通信是计算机中的进程(即运行着的程序)之间的通信。计算机网络采用的通信方式是客户-服务器方式、P2P （1）客户-服务器方式 服务器被动等待，客户主动发出任务(正常) 客户是服务器请求方，服务器是服务提供方。服务器请求方和服务提供方都要使用网络核心部分所提供的服务。 例子：发邮件、网上查资料 以上所说的客户和服务器本来都指的是计算机进程(软件) 使用计算机的人是计算机的“用户”(user) 运行客户程序的机器称为client(客户机/客户端)，运行服务器程序的机器称为server(服务器/服务器端) （2）对等连接方式peer-to-peer 两台主机在通信时，并不区分哪一个是服务请求方和哪一个是服务提供方。只要两台主机都运行了对等连接软件(P2P软件)，就可以进行平等的对等连接通信，双方都可以下载对方已经存储在硬盘中的共享文档。 P2P引起的版权问题：P2P服务器并不会储存和提供资源，它只会保存一个索引index用来找到拥有该资源的人。用户通过下载P2P软件，在服务器的指引下找到真正拥有资源的人来获取资料 -&gt; 核心部分(电路交换、报文交换、分组交换) 核心部分 ：由大量网络和连接这些网络的路由器组成，是为边缘部分提供服务服务的(提供连通性和交换) 网络核心部分起特殊作用的是路由器，它是一种专用计算机(不叫主机)，是实现分组交换的关键构件，其任务是转发收到的分组(核心部分重要功能)。 (1)电路交换 双方接通形成一条专用的物理通路，不使用挂断归还给予他人使用。 电路交换：建立连接(占用通信资源) --&gt; 通话(一直占用通信资源) --&gt; 释放连接(归还通信资源) 特点：独占性、语音服务、线路使用效率较低(2人一说&lt;50%) (2)报文交换 按序 (3)分组交换 分组独立发，先发不一定先到 以观看电影为例，我们发出看电影的请求，服务器会将电影的数据(很大)切割成一小块一小块块(分组)再放进链路中，数据被路由器接受并选择合适的路再继续发送下去，最终将数据全部放送到用户手机(终端)中。 所以有一个现象：加载中的转圈(等待序号)，既是分发数据的延时，也是数据在路上开了小差(只有按先后序排列回原本的大数据才能看电影，且各小块数据送达的时间是随机的)。 开了小差：乱丢错 计算机网络的类别 -&gt; WAN,MAN,LAN,PAN 按照网络的作用范围分类 广域网WAN 几十到几千公里(跨国) 城域网MAN 5~50km(城市) 局域网LAN 1km(学校、企业) 个人区域网PAN 10m 微微网 蓝牙 按照网络的使用者分类 公共网 电信公司建造的大型网络，日常使用的网络 专用网 部门 用来把用户接入到互联网的网络 接入网AN(Access Network)本地接入网/居民接入网 计算机网络的性能 -&gt; 性能指标(速率、带宽、吞吐量、时延) 性能指标 速率(数据率、比特率) --&gt; 网络技术中指数据的传输速率 比特：信息论中使用的信息量的单位(二进制数字的0或1) 速率单位：bit/s(bps) , B/s k = 1000 (k千, M兆, G吉, T太, P拍, E艾, Z泽, Y尧) 现实生活中提到网络的速率，往往指的是额定速率或标称速率，并不是网络上实际运行的速率 带宽 --&gt; 计算机网络中表示网络中某通道传送数据的能力(时域称谓) 网络带宽指单位时间内数字信道所能传送的“最高数据率” 带宽单位：bit/s 某个信号具有的频带宽度(例广播)，即该信号所包含的各种不同频率成分所占据的频率范围(带宽=高频-低频)，单位是赫(频域称谓) 吞吐量 --&gt; 单位时间内通过某个网络的实际数据量 吞吐量受网络的带宽或网络的额定速率的限制，且取决于实际情况 例一：额定速率为100 Gbit/s，是吞吐量的绝对上限值，实际吞吐量可能&lt;=100 Mbit/s 例二：主机A和服务器B接入互联网的链路速率为100Mbit/s和 1Gbit/s，但主机A只能从服务器A那最大接收自己的速率100Mbit/s。若100个用户连接到服务器B，则服务器B的链路容量将被用户平分成每人10Mbit/s的带宽。这是主机A连接到服务器B的吞吐量只有10Mbit/s。 当互联网某处发生严重堵塞，主机A接收不到服务器B发来的数据，吞吐量降为0。 故日常交的宽带费用只保证某个路由器之间的数据传输速率，进入互联网之后就取决于互联网的流量分布(用户无法控制) 时延 latency （1）发送时延/传输时延 --&gt;机器内部的发送器(网络适配器) 数据块长度：观看电影1GB ； 发送速率：每次传多少数据 （2）传播时延 --&gt;机器外部 从一个节点到另一个节点 信道长度：数据传输的距离 ； 电磁波在信道上的传播速率：定值，依所用介质而定 （3）处理时延 --&gt; 主机/路由器收到分组要分析首部、提取数据部分、进行差错检验或查找转发表 （4）排队时延 --&gt; 路由器内部分组排队等待处理和在接口等待转发 利用率(信道利用率和网络利用率) 非性能指标 费用、质量、标准化、可靠性、可扩展性和可升级性、易于管理和维护 计算机网络的体系结构 计算机网络的体系结构定义：计算机网络的各层及其协议的集合 –&gt; 只讲层与层逻辑关系(面)，不讲一层一层实现的细节(点) 实现：计算网络的体系结构就是这个计算机网络及其构件所完成的功能的精确定义。强调的是，这些功能究竟是用何种硬件或软件完成的，则是一个遵循这种体系结构的实现(implementation)的问题 体系结构是抽象的，而是现实是具体的，是真正在运行的计算机的软件和硬件 ISO和OSI/RM ISO：国际标准化组织 International Standard Organization OSI/RM：开放系统互联基本参考模型 Open Systems Interconnection Reference Model 网络协议的组成要素 为进行网络中的数据交换而建立的规则、标准或约定成为网络协议，简称协议 语法：结构、格式问题 --&gt; 数据结构 语义：功能问题 --&gt; 实现什么功能 同步：事件发生的先后次序 具有五层协议的体系结构(从下到上) TCP/IP 四层结构 --&gt; 商业标准(真正应用) Application:7,6,5 ; Transport: 4 ; Network: 3 ; Network Access: 2,1 该体系只关心网络的互相连接，并不关心局域网的构建(2,1) OSI模型 --&gt; 学术/国际标准 （1）Physical：规定信号和介质 （2）Data Link：帧、介质的访问控制 （3）Network：路径的选择 （4）Transport：流控，保证可靠性 （5）Session：控制会话 （6）Presentation：通用的数据格式，语法 （7）Application：0,1转化用户可使用的 功能冗余，复杂 具有五层协议的体系结构 --&gt;教科书标准(不存在) 为了能网络的相互连接，并关心局域网(小网)的构建。将TCP/IP 四层结构Application，Transport，Network和OSI模型Data Link，Physical合并成了教科版的五层协议结构。 主机1向主机2发送数据 主机1接收到&quot;今天吃面的消息&quot;从应用层开始从上到下在上一层的基础上进行逐层加密，通过介质传输到另一端再从下到上逐层进行解密将”今天吃面“显示给主机2 一些概念 -&gt; 实体、协议 实体：可发送或接受的硬件或软件进程(任务管理器中的皆是软件进程) 协议：控制两个对等实体进行通信的规则的集合 两个对等实体：网络层1-&gt; 网络层2，网络层1 &lt;- 网络层2 ！注意：这只是逻辑通信(水平)，真正的通信是垂直通信(上文) 协议是水平的(对等实体之间的通信规则)，服务是垂直的(能被上一层看见) 在协议的控制下，两个对等实体间的通信使得本层能够为上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。(只看见服务，看不见协议) IP协议支持最强 应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互规则。此进程指主机中正在运行的程序。报文是应用层交互的数据单元。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"《应用密码学》——第一章 概述","slug":"笔记/密码学/第一章 概述","date":"2022-03-01T08:50:06.823Z","updated":"2022-04-19T08:58:42.912Z","comments":true,"path":"2022/03/01/笔记/密码学/第一章 概述/","link":"","permalink":"https://zhang0224gz.github.io/2022/03/01/%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1.1 信息安全与密码技术 信息安全是目的，密码技术是解决方法 1.2 密码技术发展简介 古典密码时期 时间：古代–19世纪末 人工，未形成学科，仅能称其为密码术 近代密码时期 时间：20世纪初–20世纪50年代左右 自动编码的转轮密码机：德国“艾尼格玛”ENIGMA密码机 现代密码时期 时间：1949年–现在 香农的奠基性论文“保密系统的通信理论” 1.3 密码学基本概念 密码学的主要任务 机密性：非授权用户不得访问 数据完整性：不允许添加，删除，篡改等 鉴别：消息的来源和本身的真实性 抗抵赖性：已发（先前的通信行为及其相关内容）不可以否认 密码学两方面：密码编码学和密码分析学 密码体制的五大部分 消息空间M，即明文空间 密文空间C 密钥空间K：加密秘钥和解密秘钥 加密算法E 解密算法D 啥啥空间：一个非常大的数据集合 熵：衡量信息的不确定性 max：等概率 例子：算法 Y=aX+b, 秘钥 a,b E(m)=c -&gt; 秘钥,即 f 密码系统的安全性 密码攻击者常用方法 穷举（暴力攻击） 统计分析 --&gt; 规律 数学分析攻击 --&gt; 数学模型 攻击类型 攻击者拥有的资源 惟密文攻击 加密算法截获的部分密文 已知明文攻击 加密算法截获的部分密文，和相应的明文 选择明文攻击 加密算法截获的部分密文；加密黑盒子，可加密任意明文得到相应的密文 选择密文攻击 加密算法截获的部分密文；解密黑盒子，可解密任意密文得到相应的明文 当前密码算法只要抵抗住穷举攻击状态下，惟密文攻击的攻击就是成功的 密码算法要求 数据复杂性：计算量 处理复杂性：花费时间 存储复杂性：空间大小 密码算法安全性的因素 密码算法的保密程度 之外的不安全因素（管理程度） 密码算法的保密强度并不等价于密码系统整体的安全性。一个密码系统必须同时具备完善的技术和管理要求，才能保证整个密码系统的安全。 密码系统的安全性 无条件安全性 一次一密，秘钥不能重复使用 --&gt; 存储管理花费巨大，不采取 可证明安全性 数学难题：大整数素因子分解，计算离散对数(log n = b%m，模前可能b无穷等于余数) --&gt; 解决耗费时间过大 计算安全性性 当密码系统的秘钥空间足够大时，由于攻击者受计算条件、资源限制，而且有其特定目的，若不能在希望的时间内或实际可能的条件下破译成功，则称计算上不可破译 达到实际安全性要满足的准则 实际计算量十分巨大 计算时间超过被加密信息有用的生命周期 破译该密码系统的费用超过被加密信息本身的价值 1.4 密码系统设计的基本原则 科克霍夫斯(Kerckhoffs)原则 数据安全基于秘钥而不是算法的保密性 密码设计公开原则并不等于所有的密码在应用时都一定要公开密码算法 1.5 密码体制的分类 按秘钥数量 对称密码体制 非对称密码体制 也称单钥、秘密密钥…… 也称双钥、公开密钥…… c=Ek(m), m=Dk© c=Epk(m), m=Dsk© DES(56 bits) --&gt; AES(128 bits) RSA --&gt; ECC O(n2) : C(2,n) = n(n-1)/2 O(2n): 每人分配一个公钥一个密钥 加/解密使用一样，效率高密钥管理成本高，麻烦(比如分发) 加/解密使用不一样，效率低密钥管理简单 公钥不可解出密钥，密钥可以推出公钥 根据对明文信息的处理方式 可将对称密码体制再分为分组密码和序列密码(流密码) 分组密码 序列密码(字符流) 一个字符/1 bit处理k足够长，不重复使用密钥非常重要（异或） 根据是否能进行可逆的加密变换 单向函数密码体制 双向变换密码体制 例子： b%m=c 对称密码体制的优缺点 优点 加密、解密的处理速度快、效率高、算法安全性高 缺点 密钥分发过程复杂，说花代价高 密钥管理量的困难 非对称密码体制的优缺点 优点 密钥分配简单 系统密钥量少 系统开放性好(随便加入正负) 可以实现数字签名(私钥不可伪造性；不可否认性：因偷了或丢了造成的损失都要负责) 缺点 加密、解密的运算复杂、处理速度较慢，同等安全强度下，非对称密码体制的密钥位数较多 对称密码体制是每个人都有其他人的密钥，一旦加了一个人就要通知所有人人手增加一把新人的密钥。 对称密码体制每人一把公钥和私钥，用收件人的公钥加密信件，收件人只需要用自己的私钥解密即可。若增加一人只需给新人配两把公私密钥就行，不需要通知所有人","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"蓝桥杯题目","slug":"刷题/蓝桥","date":"2022-02-23T10:00:54.461Z","updated":"2022-05-18T15:31:40.781Z","comments":true,"path":"2022/02/23/刷题/蓝桥/","link":"","permalink":"https://zhang0224gz.github.io/2022/02/23/%E5%88%B7%E9%A2%98/%E8%93%9D%E6%A1%A5/","excerpt":"","text":"背包问题 01背包问题 1max(f[i-1][j],f[i-1][j-v[i]]+w[i]) 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int n=1010;int N,V;int v[n],w[n];int f[n][n];int main()&#123; cin&gt;&gt;N&gt;&gt;V; for(int i=1;i&lt;=N;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1;i&lt;=N;i++) &#123; for(int j=0;j&lt;=V;j++) &#123; f[i][j]=f[i-1][j]; if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); &#125; &#125; int res=0; for(int i=0;i&lt;=V;i++)res=max(res,f[N][i]); cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 报错： [[Error] array bound is not an integer constant before ‘]’ token](https://alanhere.com/2021/01/11/array-size-constant/) 报错地方：全局变量 int n=1010;未加const 报错原因：一般而言，C/C++ 的编译器在编译时，一个数组的长度往往要求是静态已知的。因此，如果数组 array[n] 长度是借助一个变量 n 来确定，那么可以加上 const 限定符。const 关键字是 用于限定一个变量为只读。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int n=1010;int N,V;int v[n],w[n];int f[n];int main()&#123; cin&gt;&gt;N&gt;&gt;V; for(int i=1;i&lt;=N;i++)cin&gt;&gt;v[i]&gt;&gt;w[i]; for(int i=1;i&lt;=N;i++) &#123; for(int j=V;j&gt;=v[i];j--) &#123; f[j]=max(f[j],f[j-v[i]]+w[i]); &#125; &#125; cout&lt;&lt;f[V]&lt;&lt;endl; return 0;&#125; 完全背包问题 1max(f[i-1][j],f[i][j-v[i]]+w[i])","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[]},{"title":"三天","slug":"数学建模/三天计划","date":"2022-02-17T10:39:42.831Z","updated":"2022-03-06T07:31:30.912Z","comments":true,"path":"2022/02/17/数学建模/三天计划/","link":"","permalink":"https://zhang0224gz.github.io/2022/02/17/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E4%B8%89%E5%A4%A9%E8%AE%A1%E5%88%92/","excerpt":"","text":"相关问题 Q：队伍在微信群里打字交流算作弊吗？ A：不算。 Q：论文控制号就是赛克的队伍编号吗？ A：不是，论文控制号在美赛官网。mcm参赛编号为赛氪系统生成的编号，不是美赛官网的队伍号！！！ Q：翻译软件 A：谷歌翻译 Q：WPSPDF还是不如AdobePDF保险，对吗？ A：当然，它的准则说只接受Adobe PDF。个人建议还是用office别用WPS，会LaTeX最好 Q：新赛题的中文版 A：关注 数学建模比赛 公众号，8点左右 Q：论文里可以不放程序吗？ A：可，代码之类放附件 Q：可以不用官网给的摘要吗？ A：写控制号就行（22+五位数），需要使用官方给定的模板 美赛官网登录网址：https://www.comap.com/undergraduate/contests/mcm/login.php 辅助报名完成后2小时左右会给队长的赛氪账号发送站内消息，消息内通知美赛控制号。 或登录美赛官网查看控制号。 ![img](file:///C:\\Users\\zhangguozhi\\Documents\\Tencent Files\\2251787923\\Image\\Group2\\F\\89\\F89BQ$`3}N4}BJOJ_0IR3O.jpg) A:比赛结束之前都可以选的对吧，到时候写完了再选题提交没问题吧 Q:选题开始比赛后才能选，选定了就先选上再写，以防意外。文件，即论文，插到邮箱附件（交官方邮箱） A:今年 目录，参考文献列表（或书目）、注释页和任何附录”是不是全都计入25页数限制？ Q:是的 2022年美赛选题步骤+论文提交步骤指导：https://www.saikr.com/c/nd/8549 美赛官方最新发布丨MCM-ICM_Tips（中英文对照版）：https://www.saikr.com/c/nd/8552 22年美赛常见问题及解答:22年美赛常见问题及解答 (qq.com) 2022.2.18 6:00 – 2022.2.21 20:00 – 2022.2.21 21:00 赛题分析，哪种问题+算法 模型假设 参数 模型建立 顺序步骤 求解 模型结果分析-&gt;图表分析 模型检验（是否正确）利用已知数据 模型应用 数据处理（算法：差值，拟合，组成和分析，层次分析法），关联与分析，分析与判别，评价与决策，预测与预报，优化和控制 聚类分析：诊断数据异常值 神经网络评价 小样本灰色预测 公式类评价模型（正比反比并拟合），模糊数学评价体系，因子分析法，主成分分析法，神经网络类的算法，层次分析法，灰色关联分析 预测模型：线性回归，非线性回归，灰色预测，时间序列分析，小波分析，神经网络预测 有效性评价，当出现某个指标变动之后，就需要对未来的数据进行重新预测，简易的方法是通过百分比的方式，或者参数方法，对原预测结果进行直接的提升，也可以使用马尔科夫模型，针对新的政策对未来进行预测，再将预测之后的结果，带入到之前建立的模型，评价结果上升，才会说明政策的有效性 最后我们之前的变动是直接针对指标进行变动 国家做出调整各个方面为这个指标努力，努力就会牵动更多的内容，需要细致分析和自由发挥，需要说明国家推行新政策时可能遇到的困难 灵敏度分析，当有些政策无法迅速做出变动时，或出现其他状况时，公平出现的趋势 方差分析：单因素和多因素 标准差，极差，方差，偏度，峰度 正态分布 1.如何数据处理，如何实现降维过程 第一个要素：评价指标 如何选择 花篇幅为什么选择这个指标 如何建模量化得出结论 详细说明指标含义，指什么东西，和论文有什么关系，为什么选她做指标 谈怎么量化 不可忽视数据来源 评价模型 相对重要，权重大 我们选择TOPSIS(基于理想解相似度的排序偏好技术)来建立我们的评价模型。考虑到层次分析法在确定权重时过于依赖管理者判断的缺点，我们决定采用信息熵权法(view)确定各指标的权重。 我们输入来自21个经合组织国家(包括发展中国家)的数据，并对其健康状况进行排名 使用GM(灰色模型)来说明改善智利高等教育现状的强有力政策的必要性，并通过问题6的评估模型来评估政策的有效性。 三个维度:输入、输出和效率。投入是指国民经济对高等教育系统的教育支出。产出是指高等教育系统回报社会的经济价值和社会价值。而效率则是指资源的输入要素的利用程度 三个维度，即覆盖率、公平性和绩效作为主要指标。覆盖率由三个二级指标来衡量:大学生在青年群体中的比例、研究生与本科生的比例和近30年来高等教育覆盖率的增长速度。公平是由学生家庭在高等教育支出中所占的比例和大学的宣传程度来衡量的。成绩由四个能力分布指标和博士毕业率来衡量。 公平侧重于获得资源的机会","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[]},{"title":"智能车基础知识","slug":"智能车/基础知识1","date":"2022-02-07T14:39:13.103Z","updated":"2022-07-17T08:41:24.318Z","comments":true,"path":"2022/02/07/智能车/基础知识1/","link":"","permalink":"https://zhang0224gz.github.io/2022/02/07/%E6%99%BA%E8%83%BD%E8%BD%A6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/","excerpt":"","text":"一些报错 Warning[Pe223]: function “Speed_Control” declared implicitly 出现原因1 该函数没有在本文件包含的头文件中定义，而只在其他c文件的头文件中有定义，也就是间接地有定义。这样是不规范的。 解决办法1 把出现问题的函数所在头文件包含进来。且如果包含进来还未解决，可能是头文件包含的先后顺序有关。 出现原因2 头文件和C文件中的函数声明不完全相同，可能出现函数名有细微差别，比如字母大小写不一致等情况。 解决办法2 回去仔细看一下出现问题的函数是否在声明和调用时使用了完全一致的函数名称和变量 Error[Pe028]: expression must have a constant value 报错内容：float Output=angle_duty; 报错原因：Output和angle_duty都是变量不能在定义时赋值，可以先定义在函数中赋值。 123456意思是.表达式必须是常量推论---------------1.数组在声明时初始化必须是常量！2.unsigned char const Tab[]。Tab是变量3.const unsigned char const Tab[]。Tab也是是变量！尽管程序整个过程它都不能被改变. Error[Pe028]: expression must have a constant value 常见原件 电阻和电容 贴片电容(不分+,-)，钽电容(分+,-) 固态电解电容(用于主板) 电阻、电容的标号： 电容：1μF = 1,000nF = 1,000,000pF 【103】，即10 x 10^3皮法 = 10纳法； 计算方法：前两位数字代表有效数字，第三位代表10的n次幂（也可以理解为在有效数字后面有几个0），单位是皮法。 前3位数字是容量代码，字母是额定电压代码(耐压值) 字母C表示额定电压为16V(C型耐压16V),字母A表示额定电压为10V(A型耐压10V) 107C是 100UF 16V，107A是100UF 10F 电阻：1MΩ=1,000KΩ=1,000,000Ω 数字索位标称法（一般矩形片状电阻采用这种标称法） 数字索位标称法就是在电阻体上用三位数字来标明其阻值。它的第一位和第二位为有效数字，第三位表示在有效数字后面所加“0”的个数。这一位不会出现字母。 例如：【472】表示“4700Ω”；【151】表示“150Ω”。 如果是小数。则用“R”表示“小数点”。并占用一位有效数字，其余两位是有效数字。例如：【2R4】表示“2.4Ω”；【R15】表示“0.15Ω”。 色环标称法（一般圆柱形固定电阻采用这种标称法） 色环电阻大多采用三环、四环（有时五环、六环）标明其阻值，原理都一样。 ​ 颜色表示： 从左到右，前三列为有效数字，第四列为倍数，第五列为误差，第六列为温度系数。 例如：【蓝灰橙银】表示“68kΩ”，误差±10% 二极管LED 有正有负，有线的一边为负极 蜂鸣器 调车使用，有问题可以响 排母、排针 焊接工具 焊箱 松香 焊芯片，自动分开防止短路 细丝 吸锡器 排针孔堵了 IAR安装和使用 Ctrl+Shift+F 快捷键唤出查找功能-&gt;查找之后再go to defination Ctrl+T 格式化 C语言基础知识 内存和地址 内存是以字节为单位的存储空间 有底到顶：机械码、代码-&gt;静态变量-&gt;全局变量-&gt;堆区(指针）-&gt;栈区(main函数中的) 数据类型 1234567typedef char int8; // 8 bitstypedef short int int16; // 16bitstypedef long int int32; //32 bitstypedef unsigned char uint8; //8 bitstypedef unsigned short int uint8;// 16 bitstypedef unsigned long int uint8;// 32 bitstypedef unsigned long long uint8;// 64 bits 外部变量和外部函数 文件之间调用 关键字extern: 当extern不与“C”在一起修饰变量和函数时，如在头文件中：extern int g_Int : 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或者其他模块中使用。！！！它是一个声明不是一个定义。 栗子：B模块（编译单元）要是引用模块（编译单元）A中定义的全局变量或函数时，它只要包含A模块的头文件即可，在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。 12345678//include.cpp#include&quot;include.h&quot;int a=10;int b=5;int sum(int a,int b)&#123; return a+b;&#125; 123456789//include.h#ifndef _INCLUDE_H_ //防止嵌套，造成资源浪费#define _INCLUDE_H_extern int a;extern int b;int sum(int a,int b);#endif 123456//主函数异步编译多个不同代码，使用关键词#if 0#elif 1#elif 0#endif //想编译的写1，不想编译的写0 123456789//main.cpp#include&lt;iostream&gt;#include&quot;include.h&quot;using namespace std;int main()&#123; cout&lt;&lt;a&lt;&lt;&quot;+&quot;&lt;&lt;b&lt;&lt;&quot;=&quot;&lt;&lt;sum(a,b)&lt;&lt;endl; return 0;&#125; 中断原理及应用 中断服务程序 中断服务程序，处理器处理“急件”，可理解为是一种服务，是通过执行事先编好的某个特定的程序来完成的，这种处理“急件”的程序被称为——中断服务程序。 与每类I/O设备相关的进程都有一个靠近内存底部的地址，称作中断向量。 它包括中断服务程序的入口地址。 当中央处理器正在处理内部数据时，外界发生了紧急情况，要求CPU暂停当前的工作转去处理这个紧急事件。处理完毕后，再回到原来被中断的地址，继续原来的工作，这样的过程称为中断。实现这一功能的部件称为中断系统，申请CPU中断的请求源称为中断源，单片机的中断系统一般允许多个中断源，当多个中断源同时向CPU请求中断时，就存在一个中断优先权的问题。通常根据中断源的优先级别，优先处理最紧急事件的中断请求源，即最先响应级别最高的中断请求。 1、中断标识码（中断类型号）：由硬件（通常是中断控制器）产生，以标识不同的中断源。 2、中断向量：早期的微机系统中将由硬件产生的中断标识码（中断源的识别标志，可用来形成相应的中断服务程序的入口地址或存放中断服务程序的首地址）称为中断向量。在某些计算机中，中断向量的位置存放一条跳转到中断服务程序入口地址的跳转指令。 3、中断向量地址：存储中断向量的存储单元地址。 4、中断：在计算机执行程序的过程中，当出现异常情况或者特殊请求时，计算机停止现行的程序的运行，转而对这些异常处理或者特殊请求的处理，处理结束后再返回到现行程序的中断处，继续执行原程序。 存放：存放中断服务程序的入口地址，来存放中断向量（共256个），称这一片内存区为中断向量表。 **跳转：**跳转到中断服务程序的入口地址，在AVR或ARM微处理器中，中断向量的大小也是4个字节，但其中存放的不是中断程服务程序的入口地址，而是可执行的代码。当响应中断时，硬件自动执行相应中断向量处的跳转代码，然后跳转到具体的中断服务程序的入口地址。 综上所述：中断向量的地址一定是 中断服务程序的入口地址的地址，但中断向量不一定就是中断服务程序的入口地址。 单片机中重要中断 PID定时中断： 对于时间进行精准的控制，定时进入中断服务程序完成某个任务 123456789main()&#123; 1.关总中断 2.中断初始化(中断开启): PID中断初始化(4个PID定时器用哪个:一般只使用一个，定时的时间:10ms进入一次) 3.开启中断 4.使能(使其能工作) 5.&#125; 串口接收中断： 由单片机通过蓝牙串口接收到信息时，做出对应的反应(调车使用) 中断一多就有中断优先级问题…… https://www.bilibili.com/video/BV1fJ411K7bk?spm_id_from=333.999.0.0 怎样烧录程序 硬件准备：1.主板 2.核心板 3.下载器 软件准备：IAR 不要插反 GPIO通用输入输出接口 概念：通用型之输入输出的简称，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入GPI或通用输出GPO或通用输入输出GPIO。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它 输入模式：通过读取某个寄存器来确定引脚电位的高低 输出模式：写入某个寄存器来让这个引脚输出高电位或低电位 通用串行异步数据总线： 异步通信：通信中两个字符（8位）之间的时间间隔是不固定的，而在一个字符内各位的时间间隔是固定的。 波特率：每秒钟传送的二进制位 PC–&gt;USB原则 单片机–&gt;TTL原则（USB转TTL模块转Kea板） 主要：引脚（即排针） 1234GPIO初始化 gpio_init(port,dir,state) port/ptxn端口号，dir引脚方向(0=输入,1=输出)，state引脚初始状态(0=低电平,1=高电平)设置引脚状态 gpio_set(ptxn,state)获取引脚状态 gpio_get(ptxn) UART串口(输入输出信息) 概念：串行接口(Serial Interface)是指数据一位一位地顺序传送 ​ 有线串口：usb转ttl的模块； ​ 蓝牙串口更适用于调试； 硬件：1.USB to TTL模块 2.KEA板 3.下载器 !！注意：硬件连接时，下载器拔掉3.3V跳线帽 12345UART初始化 uart_init(uartn,band_rate) UARTn通道(实际是两个引脚)，band_rate波特率(数据传输的速度：9600 11400……)UART串口打印 uartPrintf(UARTn uartn,char *pcFmt....)虚拟示波器 uart_sendware(UARTn uartn,void *wareaddr,uint32 waresize)串口接收中断 uart_rx_irq_en AD采集(电磁组) 概念：模拟信号(Analog signal) -&gt; 数字信号(Digital signal) 1234567初始化 ADC_Init(ch,bit) ch采集通道，bit采集位数单次采集 adc_once(adcn_ch) adcn_ch ADC通道均值滤波 adc_ave(adcn_ch,N) adcn_ch ADC通道,N均值滤波次数(范围:0~255) 其他滤波算法：中位值平均滤波算法、卡尔曼滤波算法…… PIT定时中断 软件上执行时间一致，但在硬件上(电容、电阻跑久了温度会升高，时间发生变化会导致周期变化)时间不一致 概念：定时器实际上是计数器，它通过累计已知时间间隔的个数来计算时间。被累积的时间间隔若是系统时钟，计数器就变成了定时器。（周期性地做某一件事……） 1234初始化 PIT_Init(uSChannel_No,freq) uSChannel_No PIT通道端口号0、1,freq定时器频率中断服务函数 PIT0_ISR(uSChannel_No)中断使能 pit_irq_en(uSChannel_No) 关于中断 内核 约等于 操作系统 单片机上的程序，始终获得CPU的控制权 用户程序并发处理的时候，是轮番处理的且交换很快 所以单片机要明确知道IO什么时候做这些输入输出和这些中断，要自己亲自过问 摄像头的获取，摄像头输入：首先摄像头分传感器和集成本地缓存，传感器会把光的信号转换为数字信号，数值放在缓存里。若是写成请求一次程序，完全收集好一次数据交给CPU处理会非常难慢。先初始摄像头给摄像头配置寄存器写好时然后告诉摄像头以什么频率和分辨率、彩色还是干风暴的画面，按行采集完一次告诉CPU一次，使用的是外部中断，CPU给传感器一个地址，就是DMA传送方式（DMA直接内存访问：在传的过程中不需要CPU一条一条把缓存里的东西取到内存里，而是传感器的缓存是直接向内存传数据，CPU只要直接告诉缓存往哪存数据缓存往哪存数据） FTM多功能定时器 PWM波驱使电机转动和舵机打角 编码器测速（轮胎转的速度） 占空比（高电平的时间占总时间的比例） FTM模块的核心是一个16位计数器。 主要功能：PWM输出、输入捕捉、正交解码 PWM输出： PWM的周期=(MOD-CNTIN) 123456FTM模块初始化 FTM_PWM_init(ftm,ch,freq,duty) ftm PWM模块，ch通道，freq频率，duty占空比(0-1000 可以调节FTM_PRECISON这个系数)设置占空比 FTM_PWM_Duty计数模块初始化 ftm_count_init获取计数值 ftm_count_get清空计数值 ftm_count_clean 初始化以及其他一些功能函数写在.c文件，服务函数统一写在Isr.c ！注意：串口打印和虚拟示波器不能同时使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#if 1//GPIOvoid main()&#123; DisableInterrupts; gpio_init(GPI0,1,0); gpio_init(GPI1,0,0); if(gpio_get(PIG1)==0)gpio_set(GPI1,1); EnableInterrupts;&#125;#elif 0//串口void main()&#123; DisableInterrupts; uart_init(UARTR0,9600); int pulse[2]; pulse[0]=0; pulse[1]=100; uartPrintf(UARTR0,&quot;ok\\n&quot;); EnableInterrupts; while(1) &#123; //串口打印时需注释掉虚拟示波器 //uart_sendware(UARTR0,&amp;pulse,sizeof(pulse)); &#125;&#125;#elif 0//串口接收中断void main()&#123; DisableInterrupts; uart_init(UARTR0,9600); gpio_init(PIG0,1,0); gpio_init(PIG1,1,0); gpio_init(PIG2,1,0); gpio_init(PIG3,1,0); uart_rx_irq_en(UARTR0);//rx接收，tx发放-&gt;isr.c EnableInterrupts;&#125;#elif 0//AD采集void main()&#123; DisableInterrupts; uart_init(UARTR0,9600); int val; ADC_Init(ADC_CHANNEL_AD6,ADC_12BIT); EnableInterrupts; while(1) &#123; val=adc_once(ADC_CHANNEL_AD6); //val=adc_ave(ADC_CHANNEL_AD6);//均值滤波 uart_sendware(UARTR0,&amp;val,sizeof(val)); &#125;&#125;#elif 0//PIT定时中断void main()&#123; DisableInterrupts; PIT_Init(PIT_CHANNEL0,1); uart_init(UARTR0,9600); PIT_IRQ_EN(PIT_CHANNEL0); EnableInterrupts;&#125;#elif 0//FTMvoid main()&#123; DisableInterrupts; PIT_Init(PIT_CHANNEL0,1); uart_init(UARTR0,9600); FTM_PWM_init(CFTM0,FTM_CH1,50,10); ftm_count_init(CFTM1); PIT_IRQ_EN(PIT_CNANNEL0); EnableInterrupts;&#125; #endif #if 0//FTMvoid PIT0_ISR(void)&#123; //清除中断标志位 PIT-&gt;CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK; uartPrintf(UARTR0,&quot;%d\\n&quot;,ftm_count_get(CFTM1)); ftm_count_clean(CFTM1);&#125;#elif 1//PIT定时中断void PIT0_isr(void)&#123; //清除中断标志位 PIT-&gt;CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK; uartPrintf(UARTR0,&quot;%d\\n&quot;,1);&#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"Python 数据获取与可视化分析综合练习题","slug":"Python/实验课代码","date":"2022-01-15T10:33:10.359Z","updated":"2022-03-21T09:25:24.308Z","comments":true,"path":"2022/01/15/Python/实验课代码/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/15/Python/%E5%AE%9E%E9%AA%8C%E8%AF%BE%E4%BB%A3%E7%A0%81/","excerpt":"","text":"Python 数据获取与可视化分析综合练习题 实验内容： (1) 用自己的姓名或学号新建一个文件夹，在文件夹中新建一个文本文件 “111.txt”。 (2) 从网上复制“当好学生成长的引路人——习近平总书记给全国高校黄大 年 式 教 师 团 队 代 表 的 回 信 引 发 强 烈 反 响 （ 网 址 ： http://www.xinhuanet.com/2021-09/13/c_1127858064.htm）”中的文本内容 保存到“111.txt”中。 (3) 将“111.txt”文件中的内容的中文提取到“222.txt”文档中（使用 re 方法）。 (4) 使用 jieba 对提取的中文文档（222.txt）进行分词处理，并统计出现频 率最高的前 100 个。 (5) 使用 wordcloud 和 matplotlib.pyplot 方法对“222.txt”中的分词制作 分词云图，并保存为“分词云图 1.png”。 (6) 使用“222.txt”中出现频率最高的前 10 个词语，制作条形图，X 轴对应 10 个词语，y 轴对应每个词语的频率值，保存成“条形图 2.png”。 （附：有余力的同学可以将实验内容的第(1)(2)步换成爬取网页内容的操作。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#原始版本import osimport requestsimport reimport jiebaimport matplotlib.pyplot as pltfrom wordcloud import WordCloudimport numpy as npfrom PIL import Imageimport matplotliburl = r&#x27;http://www.xinhuanet.com/2021-09/13/c_1127858064.htm&#x27;response = requests.get(url)response.encoding = &#x27;utf-8&#x27;path = r&#x27;C:\\Users\\zhangguozhi\\Desktop\\2020416177&#x27;isExists = os.path.exists(path)if not isExists: os.makedirs(path) print(&#x27;创建成功&#x27;)else: print(&#x27;目录已存在&#x27;)path1 = path + &#x27;\\\\&#x27; + &#x27;111.txt&#x27;file = open(path1, &#x27;w&#x27;, encoding=&#x27;utf&#x27;)file.write(response.text)file.close()file = open(path1, &#x27;r&#x27;,encoding=&#x27;utf&#x27;) #r表示是文本文件，rb是二进制文件content = file.read()file.close()pattern1 = &#x27;[\\u4e00-\\u9fa5]+&#x27; #形成字符串列表（提取中文(默认一个)，+(至少匹配一个))#pattern2 = &#x27;[A-Za-z0-9\\!\\%\\&lt;\\&gt;\\，\\。]&#x27;re1 = re.compile(pattern1) #正则表达式对象：匹配或替换方式res1 = re1.findall(content) #指定字符串进行匹配#res2 = re1.sub(pattern2, &#x27;&#x27;,content) #过滤path2 = path + &#x27;\\\\&#x27; + &#x27;222.txt&#x27;file = open(path2, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)n = len(res1)for i in range(n): file.write(res1[i])file.close()file = open(path2, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)content = file.read()jb_li = list(jieba.cut(content, cut_all=False))#print(jb_li)file.close()list1 = []list4 = []dict1 = &#123;&#125;n = len(jb_li)for i in range(n): if len(jb_li[i])&gt;1: num = jb_li.count(jb_li[i]) dict1[jb_li[i]] = num list4.append(jb_li[i])for i in dict1: tup = (dict1[i],i) list1.append(tup)list1.sort(key=lambda x:x[0],reverse=True)list2 = list1[0:99]list3 = [i[1] for i in list2]fcl = &#x27; &#x27;.join(list4)bgl = np.array(Image.open(r&#x27;C:\\Users\\zhangguozhi\\Pictures\\Saved Pictures\\QQ截图20210529160439.png&#x27;) ) #功能:将数据转化为矩阵cyl = WordCloud( font_path = &#x27;C:\\WINDOWS\\Fonts\\STFANGSO.TTF&#x27;, background_color = &#x27;white&#x27;, width = 500, height = 400, max_font_size = 100, min_font_size = 10, mask = bgl )cyl.generate(fcl)plt.figure(&#x27;词云图&#x27;)plt.imshow(cyl) #?plt.axis(&#x27;off&#x27;) #关闭坐标轴plt.savefig(r&#x27;C:\\Users\\zhangguozhi\\Desktop\\2020416177\\分词云图1.png&#x27;,dpi=300)#plt.show()matplotlib.rcParams[&#x27;font.family&#x27;]=&#x27;SimHei&#x27;x = [list1[0][1],list1[1][1],list1[2][1],list1[3][1],list1[4][1],list1[5][1],list1[6][1],list1[7][1],list1[8][1],list1[9][1]]y = [list1[0][0],list1[1][0],list1[2][0],list1[3][0],list1[4][0],list1[5][0],list1[6][0],list1[7][0],list1[8][0],list1[9][0]]figure = plt.figure()plt.bar(x,y)plt.savefig(r&#x27;C:\\Users\\zhangguozhi\\Desktop\\2020416177\\条形图2.png&#x27;,dpi=300) 实验2 在已有网络拓扑基础上，给每个节点随机生成剩余能量（取值范围：1～10） 骨干节点： 随机性 成为骨干节点的要求：剩余能量&gt;=4.2 骨干节点之间是连通的 普通节点表示、普通节点之间连线 骨干节点表示、骨干节点之间连线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import matplotlib.pyplot as pltimport numpy as npfrom matplotlib.patches import Circlen = 80rl = 0rr = 100r = 20energy = np.random.randint(1,10,size=[n])a = np.random.randint(rl,rr,size=[n])b = np.random.randint(rl,rr,size=[n])fig = plt.figure()ax = fig.add_subplot(111)plt.scatter(a,b,c=&#x27;r&#x27;,marker=&#x27;o&#x27;,s=5)pre = &#123;&#125;for i in range(n): pre[(a[i],b[i])]=[0,0,0] for i in range(n): for j in range(i+1,n): if (a[i]-a[j])*(a[i]-a[j])+(b[i]-b[j])*(b[i]-b[j])&lt;r*r: if energy[i]&gt;=4.2 and energy[j]&gt;=4.2: aa = [a[i],a[j]] bb = [b[i],b[j]] plt.plot(aa,bb,color=&#x27;gold&#x27;,linewidth=1) pre[(a[i],b[i])][1] += 1 pre[(a[j],b[j])][1] += 1 else: aa = [a[i],a[j]] bb = [b[i],b[j]] plt.plot(aa,bb,color=&#x27;skyblue&#x27;,linewidth=1) pre[(a[i],b[i])][2] += 1 pre[(a[j],b[j])][2] += 1 pre[(a[i],b[i])][0] += 1 pre[(a[j],b[j])][0] += 1mini0 = 0;mini1 = 0;mini2 = 0; for j in range(n): if pre[(a[j],b[j])][0]&lt;mini0:mini0=j if pre[(a[j],b[j])][1]&lt;mini1:mini1=j if pre[(a[j],b[j])][2]&lt;mini2:mini2=jprint(pre[(a[mini0],b[mini0])][0],pre[(a[mini1],b[mini1])][1],pre[(a[mini2],b[mini2])][2])#print(pre)for i in range(n): circle = plt.Circle(xy=(a[i],b[i]),radius=20,alpha=0.05,color=&#x27;lightseagreen&#x27;) ax.add_patch(circle) plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"}],"tags":[]},{"title":"最优化方法","slug":"数学建模/线性规划","date":"2022-01-11T14:14:05.578Z","updated":"2022-02-09T14:06:57.519Z","comments":true,"path":"2022/01/11/数学建模/线性规划/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/11/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/","excerpt":"","text":"最优化方法广泛应用于工农业、交通运输业、商业、国防、建筑、通信与政府机关及管理各部门各领域，旨在解决最优计划、最优分配、最优决策、最佳管理等最优化问题。最优化方法是一门应用科学，它以量化为基础，融合多学科交叉特点，强调做出最优决策 内容包括线性规划、运输问题、整数规划、非线性规划的基本概念与基本原理、无约束问题的最优化方法和约束问题的最优化方法 线性规划问题 我们将一个问题抽象为在满足一组约束条件下，寻求变量x1,x2…xn使目标函数达到最大值的一个数学问题 线性规划数学模型 -&gt;可行域：满足约束条件和非负条件的点组成的交集 -&gt;最优解： 线性规划标准形式 目标函数一律改为最大化 约束条件一律改为等式（非负约束条件除外） 等式右端项大于等于零 -&gt; 两种形式：一般形式、矩阵形式和向量形式 -&gt; 将非标准形式化为标准形式 例子：","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[]},{"title":"评价类模型","slug":"数学建模/层次分析法","date":"2022-01-07T11:08:39.548Z","updated":"2022-08-10T02:12:22.582Z","comments":true,"path":"2022/01/07/数学建模/层次分析法/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/07/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/","excerpt":"","text":"层次分析法 层次分析法（The Analytic Hierarchy Process即 AHP) 最基础的模型之一，最主要用于解决评价类问题（例如：选择哪种方案最好、哪位运动员或者员工表现的更优秀） 评价类问题关键字：确定评价指标，形成评价体系 解决评价类问题，首先想到的三个问题： （1）我们评价的目标是什么？ （2）我们为了达到这个目标有哪几种可选的方案？ （3）评价的准则或者指标是什么？（我们根据什么东西来评价好坏） 优先选择知网（或者万方，百度学术，谷歌学术等平台）搜索相关文件 和小组成员来场头脑风暴+在平台上搜索别人或者专家的看法 **虫部落-快搜：**https://search.chongbuluo.com/ 搜索优先级：谷歌&gt;微信&gt;知乎 第一步：建立层次结构图 ​ -&gt; 通过题目找出目标、方案和准则 第二步：建立权重表格 -&gt; 求出指标权重和方案权重 法一：直接打分法 法二：分而治之法 -&gt; 一次性考虑不周，两个两个指标进行比较，最终根据两两比较的结果来推算出权重 第一步：使用程度打分表，填写判断矩阵 计算指标权重的 计算同一指标下方案间权重的 出现问题：几个方案会出现逻辑矛盾（不一致现象：A&gt;B,A=C,B&gt;C） 第二步：一致性检验 -&gt; 判断矩阵和一致矩阵对比 -&gt; 一致矩阵 引理1：一致矩阵A各行成比例，所以矩阵的秩为1，故一致矩阵有一个特征值为n（tr(A)=a11+……+ann)，其余特征值为0；对应特征向量为第一行各元素取反，即第一列 引理2：n阶正互反矩阵A为一致矩阵时，最大特征值为n 当不是一致矩阵时，最大特征值&gt;n -&gt; 矩阵之间关系 -&gt; 一致性检验 CR &gt; 0.1 如何修正？往一致矩阵上调整~~~ 第三步：计算权重 PS:选一列进行计算 -&gt; 算术平均法 -&gt;几何平均法 -&gt; 特征值法 求判断矩阵最大特征值和其特征向量，将其归一化处理 第三步：计算各方案得分 局限性 （1）评价的决策层不能太多，太多的话n会很大，判断矩阵和一致矩阵差异可能会很大。 （2）如果决策层中指标的数据是已知的，那么我们如何利用这些数据来使得评价的更加准确呢？ TOPSIS法 第一步：原始矩阵正向化 第二步：正向化矩阵标准化 第三步：计算得分并归一化 熵权法 信息熵小，信息清晰；信息熵大，信息杂乱 灰色预测 数据预处理工作 apha=0.5,所以是1/2 a,b未知 因为我们所得数据不是连续而是离散 保证a,b精度 真实值（已知值）减去拟合值（预测值）的差（残差） 整体是好的，但有小概率问题，在后期进行模型优化","categories":[{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[]},{"title":"","slug":"智能车/PID","date":"2022-01-05T08:13:52.956Z","updated":"2022-07-17T08:35:17.496Z","comments":true,"path":"2022/01/05/智能车/PID/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/05/%E6%99%BA%E8%83%BD%E8%BD%A6/PID/","excerpt":"","text":".直立环pd：d参数的引入是为了抑制震荡 p，比例参数，它的作用是反应了控制的响应速度，过小的话平衡车表现是pwm明显不够直立不起来，过大的话小车过于震荡，震荡的时候就要加微分参数抑制震荡· d，微分参数，它的作用是反应了对震荡的抑制。过小的话和没加微分参数只有比例参数一样的现象，过大的话会低频迅速抖动 控制时序：角度5ms采集一次 直立环和角度环10ms控制一次 下面是程序分析： 1234567891011121314151617/************************************************************************/直立环 ：int balance(float Angle,float Gyro) &#123; float Bias;int balance;Bias=Angle-ZHONGZHI; //===求出平衡的角度中值 和机械相关balance=Bkp*Bias+Gyro*Bkd; //===计算平衡控制的电机PWM PD控制 kp是P系数 kd是D系数 return balance;&#125; 角度环pid分析：这里使用的是 位置pid控制器的PD控制器，这里 微分D乘的参数是角速度是因为：这里的角速度已经转变为弧度/s单位，当在单位时间内，车子由一个角度猛然的转到另一个角度的时候，角速度先变大后变为0，这里的角速度就可以理解为在这段时间内的此时的角度差值和上次角度差值的差值(因为角度差值除以单位时间就是角速度)，这就很符合位置pid的微分乘的参数的要求了。所以这里的微分乘的是角速度（这里的角速度单位已经从°/s转为弧度/s） 角度环是根据平衡角度的变化给出的pwm值 kp：是比例参数 他决定平衡小车响应速度的快还是慢 太小响应速度慢太大会发生低频抖动 kd：是微分参数 对于干扰要进行迅速响应的的要加入微分参数 太小的话没什么作用太大会高频抖动 只有直立环调试比较好的现象是：平衡车可以直立几秒钟然后像一个方向加速 直立环调试指南： 在调试直立环的时候，我们要把速度环和转向环屏蔽掉，只打开直立环。 （1）先确定平衡车机械平衡位置角度。 （2）确定kp值得极性和大小: 首先我们估计kp的取值范围。我们的PWM设置的是7200代表占空比100%，假如我们设定 kp 值为 720，那么平衡小车在±10°的时候就会满转。根据我们的感性认识，这显然太大了，那我们就可以估计 kp 值在 0~720 之间，首先大概我们给一个值 kp=-200,我们可以观察到，小车往哪边倒，电机会往那边加速让小车到下，就是一个我们不愿看到的正反馈的效果。说明 kp 值的极性反了，接下来我们设定 kp=200,这个时候可以看到平衡小车有直立的趋势，虽然响应太慢，但是，我们可以确定 kp 值极性是正的。具体的数据接下来再仔细调试。 确定 kp 值的大小（令 kd=0，请结合本小节开头的直立控制函数理解）确定参数的原则是： kp 一直增加，直到出现大幅度的低频抖动。 设定 kp=200,这个时候我们可以看到，小车虽然有平衡的趋势，但是显然响 应太慢了。 设定 kp=350,这个时候我们可以看到，小车虽然有平衡的趋势，而且响应有 所加快，但是响应还是不足以让小车保持平衡。 设定 kp=500,这个时候我们可以看到，小车的响应明显加快，而且来回推动 小车的时候，会有大幅度的低频抖动。说明这个时候 kp 值已经足够大了，需要 增加微分D控制削弱 p 控制，抑制低频抖动(也就是抑制超调)。 （3）确定kd值得极性和大小： 我们得到的 MPU6050 输出的陀螺仪的原始数据，通过观察数据，我们发现最大值不会超过 4 位数（9999），再根据 7200 代表占空比 100%，所以我们估算 kd 值应该在 0~2 之间，我们先设定 kd=-0.5，当我们拿起小车旋转的时候，车轮会反向转动，并没有能够实现 跟随效果。这说明了 kd的极性反了。接下来，我们设定 kd=0.5,这个时候我们可以看到，当我们旋转小车的时候，车轮会同向以相同的速度跟随转动，这说明我们实现了角速度闭环，至此，我们可以确定 kd 的极性是正的。具体的数据接下来再仔细调试。 确定 kd 值的大小（令 kp=500，请结合本小节开头的直立控制函数理解） 确定参数的原则是： kd 一直增加，直到出现高频抖动。 设定 kd=0.5,这个时候我们可以看到，低频大幅度频抖动已经基本消除。 设定 kd=1,这个时候我们可以看到，整体性能已经非常棒。 设定 kd=1.7,这个时候我们可以看到，小车开始出现高频剧烈抖动(调试过程 遇到这种情况请马上关闭小车，长时间高频抖动会导致驱动被烧坏的) 至此，我们可以确定得到 kp=500,kd=1.7 是 P、D 参数的最大值。然后我们进行最关键的一步，对每个系数乘以 0.6,取整得到 kp=300,kd=1，这就是最终我们需要的参数，这样做的原因是，我们之前得到的参数是 kp、kd 最大值，理想值是根据我们的工程经验，对每个数据乘以 0.6 得到。这个时候我们可以看到，小车没有任何的抖动，非常平稳，但是依然无法保持长时间的直立，直立很短一段时间后会往一个方向加速倒下。这个等我们下面加上速度环才能得到更好的性能。只有直立环是很难让小车达到很好的直立效果的。至此，直立调试部分就告一段落了。 感谢平衡小车之家在技术上的帮助 如果觉得有用的话 请关注我哦 也可以和我一起交流，或者评论，我会一一回复。 1.占空比 就是输出的PWM中，高电平保持的时间与该PWM的时钟周期的时间之比。 如，一个PWM的频率是1000Hz，那么它的时钟周期就是1ms，就是1000us，如果高电平出现的时间是200us，那么低电平的时间肯定是800us，那么占空比就是200：1000，也就是说PWM的占空比就是1:5。 2.分辨率 也就是占空比最小能达到多少，如8位的PWM，理论的分辨率就是1：255(单斜率)，16位的的PWM理论就是1:65535(单斜率)。 频率就是这样的，如16位的PWM，它的分辨率达到了1:65535，要达到这个分辨率，T/C就必须从0计数到65535才能达到，如果计数从0计到80之后又从0开始计到80…，那么它的分辨率最小就是1:80了，但是，它也快了，也就是说PWM的输出频率高了。 3.双斜率 / 单斜率 假设一个PWM从0计数到80，之后又从0计数到80… 这个就是单斜率 假设一个PWM从0计数到80，之后是从80计数到0… 这个就是双斜率 可见，双斜率的计数时间多了一倍，所以输出的PWM频率就慢了一半，但是分辨率却是1：(80+80)=1:160，就是提高了一倍。 假设PWM是单斜率，设定最高计数是80，我们再设定一个比较值是10，那么T/C从0计数到10时(这时计数器还是一直往上计数，直到计数到设定值80)，单片机就会根据你的设定，控制某个IO口在这个时候是输出1还是输出0还是端口取反，这样，就是PWM的最基本的原理了。 传感器（陀螺仪和加速度计） (4条消息) 陀螺仪原理–转载_jaczen的博客-CSDN博客_陀螺仪原理 - 加速度计（accelerometer）检测什么 - 陀螺仪（gyroscope，也称作 gyro）检测什么 - 如何将传感器ADC读取的数据转换为物理单位（加速度传感器的单位是g，陀螺仪的单位是 度/秒） - 如何结合加速度传感器和陀螺仪的数据以得到设备和地平面之间的倾角的准确信息 加速度计检测到得力的方向与它本身加速度的方向是相反的。这种力量通常被称为 惯性力或假想力 R ^ 2 = RX ^ 2 + RY ^ 2 + RZ ^ 2（ 公式1），此公式等价于 三维空间勾股定理。 直立车，PID部分 角度环 (4条消息) 【平衡小车制作】（五）位置式PID、直立环与速度环概念（超详解）_鲁乎乎的博客-CSDN博客_直立环 这个信息挺全的 直立平衡角度环PID控制 · 给新手的两轮自平衡小车开发实战指南 (miaowlabs.com) PID (4条消息) PID应用时要注意的一些点_maitd的博客-CSDN博客_pid限幅 位置式连续式 位置式离散式(注意此时Kp=Kp, Ki=Kp*T/Ti, Kd=Kp*Td/T) 增量式离散式： 12345678910参数整定找最佳，从小到大顺序查 先是比例后积分，最后再把微分加 曲线振荡很频繁，比例度盘要放大(Kp减小) 曲线漂浮绕大湾，比例度盘往小扳(Kp增大)曲线偏离回复慢，积分时间往下降(Ki增大)曲线波动周期长，积分时间再加长(Ki减小)曲线振荡频率快，先把微分降下来(Kd增大) 动差大来波动慢。微分时间应加长(Kd减小) 理想曲线两个波，前高后低4比1 一看二调多分析，调节质量不会低 二.控制PID的执行周期(T) 虽然在离散化的公式里这个地方这个参数隐藏了,但注意它只是被隐藏了,但还是还会发生作用,看一下离散位置PID公式里那几个参数的公式,是不是它会影响参数的大小啊. 所以在应用第二个第三个PID公式时执行周期一定是要确定的,不能变更的,一T变更那么参数就得跟着变了,注意是T变了,参数就得相应的去变化,而不是一直不变,但如果此时你的参数维持不变的话,显然这组参数已经不是当前的最优参数了. 举个例子,有一个取样周期为1的PID和一个取样周期为10的PID控制同一个的执行元件,若此时参数还采取一样,它的控制效果显而易见是不会一样的.所以要控制执行周期,最好能将Ki=KpT/Ti, Kd=KpTd/T,这个公式直接应用,公式变为: 我推荐用这个公式,在控制好T,或者获取T的实际值,代入,调节Ti和Td.许多开源四轴的控制一般是用这个公式的. 三.积分环节的限幅 我不推荐做智能车啥的用增量式PID,说是简化了运算,但现在的单片机啥的运算能力和频率都挺强的,又不是51那个时代了,所以减那一点实在没什么作用.此外用增量式PID,不好去做积分限幅的,只能对每次的输出做限制,但对积分的限幅没什么作用. 有时候当误差量e(k)比较大,而e(k)-e(k-1)要小的多的时候,系统有较大的迟滞的时候(感觉是)要防止积分的饱和.就是当系统的输出一直摇摆,不会收敛,而且摇摆的频率比较缓慢,那么我感觉可能是饱和,得限制下积分了.也就是 这个环节的累积值大小做限幅. 我感觉用的时候可以最后加积分环节,看一下系统的稳态误差,如果没稳态误差,我就直接不加了,如果有的话,那么看一下稳态误差的大小在什么范围,积分限幅也就大致限制在那个范围了. 四.微分环节的滤波 当系统容易收到高频信号的干扰时,微分作用会将高频信号的扰动放大(自控课本上说的),高频信号变化的较快,而微分是去求误差的变化率,所以有高频扰动信号,就会被微分作用给放大,建议对微分环节做低通滤波,通常是一阶低通滤波,讲低通滤波的帖子文章挺多的,我就不写了. 五.关于各种自适应PID 包括什么神经网络PID,模糊PID,遗传算法优化PID等等,本质上都是对参数的统计和优化,但通常这些算法运算量时挺大的,写肯定可以写出来,但这个在一些嵌入式设备上运行的效率速度不是很好,会占很大的运行速度,而且要搞清楚各种自适应PID的使用范围,比如模糊PID适用于过程控制,控制个温度什么的,它不适合用来做运动控制,控制电机什么的,因为计算量较大,在单片机上还有可能会参数迟滞什么的.做个智能车类的小东西,还是用不上这些方法的,单纯PID就够了,论文里的一些自适应PID方法,不一定都是经过实际检验的,可能只是在MATLAB里做了个仿真.所以我感觉不能全信. 先把单片机，驱动芯片，陀螺仪，加速度计，电机准备好。 然后搭车，质量尽可能集中在两个车轮轴心线，陀螺仪和加速度计也要尽可能放在轴心线。 我这个是个错误的示范，质量比较分散了，但是又无可奈何，又想要零点，又想把传感器伸的远一点。。。 然后调试代码，1读取三轴加速度和角速度2姿态结算，互补滤波，四元数，卡尔曼估计器都可以。 直立控制，找出你的车的机械零点，也就是质量平衡点。最简单的方法：电机输出=p*（当前角度-期望角度）＋d*（角速度） 参数整定参考一下csdn的一些文吧。 你的车就立起来了。 直立控制不止这一种，也有各种双pi，双pd的串级控制等等。 然后再搞速度和方向。 可以去智能车论坛找个代码研究一下。 https://www.its203.com/article/Mark197/119486864?2022-03-13T1?2022-03-20T0 机械结构的设计决定了整个系统的极 限，硬件电路提供实现极限的方法与条件，而软件算法则是决定了整体系统能 否达到极限 https://www.its203.com/article/Mark197/119486864?2022-03-13T1 直立车模控制中三种滤波算法简单分析 https://www.eefocus.com/sensor/467379?_ga=2.136496885.490729479.1647172634-1494707267.1647172610&amp;pk_vid=3f99cf4edfd158d71647182427d8fba1 参数调试的话可以参照平衡小车之家的平衡车调试指南来进行相应的调试，里边写的还是比较好的哦https://wenku.baidu.com/view/3e5fc765bb4cf7ec4bfed00b.html 这里说一下机械结构对控制的影响。机械结构对直立控制的影响还是比较巨大的，特别是车速越快对结构的要求就越高，如果只是单纯的想立起来的话对结构的要求则没那么高。 主要遵循的原则就是机械重心越集中、越靠近两车轮轴线越好。车子除去底盘的话基本就电池和电路板了。电池是比较重的，所以可以优先考虑电池的放置，其次就是考虑电路板的放置了。重心越低越靠近车轮轴线相应的PID参数的调试就会更加的简单。反之的话则会更难。 https://www.cxy80.com/article/qq_36240874/100026227 https://its401.com/article/qq_46336588/119916341 关于直立环 https://www.guyuehome.com/24372 详细介绍如何从0开始写一个数据通信，将数据从单片机发送到上位机（或者虚拟示波器）进行数据或图像显示，以及常见问题或注意事项解答 https://www.guyuehome.com/19990 卡尔曼滤波（非矩阵）在平衡直立车直立角度测量中的应用（MATLAB模拟仿真），简单易懂，详细注释，附卡尔曼滤波(矩阵) https://blog.csdn.net/qq_44339029/article/details/105597930 直立车的控制可分为直立环、转向环、和速度环，首先要写的肯定是直立环，直立环根据姿态传感器的数据，进行直立环PID控制，输出直立环PWM，使车保持直立状态，直立车直立是基础，当然直立环也不是越硬越好，这个看个人的需要吧，关于直立的角度，经过我的多次实验，一定不要太低，过低后会带来很多不必要的麻烦（比如上坡道时车不稳，贴地，电感值异常等），一般直立环调节到原地站立在机械零点，给予下压或者上挑干扰后可以在短距离的前后移动后恢复稳定状态，这时候就可以加转向环了，之前刚开始调完直立环后，我直接加的速度环，发现虽然给两个电机相同的PWM值，但是我的车就是不跑直线，后来经过数据采集后发现，两者的转速也没有什么规律可言，通过差值PWM来使其走直线也是不可行的，索性就直接先加转向环，通过转向环的作用来纠正其偏离中心赛道的偏差，发现效果很好，调完转向环后再调速度环（同时调也行），转向环和速度环都可以看做是对直立环的干扰，推荐使用串级PID的方法 直立环：在周期性中断中采集姿态传感器的数据，比如10ms采集一次，在主函数中初始化相应的外设，比如姿态传感器MPU6050的初始化、IIC的初始化、电机PWM的初始化，然后在直立控制函数中，先调用写好的由陀螺仪和加速计计算角度的函数，分别计算出当前小车距离地面的夹角，然后采用滤波算法，获取其融合后真正使用的角度值，然后将该角度值与设定的机械零点值相减，获取偏差通过PID算法对其进行控制，调试参数使其保持直立 转向环和速度环：在周期性中断中采集电感值ADC的数据，比如10ms采集一次，在主函数中初始化相应的外设，比如编码器所用的定时器的初始化、电感值ADC通道的初始化等，然后在控制函数里，读取编码器的值，并对其进行异常数据检查及处理，适当的滤波处理，然后由左右编码器的值得到车中心的速度值与设定值做差来获取速度偏差进行控制，在输出速度环和转向环PWM时建议采用平滑输出的方式，来减小短时间内对直立环的干扰，此外关于转向环，根据在不同的赛道元素采用不同的转向环系数的方式来增强控制效果，当然这种方法虽然使得控制效果更优化，但是需要检测和判断赛道元素，调试的参数也变多了，大家根据实际情况选择是否使用，还有非常重要的一点各环PWM的输出一定要限幅，限幅值的大小也是很重要的调节参数，尤其是直立环的 MCU（Microcontroller Unit）微控制单元，核心板上的芯片 USB转TTL是可以直接转换，插头同时插在塑料壳上的 编码器分正交编码器和角度编码器(不用了)，一个是带方向的(数字显示正负表示正反)，一个不带方向 512 速度环、直立环、转向环 电子设计竞赛(4)-常用的两种PID算法 (qq.com) 基于TC264的两种电机驱动使用教程及PID算法浅析–逐飞科技 (qq.com) 陀螺仪：灵敏度高，调整舵机角度偏转 (33条消息) 平衡车直立PID调节总结_a568713197的博客-CSDN博客_平衡车pid 这个有代码参考 (33条消息) PID实践笔记-PID浅解及两轮直立车参数调试经验_尔过留香的博客-CSDN博客_方向环pid 这个很不错 (33条消息) PID实践笔记-两轮直立车的速度控制_尔过留香的博客-CSDN博客_直立车速度环 拒绝瞎调，用matlab，自动调节PID参数 - 知乎 (zhihu.com) 好方法！！ [平衡小车PID，就该这么调！！！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/119160742#:~:text=在直立环中，PID的入口参数为：平衡小车的姿态角和姿态角对应的角速度。,值得说明，MPU6050得出来的姿态角有三种：PITCH（俯仰角）、ROLL（翻滚角）、YAW（航向角） 一般来说，MPU6050都是平方且平行装在平衡小车上，总不会有人垂直装吧。) 调参 (1条消息) 直立车想节能——2020全国大学生智能车车竞赛经验记录之我想要直立（平衡小车串级pid调参经验）_沉睡的小灰的博客-CSDN博客_平衡车串级pid 平衡车我相信很多电赛测控的入门的玩家都也玩过，很多朋友们也都听说过平衡小车之家这家淘宝店铺。而串级PID也是一个经典且牛批的方案而广为人知，所以在这样的比赛结束之后作为俩套方案都试过的我，谈一谈平衡小车之家的代码即并行的pid和串级pid的优缺点以及调参经验。 三环介绍 废话少说正题开始 我相信大家都应该很了解PID是什么，以及 P I D分别是干什么的，这里就不详细介绍了。反而我想谈一谈平衡小车的控制需要什么。 首先我觉得大家更为熟知的是角度环，速度环，和转向环。角度环是为了控制小车的一个直立，速度环是为了控制小车的速度，而方向环则是为了控制小车的转向。其实这三个环分别起到什么作用是非常好理解的。 角度环也叫直立环，就是机械中值的角度值为目标值，误差为目标值减去当前姿态传感器读到的角度即 误差角度 = 中值角度 - 当前角度 速度环，就是你设定速度为目标速度，如果想他站着不动，那么设定的目标速度就是0，误差就是编码器读到的车轮的值，如果是俩个车轮就将其加起来乘或不乘一个1/2（本质没区别）。 误差速度 = 设定速度 - （编码器左+编码器右） 转向环，转向环通过读取航向角的角速度来，其实本质上还是控制这个角速度为莫个值。比如你想小车走直线，那么你就需要设定值为0，误差值就是设定值减去角速度 误差转向 = 设定转向 - 航向角角速度 那么并行pid和串级pid有什么区别呢？ 并行PID 如何做 并行的PID是将三个环分别独立计算，最后叠加起来最后输出到电机上面去即 电机PWM = 直立环 + 速度环 如果加上转向环就是 电机左PWM = 直立环 + 速度环 +（转向环/2） 电机左PWM = 直立环 + 速度环 - （转向环/2） （加减得看你的极性） 为什么这样做 其实这三个环分别都很好理解，直立环控制直立，速度环控制你的速度，转向环控制你的转向。 至于为什么叠加起来就能直接赋值给电机好像是可以参考卓大大之前的那片文章，里面有对模型的详细介绍。 这样做有什么好处 其实并行pid最大的好处就是现象十分明显，为什么这么说呢？ 直立环加上你就能看见小车能立起来了，速度环加上你就能看到小车停止或者按照指定的样子跑，转向环也是这样，你能看到小车转向很明显。明显带来的效果就是非常方便你调试PID你可以很清楚的看到现象，从而PID的参数整定就会十分顺利。由于参数调试十分简单这里就不详细介绍了，在很多淘宝店铺都提供了很多代码，包括b站也都有许多教程。 串级PID 因为串级pid有很多种串联的方法，我在这里仅介绍一下我的方法，和按照我的方法的效果，仅供参考 如何做 串级pid不同于上面的，会多出一个环叫做角速度环，而且串级pid会多出一些概念，如内环和外环。我的串级pid的构造为，角速度内环，速度外环，中间是角度环，叠加转向环。具体是怎么工作的呢？ 速度环的输出结果作为角度环的设定值，角度环的输出结果作为角速度环的设定值，角速度环的输出结果累加上我们上面介绍的转向环作为我们的电机PWM的输出。 速度环——&gt;角度环——&gt;角速度——&gt;输出 + 转向环 = PWM 为什么这样做 首先两点，多出了一个串起来和一个角速度环。 汉堡告诉我的是，串起来的目的是为了PID更快的收敛，但是我个人的感觉不止于此。我认为串级PID能给传感器很多信息分布不同的权重，并且让其有序，而不是简单粗暴的累加起来，就像煮大锅饭一样。 角速度环是我一开始最不能理解的一个东西，我队友也十分抗拒加上这个东西，可是我到最后才发现角速度环才是这个串级PID的灵魂。如果大家调试过直立环大家就会发现一个问题就是，如果直立环调的太软（p比较小）你会发现整个平衡小车会有点来回的低频振荡不能稳住，如果你的调的太硬（p比较大）你会发现整个车会在高频抖动，这种情况下一是容易烧电机驱动（来回转电流很大都是堵转电流，不要问我为什么知道容易烧，我板子经历了他这个年纪不改经历的惨痛），二是你会发现车非常抖，就包括你加上速度环之后，你的车在行进过程中十分抖动，这会非常耗电，对节能就不友好了，而且车子是不稳定的（太软车就容易倒，甚至一碰就倒）。你要调试到那种堪堪不抖动，而且车还不容易倒的状态下，这个pid的参数十分难调，而角速度环就能解决这个问题。我在调试之前问学长，角速度环的 目的是干什么的，他给我的解答是能排除扰动和干扰。我一开始一直认为排除的扰动可能是车在进行过程中装到旁边的路障，或者转向过大的时候带来的不稳定，可是我到最终发现其实角速度环能解决的一个很大问题的就是你直立环调的过硬的时候，所带来的高频抖动，角速度环能帮助你去掉这个高频抖动。所以从这一点来说，你的角速度环和速度环调的得较为适配，这样你的车很难倒下，而且车不会很抖。 这样做有什么好处 我在上一点上也大概说了串级pid的几点好处，首先你会直观的发现你的车非常非常非常稳，稳到什么地步呢，基本上你的电磁前瞻杆子你拍一下他能起来而且不会倒，我在侧面对着车踢一脚车也是不会倒的。其次你的加速会非常明显只要你的重心不要过分的往后，加速是很到位的。最后就是避免了高频抖动，避免了电机的堵转，也会进一步节能。 缺点也很明显 其实带来好处的同时就会带来缺点，缺点就是PID十分难调，因为你的pid是一环套一环，首先你出了问题，现象不容易看出来是哪个环的问题，主要是角速度环和角度环 ，然后就是怎么调整，而且中间某个环的参数没调好，后面的都不好使，这就带来了很多挑战和难题。 我该怎么调 在串级pid中，内环是直接输出的，对于这一点来说，外环粗调就ok，内环精调。对于我们这个模型来说，主调角度环副调角速度环，调参顺序是从内环到外环，最后调转向环。 首先调参角速度环，角速度环一般是pi控制，其实很多地方有用增量式也有用位置式，对于内环的角速度环，我们需要高频控制，大概每2ms运算一次，对于这样的运算我们可以选择增量式来减少我们的运算量，当然对于增量式不熟用位置式也是一样的。在调整这个参数的时候与以往不同，我们需要先调整i的参数，原因是陀螺仪的角速度跳动非常大，十分容易出现静差，我们需要加上i来消除那部分静差，调整的现象是加上i车就能大幅的低频来回晃，能勉强立住，立住的效果越好i的参数越好，i过大也会导致高频抖动。在调整完i的参数之后我们就需要调p的参数，其实加上p之后你会发现车就能勉强立住了，不会晃的很大，你需要增大p大概到车子会稍微抖动，还没要到高频抖动的感觉。效果就是小车基本上能立起来。 其次调角度环，角度环一般是pd控制，大概是10ms运算一次（串级pid 的级和级之间的运算时间是2-9倍之间），加上角度环的p之后你会发现小车基本上能稳稳的立住了，当然这是合适的p，但是区分这个的现象真的一点都不明显，我的方法是拍前瞻的杆子，看响应速度，力气越大 响应速度越快，说明效果越好，其实基本上车是会往前冲，来调整角度，你也可以看冲完之后小车稳定下来的pid收敛速度，来判断p的值是否合适。基本上p感觉调到差不多了的时候，可以加上d，d是提高车的响应速度，加上d之后你会发现小车向前冲的距离会不大，力气不大的时候，能看到小车立刻弹起来，这就是比较好的响应速度，d过大也会带来高频的抖动。加上合适pd之后你会发现小车基本是很稳定的立在地面上，除非特别暴力什么的，小车是不会倒的，哪怕是撞上什么物体，或者是碾过什么物体都不会倒。**这个角度环得调的比较硬，这样你才能在加速的时候看起来效果比较好，不然你会看到小车在形式过车中，车身比较抖或者车容易倒，这是俩个极端。**角度环是比较重要的一个环，需要我们耐心去调试。其实这也会面临一个问题，我大概调到什么样子才能到下一个环上面去调，这就得靠自己的尝试和感觉了，我个人觉得需要自己多调一调就会找到那个感觉，我调了三遍，第一遍调了大概五六个小时，第二遍调了大概2-3小时，第三遍一个小时就调完了，需要自己摸索找感觉。 最后速度环，速度环的调试其实比较粗糙了，感觉速度环的p就是小车的一个加速度，p越大加速度越大，甚至速度环不加i都是可以的。虽然速度环的i固然会积分导致一些问题出现，但是我们可以用多少次的一个清零尽可能的解决这个问题，**如果不加i的话，感觉速度会不稳定，**这就对你的直立环和角速度环提出了很大的考验，我看到的一个朋友就是没有加i，我看他加速的时候车屁股一直在点地，虽然规则是允许平衡车的第三点点地，但是这比如对我们的节能产生了很大的影响，节能的很重要的一个前提就是稳定的工作，以我们的电瓶车为例，频繁的加速减速你车的待电就不行。 转向环其实都是差不多的，但是有一点就是转向环需要和速度形成一定的联系，因为转向的多少是累加在我们角速度环的输出上，和并行那边是差不多的，如果你转向环是死的，你高速和低速状态下的转向环的值不一样，这就容易出问题。我看到人家的代码是 利用一个俩个的串级串到一起，是利用电磁的差比和作为当前值，设定值为0，进一个pid算出参数，当前的航向角的角速度为当前值，这个参数乘上速度作第二个pid的设定值，第一个pid还是一个动态pid，感觉挺巧妙的，由于时间关系没有尝试 END 调参很苦，熟能生巧，思考现象，方能直立 感觉踩了很多坑，也问了很多人，非常感谢这一路上许多学长耐心解答，我也希望我的文章能给别人带来一丝丝参考价值。节能直立挺好玩的，但是很可惜，在方向上走错了很多，只能怪我太菜了。愿大家都能做出三米神车，越来越牛批！ 突然有些朋友问我要代码，其实我也没什么可以给的，pid都是一个样子，可以给大家看一下流程的样子(这是学长的代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void Balance_Control(void)&#123; if (Ang_Velocity_Flag) // 直立角速度环 2ms &#123; Ang_Velocity_Flag = 0; ICM_GetData(&amp;GYRO,&amp;ACC); //Data_Filter();//原始数据滤波 Data_steepest(); IMU_update(0.008f,&amp;(sensor.Gyro_deg), &amp;(sensor.Acc_mmss),&amp;imu_data); //匿名移植姿态解算 icm_gyro_z = LPButterworth(icm_gyro_z, &amp;Gyro_Butter, &amp;Butter_20HZ_Parameter_Acce);//巴特沃斯30HZ滤波 Z轴和Y轴角速度都用原始数据，只经过滑动滤波和低通处理 icm_gyro_y = LPButterworth(icm_gyro_y, &amp;Gyro_Butter1, &amp;Butter_30HZ_Parameter_Acce); //IMUupdate(GYRO.X*Gyro_Gr, GYRO.Y*Gyro_Gr, GYRO.Y*Gyro_Gr, ACC.X*AcceRatio, ACC.Y*AcceRatio, ACC.Z*AcceRatio); state = Long_street();// if (state)//障碍，长直道减速// &#123;// Speed_Set = 180;// &#125;//// else// &#123;// Speed_Set = 320;// // &#125; //Middle_Err = LPButterworth(Middle_Err, &amp;Middle_Err_Butter, &amp;Butter_10HZ_Parameter_Acce); Radius = -PlacePID_Control(&amp;Turn_PID, Turn[Fre], Middle_Err, 0);//动态PID，动态范围0-0.04 ，大误差时起作用， Theory_Duty += -PID_Increase(&amp;Ang_gyro_PID, Ang_gyro, (int32)icm_gyro_y, (int32)(Tar_Ang_Vel.Y)); /* 角速度环作为最内环控制直立 */ //abs +=PID_Increase(&amp;Ang_gyro_PID, Ang_gyro, (int32)(GYRO_Real.Y*10), 0)*10;//(int32)(Tar_Ang_Vel.Y)); // 计算直立PWM //abs +=Theory_Duty; //Theory_Duty += Theory_Duty; //Theory_Duty = -Theory_Duty; //abs = abs * 10; Theory_Duty = LIMIT(Theory_Duty, -900, 900); //Direct_Parameter = -PID_Realize(&amp;Turn_gyro_PID, Turn_gyro, (int32)(icm_gyro_z),0); Direct_Parameter = -PID_Realize(&amp;Turn_gyro_PID, Turn_gyro, (int32)(icm_gyro_z),Radius*Speed_Min); // 转向环左正右负 Direct_Parameter = range_protect(Direct_Parameter, -800, 800); Direct_Parameter = Turn_Out_Filter(Direct_Parameter);//输出滤波 // Direct_Parameter = Direct_Last*0.2 + Direct_Parameter * 0.8; // 更新上次角速度环结果 // Direct_Last = Direct_Parameter; //Direct_Parameter = 0; MOTOR_Duty_Left = Theory_Duty + Direct_Parameter; // 左右电机根据转向系数调整差速 MOTOR_Duty_Right = Theory_Duty - Direct_Parameter; //get_angle(); // Kalman_Filter(Mpu_date.roll, Mpu_date.groy);//卡尔曼滤波 &#125; if (AngleJS_Flag) &#123; AngleJS_Flag = 0; &#125; if (Angle_Flag) // 直立角度环 10ms &#123; Angle_Flag = 0; get_speed(&amp;left_speed,&amp;right_speed);// 获取当前速度 //speed_measure(left_speed, right_speed); Speed_Now = ( left_speed-right_speed)/ 2; Distance = Speed_Now + Distance; Speed_Now = Speed_Now * 0.8 + Speed_Last * 0.2; Speed_Last = Speed_Now; //Long_Load(); Tar_Ang_Vel.Y = -PID_Realize(&amp;Angle_PID, Angle, (int32)(imu_data.pit*100), (int32)Target_Angle.Y); Tar_Ang_Vel.Y = range_protect(Tar_Ang_Vel.Y, -1000, 1000); // 注意正负号 &#125; if (Speed_Flag) // 速度环 50ms &#123; Speed_Flag = 0; /* 速度环加到角度环上串级控制 */ Target_Angle.Y = -PID_Realize(&amp;Speed_PID, Speed, Speed_Now, Tar_v+Speed_Set); // 结果为放大1+00倍的目标角度 Target_Angle.Y += Zero_Angle*100; // 目标角度叠加在零点上 //Target_Angle.Y = -Target_Angle.Y;// if (Middle_Err&gt;=500 || Middle_Err&lt;=-500)//一定程度上防止弯道减速// &#123;// Target_Angle.Y = 3500;// &#125; Target_Angle.Y = range_protect((int32)Target_Angle.Y, 200, 3000); Speed_Min = Speed_Min * 0.1 + Speed_Now * 0.9; if (Speed_Min &lt; 40) &#123; Speed_Min = 40; &#125; //oled_int16(84,0,Target_Angle.Y); &#125; &#125; 以及位置式pid的代码 12345678910111213141516171819202122232425262728293031// 位置式动态PID控制int32 PlacePID_Control(PID *sprt, float *PID, float NowPiont, float SetPoint)&#123; //定义为寄存器变量，只能用于整型和字符型变量，提高运算速度 float iError; //当前误差 int Actual; //最后得出的实际输出值 float Kp; //动态P iError = SetPoint - NowPiont; //计算当前误差 sprt-&gt;SumError += iError*0.01; if (sprt-&gt;SumError &gt;= PID[KT]) &#123; sprt-&gt;SumError = PID[KT]; &#125; else if (sprt-&gt;SumError &lt;= PID[KT]) &#123; sprt-&gt;SumError = -PID[KT]; &#125; //二次函数是为了达到 误差越大 反应越快 回复力越大 其中 KI值是误差为0时的P 也就是直道上的P值 Kp = 1.0 * (iError*iError) / PID[KP] + PID[KI]; //P值与差值成二次函数关系，此处P和I不是PID参数，而是动态PID参数，要注意！！！ Actual = Kp * iError + PID[KD] * ((0.8*iError + 0.2*sprt-&gt;LastError) - sprt-&gt;LastError);//不完全微分 sprt-&gt;LastError = iError; //更新上次误差 Actual = range_protect(Actual, -260, 260); return Actual;&#125;","categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"}],"tags":[]},{"title":"计算机组成原理","slug":"笔记/计算机组成","date":"2022-01-02T08:37:04.897Z","updated":"2022-03-21T09:21:54.410Z","comments":true,"path":"2022/01/02/笔记/计算机组成/","link":"","permalink":"https://zhang0224gz.github.io/2022/01/02/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/","excerpt":"","text":"翻译程序 -&gt; 编译程序（C）和解释程序（Python） 冯·诺依曼计算机的特点 计算机由五大部件组成 指令和数据以同等地位存于存储器， 可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 指令在存储器内按顺序存放 以运算器为中心 机器指令格式 -&gt; 操作码+地址码 PC 存放当前欲执行指令的地址， 具有计数功能（PC）+ 1 -&gt; PC PC Program Counter IR 存放当前欲执行的指令 IR Instruction Register 机器字长 CPU 一次能处理数据的位数, 与 CPU 中的 寄存器位数 有关，一般字长越长，表示范围就越大，精度也越高。 机器字长也会影响机器运算速度 存储容量 存放二进制信息的总位数 主存容量： 存储单元个数MAR × 存储字长MDR ​ C = 2**MAR + MDR bit B KB MB GB 运算速度 （1）与主频、执行的操作和主存本身的速度等有关 （2）衡量方法 &lt;1&gt; 完成一次加法或乘法所需要的时间（不合理） &lt;2&gt; TM=fi*ti（连加） 其中TM 为平均指令执行时间，fi为第i条指令占全部操作的比例，ti为第i条指令的执行时间。 &lt;3&gt; 单位时间内完成的平均指令条数 MIPS (million instruction per second)百万指令每秒 &lt;4&gt; 执行一条指令所需要的平均时钟周期数 CPI (cycle per instruction) &lt;5&gt; 每秒执行的浮点操作数目 FLOPS（floating point operation per second） 或 MFLOPS (million FLOPS)百万浮点操作每秒 &lt;6&gt; 每个时钟周期数执行的指令数目 IPC（instruction per cycle） 补充：GFLOPS（Giga FLOPS）每秒10亿次 109 TFLOPS（Tera FLOPS）每秒万亿次 1012 PFLOPS（Peta FLOPS）每秒千万亿次 1015 总线 1.片内总线 芯片内部 的总线 2.系统总线 计算机各部件之间 的信息传输线 数据总线（双向），地址总线（单向），控制总线（有出有入） 3.通信总线 用于 计算机系统之间 或 计算机系统与其他系统（如控制仪表、移动通信等）之间的通信 串行通信和并行通信 总线的性能指标 总线宽度 数据线 的根数 总线带宽 数据传输率，每秒传字节数（MBps） -&gt; 总线宽度和总线带宽 总线通信控制四个阶段 申请分配阶段 主模块提出申请，总线仲裁决定 寻址阶段 主模块向从模块 给出地址 和 命令 传数阶段 主模块和从模块 交换数据 结束阶段 主模块 撤消有关信息 -&gt;申请分配阶段，寻址阶段，传数阶段，结束阶段 1秒=1000毫秒，1秒=1000000微妙 求总线的数据传输率 例3.1 假设总线的时钟频率为100MHz，总线的传输周期是4个时钟周期，总线的宽度为32位，求总线的数据传输率。若想把数据的传输率提高一倍，可采取什么措施？ 解： 法一： 1个时钟周期=1/100MHz=0.01μs 总线传输周期=0.01 μs*4=0.04 μs 因为总线宽度为32位（4B） 所以数据传输率v=x/t=4B/(0.04 μs)=100 MBps 法二： f = 100MHz -&gt; 1s有100M个时钟周期 100/4 = 25 个总线周期 25 * (32/8)B = 100MBps 提高数据传输率方法： ① 数据宽度改为64位 ②总线频率变为200MHz | 比特率和波特率 波特率：单位时间内传送的二进制数据的位数，单位用bps表示。 比特率：单位时间内传送的二进制有效数据的位数，单位用bps表示。 例3.2 在异步串行传输系统中，假设每秒传输120个数据帧，字符格式包含1个起始位，7个数据位，1个奇校验位，1个终止位，计算波特率和比特率。解：一帧包含1+7+1+1=10位 故波特率为10120=1200bps=1200波特 比特率为7120=840bps=840比特 | 存储器按存取方式分类 (1) 存取时间与物理地址无关（随机访问） 随机存储器：在程序的执行过程中 可 读 可 写 RAM：Random Access Memory（一旦停电，信息丢失） 只读存储器：在程序的执行过程中 只 读 ROM：Read Only memory（存放固定不变的程序、常数、汉字库等） (2) 存取时间与物理地址有关（串行访问） 顺序存取存储器 磁带 直接存取存储器 磁盘 存储器：主存储器（RAM，ROM），Flash Memory，高速缓冲存储器（Cache)，辅助存储器 主存中存储单元地址的分配 ​ 小端：低地址存低字节 ​ 大端：低地址存高字节 -&gt; 大端和小端 动态 RAM 刷新 刷新（再生）：由于漏电阻的存在，电容上的电荷一般只能维持1~2ms，即使电源不掉电，信息也会自动消失，因此，必须在2ms内对所有存储单元恢复一次原状态 刷新过程实质上是先将原信息读出，再由刷新放大器形成原信息并重新写入的再生过程。 刷新周期：在规定时间内，对DRAM全部基本单元电路全部刷新一遍，通常取2ms 刷新是一行行进行的，一次刷新一行 对于 128 ×128 的存储芯片（存取周期为 0.5 gs ） ① 集中刷新（存取周期为0.5 微妙 ） 将所有行进行读写，再整体刷新128行 “死区” 为 0.5 gs ×128 = 64 gs (gs暂代微秒) “死时间率” 为 128/4 000 ×100% = 3.2% ② 分散刷新（存取周期为1 gs ） 读/写一个，同时刷新该数据 tC = tM + tR (无 “死区”) (存取周期为 0.5 gs + 0.5 gs ) ③ 分散刷新与集中刷新相结合（异步刷新） 读/写一行后，同时将该行刷新 每行每隔 2 ms 刷新一次 “死区” 为 0.5 gs 将刷新安排在指令译码阶段，不会出现 “死区” 动态 RAM 和静态 RAM 的比较 DRAM SRAM 存储原理 电容 触发器 集成度 高 低 芯片引脚 少 多 功耗 小 大 价格 低 高 速度 慢 快 刷新 有 无 主存 触发器 只读存储器（ROM） 行列选择线交叉处有 MOS 管为“1” 行列选择线交叉处无 MOS 管为“0” -&gt; PD/Progr 功率下降 / 编程输入端 读出时 为 低电平 存储器与 CPU 的连接 存储器容量的扩展 (1) 位扩展（增加存储字长）-&gt; DBUS (2) 字扩展（增加存储字的数量）-&gt; ABUS -&gt; 位扩展和字扩展 汉明码 2**k ≥ n + k + 1 1 :无错误发生 n :错误发生在n个数据位 k : 错误发生在k个校验位 高速缓冲存储器 -&gt; 命中率 命中率：h = Nc/(Nc+Nm) 平均访问时间：ta = h*tc+(1-h)tm 效率：e = 访问cache的时间/平均访问时间 * 100% -&gt; Cache – 主存的地址映射 ​ -&gt; 直接映射 软盘硬盘区别 硬盘 软盘 速度 高 低 磁头 固定，活动，浮动 活动，接触盘片 盘片 固定盘、盘组，大部分不可换 可换盘片 价格 高 低 环境 苛刻 I/O设备与主机信息传送的控制方式 程序查询方式 程序中断方式 DMA方式 I/O通道方式 I/O处理机方式 I/O 接 口 接口 两个系统或者两个部件之间的交接部分为什么要设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串—并格式转换 实现电平转换 传送控制命令 反映设备的状态（“忙”、“就绪”、 “中断请求”） 接口 Interface 端口 Port 端口：接口电路中的一些寄存器，用来存放数据信息、 控制信息和状态信息 数据端口 控制端口 状态端口 若干个端口加上相应的控制逻辑才组成接口。 总线连接方式的 I/O 接口电路 (1) 设备选择线 (2) 数据线 (3) 命令线 (4) 状态线","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"数据结构的小知识点","slug":"笔记/数据结构/数据结构的一些小知识点","date":"2021-12-28T12:36:46.476Z","updated":"2022-03-20T15:45:57.456Z","comments":true,"path":"2021/12/28/笔记/数据结构/数据结构的一些小知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/28/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"随机存取、顺序存取、随机存储和顺序存储的区别 1.存取结构:随机存取和顺序存取 随机存取（直接存取，Random Access） 指当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关 微观栗子：编程语言中的数组 宏观栗子：随机存取存储器（RAM：Random Access Memory,内存条） （因为RAM利用电容存储电荷的原理保存信息，所以RAM可以高速存取，且与物理地址无关。） 顺序存取（Sequential Access） 一种按记录的逻辑顺序进行读、写操作的存取方法，所需要的时间与该数据所在的物理地址有关。 顺序存取表现为:在存取第N个数据时，必须先访问前（N-1）个数据。 微观栗子：数据结构中的链表 宏观栗子：录音磁带、光盘、机械硬盘里面的磁盘 （磁带、光盘、磁盘上的数据分别存储在不同扇区、不同磁道上，磁盘的读写磁头通过切换不同扇区和磁道来读取物理地址不连续的数据时，该过程中要经过不同扇区和不同磁道上的无关数据，磁盘的读写磁头在切换不同扇区和磁道所需时间也不同，故为顺序存取。） 2.存储结构:顺序存储、随机存储 按ctrl+D键将本页面保存为书签，下次可直接打开网页；按F11(或Fn+F11)键把网页设置成全屏，学习效率更高。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Python小知识点","slug":"Python/细小知识点","date":"2021-12-22T03:03:46.564Z","updated":"2022-05-18T15:32:15.587Z","comments":true,"path":"2021/12/22/Python/细小知识点/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/22/Python/%E7%BB%86%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.复数 我们把形如z=a+bj（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，j称为虚数单位。 一个复数时一对有序浮点数 (x,y)，其中 x 是实数部分，y 是虚数部分。 Python 语言中有关复数的概念： 1、虚数不能单独存在，它们总是和一个值为 0.0 的实数部分一起构成一个复数 2、复数由实数部分和虚数部分构成 3、表示复数的语法：real+imagej 4、实数部分和虚数部分都是浮点数 5、虚数部分必须有后缀j或J 2.and,or (有0,逻辑数据时进行c/c++中的&amp;&amp;与运算(1,0)，or取前and取后) 10 and 20 -&gt; 20 10 or 20 -&gt; 10 10 &amp; 20 -&gt; 0 （01010&amp;10100=00000）每位进行与运算 10 | 20 -&gt;30 逻辑数据，是一种操作数类型。是用来表示二值逻辑中的 &quot;是&quot;与 “否” 、或称 &quot;真&quot;与 “假” 两个状态的数据。 3.Python浮点数占4个字节 4.pass 表示空语句 5.encode异常报错 -&gt; AttributeError: module ‘sys’ has no attribute 'setdefaultencoding Python3字符串默认编码unicode, 所以sys.setdefaultencoding也不存在了,所以去掉，sys.setdefaultencoding -&gt; UnicodeDecodeError: ‘ascii’ codec can’t decode byte …… 默认执行的decode(‘ascii’)执行为decode(‘utf-8’) #python3不能使用 12345import sysreload(sys)sys.setdefaultencoding(&#x27;utf8&#x27;) #python3的话reload函数被移到了importlib库 使用需要使用from importlib import reload 一下或者import importlib 然后使用 importlib.reload() -&gt; ‘gb18030’ codec can’t decode byte 0x80 in position 10: incomplete multibyte sequence（解决方法） 出现这种报错的问题原因是：我们要解码的数据不符合我们期望的类型，所以有时候我们知道数据的编码格式，但是其中有一些其他格式的数据，这样我们就要将其他的格式数据进行忽略，否则解码会报错，程序运行不下去,在decode 中添加’ignore’参数即可 data_str = ** data.decode(‘gb18030’,’ignore’).encode(‘utf8’) 读取文件的时候也可以使用ignore 1file = open(path, encoding=’gb18030’, errors=’ignore’) -&gt; 真正解决Windows下UnicodeDecodeError: ‘gbk‘ codec can‘t decode byte 0xff in position 0错误的方法 在open函数encoding参数中设置正确的文件编码。 123456789101112# coding=utf-8def check_charset(file_path): import chardet with open(file_path, &quot;rb&quot;) as f: data = f.read(4) charset = chardet.detect(data)[&#x27;encoding&#x27;] return charset your_path = 你的文件路径with open(your_path, encoding=check_charset(your_path)) as f: data = f.read() print(data) 6.CSV读取大文件报错 -&gt; _csv.Error: field larger than field limit 该问题出现在用csv读取文件的时候，出现大字段，导致超过字段默认限制，而无法读取。 因此，需要在使用csv读取文件前，先设置下csv字段显示大小。 1234csv.field_size_limit(500 * 1024 * 1024)for i in range(1, 5): # 21 print(&#x27;开始读取第%d个&#x27; % i) csv_reader = csv.reader(open(&quot;E:\\\\数据备份\\\\处理\\\\zc (%d).csv&quot; % i,encoding=&#x27;utf-8&#x27;)) 7.判断key是否存在 方法一：使用自带函数实现 print(dict.contains(“b”)) 方法二：使用in方法 ‘a’ in d /d.key() 方法三：dict.get(‘a’,'没有该key‘)避免了dict[‘a’]没有就报错 判断字典key的个数: len(dict) 8.列表越界报错 -&gt; IndexError: list index out of range 错误原理及解决方法（python） 报错原因：（1）下标超出范围，(2)list是空的，没有一个元素 源文档末尾存在一行空行可以用try…except模块跳过该错误，或删除末尾的空行 9.plt.figure()的使用 1figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True) num:图像编号或名称，数字为编号 ，字符串为名称 figsize:指定figure的宽和高，单位为英寸； dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80 1英寸等于2.5cm,A4纸是 21*30cm的纸张 facecolor:背景颜色 edgecolor:边框颜色 frameon:是否显示边框 10.Python 读写 tsv TSV文件和CSV的文件的区别是： 前者使用\\t作为分隔符，后者使用,作为分隔符 tsv和csv都是以纯文本文件存储的电子表格格式，两者都可以用文本编辑器、Sublime等程序打开，同时他们又是电子表格形式，可以用Excel等电子表格程序打开。tsv和csv被广泛用于计算机存储简单的电子表格数据（貌似csv用的更频繁些~但是有些老外喜欢用tsv格式……嗯……坑货！） 12345678#TSV：tab separated values；即“制表符分隔值”，用制表符分隔数据name,agename age张三 20李四 30#CSV： comma separated values；即“逗号分隔值”，用逗号分隔数据张三,20李四,30 1.python库 2.用csv包读取tsv文件 1234567891011121314#第一步：修改csv包的解析文件模式import csvcsv.register_dialect(&#x27;mydialect&#x27;,delimiter=&#x27;\\t&#x27;,quoting=csv.QUOTE_ALL)#csv中register_dialect()方法是创建自己的解析模式，第一个参数是模式名称（自己取名），第二个参数用于配置分隔符（这里我们把分隔符改成制表符，这样便可以解析tsv格式）#第二步：用自己的解析模式读入tsv文件with open(&#x27;myFile.tsv&#x27;,) as csvfile: file_list = csv.reader(csvfile,&#x27;mydialect&#x27;) for line in file_list: print line #通过csv中的reader()方法解析tsv文件便可，第一个参数是要解析的文件，第二个参数是要使用的解析模式（这里用刚刚配置好的mydialect解析文件）#第三步：注销自己的解析模式csv.unregister_dialect(mydialect) 3.使用pandas： 123456#使用pandas读取tsv文件train=pd.read_csv(&#x27;test.tsv&#x27;, sep=&#x27;\\t&#x27;)#如果已有表头，则可使用header参数train=pd.read_csv(&#x27;test.tsv&#x27;, sep=&#x27;\\t&#x27;, header=0)#如果已有主键列train=pd.read_csv(&#x27;test.tsv&#x27;, sep=&#x27;\\t&#x27;, header=0, index_col=&#x27;id&#x27;) 11.pyplot绘制的图中中文不会正常显示 -&gt; RuntimeWarning: Glyph 22270 missing from current font. font.set_text(s, 0, flags=flags) 1234解决办法：添加一句：plt.rcParams[“font.sans-serif”] = [“SimHei”]再添加一句：plt.rcParams[‘axes.unicode_minus’] = False之后便可以正常显示中文以及负号 12.1e6 = 1000000 13.深浅拷贝 14.缓存机制 15.切片的原理 16.Python取整 17.可视化图简介 子图等 直方图 箱线图 小提琴图 条形图 折线图 1,2 堆叠柱状图 散点图 气泡图 饼状图 热力图 地图等(pyecharts库使用) 18.os.path.exists() os即operating system（操作系统），Python 的 os 模块封装了常见的文件和目录操作。 os.path模块主要用于文件的属性获取,exists是“存在”的意思，所以顾名思义，os.path.exists()就是判断括号里的文件是否存在的意思，括号内的可以是文件路径。 存在返回True；如果不存在，返回的则是FALSE。 19.os.mkdir()与os.makedirs()的区别 os.mkdir(path)，他的功能是一级一级的创建目录，前提是前面的目录已存在，如果不存在会报异常。当你的目录是根据文件名动态创建的时候，你会发现他虽然繁琐但是很有保障，不会因为你的一时手抖，创建而创建了双层或者多层错误路径 os.makedirs(path),可以一次创建多级目录，哪怕中间目录不存在也能正常的（替你）创建，想想都可怕，万一你中间目录写错一个单词… 20.创建文件和文件夹 -&gt; import os 1234567891011121314151617def mkdir(path): path = path.strip()# 去除首位空格 path = path.rstrip(&#x27;\\\\&#x27;) # 去除尾部 \\ 符号 isExists = os.path.exists(path)#判断一个目录是否存在:存在True/不存在False if not isExists: print(&#x27;文件夹不存在！&#x27;) os.makedirs(path)#创建多级目录，不存在会自动创建（有些缺陷，不太严谨） print(&#x27;创建成功！&#x27;) return True else: print(&#x27;文件已存在！&#x27;) return False path = os.getcwd() #可以查看py文件所在路径dictname = &#x27;Dict&#x27;dictpath = path + &#x27;\\\\&#x27; + dictnamemkdir(dictpath) 1234567891011121314#&quot;x&quot; - 创建 - 不存在将创建一个文件，如果文件存在则返回错误#&quot;a&quot; - 追加 - 会追加到文件的末尾#&quot;w&quot; - 写入 - 会覆盖任何已有的内容with open(filepath,&#x27;w&#x27;) as file: file.write(info)file = open(filepath,&#x27;w&#x27;)file.write(info)file.fiutterfile.close()file = open(filepath,&#x27;r&#x27;)print(file.read())file.close() -&gt; import csv 12345with open(filepath,&#x27;w&#x27;) as file: writer = csv.writer(file) writer.writerow(item[itemkind_name[i]])with open(filepath) as fp: reader = csv.reader(fp) 21.Matplotlib设置坐标轴 xlim():设置x坐标轴范围 ylim():设置y坐标轴范围 xlabel():设置x坐标轴名称 ylabel():设置y坐标轴名称 xticks():设置x轴刻度 yticks():设置y轴刻度 22.plt.scatter()的使用 1,2 1scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, , data=None, *kwargs) x, y : 相同长度的数组，数组大小(n，)，也就是绘制散点图的数据； s：绘制点的大小，可以是实数或大小为(n，)的数组， 可选的参数 ； c：绘制点颜色， 默认是蓝色’b’ ， 可选的参数 ； marker：表示的是标记的样式，默认的是’o’ ， 可选的参数 ； cmap：当c是一个浮点数数组的时候才使用， 可选的参数 ； norm：将数据亮度转化到0-1之间，只有c是一个浮点数的数组的时候才使用， 可选的参数 ； vmin , vmax：实数，当norm存在的时候忽略。用来进行亮度数据的归一化 ， 可选的参数 ； alpha：散点的透明度，实数，0-1之间， 可选的参数 ； linewidths：散点的边缘线宽 ； edgecolors：散点的边缘颜色； 23.生成1到100的列表并打印的方法 12345678910111213#使用list生成list1 = list(range(1,100+1))print(list1)#使用列表生成式list2 = [i for i in range(1,100+1)]print(list2)#使用for循环list3 = []for i in range(1,100+1): list3.append(i)print(list3) 24.numpy.random.randn()的使用 numpy.random.rand(d0,d1,…,dn) rand函数根据给定维度生成[0,1)之间的数据，包含0，不包含1 dn表格每个维度 返回值为指定维度的array 25.plt作图时出现横坐标或者纵坐标乱序的解决方法 可以看到Y轴坐标已经乱掉了。 出现这种情况的主要原因在于：Y轴的值不是int或float这种数据，而是 string这种类型，导致转换成数据的时候出错。 123456789fig =plt.figure(100)x=SDFfile[&#x27;ID&#x27;] #元素类型：&lt;class &#x27;numpy.int64&#x27;&gt;y=SDFfile[&#x27;logBB&#x27;] #元素类型：&lt;class &#x27;str&#x27;&gt; 会导致y轴顺序发生变化#改成下面这种代码，把元素类型改一下就好y=[np.float64(i) for i in SDFfile[&#x27;logBB&#x27;]]plt.scatter(x, y)fig.show() 12#我使用的list(map(float, mylist)) 26.plt.plot()的使用 123#不显示y轴,x轴plt.xticks([]) # 不显示x轴plt.yticks([]) # 不显示y轴 27.在文本中寻找关键词(已知) 1 2 3 28.字符串是否为关键字 1 2 29.创建关键词 1 2 3 4 30.502 Bad Gateway 出现502的原因是：对用户访问请求的响应超时造成的 解决办法： 1.提高 Web 服务器的响应速度，也即减少内部的调用关系，可以把需要的页面、素材或数据，缓存在内存中，可以是专门的缓存服务器 ，也可以Web服务器自身的缓存，提高响应速度； 2.网络带宽的问题，则对传输的数据包进行压缩处理，或者向IDC申请增加带宽； 3.属于内部网络的故障或设置问题，也即内部网络拥塞，可能内部存在大量的数据调用或交互造成的，则需要优化内部网络传输或协议； 4.数据库的数据读取造成前端服务器 ，响应用户的请求变慢，那么必须提高数据库的处理能力，若是只读业务可以增加数据缓存的模式 或者增加数据库备机，分散读压力； 若是写的压力，则可以考虑延迟写的模式，想这个时候做数据写分散肯定来不及","categories":[{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://zhang0224gz.github.io/tags/tips/"}]},{"title":"数据结构笔记","slug":"笔记/数据结构/数据结构","date":"2021-12-09T05:52:57.914Z","updated":"2022-03-27T15:50:18.870Z","comments":true,"path":"2021/12/09/笔记/数据结构/数据结构/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"第二、三、四章 线性表 字符串：线性表特例 多维数组：线性表推广（严格不是） 线性表（表）：具有相同类型的数据元素的有限序列 -&gt; 将元素类型限制为字符：字符串（串）：零个或多个字符组成的有限序列 串长：串中所包含的字符个数 空串：长度为 0 的串 子串：串中任意个连续的字符组成的子序列(包含空串) 主串：包含子串的串 子串的位置：子串的第一个字符在主串中的序号 串的存储结构 字符串通常采用顺序存储，即用数组存储 模式匹配 -&gt; BF算法 模式匹配：在主串 S 中寻找子串 T 的过程，T 也称为模式 如果匹配成功，返回 T 在 S 中的位置；否则返回 0 模式匹配问题有什么特点？ （1） 算法的一次执行时间：问题规模通常很大，常常在大量信息中进行匹配 （2） 算法改进所取得的积累效益：模式匹配操作经常被调用，执行频率高 数组的存储结构 如何存储（多维）数组呢？ 数组没有插入和删除操作，所以，不用预留空间，适合采用顺序存储 按行优先：先存储行号较小的元素，行号相同者先存储列号较小的元素 按列优先：先存储列号较小的元素，列号相同者先存储行号较小的元素 -&gt; KMP算法 i 0 1 2 3 4 5 6 char[i] a b a b a b c next -1 0 0 1 2 3 4 nextval -1 0 -1 0 -1 0 4 一、过程： 求next值： 1.两个固定值：char[0]_next=-1; char[1]_next=0（一个，没有匹配的，长度为0） 2.开始求：char[2]匹配出错，前面a!=b（两组字符不同），故next=0(重头开始） char[3]匹配出错，前面有aba, a(char[3]前面的a)和a（匹配必从第一个开始）相同，字符a长度为1，故next=1 char[4]匹配出错，前面有abab,ab和ab相同，长度为2，故next=2 char[5]匹配出错，前面有ababa，aba和aba(123和345)相同，长度为3，故next=3 char[6]匹配出错，前面有ababab,abab和abab(1234和3456)相同,长度为4，故next=4 求nextval值： 1.一个固定值：char[0]_nextval=-1 2.开始求：char[1]_next=0(char[0]=a), a!=b,所以nextval=char[1]_next char[2]_next=0(char[0]=a),a==a,所以nextval=char[0]_nextval 同理可得…… 二、总结： 求next的值： 看当前字符的前面的一组字符是否有相似的一组字符（开头开始）与之相同，取其最大长度作为next的值 求nextval值（修正值）： 当前字符的next值(索引值)所指向的字符是否和当前字符相同：相同则修正值为当前字符的next值所指向的字符的修正值；不同则去当前字符的next值 三、例子再来一个： 0 1 2 3 4 5 6 7 8 9 a b c a b c a b a a next -1 0 0 0 1 2 3 4 5 1 nextval -1 0 0 -1 0 0 -1 0 5 1 **求next值：**next0=-1,next1=0 a!=b,next2=0; abc不可能(ab!=bc),next3=0; 0==3,next4=1; 01==34,next5=2;012==345,next6=3; abca==abca(1234==3456),next7=4; 01234==34567,next8=5 1==8,next9=1 **求nextval值：**nextval0=-1 b!=char[next1]=a, nextval=next1=0 c!=char[next2]=a, nextval=next2=0 a==char[next3]=a,nextval=nextval0=-1 同理可得…… 这个思路也可以： [(7条消息) KMP算法中计算next值和nextval的值_threecat.up的博客-CSDN博客_kmp算法next修正值计算方法https://blog.csdn.net/qq_43919400/article/details/103736457]( 特殊矩阵的压缩存储 什么是特殊矩阵？ 特殊矩阵：矩阵中很多值相同的元素并且它们的分布有一定的规律 特殊矩阵如何压缩存储？ 为值相同的元素分配一个存储空间 特殊矩阵压缩存储后有什么要求吗？ 保证随机存取，即在O(1)时间内寻址 -&gt; 对称矩阵的压缩存储 如何压缩存储对称矩阵呢？ 只存储下三角部分的元素 aij 在一维数组中的下标 k = i×(i-1)/2+ j-1 对称矩阵压缩存储后的寻址方法 对于下三角中的元素aij（i ≥ j）：k＝i×(i-1)/2＋j -1 对于上三角中的元素aij（i＜j），因为aij＝aji，则 k＝j×(j-1)/2＋i -1 -&gt; 三角矩阵的压缩存储 如何压缩存储三角矩阵呢？ 下（上）三角部分的元素；相同的常数只存储一个 下三角矩阵压缩存储后的寻址方法 对于下三角中的元素aij（i ≥ j）：k＝i×(i -1)/2 + j-1 对于上三角中的元素aij（i＜j）：k＝n×(n + 1)/2 -&gt; 对角矩阵的压缩存储 对角矩阵：所有非零元素都集中在以主对角线为中心的带状区域中，所有其他元素都为零 稀疏矩阵的压缩存储 什么是稀疏矩阵？ 稀疏矩阵：矩阵中有很多零元素，并且分布没有规律 稀疏矩阵如何压缩存储？ 只存储非零元素，零元素不分配存储空间 如何只存储非零元素？ 三元组：（行号，列号，非零元素值） -&gt; 三元组顺序表 三元组表：将稀疏矩阵的非零元素对应的三元组所构成的集合，按行优先的顺序排列成一个线性表 -&gt; 十字链表 第五章 树和二叉树 树的前序遍历等价于二叉树的前序遍历！ 树的后序遍历等价于二叉树的中序遍历！ 先访问该结点打标记，再孩子入队列-&gt;图结构时，不会造成重复入队 先访问左右孩子入队列，再打标记 -&gt;图结构时会造成重复入队 逻辑关系 线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继； 树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子 图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接 树 树：n个结点(数据元素)的有限集合 ，当 n＝0 时，称为空树；任意一棵非空树 T 满足以下条件： （1）有且仅有一个特定的称为根的结点； （2）当 n＞1 时，除根结点之外的其余结点被分成 m（m &gt; 0）个互不相交的有限集合 T1,T2,… , Tm，其中每个集合又是一棵树，并称为这个根结点的子树。 ​ *树的定义是采用递归方法 互不相交的具体含义是什么？ 结点：结点不能属于多个子树 边：子树之间不能有关系 *互不相交-&gt;没有回路-&gt;树结构具有层次性 结点的度：结点所拥有的子树的个数 树的度：树中各结点度的最大值 叶子结点：度为 0 的结点，也称为终端结点 分支结点：度不为 0 的结点，也称为非终端结点 *在树结构中，逻辑关系表现为双亲——孩子 路径：结点序列 n1, n2, …, nk 称为一条由 n1 至 nk 的路径，当且仅当满足如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k） 路径长度：路径上经过的边的个数 在树结构中，路径是唯一的 祖先、子孙：如果有一条路径从结点 x 到结点 y，则 x 称为 y 的祖先，而 y 称为 x 的子孙 结点所在层数：根结点的层数为 1；对其余结点，若某结点在第 k 层，则其孩子结点在第 k+1 层 树的深度（高度）：树中所有结点的最大层数 树的宽度：树中每一层结点个数的最大值 树的遍历 -&gt;前序，中序，后序和层序 树的遍历：从根结点出发，按照某种次序访问树中所有结点，并且每个结点仅被访问一次 树的存储结构 -&gt;双亲，孩子，孩子兄弟表示法 实现树的存储结构，关键是什么? 如何表示树中结点之间的逻辑关系 什么是存储结构? 数据元素及其逻辑关系在存储器中的表示 树中结点之间的逻辑关系是什么? 思考问题的出发点：如何表示结点的双亲和孩子 二叉树 -&gt;斜树，满二叉树，完全二叉树 二叉树： n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树是度为 2 的树吗？ 二叉树是度小于等于 2 的树吗？ 二叉树有什么特点？ （1）每个结点最多有两棵子树 （2）二叉树是有序的，其次序不能任意颠倒 左斜树：所有结点都只有左子树的二叉树 右斜树：所有结点都只有右子树的二叉树 斜树：左斜树和右斜树的统称 斜树有什么特点呢？ （1）每一层只有一个结点 （2）结点个数与其深度相同 *斜树是树结构的特例，是从树结构退化成了线性结构 满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上的二叉树 满二叉树有什么特点呢？ （1）叶子只能出现在最下一层 （2）只有度为 0 和度为 2 的结点 （3）在同样深度的二叉树中结点个数最多 （4）在同样深度的二叉树中叶子结点个数最多 满二叉树是树结构的特例，是最丰满的二叉树 完全二叉树：在满二叉树中，从最后一个结点开始，连续去掉任意个结点得到的二叉树 完全二叉树有什么特点呢？ （1）叶子结点只能出现在最下两层且最下层的叶子结点都集中在二叉树的左面 （2）完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子 （3）深度为 k 的完全二叉树在 k-1 层上一定是满二叉树 （4）在同样结点个数的二叉树中，完全二叉树的深度最小 二叉树性质 -&gt; n0＝n2＋1 性质 5-1：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2＋1 n＝n0＋n1＋n2 ;n＝n1＋2n2＋1;n0＝n2＋1 -&gt; 第i层：2**(i-1)个结点 性质 5-2：二叉树的第 i 层上最多有2i-1个结点（i≥1） -&gt;最多有2**(k-1)个结点 性质 5-3：一棵深度为 k 的二叉树中，最多有 2k-1个结点 深度为 k 且具有 2k-1个结点的二叉树一定是满二叉树 -&gt;深度：log n下取整+1 性质 5-4：具有 n 个结点的完全二叉树的深度为[ logn] +1/log(n+1)上取整 -&gt;双亲i/2，左孩子2i，右孩子2i+1 性质 5-5：对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，对于任意的序号为 i（1≤i≤n）的结点（简称结点 i），有： （1）如果 i＞1，则结点 i 的双亲结点的序号为 i/2，否则结点 i 无双亲结点 （2）如果 2i≤n，则结点 i 的左孩子的序号为 2i，否则结点 i 无左孩子 （3）如果 2i+1≤n，则结点 i 的右孩子的序号为2i+1，否则结点 i 无右孩子 二叉树的遍历 -&gt;前序，中序，后序和层序O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445template &lt;typename DataType&gt;class BiTree&#123;public: BiTree( )&#123;root = Creat(root);&#125; ~BiTree( )&#123;Release(root);&#125; void PreOrder( )&#123;PreOrder(root);&#125; void InOrder( )&#123;InOrder(root);&#125; void PostOrder( )&#123;PostOrder(root);&#125; void LeverOrder( ); private: BiNode&lt;DataType&gt; *Creat(BiNode&lt;DataType&gt; *bt); void Release(BiNode&lt;DataType&gt; *bt); void PreOrder(BiNode&lt;DataType&gt; *bt); void InOrder(BiNode&lt;DataType&gt; *bt); void PostOrder(BiNode&lt;DataType&gt; *bt); BiNode&lt;DataType&gt; *root; &#125;;template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; :: PreOrder(BiNode&lt;DataType&gt; *bt) &#123; if (bt == nullptr) return; //递归调用的结束条件 else &#123; cout &lt;&lt; bt-&gt;data; //访问根结点bt的数据域 PreOrder(bt-&gt;lchild); //前序递归遍历bt的左子树 PreOrder(bt-&gt;rchild); //前序递归遍历bt的右子树 &#125;&#125;template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; :: LeverOrder( )&#123; BiNode&lt;DataType&gt; *Q[100], *q = nullptr; int front = -1, rear = -1; if (root == nullptr) return; Q[++rear] = root; while (front != rear) &#123; q = Q[++front]; cout &lt;&lt; q-&gt;data; if (q-&gt;lchild != nullptr) Q[++rear] = q-&gt;lchild; if (q-&gt;rchild != nullptr) Q[++rear] = q-&gt;rchild; &#125;&#125; 二叉树的存储结构 -&gt;顺序存储结构 顺序存储结构的要求是什么？ 用一组连续的存储单元依次存储数据元素，由存储位置表示元素之间的逻辑关系 二叉树的顺序存储结构是用一维数组存储二叉树的结点，结点的存储位置（下标）应能体现结点之间的逻辑关系——父子关系 缺点：浪费存储空间 二叉树的顺序存储结构一般仅存储完全二叉树 1234567void PreOrder(char a[],int i,int n)&#123; if(i&gt;=n)return; cout&lt;&lt;a[i]&lt;&lt;endl; PreOrder(a,2*i,n); PreOrder(a,2*i+1,n);&#125; -&gt;二叉链表 二叉链表：二叉树的每个结点对应一个链表结点，链表结点存放结点的数据信息和指示左右孩子的指针 叶子结点的标志？ 左右孩子指针均为空 n 个结点的二叉链表有多少个空指针？ 2n-(n-1) = n+1 个空指针 如何由一种遍历序列生成该二叉树？ 扩展二叉树：将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值如 ‘#’ -&gt;扩展二叉树 123456789101112131415template &lt;typename DataType&gt;BiNode&lt;DataType&gt; *BiTree&lt;DataType&gt; :: Creat(BiNode&lt;DataType&gt; *bt)&#123; char ch; cin &gt;&gt; ch; //输入结点的数据信息，假设为字符 if (ch == ‘#’) bt = nullptr; //建立一棵空树 else &#123; bt = new BiNode&lt;DataType&gt;; bt-&gt;data = ch; bt-&gt;lchild = Creat(bt-&gt;lchild); //递归建立左子树 bt-&gt;rchild = Creat(bt-&gt;rchild); //递归建立右子树 &#125; return bt;&#125;扩展二叉树的前序遍历序列：A B # D # # C # # 森林 森林：m（m≥0）棵互不相交的树的集合 森林的遍历：按照某种次序(前序（根）、后序（根）)依次遍历构成森林的 m（m≥0）棵树 最优二叉树 叶子结点的权值：对叶子结点赋予的一个有意义的数值量 二叉树的带权路径长度：从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和 最优二叉树（哈夫曼树）：给定一组具有确定权值的叶子结点，带权路径长度最小的二叉树 最优二叉树有什么特点? （1）权值越大的叶子结点越靠近根结点 （2）只有度为 0 和度为 2 的结点，不存在度为 1 的结点 -&gt;哈夫曼算法 1选取权值最小的两棵二叉树进行合并，重新排序，再选权值最小的两棵二叉树进行合并 -&gt;哈夫曼编码 编码：给每一个对象标记一个二进制位串来表示一组对象 等长编码：用长度相等的二进制位串表示一组对象 编码的目的是什么? 数字化（编码效率取决于编码长度） 不等长编码：表示一组对象的二进制位串的长度不相等 设计不等长编码时，必须考虑解码的唯一性 前缀编码：在一组编码中，任一编码都不是其它任何编码的前缀 ​ *前缀（无歧义）编码保证了在解码时不会有多种可能 线索二叉树 线索：指向前驱和和后继结点的指针 线索二叉树：加入线索的二叉树 缺点：指针和线索无法区分-&gt;加标记 0孩子,1前驱后继 以一定规则将二叉树中的结点排列成一个线性序列，使每个结点(除第一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继 优点：如果右链中中序后继，左链中中序前趋，则中序遍历的效率高 第六章 图 单链表的逆置，寻找叶子结点，树的遍历，折半查找，哈夫曼树 逻辑关系 线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继； 树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子 图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接 连通图（无向图） 连通顶点：在无向图中，如果顶点vi和顶点vj(i≠j)之间有路径，则称顶点vi和vj是连通的 连通图：在无向图中，如果任意两个顶点都是连通的，则称该无向图是连通图 连通分量：非连通图的极大连通子图：含有极大顶点数，依附于这些顶点的所有边 强连通图、强连通分量（有向图） 强连通顶点：在有向图中，如果从顶点vi到顶点vj和从顶点vj到顶点vi均有路径，则称顶点vi和vj是强连通的 强连通图：在有向图中，如果任意两个顶点都是强连通的，则称该有向图是强连通图 强连通分量：非强连通图的极大连通子图 图的遍历 图的遍历：从图中某一顶点出发访问图中所有顶，并且每个结点仅被访问一次 在图中，如何选取遍历的起始顶点？ 解决方案：将图中的顶点按任意顺序排列起来， 从编号最小的顶点开始 从某顶点出发能访问其他所有顶点吗？ 解决方案：多次调用图遍历算法 如何避免遍历不会因回路而陷入死循环？ 解决方案：附设访问标志数组visited[n] 采用什么次序依次访问图中所有顶点？ -&gt; 深度优先遍历和广度优先遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061深度优先遍历DFTraverse（类似树的前序遍历）广度优先遍历BFTraverse（类似树的层序遍历） template &lt;typename DataType&gt;void MGraph&lt;DataType&gt; :: DFTraverse(int v) &#123; cout &lt;&lt; vertex[v]; visited[v] = 1; for (int j = 0; j &lt; vertexNum; j++) if (edge[v][j] == 1 &amp;&amp; visited[j] == 0) DFTraverse( j );&#125;template &lt;typename DataType&gt;void MGraph&lt;DataType&gt; :: BFTraverse(int v) &#123; int w, j, Q[MaxSize]; //采用顺序队列 int front = -1, rear = -1; //初始化队列 cout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v; //被访问顶点入队 while (front != rear) //当队列非空时 &#123; w = Q[++front]; //将队头元素出队并送到v中 for (j = 0; j &lt; vertexNum; j++) if (edge[w][j] == 1 &amp;&amp; visited[j] == 0 ) &#123; cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j; &#125; &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: DFTraverse(int v)&#123; int j; EdgeNode *p = nullptr; cout &lt;&lt; adjlist[v].vertex; visited[v] = 1; p = adjlist[v].firstEdge; while (p != nullptr) &#123; j = p-&gt;adjvex; if (visited[j] == 0) DFTraverse(j); p = p-&gt;next; &#125;&#125;template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt; :: BFTraverse(int v) &#123; int w, j, Q[MaxSize]; int front = -1, rear = -1; EdgeNode *p = nullptr; cout &lt;&lt; adjlist[v].vertex; visited[v] = 1; Q[++rear] = v; while (front != rear) &#123; w = Q[++front]; p = adjlist[w].firstEdge; while (p != nullptr) &#123; j = p-&gt;adjvex; if (visited[j] == 0) &#123; cout &lt;&lt; adjlist[j].vertex; visited[j] = 1; Q[++rear] = j; &#125; p = p-&gt;next; &#125;&#125; 存储结构 -&gt; 邻接矩阵和邻接表 1234567891011struct EdgeNode&#123; int adjvex; EdgeNode *next;&#125; ;template &lt;typename DataType&gt; struct VertexNode&#123; DataType vertex; EdgeNode *firstEdge;&#125;; 边表中的结点表示什么？对应图中的一条边 设图有n个顶点e条边，邻接表的空间复杂度是多少？O(n+e) 如何求顶点 v 的度？顶点 v 的边表中结点的个数 12345p = adjlist[v].firstEdge; count = 0;while (p != nullptr)&#123; count++; p = p-&gt;next;&#125; 如何求顶点 v 的所有邻接点?顶点 i 的边表中的所有结点 123456p = adjlist[v].firstEdge; while (p != nullptr)&#123; j = p-&gt;adjvex; //j是v的邻接点 p = p-&gt;next;&#125; 最小生成树（无向图） -&gt; Prim算法O(n2) 生成树：连通图的生成树是包含全部顶点的一个极小连通子图（含有n-1条边） 生成树的代价：在无向连通网中，生成树上各边的权值之和 最小生成树(Minimum Spanning Tree) ：在无向连通网中，代价最小的生成树 贪心算法的应用：Prim算法，Kruskal算法和Boruvka算法 Prim算法：先构造满足条件的候选最短边集，再查找最短边 Kruskal算法：先查找最短边，再判断是否满足条件 123456Prim算法 O(n2)*每步添加一条边及其相连的顶点(min)到一棵树，从而逐步生成最小生成树(可能不唯一，但代价唯一)通过第一个顶点，将第一个顶点和其他顶点的权值进行比较，找到最小边邻接的顶点该邻接顶点和剩余顶点比较，比第一个顶点和其权值小就替换进数组，找到更新后的最小边的邻接顶点……（创建一个数组存放当前顶点和邻接顶点的边，当邻接顶点和当前顶点的边权值更小就更新。每次找出更新的最小边，并将选择出的顶点从数组中标除去） -&gt; Kruskal算法O(elog2e) 12345678910？Kruskal算法 O(elog2e)*将所有的点放入，每次选最小的边，但不能形成回路图采用什么存储结构呢？ 边集数组表示法Kruskal算法在图中存在相同权值的边时也有效如何存储连通分量呢？ 并查集（并查集：集合中的元素组织成树的形式：（1）查找两个元素是否属于同一集合：所在树的根结点是否相同（2）合并两个集合——将一个集合的根结点作为另一个集合根结点的孩子）*如何判断两个顶点是否位于同一个连通分量呢？*如何合并两个连通分量呢？ 最短路径（有向图） -&gt; Dijkstra算法O(n2) 最短路径：非带权图——边数最少的路径 最短路径：带权图——边上的权值之和最少的路径 路径上第一个顶点称为源点；最后一个顶点称为终点 对于非带权图，如何求最短路径？ 广度优先遍历 对于带权图，如何求最短路径？ 123Dijkstra算法 O(n2)针对一个源点，求出中转（mini)；将中转和剩下点连接，比剩下点与上一个点的路径短就替换，再在整合好的表中找到最短的当前最短路径中最小路为最终最短路（路径长度递增） (dist,path) v1 v2 v3 v4 {v0} (10,‘v0v1’) (**,’ ') (30,‘v0v3’) (100,‘v0v4’) {v0v1} (60，‘v0v1v2’) (30,‘v0v3’) (100,‘v0v4’) {v0v1v3} (50,‘v0v3v2’) (60,‘v0v3v4’) {v0v1v3v2} (60,‘v0v3v2v4’) {v0v1v3v2v4} 疑惑性很大，如何当点&gt;2时，进行判断不同可能性（类似Prim但必须包含源点得出的路径？） -&gt; Floyd算法O(n3) 123456Floyd算法 O(n3)*可有权值为负，但不能有负的回路(*)-&gt; 使用邻接矩阵初始化path0（两点相连的所有可能性9种，以a/b/c为源点），在两点间插入a(保持源点不变，以a为源点的一行可忽视,6种；如果值比原来小就替换)形成path1,在path1中插入b……同理……dist保存路径权值，path保存路径中的点-&gt;该算法将所有的可能性都计算出来，只有最后一步有效 有向无环图 -&gt; AOV网和拓扑排序 O(n+e) 什么是工程？工程有什么共性？ 几乎所有的工程都可以分为若干个称作活动的子工程 某些活动之间通常存在一定的约束条件 AOV网（顶点表示活动的网）：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系 AOV网（activity on vertex network） AOV网中出现回路意味着什么？活动之间的优先关系是矛盾的 拓扑序列:v2必须满足v0和v1才能成立（栗子：排课系统），可能不唯一 拓扑排序：对一个有向图构造拓扑序列的过程 12345678图采用什么存储结构呢？ 邻接表在邻接表中，如何求顶点的入度？ 顶点表中增加入度域如何查找没有前驱的顶点？ 设置栈或队列成功标志：排完后，所有点都排序（NULL），不剩余点 1.重复下述操作，直到输出全部顶点，或AOV网中不存在没有前驱的顶点 1.1从AOV网中选择一个没有前驱的顶点并且输出； 1.2从AOV网中删去该顶点，并且删去所有以该顶点为尾的弧； -&gt;AOE网和关键路径 什么是工程？工程有什么共性？ 几乎所有的工程都可以分为若干个称作活动的子工程 活动之间存在某些制约关系 每个活动通常需要一个持续的时间 源点：整个工程的开始点，其入度为0 终点：整个工程的结束点，其出度为0 AOE网（边表示活动的网）：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间 AOE网（activity on edge network） AOE网的性质： （1）只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生 （2）只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始 AOE网能够解决什么问题？ （1） 完成整个工程至少需要多少时间? （2）为缩短完成工程所需的时间， 应当加快哪些活动? 关键路径：AOE网中从源点到终点的最长路径 关键活动：关键路径上的活动 不按期完成关键活动就会影响整个工程的进度；换言之，要缩短整个工期，必须加快关键活动的进度 1234567891011121314151617如何求关键路径呢？ 求关键活动如何求关键活动呢？关键活动为什么是关键的？关键活动的开始时间不能推迟-&gt;关键活动的最早开始时间和最晚开始时间相等 1. 计算各个活动的最早开始时间和最晚开始时间 2. 计算各个活动的时间余量，时间余量为 0 即为关键活动设带权有向图 G=(V，E)含有 n 个顶点 e 条边，设置 4 个一维数组：（1）事件的最早发生时间 ve[n] -&gt; 从v0=0开始到该顶点的相加ai和取最大（正序计算）（2）事件的最迟发生时间 vl[n] -&gt; 从v3=10开始到该点减去ai被减差取最小（倒序计算）（3）活动的最早开始时间 ae[e] -&gt; 等于ve[以ai为出度的事件] （4）活动的最晚开始时间 al[e] -&gt; vl[以ai为入度的事件]-ai-&gt; al[i]-ae[i]=0 取为0的相连作为关键路径书P205 表格 一个关键活动的延期，会影响延误工期；一个关键活动的提前，不一定提前工期 第七章 查找技术 基本概念 关键码：可以标识一个**记录(数据元素、结点、顶点)**的某个数据项 键值：关键码的值 主关键码：可以唯一标识一个记录的关键码 次关键码：不能唯一标识一个记录的关键码 什么是查找？ 查找：在相同类型的记录构成的集合中找出满足给定条件的记录 静态查找 ：不涉及插入和删除操作的查找 静态查找只注重查找效率，适用于： （1）查找集合一经生成，便只对其进行查找，而不进行插入和删除操作 （2）经过一段时间的查找之后，集中地进行插入和删除等修改操作 动态查找 ：涉及插入和删除操作的查找 动态查找要求插入、删除、查找均有较好的效率，适用于：查找与插入和删除操作在同一个阶段进行 例如：当查找成功时，要删除查找到的记录 当查找不成功时，要插入被查找的记录 查找结构 ：面向查找操作的数据结构 ，即查找基于的数据结构 查找基于的数据模型是什么？集合 集合 ：线性表：适用于静态查找，顺序查找、折半查找等技术 树 表：适用于动态查找，二叉排序树的查找技术 散列表：静态查找和动态查找均适用，采用散列技术 查找算法的性能 如何评价查找算法的效率呢？和关键码的比较次数 关键码的比较次数与哪些因素有关呢？ 平均查找长度ASL：查找算法进行的关键码比较次数的数学期望值 查找算法 线性表 1234567891011121314151617/*顺序查找（线性查找）O(n)改进：设置“哨兵”，就是待查值，放在查找方向的尽头处，免去了每一次比较后都要判断查找位置是否越界不要求元素的有序性，插入、删除的性能是O(1)查找性能是O(n)*/ int LineSearch :: SeqSearch2(int k) &#123; int i = n; data[0] = k; while (data[i] != k) i--; return i;&#125; 12345678910111213141516171819202122232425262728293031323334353637/*折半查找（对半查找、二分查找）在有序表（假设为递增）中，取中间记录作为比较对象，若给定值与中间记录相等，则查找成功；若给定值小于中间记录，则在有序表的左半区继续查找；若给定值大于中间记录，则在有序表的右半区继续查找。不断重复上述过程，直到查找成功，或查找区域无记录，查找失败查找性能是O(log2n)为保证元素的有序性，插入、删除要移动元素，性能是O(n)*///非递归算法：int LineSearch :: BinSearch1(int k) /*查找集合存储在r[1]~r[n]*/&#123; int mid, low = 1, high = n; /*初始查找区间是[1, n]*/ while (low &lt;= high) /*当区间存在时*/ &#123; mid = (low + high) / 2; if (k &lt; data[mid]) high = mid - 1; else if (k &gt; data[mid]) low = mid + 1; else return mid; /*查找成功，返回元素序号*/ &#125; return 0; /*查找失败，返回0*/&#125;//递归算法：int LineSearch :: BinSearch2(int low, int high, int k) &#123; int mid; if (low &gt; high) return 0; /*递归的边界条件*/ else &#123; mid = (low + high) / 2; if (k &lt; data[mid]) return BinSearch2(low, mid-1, k); else if (k &gt; data[mid]) return BinSearch2(mid+1, high, k); else return mid; /*查找成功，返回序号*/ &#125;&#125; 判定树（折半查找判定树）：描述折半查找判定过程的二叉树 查找成功的平均比较次数 = (1×1+2×2+3×4+4×4)/11 = 3 查找不成功的平均比较次数 = (3×4+4×8)/12 = 11/3 树表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*二叉排序树（二叉查找树）：或者是一棵空的二叉树，或者是具有下列性质的二叉树：（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值（3）它的左右子树也都是二叉排序树中序序列是元素升序排序存储：二叉链表*/class BiSortTree &#123;public: BiSortTree(int a[ ], int n); ~ BiSortTree( ) &#123;Release(root);&#125; BiNode&lt;int&gt; *InsertBST(int x) &#123;return InsertBST(root, x);&#125; void DeleteBST(BiNode&lt;int&gt; *p, BiNode&lt;int&gt; *f ); BiNode&lt;int&gt; *SearchBST(int k) &#123;return SearchBST(root, k);&#125;private: BiNode&lt;int&gt; *InsertBST(BiNode&lt;int&gt; *bt , int x); BiNode&lt;int&gt; *SearchBST(BiNode&lt;int&gt; *bt, int k); void Release(BiNode&lt;DataType&gt; *bt); BiNode&lt;int&gt; *root; &#125;;BiSortTree::BiSortTree(int a[ ], int n)//构造函数&#123; root = nullptr; for (int i = 0; i &lt; n; i++) root = InsertBST(root, a[i]);&#125;BiNode&lt;int&gt; * BiSortTree :: SearchBST(BiNode&lt;int&gt; *bt, int k)//查找函数&#123; if (bt == nullptr) return nullptr; if (bt-&gt;data == k) return bt; else if (bt-&gt;data &gt; k) return SearchBST(bt-&gt;lchild, k); else return SearchBST(bt-&gt;rchild, k);&#125;BiNode&lt;int&gt; * BiSortTree::InsertBST(BiNode&lt;int&gt; *bt, int x)//插入函数&#123; if (bt == nullptr) &#123; BiNode&lt;int&gt; *s = new BiNode&lt;int&gt;; s-&gt;data = x; s-&gt;lchild = s-&gt;rchild = nullptr; bt = s; return bt; &#125; else if (bt-&gt;data &gt; x) bt-&gt;lchild = InsertBST(bt-&gt;lchild, x); else bt-&gt;rchild = InsertBST(bt-&gt;rchild, x);&#125;二叉排序树的性能分析最坏情况：退化为线性查找最好情况：相当于折半查找平均情况：O(n) ~ O(logn) 123456789101112/*平衡二叉树（二叉排序树优化-&gt;深度尽可能小的二叉排序树）二叉排序树的深度取决于给定查找集合的排列，即结点的插入顺序平衡因子：该结点的左子树的深度减去右子树的深度平衡二叉树：或者是一棵空的二叉排序树，或者是具有下列性质的二叉排序树：（1）根结点的左子树和右子树的深度最多相差 1;（2）根结点的左子树和右子树也都是平衡二叉树在平衡二叉树中，结点的平衡因子是1、0 或 -1平衡调整扁担原理：将根结点看成是扁担中肩膀的位置*/ 123456/*B树：一棵m阶的B树或者为空树，或者为满足下列特性的m叉树：（1）每个结点至多有 m 棵子树；（2）根结点至少有两棵子树；（3）除根结点和叶子结点外，所有结点至少有[m/2]棵子树；*/ 散列表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*散列的基本思想：在记录的关键码和存储地址之间建立一个确定的对应关系，通过计算得到待查记录的地址。散列表：采用散列技术存储查找集合的连续存储空间。散列函数：将关键码映射为散列表中适当存储位置的函数。散列地址：由散列函数所得的存储地址。冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj)。同义词：ki 和 kj 相对于H 称做同义词。 散列是一种完整的存储结构吗？散列只是通过记录的关键码定位该记录，没有完整地表达记录之间的逻辑关系，所以，散列主要是面向查找的存储结构散列技术能进行范围查找吗？适合于哪种类型的查找？散列技术最适合回答的问题是：如果有的话，哪个记录的关键码等于待查值除留余数法 H(key)=key mod p 处理冲突的方法——开放定址法（数组）对于给定的关键码key执行下述操作：（1）计算散列地址：j = H(key)（2）如果地址 j 的存储单元没有存储记录，则存储key对应的记录；（3）如果在地址 j 发生冲突，则寻找一个空的散列地址，存储key对应的记录；闭散列表：用开放定址法处理冲突得到的散列表线性探测法：从冲突位置的下一个位置起，依次寻找空的散列地址。堆积：非同义词对同一个散列地址争夺的现象二次探测法：以冲突位置为中心，跳跃式寻找空的散列地址。Hi=(H(key)＋di) % m （di = 12,-12,22,-22,… , q2,-q2(q≤m/2)）处理冲突的方法——拉链法（链表）对于给定的关键码key执行下述操作：（1）计算散列地址：j = H(key)（2）将key对应的记录插入到同义词子表 j 中；（头插）同义词子表：所有散列地址相同的记录构成的单链表。开散列表：用拉链法处理冲突得到的散列表。开散列表中存储同义词子表的头指针，开散列表不会出现堆积现象散列查找的性能分析散列技术的查找性能取决于什么？产生冲突后，仍然是给定值与关键码进行比较影响冲突产生的因素有什么？（1）散列函数是否均匀（2）处理冲突的方法 （3）散列表的装填因子α= 表中填入的记录数/散列表的长度*/ 堆积：非同义词对同一个散列地址争夺的现象 冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj) 第8章 排序技术 基本概念 1.排序：给定一组记录（数据元素，结点，顶点）的集合{r1,r2,…,rn}，其相应的关键码分别为{k1,k2,…,kn},将这些记录排列为{s1,s2,…,sn}的序列，使得相应关键码满足升序或降序。 （排序是对线性结构(数据模型)的一种操作） 2.排序码(关键码)：排序的依据 3.趟：在排序过程中，将待排序的记录序列扫描一遍称为一趟 4.排序算法的稳定性：相同关键码的相对次序经过排序保持不变 （只是算法的一种属性，且有具体算法决定） 排序算法的性能 （1）时间性能：排序算法在各种情况（最好、最坏、平均）下的时间复杂度。 例如，基于比较的内排序在排序过程中的基本操作： ① 比较：关键码之间的比较； ② 移动：记录从一个位置移动到另一个位置。 （2）空间性能：排序过程中占用的辅助存储空间。 辅助存储空间是除了存放待排序记录占用的存储空间之外，执行算法所需要的其他存储空间。 直接插入排序 希尔排序 起泡排序 快速排序 简单选择排序 堆排序 归并排序 最好情况 正序 O(n) O(n**1.3) 正序 O(n) 都是中值O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 最坏情况 逆序 O(n**2) 逆序 O(n**2) 正序逆序O(n**2) O(n2) O(nlog2n) O(nlog2n) 平均情况 O(n**2) O(n**2) O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 稳定性 稳定 不稳定 稳定 不稳定 不稳定 不稳定 稳定 时间性能 O(n**2) 取决于增量序列O(n**2) ~ O(nlogn) O(n**2) O(nlog2n) O(n**2) O(nlog2n) O(nlog2n) 空间性能 O(1) O(1) O(1) O(log2n)~O(n) O(1) O(1) O(n) 稳定性：直接插入排序，起泡排序，归并排序 不稳定：希尔排序，快速排序，简单选择排序，堆排序 直接插入排序、简单选择排序和起泡排序 O(n2) 堆排序、快速排序和归并排序 O(nlogn) 希尔排序的时间性能取决于增量序列，介于O(n2)和O(nlog2n)之间 缓冲区应该是一个（队列 ）结构。 最快的速度挑选出前10个最大的，采用（ 堆排序）方法最好。 （插入排序）可能会出现下面情况：在最后一趟开始之前，所有元素都不在最终位置上 基于比较的内排序 -&gt; 比较排序 -&gt; 直接插入排序 直接插入排序：（正序）循环第k个元素开始，向前进行比较，大于就交换，小于就结束，进行下一趟 -&gt;排序过程：前面k-1个有序，后面无序 -&gt; 希尔排序 希尔排序：步数为n，序列中索引值为(i += n)的作为一个子序列进行排序，再全部进行直接插入排序 -&gt; 交换排序 -&gt; 起泡排序 起泡排序：两两比较，如果反序则交换 -&gt;排序过程：后面k+1个有序，前面无序 -&gt; 快速排序 快速排序：将第一个作为中间值mid，从后向前找比mid小的，找到就交换位置，i++；从前向后开始找比mid大的，找到就交换位置,j–；重复，直到i&gt;=j,一趟结束。i==j的位置作为下一趟的mid值。 -&gt; 选择排序 -&gt; 简单选择排序 简单选择排序：将前n-1个值和和该值后面的进行比较，找到最小的和该值交换 -&gt;排序过程：前面k-1个有序，后面无序 -&gt; 堆排序 堆排序：（大根堆）原顺序作为层序形成完全二叉树，从大到小的根节点和孩子比较，小就交换，然后向下继续比较小就交换直到底。形成大根堆，将第一个0和最后一个n-1交换，剩下n-1个进行堆调整。 -&gt; 归并排序 归并排序：将序列划分为2**n个子序列进行单独排序，两两合并为2*n-1个子序列进行单独排序,一直到合并为一个排序 -&gt; 基数排序 基数排序：栗子三位数排序(有明显界限的个位，十位，百位) 创建10个链表09,先后按个位按09连进属于的表头（尾插），结束将其串成整表，再按照十位做相同的行为","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SET4-作文","slug":"英语/CET4--作文","date":"2021-12-06T02:20:39.278Z","updated":"2021-12-17T15:19:33.154Z","comments":true,"path":"2021/12/06/英语/CET4--作文/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4--%E4%BD%9C%E6%96%87/","excerpt":"","text":"“use&quot;类 栗子：the use of translation apps is becoming increasingly popular 开篇可概述翻译应用程序在生活中的应用越发广泛的趋势 主体部分应详述其应用情况：多种应用场景 + 积极影响/受欢迎的原因 结尾部分可总结其带来的益处，适当提及不足之处和未来的应用或发展趋势 The use of translation apps is becoming increasely popular.They play a critical role in removing the language barrier in this globalized era(全球化的时代). These technology tools are especially helpful for both leisure(闲暇，业余时间；休闲活动) and business travelers. With the ever-increasing input of linguistic data,these apps will be smarter and thus applied in broader fields.As a result,more people will enjoy the fruits of this technological advance. 123456789101112131415词汇：machine translation 机器翻译convert speech to text 将语音转换为文字voice/speech recognition 语音识别voice translator apps 语音翻译应用程序photo/camera translator apps 拍照翻译应用程序an offline multilingual dictionary 可离线使用的多语种词典translate text into multiplelanguages 将文本翻译为多种语言offer instant speech-to-speech translation 提供即使语音翻译foreign/overseas/international travel 出国游have a short conversation with locals 与当地人进行简短的交流bridge the information and communication gap 架起信息与沟通的桥梁keep in contact with clients/customers worldwide 与世界各地的客户保持联系conduct trade negotiations with foreign companies 与外国公司进行贸易洽谈 &quot;changes of ways&quot;类 栗子：Changes in the way of education 开篇可铺陈背景，引入对“教育方式发生改变”的探讨，或开门见山，直接概述教育领域发生的变化 主体部分应详细阐述具体变化（今昔对比/当下变化）+ 这些变化的成因/影响 结尾部分可对这些变化简要作评，或展望未来的发展趋势并呼吁人们做好准备 The past decades have witnessed a surge of technological innovations.Irresistibly useful and convenient,tools resulting from these innovations have prompted(促使，导致) radical changes in our lifestyle.Among them,changes in the way of education are some of the most noticeable ones. Nowadays,the computer and projector(投影仪) have become indispensable(不可或缺的) in every classroom.Compared with old-fashioned chalk and talk(板书口授),multimedia-based teaching enables teachers to demonstrate what they found hard or even impossible in the past,such as abstract geometric(几何的) concepts and bizarre lanscapes. The trend of distance learning is another significant change.With a wide array of(大量各式各样的) online courses to choose from,teaching and learning are no longer confined(局限) to the classroom or school day.Students now can attend lectures by prominent(著名的，卓越的) professors in far-away locations in their own bedroom anytime they want.And all this happens just within a few clicks. Although these changes are by and large(大体上) constructive,they do have a couple of unintended(无意地的，意想不到的) negative consequences.For instance,distance learning is likely to lead to a detached(冷淡的，疏远的) relationship between the student and the teacher. 其他作文： the changes of communication:At one time,people communicated primarily face to face and via letters.Nowadays,however,the advancement of network technology offers us more options such as text messaging,voice calling and video chatting.These changes bring a great deal of benefits.Perhaps the most obvious one is convenience.Irrespective of (不考虑，不管)the geographical locations and time zones,we can now keep in touch with each other through the Internet at a previously unimaginable speed. This increased efficiency,in turn,leads to reduced costs.For instance,the advent of video conferencing(视频会议) allows people to meet each other without having to worry about travel expenses. More excitingly,changes in the way of communication make possible remote “importance of quality&quot;类 栗子：Self-confidence:an importance factor for success 开篇可概述没有自信的危害来强调自信的重要性 主体部分：自信的定义+例子论证自信是成功的必要因素 结尾部分总结其带来的益处 If we don’t feel self-confident about our ability,we will not be able to take up a task and get it done.If we dont’t have confidence in our competence,we won’t be courageous enough to face up to a challenge.Only when we think we are capable of doing something,will we be able to succeed in doing that. Self-confidence is different from complacency(自满).It is solidly(坚固地，坚硬地) based on our knowledge,judgement,abilities and skills.To develop it takes years of learning and to consolidate(巩固) it takes years of practicing.Self-confidence means more than mental preparedness(准备就绪).It serves as an indication(象征，暗示，迹象) of professional readiness(敏捷；准备就绪).It is also an expression of intellectual maturity. With self-confidence,we are able to firmly take each step in our journey of life(坚定地迈出人生旅途中的每一步) and it is self-confidencet that has been paving the way to the ultimate(最终的，最后的) goal of our professional career(为我们职业生涯的终极目标铺路). 新闻写作：记叙类报道 栗子：a news report to your campus newspaper (on a volunteer activity organized by Student Union to assist elderly people in the neighbor hood) 开篇应为导语，介绍活动的时间、地点及参与者（基本事实+抓人眼球） 主体部分应介绍活动目的及具体内容/流程 结语部分应总结活动的意义、影响或收获，也可简要提及活动举办的大背景 ​ 记叙方式：时间循序（暖场-&gt;活动主体-&gt;结束） ​ 空间顺序（不同区域举办的活动依次参观） ​ 组别顺序（一人负责一件事，另一组人负责另一件事） ​ 记叙类新闻写作五个基本要素5W（when,where,what,why,who）+ 1H:how The students,organized by the Student Union,visited a senior center close to our school on Wednesday,June 12th,for the purpose of providing help for the elderly there. Our volunteer were warmly welcomed when they arrived there at about 1 p.m.They presented the elderly with fresh fruits before dividing themselves into two groups,one responsible for cleaning and the other for chatting.It took nearly an hour for half a dozen volunteers to sweep and mop the floor and then wash all the windows.The rest were,meanwhile,listening attentively to the elderly who looked back on their good old days(过去美好时光) with a certain amount of nostalgia(n.怀旧，念旧).The activity ended with a certain lecture on how to send voice messages and make video calls on WeChat. &quot;I’m impressed with their vigor(n.活力，精力) and optimism(n.乐观),&quot;says one of the volunteers.“And I’m glad that the entire afternoon we spent together means something to them.They expressed their gratitude for our company,which may be,in my opinion,what they need most.” &quot;whether正反观点观点&quot;类 栗子：Whether technology will make people lazy With the continus progress of science and technology,great changes have taken place in the way people live.This progress has brought great convenience to people.Nonetheless,it has also made many people lazy.First,the widespread use of Internet technology,especially smart phones ,allows people to know what is happening outside without going out.People just need to pick up a mobile phone,connect to the Internet,and open the corresponding software,then the major events of the world will be caught in their eyes.They no longer have to open books and newspapers or go out to get information.Second,the appearance of takeaways has also made people lazier.People can get whatever they want to eat without cooking for themselves or even getting up to go to a restaurant…To sum up ,the ever-changing technology brings convenience to people,but it also make people laxy.Consequently,while improving the quality of life,people should learn to use science and technology correctly instead of relying on it blindly. 栗子：Whether violent video games online will cause students violent behaviors With the progress of the times, the use of smart phones, computers and other electronic products is becoming more and more common among students. And many students like violent video games online. This raises a question, whether violent online games will lead to students’ violent tendency? From my point of view, the answer is no.First of all, through online games, students can relieve the pressure in real life and find like-minded people to communicate with, which will reduce students’ irritable tendency in real life. In this way, these video games will not increase students’ violent tendency. On the contrary, to a certain extent they will reduce students’irritable behaviors. Moreover, online video games are virtual and the violent elements in the games are unrealistic, and these violent scenes can hardly be implemented in real life. So the violence in online games has little impact on real life.To sum up, from my point of view, violent online games will not lead to students’ violent tendency. The development of science and technology is bound to change people’s way of life, which will bring about a lot of influence on people’s life. It is only necessary for us to learn to use it properly. 栗子：Are People Becoming Addicted to Technology? Numerous studies claim that addiction to technology is real and it has the same effect on the brain as drug addiction. First, no one can deny the fact that technology is of great importance to our daily life. However, as a matter of fact, its adverse effect should not be ignored by the public.Confronted with such phenomenon, we should take a series of effective measures to cope with the situation. For one thing, it is obvious that the universitiesand mass media should increase publicity and educationto encourage people to apply technology more appropriately. For another, we should bear in mind that we are supposed to take a reasonable attitude toward modern technology, andmake its advantages over-weigh disadvantages.Personally, I believe that only by doing so can we better ourselves in every aspect of our life. Consequently, I’m confident that a bright future is awaiting us because technology makes our life rich and colorful. 高级替换： 1234end/finish with sth;end/finish by doing sth(do sth at last) 以某事收尾mean something/a lot to sb;matter to sb(be important to sb) 对某人来说很重要show/express one&#x27;s gratitude/appreciation for (doing) sth(thanks for (doing) sth) 对某事表示感谢 单词 12345678副词应用：solidly(坚固地，坚硬地)/firmlymore than + n./no longer/by and largeincreaselyespeciallyAs a result/For instanceIrresistibly 12345同义转换：feel self-confident about our ability/have confidence in our competencetake up a task/face up to a challengeare capable of doing/be able to take/be courageous enough to facemean/ an indication(象征，暗示，迹象) of/an expression of","categories":[{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"}],"tags":[{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]},{"title":"数据结构 PTA","slug":"刷题/PTA","date":"2021-12-04T15:24:25.366Z","updated":"2022-03-21T09:24:12.339Z","comments":true,"path":"2021/12/04/刷题/PTA/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E5%88%B7%E9%A2%98/PTA/","excerpt":"","text":"第一章 绪论 判断题 1-1 数据元素是数据的最小单位。F(数据项) 1-2 数据的逻辑结构是指数据的各数据项之间的逻辑关系。F（数据元素之间） 1-3 数据结构概念包括数据之间的逻辑结构、数据在计算机中的存储方式和数据的运算三个方面。T 1-4 数据结构的抽象操作的定义与具体实现有关。F 1-5 算法和程序没有区别，在数据结构中二者是通用的。F 1-6 数据结构包括数据对象集以及它们的逻辑结构和物理结构，还包括与数据对象相关联的操作集，以及实现这些操作的高效的算法。T 选择题（错题：2-9,2-13） 2-1 在 Data_Structure = (D，R)中，D 是（ ）的有限集合。 A.数据元素 2-2 以下关于数据结构的说法中错误的是（ ）。 A.数据结构相同，对应的存储结构也相同 2-4 算法分析的目的是( ) C.分析算法的效率以求改进 2-5 算法分析的两个主要方面是( ) A.空间复杂度和时间复杂度 2-6 采用链结构存储线性表时，其地址（ ）。 B.连续不连续都可以 2-7 一个正确的算法应该具有 5 个特性，除输入、输出特性外，另外 3 个特性是（ ）。 A.确定性、可行性、有穷性 2-8 算法的时间复杂度取决于（ ） C.问题的规模和待处理数据的初态 2-9 以下数据结构中，哪一个是线性结构（ ） D.串 2-10 以下数据结构中，（ ）是非线性数据结构 B.字符串 2-11 算法的时间复杂度与（ ）有关。 A.问题规模 2-12 以下程序段的空间复杂度为 12345int a = 1, b = 1, i;for (i=0; i&lt;=10; i++) &#123; b += a; a = b - a;&#125; B.O(1) 2-13 下列程序段的时间复杂度是（ ）。 1234count=0;for(k=1;k&lt;=n;k*=2) for(j=1;j&lt;=n;j++) count++; C.O*(nlog2*n) 2-14 下面说法中，错误的是（ ）。 ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间 ⅱ.在相同规模n下，复杂度为O(n)的算法在时间上总是优于复杂度为O(2n)的算法 ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界 ⅳ.同一个算法，实现语言的级别越高，执行效率越低 C.ⅰ,ⅳ 2-15 算法的计算量的大小称为算法的____。 B.复杂度 2-16 在下面的程序段中，对x的赋值语句的频度为（ ） 123for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++) x=x+1; C.O(n2) 2-17 下面程序段的时间复杂度是 ( ) 123i ＝ 0；while（i&lt;=n） i = i * 3； D.O(log3n) 填空题（错题：4-1, 4-4, 4-6，4-7，4-10） 4-1 算法效率的比较 假设为解决某问题而设计的若干算法的时间复杂度分别为： A) O(n) B) O(n2) C) O(log2​n) D) O(nlog2​n) E) O(2n) F) O(n​) G) O(n!) H) O(1) I) O(n**n​) J) O(n**n) 这些算法按效率由高到低的顺序是 HCFADIBEGJ 4-2 基本术语 数据 是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。 4-3 数据结构的数学定义 数据结构的数学定义为一个二元组： D**S=(D,R) 其中：D 是数据元素的有限集，R 是 D 上的关系 的有限集。 4-4 存储结构存储结构包括数据元素的表示和关系的表示。 4-5 基本术语 抽象数据类型 一般指由用户定义的、表示应用问题的数学模型，以及定义在该模型上的一组操作。 4-6 在数据结构中，数据的逻辑结构分为线性结构和非线性结构 。 4-7 数据结构由数据的逻辑结构、存储结构 和运算|操作三部分组成。 4-8 算法的特性 一个算法必须满足以下五个重要特性： (1) 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都可以有穷有时间内完成。 (2) 确定性 一个算法中每一条指令必须有确切的含义。 (3) 可行性 算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。 (4) 输入一个算法有零个或多个输入。 (5) 输出一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果。 4-9 基本术语 数据元素是数据的基本单位，数据项是数据的不可分割最小单位。其中：前者在计算机中通常作为一个整体进行考虑和处理，它可以由一个或多个后者组成。 4-10 数据的实例 观察下面的表格： 学号 姓名 性别 语文 数学 物理 化学 英语 总分 15160101 王克强 男 87 95 93 76 84 435 15160102 刘铭志 男 77 82 80 97 95 431 15160103 孙勇 男 78 85 87 86 65 401 15160104 李瀚东 男 93 82 72 75 95 417 15160105 赵敏 女 95 90 88 82 96 451 15160106 张毅 男 78 76 65 81 80 380 15160107 柳青 女 82 91 82 84 85 424 15160108 蔡文婷 女 85 78 80 86 95 424 整张表格称为一个 数据对象，其中每一行称为一个 数据元素，任意一行中的每一个栏目称为一个数据项。 4-11 沃斯的名言 瑞士科学家尼古拉斯·沃斯(Niklaus Wirth)有一句在计算机领域里人尽皆知的名言： 算法 + 数据结构 = 程序 编程题 7-1 求最小值和次小值 (25 分) 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int main()&#123; int n,x; cin&gt;&gt;n; cin&gt;&gt;x; if(n&gt;1)&#123; int mini = x; int mini2 = x; int a[n]=&#123;x&#125;; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; if(mini&gt;a[i])mini=a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; if(a[i]==mini)continue; if(mini2==mini)mini2=a[i]; if(mini2&gt;a[i])mini2=a[i]; &#125; if(mini==mini2) cout&lt;&lt;&quot;There is no second smallest element&quot;&lt;&lt;endl; else cout&lt;&lt;mini&lt;&lt;&quot; &quot;&lt;&lt;mini2; &#125; else &#123; cout&lt;&lt;&quot;Invalid Input&quot;&lt;&lt;endl; &#125; return 0;&#125; 7-2 求素数个数 (30 分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=0; cin&gt;&gt;n; int *a=new int[n+1]; for(int i=2;i&lt;=n;i++) a[i]=1; a[0]=a[1]=0; for(int i=2;i*i&lt;=n;i++) &#123; if(a[i]) &#123; for(int j=2*i;j&lt;=n;j+=i) a[j]=0; &#125; &#125; for(int i=2;i&lt;=n;i++) &#123; if(a[i])num++; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125;/*#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=1,flag=1; cin&gt;&gt;n; if(n==1)cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else if(n==2)cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; else &#123; for(int i=3;i&lt;=n;i+=2) &#123; for(int j=3;j*j&lt;=i;j+=2) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag) num++; flag=1; &#125; cout&lt;&lt;num&lt;&lt;endl; &#125; return 0;&#125;*//*#include&lt;iostream&gt;using namespace std;int main()&#123; int n,num=0,flag=1; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) &#123; for(int j=2;j*j&lt;=i;j++) &#123; if(i%j==0) &#123; flag=0; break; &#125; &#125; if(flag) &#123; num++; &#125; flag=1; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125;*/ 第二章 线性表 判断题（错题：1-2,1-4,1-15,1-17） 1-1 顺序存储方式只能用于存储线性结构。F 1-2 在顺序表中取出第i个元素所花费的时间与i成正比。F 1-3 线性表的顺序存储表示优于链式存储表示。F 1-4 带头结点的单循环链表中，任一结点的后继结点的指针域均不空。T 1-5 顺序表 - 存储结构 顺序表中逻辑上相邻的元素，其物理位置也一定相邻。T 1-6 链式存储的优点是插入、删除元素时不会引起后续元素的移动，缺点是只能顺序访问各元素。T 1-7 线性表若采用链式存储结构时，要求内存中可用存储单元的地址一定不连续。F 1-8 链表是采用链式存储结构的线性表,进行插入、删除操作时，在链表中比在顺序存储结构中效率高。T 1-9 若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用顺序表存储最节省时间。T 1-10 对于顺序存储的长度为N的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为O(1)和O(N)。F 1-11 在线性表的顺序存储结构中，插入和删除元素时，移动元素的个数与该元素的位置有关。T 1-12 顺序存储方式的优点是存储密度大，且插入、删除运算效率高。F 1-13 在具有N个结点的单链表中，访问结点和增加结点的时间复杂度分别对应为O(1)和O(N)。F 1-14 线性表采用链式存储表示时，所有结点之间的存储单元地址可以连续也可以不连续。T 1-15 在单链表中，要访问某个结点，只要知道该结点的指针即可。因此，单链表是一种随机存取结构。F 1-16 在具有头结点的链式存储结构中，头指针指向链表中的第一个元素结点。F 1-17 在一个设有头指针和尾指针的单链表中，执行删除该单链表中最后一个元素的操作与链表的长度无关。F 1-18 循环链表可以做到从任一结点出发，访问到链表的全部结点。T 1-19 在单链表中，逻辑上相邻的元素，其物理位置必定相邻。F 1-20 在双向链表中，可以从当前结点出发访问到任何一个结点。T 选择题(错题：2-10,2-13,2-16,2-20) 2-1 在一个长度为n的顺序表中，向第i个元素(1≤i≤n+1)位置插入一个新元素时需要从后向前移动多少个元素。 B.n-i+1 2-2 对于线性表，在顺序存储结构和链式存储结构中查找第k个元素，其时间复杂性分别是多少？ D.O(1)和O(k) 2-3 在顺序结构表示的线性表中，删除第i个元素（数组下标为i-1)，需要把后面的所有元素都往前挪一位，相应的语句是： 12for (___________ ) PtrL-&gt;Data[j-1]=PtrL-&gt;Data[j]; 其中空缺部分的内容应该是 A.j = i; j&lt; = PtrL-&gt;Last; j++ 2-4 向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（ ） B.63.5 2-5 顺序表是线性表的( ) B.顺序存储结构 2-6 以下说法错误的是 ( )。 C.在链表上实现读表元运算的平均时间复杂度为O（1） 2-7 哪个选项不是线性表的链式存储结构（ ） B.顺序表 2-8 在向表中第i个元素（1≤i≤n+1）位置插入一个新元素时，为保持插入后表中原有元素的相对次序不变，需要从后向前依次后移（ ）个元素。 B.n-i+1 2-9 在删除表中第i个元素时，同样地，为保持删除后表中原有元素的相对次序不变，需要从前向后依次前移（ ）个元素。 A.n-i 2-10 与单链表相比，双链表的优点之一是（）。 D.顺序访问相邻结点更加灵活 2-11 在单链表中，要删除某一指定结点，必须先找到该结点的（）。 A.直接前驱 2-12 循环链表的主要优点是（）。 D.从表中的任意结点出发都能扫描到整个链表 2-13 若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点，则采用（）存储方式最节省运算时间。 D.带表头附加结点的双循环链表 2-14 单链表又称为线性链表，在单链表上实施插入和删除操作（ ）。 B.不需移动结点，只需改变结点指针 2-15 链表不具有的特点是( )。 A.可随机访问任一个元素 2-16 下面关于线性表的叙述中，错误的是____。 B.线性表采用顺序存储，便于进行插入和删除操作。 2-17 单链表L（带头结点）为空的判断条件是____。 B.L-&gt;next==NULL 2-18 在单链表指针为p的结点之后插入指针为s的结点，正确的操作是：（ ）。 B.s-&gt;next=p-&gt;next;p-&gt;next=s 2-19 对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（ ） B.head→next==NULL 2-20 设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用( )最节省时间。 D.带头结点的双循环链表 填空题 4-1 顺序表 - 地址计算 假设顺序表第 1 个元素的内存地址是 100，每个元素占用 2 字节内存空间，则第 5 个元素的内存地址是 108 4-2 在有n个元素的顺序表中删除任意一个元素所需移动元素的平均次数为 （n-1)/2 4-3 在有n个元素的顺序表中的任意位置插入一个元素所需移动元素的平均次数为 n/2 4-4 在长度为n的顺序表L中将所有值为x的元素替换成y，该算法的时间复杂度为 O(n) 4-5 在顺序表中，逻辑上相邻的元素，其物理位置 一定 相邻。在单链表中，逻辑上相邻的元素，其物理位置 不一定 相邻。 4-6 对于顺序表的插入算法insert_sqlist来说，若以结点移动为标准操作，则插入算法的在最坏情况下的移动次数为 n ，时间复杂度是 O(n)。在平均情况下的移动次数为 n/2 ，时间复杂度是 O(n)。 4-7 线性表L=(a1, a2, … , an)用数组表示，假定删除表中任一元素的概率相同，则删除一个元素平均需要移动元素的个数是 (n-1)/2 程序填空题 5-1 顺序表删除操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0#define MAXSIZE 100typedef int datatype;typedef struct &#123; datatype *elem; int length;&#125; SqList;int ListDelete_Sq(SqList &amp;L, int i) &#123; if ((i &lt; 1) || (i &gt; L.length)) return ERROR; for (int j = i; j &lt;= L.length; j++) ; (2&#x27;) --L.length; return OK;&#125;int main() &#123; SqList L; int i = 0, n,a; datatype e; L.elem = new datatype[MAXSIZE]; L.length = 0; cin &gt;&gt; n; for (i=0;i&lt;n;i++) cin &gt;&gt; L.elem[i]; L.length = i; cin &gt;&gt; a; if (ListDelete_Sq(L, a)) &#123; for (i = 0; i &lt; L.length; i++) if(i==0) cout &lt;&lt; L.elem[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; L.elem[i]; &#125; else cout &lt;&lt; &quot;ERROR&quot;; return 0;&#125; 5-2单链表删除操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0typedef int ElemType;typedef struct LNode &#123; ElemType data; struct LNode *next; &#125; LNode, *LinkList; void CreateList(LinkList &amp;L, int n) ;//该函数未显示细节 int ListDelete_L(LinkList &amp;L, int i) &#123; LinkList p, q; int j; p = L; j = 0; while((p-&gt;next) &amp;&amp; (j &lt;i)) (2&#x27;) &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || (j &gt; i - 1)) return ERROR; q = p-&gt;next; p-&gt;next=q-&gt;next;(2&#x27;) delete q; return OK;&#125; void print(LinkList &amp;L)&#123; LinkList p; int flag=1; p = L-&gt;next; while (p) &#123; if(flag) cout &lt;&lt; p-&gt;data; else cout &lt;&lt; &quot; &quot;&lt;&lt; p-&gt;data; flag=0; p = p-&gt;next; &#125;&#125;int main() &#123; LinkList L; ElemType e; int length; int i; cin &gt;&gt; length; CreateList(L, length); cin &gt;&gt; i; ListDelete_L(L,i); print(L); return 0;&#125; 函数题 6-1 求顺序表最大值 (10 分) 123456789int GetMax(SqList L)&#123; int maxi=0; for(int i=0;i&lt;L.length;i++) &#123; if(maxi&lt;L.elem[i])maxi=L.elem[i]; &#125; return maxi;&#125; 6-2 单链表逆置* (10 分) 1234567891011121314void Reverse(NODE *head)&#123; NODE *p,*p1,*p2,*p3; p = head-&gt;next; p1 = head; p1-&gt;next = NULL; while(p!=NULL) &#123; p2 = p; p = p-&gt;next; p2-&gt;next = p1-&gt;next; p1-&gt;next = p2; &#125;&#125; 6-3 单链表统计正数个数 (6 分) 123456789101112int PositiveInt(LinkList L)&#123; LNode *p; int n=0; p = L-&gt;next; while(p!=NULL) &#123; if(p-&gt;data&gt;0)n++; p = p-&gt;next; &#125; return n;&#125; 编程题 7-1 学生顺序表的建立 (10 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576法一：#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;using namespace std;struct Node&#123; int id; string name; float s1,s2,s3; Node *next;&#125;;int main()&#123; int n; int id; string name; float s1,s2,s3; Node *p,*first,*last=NULL; last = new Node; first = last; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;id&gt;&gt;name&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; p = new Node; p-&gt;id = id; p-&gt;name = name; p-&gt;s1 = s1; p-&gt;s2 = s2; p-&gt;s3 = s3; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; p = first-&gt;next; while(p!=NULL) &#123; cout&lt;&lt;p-&gt;id&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;p-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s1&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s2&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;s3&lt;&lt;endl; p = p-&gt;next; &#125; return 0;&#125;法二：#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;struct Students&#123; int ID; string name; double score1; double score2; double score3; &#125;students[5];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;students[i].ID&gt;&gt;students[i].name&gt;&gt;students[i].score1&gt;&gt;students[i].score2&gt;&gt;students[i].score3; &#125; cout.precision(1); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;students[i].ID&lt;&lt;&quot; &quot;&lt;&lt;students[i].name&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score1&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score2&lt;&lt;&quot; &quot;&lt;&lt;fixed&lt;&lt;students[i].score3; if(i!=n-1) cout&lt;&lt;endl; &#125; return 0;&#125; 7-2 求两个一元多项式的和 (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129法一：链表#include&lt;iostream&gt;using namespace std;struct Node&#123; int coef,exp; Node *next;&#125;;int main()&#123; int n,coef,exp; Node *p,*p1,*q,*q1,*temp; Node *first1,*first2,*last; last = new Node; first1=last; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; p=new Node; p-&gt;coef = coef; p-&gt;exp = exp; last-&gt;next=p; last = p; &#125; last-&gt;next = NULL; last = new Node; first2=last; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; p=new Node; p-&gt;coef = coef; p-&gt;exp = exp; last-&gt;next=p; last = p; &#125; last-&gt;next = NULL; p=first1-&gt;next; p1=first1; q=first2-&gt;next; while(p!=NULL&amp;&amp;q!=NULL) &#123; if(p-&gt;exp&gt;q-&gt;exp) &#123; p=p-&gt;next; p1=p1-&gt;next; &#125; else if(p-&gt;exp&lt;q-&gt;exp) &#123; temp=q-&gt;next; p1-&gt;next=q; q-&gt;next=p; q = temp; &#125; else &#123; p-&gt;coef+=q-&gt;coef; if(p-&gt;coef==0) &#123; p1-&gt;next=p-&gt;next; delete p; p=p1-&gt;next; &#125; else &#123; p=p-&gt;next; p1=p1-&gt;next; &#125; q = q-&gt;next; &#125; &#125; if(q!=NULL)p1-&gt;next=q; p=first1-&gt;next; if(p!=NULL) &#123; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;coef&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;exp&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; cout&lt;&lt;p-&gt;coef&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;exp&lt;&lt;endl; &#125; else cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; return 0;&#125;法二：数组#include&lt;iostream&gt;using namespace std;int a[1001]=&#123;0&#125;;int main()&#123; int n,coef,exp; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; a[exp]=coef; &#125; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;coef&gt;&gt;exp; a[exp]+=coef; &#125; n=0; for(int i=1000;i&gt;-1;i--) &#123; if(n==0&amp;&amp;a[i]) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;i; n=1; &#125; else if(a[i]) cout&lt;&lt;&quot; &quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;i; &#125; if(n)cout&lt;&lt;endl; else cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl;&#125; 7-3 两个有序链表合并（新表不含重复元素） (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242法一：刘俊兄弟的代码……emm……#include&lt;iostream&gt;using namespace std;int main()&#123; int a[1000], b[1000]; int flog = 1; int lengtha = 0, lengthb = 0; while (flog) &#123; int c; cin &gt;&gt; c; if (c == -1) flog = 0; else &#123; a[lengtha++] = c; &#125; &#125; flog = 1; while (flog) &#123; int c; cin &gt;&gt; c; if (c == -1) flog = 0; else &#123; b[lengthb++] = c; &#125; &#125; int j = 0; for (int i = lengtha ; i &lt; lengtha + lengthb; i++) &#123; a[i] = b[j++]; &#125; if (lengtha + lengthb == 0) &#123; cout &lt;&lt; &quot;NULL&quot;; &#125; int n = lengtha + lengthb; for (int i = 0; i &lt; n-1; i++) //冒泡循环 &#123; for (int j = i + 1; j &lt; n; j++)//从i后的一个元素一直往len-1位置寻找 &#123; if (a[j] == a[i]) //如果发现重复 &#123; for (int k = j + 1; k &lt; n; k++)//j+1的位置到len-1的位置 &#123; a[k - 1] = a[k]; //将后面的数依次赋值给前一个位置 &#125; n--; //数组长度-1 j--; //重复点再次进行查重 &#125; &#125; &#125; for(int i=0;i&lt;n-1;i++) &#123; for (int j = 0; j &lt; n - i-1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; n-1; i++) &#123; cout &lt;&lt; a[i]&lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; a[n - 1]&lt;&lt;endl; return 0;&#125;法二：数组#include&lt;iostream&gt;using namespace std;int a1[10000];int a2[10000];int main()&#123; int x,n=0; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; a1[n++] = x; &#125; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; a1[n++] = x; &#125; for(int i=0;i&lt;n-1;i++) &#123; int mini=i; for(int j=i+1;j&lt;n;j++) &#123; if(a1[mini]&gt;a1[j])mini=j; &#125; if(mini!=i)swap(a1[mini],a1[i]); &#125; int flag=0; for(int i=0;i&lt;n;i++) &#123; if(a1[i]==flag)a1[i]=0; else flag = a1[i];//? &#125; int n1=0; for(int i=0;i&lt;n;i++) &#123; if(a1[i]) a2[n1++]=a1[i]; &#125; for (int i = 0; i &lt; n1-1; i++) &#123; cout &lt;&lt; a2[i]&lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; a2[n1 - 1]&lt;&lt;endl; return 0;&#125;法三：链表#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;int main()&#123; int x,flag=-1; Node *first1,*first2,*first3,*p,*p1,*p2,*last; last=new Node; first1 = last; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; if(x == flag)continue; p = new Node; p-&gt;data = x; flag = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; last=new Node; first2 = last; flag = -1; while(1) &#123; cin&gt;&gt;x; if(x == -1)break; if(x == flag)continue; p = new Node; p-&gt;data = x; flag = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; last = new Node; first3 = last; p1 = first1-&gt;next; p2 = first2-&gt;next; while(p1!=NULL||p2!=NULL) &#123; if(p1!=NULL&amp;&amp;p2!=NULL) &#123; if(p2-&gt;data&gt;p1-&gt;data) &#123; p= new Node; p-&gt;data = p1-&gt;data; last-&gt;next = p; last = p; p1=p1-&gt;next; &#125; else if(p2-&gt;data&lt;p1-&gt;data) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; &#125; else if(p2-&gt;data==p1-&gt;data) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; p1=p1-&gt;next; &#125; &#125; else if(p2==NULL) &#123; p= new Node; p-&gt;data = p1-&gt;data; last-&gt;next = p; last = p; p1=p1-&gt;next; &#125; else if(p1==NULL) &#123; p= new Node; p-&gt;data = p2-&gt;data; last-&gt;next = p; last = p; p2=p2-&gt;next; &#125; &#125; last-&gt;next = NULL; p= first3-&gt;next; if(p!=NULL) &#123; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl; return 0;&#125; 7-4 在有序链表中插入数据 (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *next;&#125;;int main()&#123; int n,x; Node *p,*p2,*p1,*first,*last=new Node; first=last; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; p = new Node; p-&gt;data = x; last-&gt;next = p; last = p; &#125; last-&gt;next = NULL; cin&gt;&gt;x; p1 = first-&gt;next; p2 = first; while(p1!=NULL) &#123; if(x == p1-&gt;data)break; if(x&lt;p1-&gt;data) &#123; p = new Node; p-&gt;data = x; p-&gt;next = p1; p2-&gt;next = p; break; &#125; else if(x&gt;p1-&gt;data&amp;&amp;(p1-&gt;next==NULL||x&lt;p1-&gt;next-&gt;data)) &#123; p = new Node; p-&gt;data = x; p-&gt;next = p1-&gt;next; p1-&gt;next = p; break; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; if(first-&gt;next == NULL) &#123; p = new Node; p-&gt;data = x; p-&gt;next = NULL; first-&gt;next = p; &#125; p = first-&gt;next; while(p-&gt;next!=NULL) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p = p-&gt;next; &#125; cout&lt;&lt;p-&gt;data&lt;&lt;endl; return 0;&#125; 第三章 栈和列表 判断题（错题：1-10） 1-1 若一个栈的输入序列为1，2，3，…，N，输出序列的第一个元素是i，则第j个输出元素是j−i−1。F 1-2 所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。F 1-3 在对不带头结点的链队列作出队操作时，不会改变头指针的值。F 1-4 不论是入队列操作还是入栈操作,在顺序存储结构上都需要考虑&quot;溢出&quot;情况。T 1-5 队列和栈都是运算受限的线性表，只允许在表的两端进行运算。F 1-6 栈和队列的存储方式，既可以是顺序方式，也可以是链式方式。T 1-7 循环队列也存在着空间溢出问题。T 1-8 循环队列执行出队操作时会引起大量元素的移动。F 1-9 栈是插入和删除只能在一端进行的线性表；队列是插入在一端进行，删除在另一端进行的线性表。T 1-10 在n个元素连续进栈以后，它们的出栈顺序和进栈顺序一定正好相反。T 1-11 环形队列中有多少个元素可以根据队首指针和队尾指针的值来计算。T 1-12 栈和队列的插入和删除操作特殊，所以，栈和队列是非线性结构。F 1-13 序列{1,2,3,4,5}依次入栈，则不可能得到{3,4,1,2,5}的出栈序列。 T 1-14 队列中允许插入的一端叫队头，允许删除的一端叫队尾。F 单选题（错题：2-2、2-18） 2-1 若用大小为6的数组来实现循环队列，且当前front和rear的值分别为0和4。当从队列中删除两个元素，再加入两个元素后，front和rear的值分别为多少？ A.2和0 2-2 如果循环队列用大小为m的数组表示，且用队头指针front和队列元素个数size代替一般循环队列中的front和rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数最多为： B.m 2-3 以下数据结构中，（ ）是非线性数据结构。 A.树 2-4 设栈S和队列Q的初始状态均为空，元素{1, 2, 3, 4, 5, 6, 7}依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是{2, 5, 6, 4, 7, 3, 1}，则栈S的容量至少是： D.4 2-5 线性表、堆栈、队列的主要区别是什么？ B.堆栈和队列都是插入、删除受到约束的线性表 2-6 栈和队列的共同点( )。 C.只允许在端点处插入和删除元素 2-7 下列关于线性表,栈和队列叙述,错误的是( )。 A.线性表是给定的n(n必须大于零)个元素组成的序列 2-8 设用一个数组A[1……N]来存储一个栈，令A[N]为栈底，用整型变量T指示当前栈顶位置，A[T]为栈顶元素。当从栈中弹出一个元素时，变量T的变化为（ ）。 A.T=T+1 2-9 链式栈与顺序栈相比，一个比较明显的优点是（ ）。 B.通常不会出现栈满的情况 2-10 (neuDS)在循环顺序队列中，假设以少用一个存储单元的方法来区分队列判满和判空的条件，front和rear分别为队首和队尾指针，它们分别指向队首元素和队尾元素的下一个存储单元，队列的最大存储容量为maxSize，则队列的长度是（ ）。 C.(rear-front+maxSize)%maxSize 2-11 (nueDS_C++)设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5、e6依次通过栈S，一个元素出栈后即进入队列Q，若6个元素出队的顺序是e2、e4、e3、e6、e5、e1，则栈S的容量至少应该是（ ）。提示：对于栈，可以全进再依次出；也可以进一个出一个；也可以进一部分，出一个，再进一部分；但是出栈之后，不能再入栈。 A.3 2-12 关于栈和队列的下列说法正确的是（） B.栈是后进先出的结构，出栈时除了栈顶元素，其余元素无需移动； 2-13 一个栈的入栈序列是a,b,c,d,e，则栈的出栈序列不可能的是（ ）。 C.dceab 2-14 在一个链表表示的队列中， f和r分别指向队列的头和尾。下列哪个操作能正确地将s结点插入到队列中： B.r-&gt;next=s; r=s; 2-15 栈和队列具有相同的。 B.逻辑结构 2-16 假定利用数组a[n]顺序存储一个栈，用top表示栈顶指针，用top==-1表示栈空，并已知栈未满，当元素x进栈时所执行的操作为（ ）。 C.a[++top]=x 2-17 队列的“先进先出”特性是指（ ）。 Ⅰ.最后插入队列中的元素总是最后被删除 Ⅱ.当同时进行插入、删除操作时，总是插入操作优先 Ⅲ.每当有删除操作时，总要先做一次插入操作 Ⅳ.每次从队列中删除的总是最早插入的元素 B.Ⅰ、Ⅳ 2-18 已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。 B.0,n-1（原因：……） 2-19 执行函数时，其局部变量一般采用（ ）进行存储。 C.栈结构 2-20 对空栈 S 进行 Push 和 Pop 操作，入栈序列为 a, b, c, d, e，经过 Push, Push, Pop, Push, Pop, Push, Push, Pop 操作后，得到的出栈序列是： D.b, c, e 2-21 用S表示入栈操作，X表示出栈操作，若元素入栈的顺序为1234，为了得到1342出栈顺序，相应的S和X的操作串为( )。 D.SXSSXSXX 填空题（错题：4-3） 4-1 栈的运算遵循 后进先出|先进后出 的原则。 4-2 以下运算实现在链队上的入队列，请在空白处用适当句子予以填充。 12345678void EnQueue(QueptrTp *lq,DataType x)&#123; LqueueTp *p; p=(LqueueTp *)malloc(sizeof(LqueueTp)); p-&gt;data=x;(1&#x27;) p-&gt;next=NULL; (lq-&gt;rear)-&gt;next=p;(1&#x27;) lq-&gt;rear=p;(1&#x27;) &#125; 4-3 以下运算实现在链栈上的初始化，请在空白处用请适当句子予以填充。 12345typedef struct Node&#123; DataType data; struct Node *next;&#125;StackNode,*LStackTp;void InitStack(LStackTp &amp;ls)&#123; ls=NULL;&#125;。(1&#x27;) 函数题 6-3 jmu-ds-舞伴问题 (20 分) 12345678910111213141516171819202122232425262728293031323334353637383940int QueueLen(SqQueue Q)&#123; return (Q-&gt;rear-Q-&gt;front+MAXQSIZE)%MAXQSIZE;&#125;int EnQueue(SqQueue &amp;Q, Person e)&#123; Q-&gt;rear = (Q-&gt;rear+1)%MAXQSIZE; Q-&gt;data[Q-&gt;rear] = e; return 0;&#125;int QueueEmpty(SqQueue &amp;Q)&#123; if(Q-&gt;rear==Q-&gt;front)return 1; else return 0;&#125;int DeQueue(SqQueue &amp;Q, Person &amp;e)&#123; Q-&gt;front = (Q-&gt;front+1)%MAXQSIZE; e = Q-&gt;data[Q-&gt;front]; return 0;&#125;void DancePartner(Person dancer[], int num)&#123; for(int i=0;i&lt;num;i++) &#123; if(dancer[i].sex==&#x27;M&#x27;) EnQueue(Mdancers,dancer[i]); else EnQueue(Fdancers,dancer[i]); &#125; while(!QueueEmpty(Mdancers)&amp;&amp;!QueueEmpty(Fdancers)) &#123; Person x,y; DeQueue(Mdancers,x); DeQueue(Fdancers,y); cout&lt;&lt;y.name&lt;&lt;&quot; &quot;&lt;&lt;x.name&lt;&lt;endl; &#125;&#125; 6-4 十进制转二进制（顺序栈设计和应用） (10 分) 12345678910111213141516171819202122232425bool isEmpty()&#123; if(top==-1)return 1; else return 0;&#125;/* 元素x入栈 */void Push(int x)&#123; //if(x==MaxSize)cout&lt;&lt;&quot;上溢&quot;&lt;&lt;endl; //else mystack[++top]=x;&#125;/* 取栈顶元素 */int getTop()&#123; return mystack[top];&#125;/* 删除栈顶元素 */void Pop()&#123; top--;&#125; 编程题 7-1 银行业务队列简单模拟 (25 分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int arr[1000];int main()&#123; int n; int flag1=0,flag2=0; int top1=0,top2=0,top=0; cin&gt;&gt;n; int a1[n+1],a2[n+1],a[n+1]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; if(arr[i]%2!=0)a1[top1++]=arr[i]; else a2[top2++]=arr[i]; &#125; int t1=0,t2=0; for(int i=0;i&lt;n;i++) &#123; if(arr[i]%2==0)flag2++; else flag1++; if(flag2%2==0&amp;&amp;flag1%4==0) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; a[top++]=a2[t2++]; &#125;else&#123; if(t1!=top1&amp;&amp;(flag1%2==0||t2==top2)) &#123; a[top++]=a1[t1++]; a[top++]=a1[t1++]; &#125; if(t2!=top2&amp;&amp;(flag2%2==0||t1==top1||flag1%2==0)) &#123; a[top++]=a2[t2++]; &#125; &#125; if(top==n)break; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;a[n-1]&lt;&lt;endl; return 0;&#125; 7-2 堆栈操作合法性 (20 分) 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N,M; string str; int n,x=0; cin&gt;&gt;N&gt;&gt;M; for(int i=0; i&lt;N; i++) &#123; cin&gt;&gt;str; n = str.size(); for(int j=0; j&lt;n; j++) &#123; if(str[j]==&#x27;S&#x27;) &#123; x++; if(x&gt;M)break; &#125; else if(str[j]==&#x27;X&#x27;) &#123; x--; if(x&lt;0)break; &#125; &#125; if(x==0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; x=0; &#125; return 0;&#125; 第四章 串和数组 判断题 1-1 假设模式串是abababaab，则KMP模式匹配算法中的next[j] = 0 1 1 2 3 4 5 6 2。T 选择题(错题：2-3,2-6,2-9,2-13) 2-1 KMP算法下，长为n的字符串匹配长度为m的字串的时间复杂度为 B.O（M+N） 2-2 串的长度是指 B.串中所含字符的个数 2-3 设主串 T = abaabaabcabaabc，模式串 S = abaabc，采用 KMP 算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是： B.10（6+4） 2-4 串“ababaaababaa”的next数组为（ ）。 C.011234223456 2-5 已知字符串S为“abaabaabacacaabaabcc”，模式串t为“abaabc”。采用KMP算法进行匹配，第一次出现“失配”(s[i]≠t[j])时，i=j=5，则下次开始匹配时，i和j的值分别是()。 C.i=5,j=2 2-6 2 符号串abcde的子串共有： C.16（1+2+3+4+5+1(空串)） 2-7 适用于压缩存储稀疏矩阵的两种存储结构是： A.三元组表和十字链表 2-8 (neuDS)以下( )是稀疏矩阵的一种存储方法。 A.十字链表 2-9 一个稀疏矩阵采用压缩后，和直接采用二维数组存储相比会失去（ ） 特性。 B.随机存取 2-10 对特殊矩阵采用压缩存储的主要目的是（ ）。 D.减少不必要的存储空间 2-11 对n阶对称矩阵压缩存储时，需要表长为（ ）的顺序表。 C.n(n+1)/2 2-12 顺序查找法适合于存储结构为（ ）的线性表。 B.顺序存储或链式存储 2-13 （SWPU-DS）设有一个 10 阶的对称矩阵 A，采用压缩存储方式，以行序为主存储，a[1, 1] 为第一元素，其存储地址为 1，每个元素占一个地址空间，则 a[8, 5] 的地址为（ ）。 *C.33（对称矩阵：(7+1)7/2+5)） 第五章 树和二叉树 选择题 2-1 设一棵非空完全二叉树 T 的所有叶节点均位于同一层，且每个非叶结点都有 2 个子结点。若 T 有 k 个叶结点，则 T 的结点总数是： A.2k−1 2-2 已知字符集{ a, b, c, d, e, f }，若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是： A.00, 1011, 01, 1010, 11, 100 2-3 已知二叉树的先序遍历序列为ABCDEFGH，中序遍历序列为CBEDFAGH，则该二叉树形态中，父节点的右子节点为（）。 C.G 2-4 若将一棵树 T 转化为对应的二叉树 BT，则下列对 BT 的遍历中，其遍历序列与 T 的后根遍历序列相同的是： B.中序遍历 2-5 对 n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有 115 个结点，则 n 的值是： C.58 2-6 设 T 是非空二叉树，若 T 的先序遍历和中序遍历序列相同，则 T 的形态是 __ D.所有结点只有右孩子 2-7 以二叉链表作为二叉树的存储结构，在具有 n 个结点的二叉链表中（n&gt;0），空链域的个数为 __ A.n+1 2-8 已知二叉树的前序遍历序列为 ABDCEFG，中序遍历序列为 DBCAFEG，则后序遍历序列为 __ B.DCBFGEA 2-9 对于任意一棵高度为 5 且有 10 个结点的二叉树，若采用顺序存储结构保存，每个结点占 1 个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存储单元的数量至少是： A.31 2-10 已知森林 F 及与之对应的二叉树 T，若 F 的先根遍历序列是 a, b, c, d, e, f，后根遍历序列是 b, a, d, f, e, c，则 T 的后序遍历序列是： C.b, f, e, d, c, a 填空题 4-1 已知一棵完全二叉树的第5层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是：47 4-2 一棵二叉树的前序遍历序列是ABDFECGHK，中序遍历序列是DBEFAGHCK，则它的后序遍历序列是 DEFBHGKCA 4-3 具有n个结点的二叉树中,一共有 2n 个指针域,其中只有 n-1 个用来指向结点的左右孩子，其余的 n+1 个指针域为NULL。 4-4 若以{4，5，6，7，8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是 69 程序填空题 5-2 下列代码的功能是将二叉树T中的结点按照层序遍历的顺序输出。 123456789101112131415161718192021222324typedef struct TreeNode *Tree;struct TreeNode&#123; int Key; Tree Left; Tree Right;&#125;;void Level_order ( Tree T )&#123; Queue Q; if ( !T ) return; Q = CreateQueue( MaxElements ); Enqueue( T, Q ); while ( !IsEmpty( Q ) )&#123; T = Front_Dequeue ( Q ); /* return the front element and delete it from Q */ printf(&quot;%d &quot;, T-&gt;Key); if ( T-&gt;Left ) Enqueue( T-&gt;Left)3分; if (T-&gt;Right 3分 ) Enqueue( T-&gt;Right)3分; &#125;&#125; 5-3 下列代码的功能是计算给定二叉树T的宽度。二叉树的宽度是指各层结点数的最大值。函数Queue_rear和Queue_front分别返回当前队列Q中队尾和队首元素的位置。 12345678910111213141516171819202122232425262728293031323334typedef struct TreeNode *BinTree;struct TreeNode&#123; int Key; BinTree Left; BinTree Right;&#125;;int Width( BinTree T )&#123; BinTree p; Queue Q; int Last, temp_width, max_width; temp_width = max_width = 0; Q = CreateQueue(MaxElements); Last = Queue_rear(Q); if ( T == NULL) return 0; else &#123; Enqueue(T, Q); while (!IsEmpty(Q)) &#123; p = Front_Dequeue(Q); temp_width++3分; if ( p-&gt;Left != NULL ) Enqueue(p-&gt;Left, Q); if ( p-&gt;Right != NULL ) Enqueue (p-&gt;Right)3分; if ( Queue_front(Q) &gt; Last ) &#123; Last = Queue_rear(Q); if ( temp_width &gt; max_width ) max_width = temp_width; temp_width=0 3分; &#125; /* end-if */ &#125; /* end-while */ return max_width; &#125; /* end-else */&#125; 函数题 6-1 求二叉树高度 (20 分) 1234567891011int GetHeight( BinTree BT )&#123; int LH,RH; if(!BT)return 0; else &#123; LH = GetHeight(BT-&gt;Left); RH = GetHeight(BT-&gt;Right); return LH&gt;RH?++LH:++RH; &#125;&#125; 6-2 二叉树的遍历 (25 分) 123456789101112131415161718192021222324252627282930313233343536void InorderTraversal( BinTree BT )&#123; if(!BT)return; InorderTraversal(BT-&gt;Left); printf(&quot; %c&quot;,BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;void PreorderTraversal( BinTree BT )&#123; if(!BT)return; printf(&quot; %c&quot;,BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void PostorderTraversal( BinTree BT )&#123; if(!BT)return; PostorderTraversal(BT-&gt;Left); PostorderTraversal(BT-&gt;Right); printf(&quot; %c&quot;,BT-&gt;Data);&#125;void LevelorderTraversal( BinTree BT )&#123; if(!BT)return; BinTree que[101],t; int first=0,rear=0; que[rear++]=BT; while(first!=rear) &#123; t=que[first++]; printf(&quot; %c&quot;,t-&gt;Data); if(t-&gt;Left)que[rear++]=t-&gt;Left; if(t-&gt;Right)que[rear++]=t-&gt;Right; &#125;&#125; 6-3 先序输出叶结点 (15 分) 123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT) &#123; if(!BT-&gt;Left&amp;&amp;!BT-&gt;Right) printf(&quot; %c&quot;,BT-&gt;Data); PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right); &#125;&#125; 6-4 二叉树的非递归遍历 (25 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void InorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); T = T-&gt;Left; &#125; T = Pop(S); printf(&quot; %c&quot;,T-&gt;Data); T=T-&gt;Right; &#125;&#125;void PreorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); printf(&quot; %c&quot;,T-&gt;Data); T = T-&gt;Left; &#125; T = Pop(S); T = T-&gt;Right; &#125;&#125;void PostorderTraversal( BinTree BT )&#123; BinTree T=BT; Stack S = CreateStack(); while(T||!IsEmpty(S)) &#123; while(T!=NULL) &#123; Push(S,T); T-&gt;flag=0; T = T-&gt;Left; &#125; T = Peek(S); if(T-&gt;flag==0) &#123; T-&gt;flag++; T=T-&gt;Right; &#125; else&#123; T = Pop(S); printf(&quot; %c&quot;,T-&gt;Data); T = NULL; &#125; &#125;&#125; 编程题 7-1 根据后序和中序遍历输出先序遍历 (25 分) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* Creat(int *Post,int *In,int n)&#123; if(n&lt;=0)return NULL; int len=0; Node *p=new Node; p-&gt;data = *(Post+n-1); while(*(In+len)!=p-&gt;data)len++; p-&gt;left=Creat(Post,In,len); p-&gt;right=Creat(Post+len,In+len+1,n-len-1);//右子树……emmm……记住吧…… return p;&#125;void Preorder(Node *t)&#123; if(!t)return; cout&lt;&lt;&quot; &quot;&lt;&lt;t-&gt;data; Preorder(t-&gt;left); Preorder(t-&gt;right);&#125;int main()&#123; int n; cin&gt;&gt;n; int a[n],b[n]; Node *t; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; t=Creat(a,b,n); cout&lt;&lt;&quot;Preorder:&quot;; Preorder(t); return 0;&#125; 7-2 玩转二叉树 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* creat(int *In,int *Pre,int n)&#123; if(n&lt;=0)return NULL; int len=0; while(*(In+len)!=*Pre)len++; Node *p=new Node; p-&gt;data=*(In+len); p-&gt;left=creat(In,Pre+1,len); p-&gt;right=creat(In+len+1,Pre+len+1,n-len-1);//n-len-1我也不清楚…… return p;&#125;void Level(Node *t,int n)&#123; if(!t)return; int first=0,last=0,i; Node* Q[n],*w; Q[last++]=t; while(last!=first) &#123; w=Q[first++]; //镜面也可以看做先右子树再左子树 if(w-&gt;right)Q[last++]=w-&gt;right; if(w-&gt;left)Q[last++]=w-&gt;left; &#125; for(i=0;i&lt;n-1;i++) cout&lt;&lt;Q[i]-&gt;data&lt;&lt;&quot; &quot;; cout&lt;&lt;Q[i]-&gt;data&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; int In[n],Pre[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;In[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;Pre[i]; Node* t=creat(In,Pre,n); Level(t,n); return 0;&#125; 7-3 树的遍历 (25 分) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *left,*right;&#125;;Node* creat(int* In,int* Post,int n)&#123; if(n&lt;=0)return NULL; int len=0; while(*(In+len)!= *(Post+n-1))len++; Node *p=new Node; p-&gt;data=In[len]; p-&gt;left=creat(In,Post,len); p-&gt;right=creat(In+len+1,Post+len,n-len-1); return p;&#125;void Level(Node* t,int n)&#123; int last=0,first=0,i; Node* Q[n],*w; Q[last++]=t; while(last!=first) &#123; w=Q[first++]; if(w-&gt;left)Q[last++]=w-&gt;left; if(w-&gt;right)Q[last++]=w-&gt;right; &#125; for(i=0;i&lt;n-1;i++) cout&lt;&lt;Q[i]-&gt;data&lt;&lt;&quot; &quot;; cout&lt;&lt;Q[i]-&gt;data&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; int In[n],Post[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;Post[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;In[i]; Node* t=creat(In,Post,n); Level(t,n); return 0;&#125; 7-4 哈夫曼编码 (30 分) 1 7-5 二叉搜索树的最近公共祖先 (30 分) 1 第六章 图 判断题 1-1 无向连通图所有顶点的度之和为偶数。T 1-2 无向连通图至少有一个顶点的度为1。F 1-3 用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。T 1-4 在一个有向图中，所有顶点的入度与出度之和等于所有边之和的2倍。T 1-5 如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。F 1-6 在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。T 1-7 用一维数组G[]存储有4个顶点的无向图如下： 1G[] = &#123; 0, 1, 0, 1, 1, 0, 0, 0, 1, 0 &#125; 则顶点2和顶点0之间是有边的。T 1-8 Kruskal 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。F 1-9 Prim 算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树。T 1-10 若图G有环，则G不存在拓扑排序序列。T 1-11 若图G为连通图且不存在拓扑排序序列，则图G必有环。T 1-12 P 是顶点 S 到 T 的最短路径，如果该图中的所有路径的权值都加 1，P 仍然是 S 到 T 的最短路径。F 1-13 对于带权无向图 G = (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。F 1-14 如果从有向图 G 的每一点均能通过深度优先搜索遍历到所有其它顶点，那么该图一定不存在拓扑序列。T 1-15 如果 e 是有权无向图 G 唯一的一条最短边，那么边 e 一定会在该图的最小生成树上。T 选择题 2-1 在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？ (1分) A. 是的肯定不同 B. 肯定是相同的 C. 有可能会不同 D. 以上全不对 2-2 若要检查有向图中有无回路，除了可以利用拓扑排序算法外，下列哪种算法也可以用？ A. Dijkstra算法 B. Prim算法 C. 广度优先搜索 D. 深度优先搜索 2-3 下图为一个AOV网，其可能的拓扑有序序列为： (2分) A. ABCDFEG B. ADFCEBG C. ACDFBEG D. ABDCEFG 2-4 下列选项中，不是下图深度优先搜索序列的是： (2分) A. V1, V5, V4, V3, V2 B. V1, V3, V2, V5, V4 C. V1, V2, V5, V4, V3 D. V1, V2, V3, V4, V5 2-5 若将n个顶点e条弧的有向图采用邻接表存储，则拓扑排序算法的时间复杂度是： (1分) A. O(n) B. O(n+e) C. O(n2) D. O(n×e) 2-6 使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是： (2分) A. 5, 2, 3, 4, 6 B. 5, 2, 3, 6, 4 C. 5, 2, 4, 3, 6 D. 5, 2, 6, 3, 4 2-7 使用迪杰斯特拉（Dijkstra）算法求下图中从顶点1到其他各顶点的最短路径，依次得到的各最短路径的目标顶点是： (2分) A. 6, 7, 5, 3, 2, 4 B. 6, 2, 5, 7, 3, 4 C. 2, 3, 4, 5, 6, 7 D. 2, 4, 3, 6, 5, 7 2-8 设无向图为 G=(V，E)，其中 V={v1,v2,v3,v4}，E={(v1,v2)，(v3,v4)，(v4,v1)，(v2,v3)，(v1,v3)}。则每个顶点的度依次为： (2分) A. 2, 1, 1, 1 B. 1, 1, 2, 1 C. 3, 2, 3, 2 D. 2, 3, 2, 3 2-9 对于给定的有向图如下，其逆邻接表为： (2分) A. B. C. D. 2-10 已知一个无向图的顶点集为 {V0,V1,⋯,V7}，其邻接矩阵如下所示： 以下哪项不可能是从 V0 出发的广度优先遍历序？ (2分) A. V0,V1,V3,V4,V2,V6,V5,V7 B. V0,V3,V1,V4,V2,V6,V5,V7 C. V0,V3,V1,V4,V6,V2,V7,V5 D. V0,V4,V3,V1,V6,V2,V7,V5 2-11 给定一个图的邻接矩阵如下，则从V1出发的宽度优先遍历序列（BFS，有多种选择时小标号优先）是： (2分) A. V1, V2, V4, V3, V6, V8, V10, V9, V7, V5 B. V1, V2, V3, V4, V5, V6, V7, V9, V8, V10 C. V1, V2, V4, V6, V8, V10, V9, V7, V5, V3 D. V1, V2, V3, V5, V7, V9, V10, V6, V8, V4 2-12 给出如下图所示的具有 7 个结点的网 G，哪个选项对应其正确的邻接矩阵？ A. B. C. D. 2-13 已知无向图 G 如下所示，使用克鲁斯卡尔（Kruskal）算法求图 G 的最小生成树，加入到最小生成树中的边依次是： A. (b,f), (b,d), (a,e), (c,e), (b,e) B. (b,f), (b,d), (b,e), (a,e), (c,e) C. (a,e), (b,e), (c,e), (b,d), (b,f) D. (a,e), (c,e), (b,e), (b,f), (b,d) 2-14 若使用 AOE 网估算工程进度，则下列叙述中正确的是： (2分) A. 关键路径是从源点到汇点边数最多的一条路径 B. 关键路径是从源点到汇点路径长度最长的路径 C. 增加任一关键活动的时间不会延长工程的工期 D. 缩短任一关键活动的时间将会缩短工程的工期 2-15 下列关于无向连通图特征的叙述中，正确的是： 所有顶点的度之和为偶数 边数大于顶点个数减1 至少有一个顶点的度为1 A.只有1 B.只有2 C.1和2 D.1和3 2-16 若无向图G =（V，E）中含7个顶点，要保证图G在任何情况下都是连通的，则需要的边数最少是： (3分) A.6 B.15 C.16 D.21 2-17 具有N（N&gt;0）个顶点的无向图至少有多少个连通分量？ A.0 B.1 C.N−1 D.N 2-18 用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是？ A. 无序的 B. 拓扑有序 C. 逆拓扑有序 D. 以上都不对 2-19 若要求在找到从S到其他顶点最短路的同时，还给出不同的最短路的条数，我们可以将Dijkstra算法略作修改，增加一个count[]数组：count[V]记录S到顶点V的最短路径有多少条。则count[V]应该被初始化为： A. 对所有顶点都有count[V]=1 B. 对所有顶点都有count[V]=0 C. 1count[S]=1; `对于其他顶点`V`则令`count[V]=0 D. 1count[S]=0; `对于其他顶点`V`则令`count[V]=1 2-20 任何一个带权无向连通图的最小生成树—— A. 是唯一的 B. 是不唯一的 C. 有可能不唯一 D. 有可能不存在 程序填空题 函数题 6-1 邻接矩阵存储图的深度优先遍历 (20 分) 12345678910111213141516/*void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )&#123; //cout &lt;&lt; vertex[v]; Visit(V); Visited[V] = true; for (int j = 0; j &lt; Graph-&gt;Nv; j++) if (Graph-&gt;G[V][j] == 1 &amp;&amp; Visited[j] == false) DFS(Graph,j,Visit);&#125;*/void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )&#123; Visit(V); Visited[V]=true; for(int j=0;j&lt;Graph-&gt;Nv;j++) &#123; if(Graph-&gt;G[V][j]==1&amp;&amp;Visited[j]==false)DFS(Graph, j, Visit); &#125;&#125; 6-2 邻接表存储图的广度优先遍历 (20 分) 1234567891011121314151617181920212223242526void BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) )&#123; int w,j,Q[MaxVertexNum]; int first=0,late=0; Visit(S); Visited[S]=true; Q[late++]=S; PtrToAdjVNode tmp; while(late!=first) &#123; w=Q[first++]; tmp=Graph-&gt;G[w].FirstEdge; while(tmp) &#123; Vertex pos=tmp-&gt;AdjV; if(!Visited[pos]) &#123; Visit(pos); Visited[pos]=true; Q[late++]=pos; &#125; tmp=tmp-&gt;Next; &#125; &#125;&#125; 编程题 第七章 查找 判断题（错题：1-1,1-4,1-6） 1-1 在散列中，函数“插入”和“查找”具有同样的时间复杂度。T 1-2 当记录个数小于哈希表长度时，哈希查找平均查找长度必然为0。F 1-3 用向量和单链表表示的有序表均可使用折半查找方法来提高查找速度。F 1-4 有n个数存放在一维数组A[1…n]中，在进行顺序查找时，这n个数的排列有序或无序其平均查找长度不同。F 1-5 折半查找法的查找速度一定比顺序查找法快。F 1-6 就平均查找长度而言，分块查找最小，折半查找次之，顺序查找最大。F 1-7 hash表的平均查找长度与处理冲突的方法无关。F 选择题(错题：2-9,2-10) 2-1 用二分查找从100个有序整数中查找某数，最坏情况下需要比较的次数是： A.7 2-2 在有n（n&gt;1000）个元素的升序数组A中查找关键字x。查找算法的伪代码如下所示： 123456k = 0;while ( k&lt;n 且 A[k]&lt;x ) k = k+3;if ( k&lt;n 且 A[k]==x ) 查找成功;else if ( k-1&lt;n 且 A[k-1]==x ) 查找成功; else if ( k-2&lt;n 且 A[k-2]==x ) 查找成功; else 查找失败; 本算法与二分查找（折半查找）算法相比，有可能具有更少比较次数的情形是： B.当x接近数组开头处 2-3 下列二叉树中，可能成为折半查找判定树（不含外部结点）的是： A. 2-4 在顺序表（8,11,15,19,25,26,30,33,42,48,50）中，用二分（折半）法查找关键码值20，需做的关键码比较次数为( )。 B.4 2-5 顺序查找n个元素的顺序表，若查找成功，则比较关键字的次数最多为( )次。 (2分) A.n 2-6 输入一个正整数序列（53,17,12,66,58,70,87,25,56,60），按次序构造一棵二叉排序树BS为（ ）。 A. 2-7 在下列查找的方法中，平均查找长度与结点个数无关的查找方法是： C.利用哈希（散列）表 2-8 对哈希(HASH)函数H(k)= k MOD m, 一般来说,m应取 (2分) A.素数 2-9 将元素序列{18, 23, 4, 26, 31, 33, 17, 39}按顺序插入一个初始为空的、大小为13的散列表中。散列函数为：H(Key)=Key%13，采用线性探测法处理冲突。问：当第一次发现有冲突时，散列表的装填因子大约是多少？ C.0.31 2-10 现有长度为 11 且初始为空的散列表 HT，散列函数是 H(k**ey)=k**ey%7，采用线性探查（线性探测再散列）法解决冲突。将关键字序列 87,40,30,6,11,22,98,20 依次插入到 HT 后，HT 查找失败的平均查找长度是： C.6 2-11 设有一组关键字 { 29，01， 13，15，56，20，87，27，69，9，10，74 }，散列函数为 H(k**ey)=k**ey%17，采用线性探测方法解决冲突。试在 0 到 18 的散列地址空间中对该关键字序列构造散列表，则成功查找的平均查找长度为 __ D.1.33 2-12 设有一组关键字 { 29，01， 13，15，56，20，87，27，69，9，10，74 }，散列函数为 H(k**ey)=k**ey%17，采用平方探测方法解决冲突。试在 0 到 18 的散列地址空间中对该关键字序列构造散列表，则成功查找的平均查找长度为 __ C.1.25 填空题（错题：4-1） 4-1 执行以下程序， 123456789101112131415161718#include &lt;stdio.h&gt;int main( )&#123; int array[10]=&#123;2, 12, 24, 36, 48, 49, 2333, 6666, 23333, 99999&#125;; int key=2333, flag=0, low=0, m, h=9, times=0; while(low &lt;= h)&#123; m = (low + h) / 2; times++; if(array[m] == key) &#123; printf(&quot;Found-%d-%d&quot;, m, times); flag = 1; break; &#125; else if(array[m] &gt; key) h = m - 1; else low = m + 1; &#125; if(flag == 0) printf(&quot;Not Found!&quot;); return 0;&#125; 程序运行结果（即：在屏幕上打印的内容）是Found-6-4 。 （注意：要严格按照程序打印的格式填写答案，包括字母的大小写、空格的多少、连字符-和叹号!的格式等，不得随意增加引号、空格等无关字符，否则不得分。例如printf(&quot;hello World&quot;);打印的内容就是hello World，而不是&quot;hello World&quot;。为防止格式书写错误，建议直接从上面的代码中复制部分相关内容。） 4-2 顺序查找算法的平均查找长度 在下面的线性表中 1( 15, 24, 32, 47, 50, 58, 62, 79, 83, 96 ) 若采用顺序查找算法，假设各元素的检索概率相同，则平均查找长度为 5.5 4-3 二分查找算法的最大查找长度 在下面的有序表中 1( 15, 24, 32, 47, 50, 58, 62, 79, 83, 96 ) 若采用二分查找算法，则最大查找长度为 4 函数题 6-1 二分查找 (20 分) 123456789101112Position BinarySearch( List L, ElementType x )&#123; int high=L-&gt;Last,low=1,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(x&lt;L-&gt;Data[mid])high=mid-1; else if(x&gt;L-&gt;Data[mid])low=mid+1; else return mid; &#125; return NotFound;&#125; 6-2 线性探测法的查找函数 (20 分) 12345678910111213141516Position Find( HashTable h, ElementType key )&#123; int p0,p; int num=0; p=p0=Hash(key,h-&gt;TableSize); while(h-&gt;Cells[p].Info!=Empty&amp;&amp;h-&gt;Cells[p].Data!=key) &#123; num++; if(num==MAXTABLESIZE) &#123; return ERROR; &#125; p=(p0+num)%h-&gt;TableSize; &#125; return p;&#125; 6-3 有序数组的插入 (20 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*bool Insert( List L, ElementType X )&#123; if(L -&gt; Last + 1 == MAXSIZE)//满了 return false; for (int i = 0; i &lt;= L -&gt; Last; i++ ) &#123; if (L -&gt; Data[i] == X) //已经有了 return false; else if (L -&gt; Data[i] &lt; X) &#123; for (int j = L -&gt;Last; j &gt;= i; j -- )//i之后的后移一位 &#123; L -&gt; Data[j + 1] = L -&gt; Data[j]; &#125; L-&gt;Data[i] = X; L-&gt;Last ++; break; &#125; else if (i==L-&gt;Last &amp;&amp; L-&gt;Data[i]&gt; X)//插在最后一位 &#123; L-&gt;Data[L-&gt;Last+1] = X; L-&gt;Last ++; break; &#125; &#125; return true;&#125;*/bool Insert( List L, ElementType X )&#123; if(L-&gt;Last==MAXSIZE-1)return false; int low=0,high=L-&gt;Last,mid; while(low&lt;=high) &#123; mid=(low+high)/2; if(L-&gt;Data[mid]&gt;X)low=mid+1; else if(L-&gt;Data[mid]&lt;X)high=mid-1; else return false; &#125; for(int i=L-&gt;Last;i&gt;high;i--) L-&gt;Data[i+1]=L-&gt;Data[i]; L-&gt;Data[high+1]=X; L-&gt;Last++; return true;&#125; 6-4 创建哈希表及查找(拉链法) (10 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445void CreateHash(HashTable HT[],int n)&#123; int x,num; HashNode *p; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x; num=x%P; p=new HashNode; p-&gt;key = x; if(HT[num]==NULL) &#123; HT[num]=new HashNode; p-&gt;next=NULL; HT[num]-&gt;next=p; &#125; else &#123; p-&gt;next=HT[num]-&gt;next; HT[num]-&gt;next=p; &#125; &#125;&#125;float ASL(HashTable HT[])&#123; HashNode *p; int sum=0,len=0; for(int i=0;i&lt;P;i++) &#123; if(HT[i]==NULL)continue; else &#123; int cnt=1; p=HT[i]-&gt;next; while(p!=NULL) &#123; sum+=cnt; cnt++; len++; p=p-&gt;next; &#125; &#125; &#125; return sum*1.0/len;&#125; 编程题 7-1 电话聊天狂人 (25 分) 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;string, int&gt; m; map&lt;string, int&gt;::iterator it;//迭代器（指针） int n, cnt = 0, people= 1; string s;//s存手机号 cin &gt;&gt; n; for (int i = 0; i &lt; n * 2; i++) &#123; cin &gt;&gt; s; m[s]++; &#125; for (it = m.begin(); it != m.end(); it++) &#123; if (it-&gt;second &gt; cnt) &#123;//第一个位置存储的second的大于人数，则 people = 1; s = it-&gt;first; cnt = it-&gt;second; &#125; else if (it-&gt;second == cnt) &#123;//电话狂人不唯一 people++;//电话狂人有几个 if (it-&gt;first &lt; s)//找最小的号码 s = it-&gt;first; &#125; &#125; cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; cnt; if (people != 1) cout &lt;&lt; &quot; &quot; &lt;&lt; people;&#125;//map容器 7-2 愤怒的牛 (25 分) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;int a[100010];int l, r;int n,c; /*bool juge(int m)//判断距离m是否可以 &#123; int s = 0, last = 1;//记录上一个 for (int i = 2; i &lt;= n; i++)//依次枚举每个牛栏 &#123; if (a[i] - a[last]&lt;m)s++;//若此距离不满足当前答案，那么需要的牛栏数+1，即把当前牛放到下一个牛栏 else last = i;//否则就更新上一次的牛栏位置 ，即上一头牛放的位置 if (s&gt;n - c) return false;//若需要牛栏数大于最大牛栏数，此答案不可行 &#125; return true;&#125;*/ bool juge(int m) &#123; int ans = 1, last = 1; //因为第一个牛一定要占据第一个隔间（这样能使本题的答案最优），所以ans初始化为1 for (int i = 2; i &lt;=n; i++) &#123; if (a[i] - a[last] &gt;= m) &#123; ans++; //如果比最近距离要大的话，那么该隔间就放牛 last = i; &#125; &#125; if (ans &gt;= c)return true; //如果所选取的隔间数量&gt;=c，则说明枚举的最近距离成立，但是不够大，所以return true,继续枚举更大的距离 return false;&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;=n; i++)cin &gt;&gt; a[i]; l = 1; r = a[n] - a[1]; //右边界为n个隔间的总长度，最近距离一定小于等于这个数值 sort(a + 1, a + 1 + n); while (l &lt;=r) &#123; int mid = (l + r)/2; if (juge(mid))l = mid+1; //如果当前枚举的最近距离符合，那么就让l=mid,看更大的距离是否也符合（因为要求最大的最近距离） else r = mid-1; &#125; cout &lt;&lt; r&lt;&lt; endl; //由于最后l&lt;=r的时候还会运行一次，会让l-1(如果答案正确的话)，所以应该输出的是r return 0;&#125; 第八章 排序 判断题 1-1 仅基于比较的算法能得到的最好的“最坏时间复杂度”是O(NlogN)。T 1-2 对N个记录进行简单选择排序，比较次数和移动次数分别为O(N2)和O(N)。T 1-3 对N个记录进行快速排序，在最坏的情况下，其时间复杂度是O(NlogN)。F 1-4 希尔排序是稳定的算法。F 1-5 堆排序是稳定的排序算法。F 1-6 在堆排序中，若要进行升序排序，则需要建立大根堆。T 1-7 排序算法中的比较次数与初始元素序列的排列无关。F 1-8 排序的稳定性是指排序算法中的比较次数保持不变，且算法能够终止。F 1-9 对于n个记录的集合进行冒泡排序，在最坏情况下需要的时间是O(n2)。T 1-10 直接选择排序的时间复杂度为O(n2)，不受数据初始排列的影响。T 选择题(错题：2-6,2-11,2-12,2-13) 2-1 对N个不同的数据采用冒泡算法进行从大到小的排序，下面哪种情况下肯定交换元素次数最多？ A.从小到大排好的 2-2 在对N个元素进行排序时，基于比较的算法中，其“最坏时间复杂度”中最好的是： C.O(Nlog**N) 2-3 对N个记录进行归并排序，归并趟数的数量级是： A.O(log**N) 2-4 有组记录的排序码为{ 46，79，56，38，40，84 }，则利用堆排序的方法建立的初始堆为： D.84，79，56，38，40，46 2-5 采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是： C.递归次数与每次划分后得到的分区处理顺序无关 2-6 有组记录的排序码为{46，79，56，38，40，84 }，采用快速排序（以位于最左位置的对象为基准而）得到的第一次划分结果为： D.{40,38,46,56,79,84} 2-7 对于10个数的简单选择排序，最坏情况下需要交换元素的次数为： A.9 将序列{ 2, 12, 16, 88, 5, 10, 34 }排序。若前2趟排序的结果如下： 第1趟排序后：2, 12, 16, 10, 5, 34, 88 第2趟排序后：2, 5, 10, 12, 16, 34, 88 则可能的排序算法是： C.快速排序 2-9 对初始数据序列{ 8, 3, 9, 11, 2, 1, 4, 7, 5, 10, 6 }进行希尔排序。若第一趟排序结果为（ 1, 3, 7, 5, 2, 6, 4, 9, 11, 10, 8 ），第二趟排序结果为（ 1, 2, 6, 4, 3, 7, 5, 8, 11, 10, 9 ），则两趟排序采用的增量（间隔）依次是： D.5, 3 2-10 下列排序算法中，占用辅助空间最多的是：( ) A.归并排序 2-11 选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是： I、数据的规模 II、数据的存储方式 III、算法的稳定性 IV、数据的初始状态 D.I、II、III、IV 2-12 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列序列中，不可能是快速排序第二趟结果的是： D.5, 2, 12, 28, 16, 32, 72, 60 2-13 对大部分元素已有序的数组进行排序时，直接插入排序比简单选择排序效率更高，其原因是： (I). 直接插入排序过程中元素之间的比较次数更少 (II). 直接插入排序过程中所需要的辅助空间更少 (III). 直接插入排序过程中元素的移动次数更少 A.仅 I 2-14 下述几种排序方法中,( )是稳定的排序方法。 C.归并排序 填空题 4-1 基于比较的排序方法，其最好的时间复杂度为O(nlogn) 4-2 时间复杂度为O(nlogn)的排序算法有归并排序、堆排序和快速排序 4-3 对包含10个记录的表r[1…10]进行简单选择排序，所需进行的关键字间的比较次数为45 函数题 6-1 快速排序 (15 分) 12345678910111213141516171819202122int Partition(SqList &amp;L,int low,int high)&#123; int i=low,j=high; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;L.r[i].key&lt;=L.r[j].key)j--; if(i&lt;j)&#123;swap(L.r[i].key,L.r[j].key);i++;&#125; while(i&lt;j&amp;&amp;L.r[i].key&lt;=L.r[j].key)i++; if(i&lt;j)&#123;swap(L.r[i].key,L.r[j].key);j--;&#125; &#125; return i;&#125;void QuickSort(SqList &amp;L, int low, int high)&#123; if(low&gt;=high)return; else &#123; int pivot=Partition(L,low,high); QuickSort(L,low,pivot-1); QuickSort(L,pivot+1,high); &#125;&#125; 6-2 冒泡排序 (10 分) 1234567891011void bubbleSort(int arr[], int n)&#123; int i,j; for(i=0;i&lt;n-1;i++) &#123; for(j=0;j&lt;n-i-1;j++) &#123; if(arr[j]&gt;arr[j+1])swap(&amp;arr[j],&amp;arr[j+1]); &#125; &#125;&#125; 6-3 简单选择排序 (10 分) 1234567891011121314void SelectSort(SqList L)&#123; int i,j,mini,temp; int n = L.Length; for(i=1;i&lt;n;i++) &#123; mini=i; for(j=i+1;j&lt;n+1;j++) &#123; if(L.elem[mini]&gt;L.elem[j])mini=j; &#125; if(mini!=i)&#123;temp=L.elem[i];L.elem[i]=L.elem[mini];L.elem[mini]=temp;&#125; &#125;&#125; 6-4 堆排序 (10 分) 12345678910111213141516171819void HeapAdjust( HeapType H, int s, int m)&#123; int dad,son,last,temp; dad=s;son=2*dad,last=m; while(son&lt;=last) &#123; if(son+1&lt;=last&amp;&amp;H.elem[son]&lt;H.elem[son+1])son++; if(H.elem[dad]&gt;H.elem[son])return; else &#123; temp=H.elem[son]; H.elem[son]=H.elem[dad]; H.elem[dad]=temp; dad=son; son=dad*2; &#125; &#125;&#125; 6-5 归并排序 (10 分) 12345678910111213141516171819202122void Merge(SqList L,int low,int m,int high)&#123; int Q[high-low+1]; int i=low,j=m+1,k=0; while(i&lt;=m&amp;&amp;j&lt;=high) &#123; if(L.elem[i]&gt;=L.elem[j]) &#123; Q[k++]=L.elem[j++]; &#125; else if(L.elem[i]&lt;=L.elem[j]) &#123; Q[k++]=L.elem[i++]; &#125; &#125; while(i&lt;=m)Q[k++]=L.elem[i++]; while(j&lt;=high)Q[k++]=L.elem[j++]; for(int i=low,k=0;i&lt;=high;i++) &#123; L.elem[i]=Q[k++]; &#125;&#125; 编程题 7-1 字符串的冒泡排序 (20 分) 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; string arr[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i]; &#125; for(int i=0;i&lt;n-1;i++) &#123; for(int j=0;j&lt;n-i-1;j++) &#123; if(arr[j]&gt;arr[j+1])swap(arr[j],arr[j+1]); &#125; if(i==k-1)break; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i]&lt;&lt;endl; return 0;&#125; 7-2 模拟EXCEL排序 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*#include&lt;iostream&gt;using namespace std;struct Info&#123; string id; string name; int score;&#125;;int main()&#123; int n,c,mini; cin&gt;&gt;n&gt;&gt;c; Info arr[n]; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;arr[i].id&gt;&gt;arr[i].name&gt;&gt;arr[i].score; &#125; if(c==1) &#123; for(int i=0;i&lt;n-1;i++) &#123; mini=i; for(int j=i+1;j&lt;n;j++) &#123; if(arr[mini].id&gt;arr[j].id)mini=j; &#125; if(mini!=i)swap(arr[mini],arr[i]); &#125; &#125; else if(c==2) &#123; int exchange,bound,temp; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].id&gt;arr[j+1].id)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].name&gt;arr[j+1].name)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; &#125; else if(c==3) &#123; int exchange,bound,temp; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].id&gt;arr[j+1].id)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; exchange=n-1; while(exchange) &#123; bound=exchange;exchange=0; for(int j=0;j&lt;bound;j++) &#123; if(arr[j].score&gt;arr[j+1].score)&#123;swap(arr[j],arr[j+1]);exchange=j;&#125; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;arr[i].id&lt;&lt;&quot; &quot;&lt;&lt;arr[i].name&lt;&lt;&quot; &quot;&lt;&lt;arr[i].score&lt;&lt;endl; return 0;&#125;*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt; using namespace std;const int maxn = 100000 + 7;int n, c; struct node &#123; int id, sc; char name[22];&#125;a[maxn]; bool cmp1(node a, node b) &#123; return a.id &lt; b.id;&#125;bool cmp2(node a, node b) &#123; if(strcmp(a.name, b.name) == 0) return a.id &lt; b.id; return strcmp(a.name, b.name) &lt; 0;&#125;bool cmp3(node a, node b) &#123; if(a.sc == b.sc) return a.id &lt; b.id; return a.sc &lt; b.sc;&#125; int main() &#123; //char s[22], t[22]; //scanf(&quot;%s %s&quot;, s, t); //printf(&quot;%d\\n&quot;, strcmp(s, t)); scanf(&quot;%d %d&quot;, &amp;n, &amp;c); for(int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d %s %d&quot;, &amp;a[i].id, a[i].name, &amp;a[i].sc); &#125; if(c == 1) sort(a, a+n, cmp1); if(c == 2) sort(a, a+n, cmp2); if(c == 3) sort(a, a+n, cmp3); for(int i = 0; i &lt; n; ++i) printf(&quot;%.6d %s %d\\n&quot;, a[i].id, a[i].name, a[i].sc); return 0;&#125; 7-3 悄悄关注 (25 分) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/*#include&lt;iostream&gt;using namespace std;struct Info&#123; string name; int zan;&#125;;int main()&#123; int n1,n2,avg=0; cin&gt;&gt;n1; string guanzhu[n1]; for(int i=0; i&lt;n1; i++) cin&gt;&gt;guanzhu[i]; cin&gt;&gt;n2; Info dianzan[n2],temp[n2]; for(int i=0; i&lt;n2; i++) &#123; cin&gt;&gt;dianzan[i].name&gt;&gt;dianzan[i].zan; avg+=dianzan[i].zan; &#125; avg /= n2; int flag=1,k=0; for(int i=0; i&lt;n2; i++) &#123; for(int j=0; j&lt;n1; j++) &#123; if(guanzhu[j]==dianzan[i].name) &#123; flag=0; break; &#125; &#125; if(flag&amp;&amp;dianzan[i].zan&gt;avg) &#123; temp[k++]=dianzan[i]; &#125; flag=1; &#125; if(k==0)cout&lt;&lt;&quot;Bing Mei You&quot;&lt;&lt;endl; else &#123; for(int i=0; i&lt;k-1; i++) &#123; int mini=i; for(int j=i+1; j&lt;k; j++) &#123; if(temp[j].name&lt;temp[mini].name)mini=j; &#125; if(mini!=i)swap(temp[mini],temp[i]); &#125; for(int i=0; i&lt;k; i++) cout&lt;&lt;temp[i].name&lt;&lt;endl; &#125; return 0;&#125;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;struct Info&#123; string name; int zan;&#125;;struct List&#123; Info dianzan[10000];&#125;;int Partition(List &amp;l,int first,int last)&#123; int i=first,j=last; while(i&lt;j) &#123; while(i&lt;j&amp;&amp;l.dianzan[i].name&lt;=l.dianzan[j].name)j--; if(i&lt;j) &#123; swap(l.dianzan[i],l.dianzan[j]); i++; &#125; while(i&lt;j&amp;&amp;l.dianzan[i].name&lt;l.dianzan[j].name)i++; if(i&lt;j) &#123; swap(l.dianzan[i],l.dianzan[j]); j--; &#125; &#125; return i;&#125;void quicksort(List&amp;l,int first,int last)&#123; if(first&gt;=last)return; else &#123; int mid=Partition(l,first,last); quicksort(l,first,mid-1); quicksort(l,mid+1,last); &#125;&#125;int main()&#123; int n1,n2,zan,sum=0,flag=1,k=0; string name; List l; set&lt;string&gt; guanzhu; cin&gt;&gt;n1; for(int i=0;i&lt;n1;i++) &#123; cin&gt;&gt;name; guanzhu.insert(name); &#125; cin&gt;&gt;n2; for(int i=0;i&lt;n2;i++) &#123; cin&gt;&gt;name&gt;&gt;zan; sum+=zan; if(guanzhu.find(name)==guanzhu.end()) &#123; l.dianzan[k].name=name; l.dianzan[k++].zan=zan; &#125; &#125; sum/=n2; quicksort(l,0,k); for(int i=0;i&lt;k;i++) &#123; if(l.dianzan[i].zan&gt;=sum) &#123; cout&lt;&lt;l.dianzan[i].name&lt;&lt;endl; flag=0; &#125; &#125; if(flag)cout&lt;&lt;&quot;Bing Mei You&quot;&lt;&lt;endl; return 0;&#125;*/#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;int main()&#123; int n,m,i,j,k=0,s=0,f=0,a,fag=0; string s1,s2; map&lt;string,int&gt;p; set&lt;string&gt;p1; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;s1; p[s1]=0; &#125; cin&gt;&gt;m; int c[m]; char b[m][10]; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;s2&gt;&gt;a; s=s+a; if(p.find(s2)==p.end()) &#123; for(j=0;j&lt;sizeof(s2);j++) &#123; b[k][j]=s2[j]; &#125; c[k]=a; k++; &#125; else &#123; p[s2]=a; &#125; &#125; s=s/m; for(i=0;i&lt;k;i++) &#123; if(c[i]&gt;s) &#123; p1.insert(b[i]); f++; fag=1; &#125; &#125; if(fag==0) &#123; printf(&quot;Bing Mei You&quot;); &#125; else &#123; set&lt;string&gt;::iterator it; for(it=p1.begin();it!=p1.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"静态博客的创建","slug":"静态博客的建立","date":"2021-12-04T11:35:25.302Z","updated":"2022-04-19T01:06:00.156Z","comments":true,"path":"2021/12/04/静态博客的建立/","link":"","permalink":"https://zhang0224gz.github.io/2021/12/04/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BB%BA%E7%AB%8B/","excerpt":"","text":"第一步：下载node ​ D:\\my app\\nodejs 第二步：github注册 ​ -&gt;Zhang2002GZ.github.io（用户名.github.io） 第三步：下载git ​ git for windows-&gt;cmd+r: git（D:\\my app\\Git） 第四步：SHH配置 (1)git_bash打开:$ ssh-keygen -t rsa -C “2251787923@qq.com”-&gt;回车(4次)直至结束 记住这行Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa) 括号里面的地址是后面要用到的 (2)打开github-&gt;setting-&gt;SHH:title:Zhang2002GZ ;key:粘贴文本文档 user-&gt;zhangguozhi-&gt;.ssh-&gt;.pub 在github上建秘钥 第五步：hexo使用 ​ -&gt;文档 npm install hexo-cli -g //安装 hexo init blog //初始化博客 cd blog npm install //hexo server 新建目录blog-&gt;cmd+r-&gt;D:-&gt;cd blog-&gt;npm install hexo-cli -g-&gt;hexo init myblog-&gt;cd myblog-&gt;npm install -&gt;hexo s -p 4000 浏览器输入网址：localhost:4000 第六步：sublime安装 ​ -&gt;将博客目录直接拖进-&gt;## hello hexo PS：推荐直接在打开方式中选择记事本打开，在记事本里直接修改 第七步：hexo发布至github hexo-&gt;文档-&gt;部署repo sublime-&gt;_config.yml 1234567891011开头： \\# URL \\## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27; **url**: https://Zhang2002GZ.github.io末尾 \\# Deployment \\## Docs: https://hexo.io/docs/one-command-deployment deploy: **type: git repo: https://github.com/Zhang2002GZ/Zhang2002GZ.github.io.git branch: master** hexo-&gt;文档-&gt;部署 hexo g-&gt;npm install hexo-deployer-git --save-&gt;hexo d 123type: git repository: https://github.com/zhang2002gz/zhang2002gz.github.io.git branch: main hexo init( Start blogging with Hexo!)-&gt;静态生成本地的hexo页面hexo s(打开本地服务器：将http://localhost:4000可以看见博客；ctrl+c关闭服务器就看不见页面） -&gt;npm install hexo-deployer-git --save-&gt;生成页面hexo g-&gt;将本地文件上传github hexo d （error10054:这个保错就执行git config --global http.sslVerify “false”） **!**登入页面弹窗只在第一次创建的时候出现 第八步：美化 git clone https://github.com/theme-nexmoe/hexo-theme-nexmoe.git themes/nexmoe (git clone 改页面代码所在地址.git 存到themes目录下/新建的nexmoe) sublime修改_config.yml:theme: nexmoe 也可以在release里下载压缩包将它解压到themes中 npm install --save hexo-renderer-pug git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun theme: sbun 清理一下hexo clean ,生成一下 hexo g,hexo s(打开服务器），hexo d(上传） 其他 检查： 123456789101112node -v git --version npm -v hexo -vssh $ ssh -T git@github.com （Hi zhang2002gz! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.）查看npm安装hexo插件的情况 npm ls --depth 0安装缺失的插件 npm install acorn --save 万能三件套： 12345git config --global --unset http.proxygit config --global --unset https.proxygit config --global http.sslVerify &quot;false&quot; 一些pure主题的配置 hexo-theme-pure/README.cn.md at master · cofess/hexo-theme-pure (github.com) 1234567891011121314151617181920212223242526272829文章索引目录title: 文章标题categories: - 文章分类tags: - 文章标签toc: true # 是否启用内容索引sidebar侧边栏文章侧边栏默认为开启状态，如果某篇文章不想开启侧边栏，在文章开头配置加入“sidebar: none”即可：title: 文章标题categories: - 文章分类tags: - 文章标签sidebar: none # 是否启用sidebar侧边栏，none：不启用友情链接Name: link: http://example.com avatar: http://example.com/avatar.png desc: &quot;这是一个描述&quot; 安装主题git clone https://github.com/cofess/hexo-theme-pure.git themes/pure更新主题cd themes/puregit pull 相关视频 【2021最新版】保姆级Hexo+github搭建个人博客_哔哩哔哩_bilibili Hexo博客开发之——WARN No layout index.html - 程序员大本营 (pianshen.com) 12345678910111213141516Git 全局设置: git config --global user.name &quot;zhang-guozhi&quot; git config --global user.email &quot;10094335+zhang-guozhi@user.noreply.gitee.com&quot; 创建 git 仓库: mkdir zhang-guozhi cd zhang-guozhi git init touch README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://gitee.com/zhang-guozhi/zhang-guozhi.git git push -u origin master 已有仓库? cd existing_git_repo git remote add origin https://gitee.com/zhang-guozhi/zhang-guozhi.git git push -u origin master 一些符号的使用 12345加粗：**文字**取消加粗：\\**文字**显示\\ : \\\\ &gt; 文字 12345678910111213表格同一格里换行：文字&lt;br/&gt;---title: 基础知识1categories: - 智能车tags: - 笔记toc: true----空格：无序列表（下面那个点，回车会再有一个点）---回车（下面那个分隔线） Markdown设置字体颜色 (2条消息) 【Markdown笔记】设置字体颜色_dadalaohua的博客-CSDN博客_markdown设置字体颜色 markdown中公式编辑教程 markdown中公式编辑教程 - 简书 (jianshu.com)","categories":[],"tags":[{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-27T13:15:34.628Z","updated":"2022-03-28T16:04:26.767Z","comments":true,"path":"2021/11/27/hello-world/","link":"","permalink":"https://zhang0224gz.github.io/2021/11/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"智能车","slug":"智能车","permalink":"https://zhang0224gz.github.io/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/"},{"name":"刷题","slug":"刷题","permalink":"https://zhang0224gz.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"CET","slug":"CET","permalink":"https://zhang0224gz.github.io/categories/CET/"},{"name":"笔记","slug":"笔记","permalink":"https://zhang0224gz.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"语文","slug":"语文","permalink":"https://zhang0224gz.github.io/categories/%E8%AF%AD%E6%96%87/"},{"name":"数学建模","slug":"数学建模","permalink":"https://zhang0224gz.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"Python","slug":"Python","permalink":"https://zhang0224gz.github.io/categories/Python/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://zhang0224gz.github.io/tags/Web/"},{"name":"数据库","slug":"数据库","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"初始化","slug":"初始化","permalink":"https://zhang0224gz.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"密码学","slug":"密码学","permalink":"https://zhang0224gz.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"tips","slug":"tips","permalink":"https://zhang0224gz.github.io/tags/tips/"},{"name":"教育知识与能力","slug":"教育知识与能力","permalink":"https://zhang0224gz.github.io/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://zhang0224gz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zhang0224gz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"SET4","slug":"SET4","permalink":"https://zhang0224gz.github.io/tags/SET4/"}]}