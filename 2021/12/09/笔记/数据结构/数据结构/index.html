<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>数据结构笔记 | Flutter</title>
  <meta name="description" content="第二、三、四章 线性表 字符串：线性表特例 多维数组：线性表推广（严格不是） 线性表（表）：具有相同类型的数据元素的有限序列 -&gt; 将元素类型限制为字符：字符串（串）：零个或多个字符组成的有限序列 串长：串中所包含的字符个数 空串：长度为 0 的串 子串：串中任意个连续的字符组成的子序列(包含空串) 主串：包含子串的串 子串的位置：子串的第一个字符在主串中的序号 串的存储结构 字符串通常采">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记">
<meta property="og:url" content="https://zhang0224gz.github.io/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第二、三、四章 线性表 字符串：线性表特例 多维数组：线性表推广（严格不是） 线性表（表）：具有相同类型的数据元素的有限序列 -&gt; 将元素类型限制为字符：字符串（串）：零个或多个字符组成的有限序列 串长：串中所包含的字符个数 空串：长度为 0 的串 子串：串中任意个连续的字符组成的子序列(包含空串) 主串：包含子串的串 子串的位置：子串的第一个字符在主串中的序号 串的存储结构 字符串通常采">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://csdnimg.cn/release/blog_editor_html/release1.9.2/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=L9C2">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ba791e546c25415b879ea2440024371e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_8,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9d2276eaa404489f959882f2550664f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_14,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b0439d1cc7e74e7d9f2e1125889bd850.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1ea4b934f19a436f8efde4bca5dec2c4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f8f08a83bb26413aba03147979db20f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0d8a52f79699405db8763c127c1c7736.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_16,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2635027a5de44d329260cef95eb8c191.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/205a54420f5b4f11bdddd6727c104a6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b359fd0e6209454ebe5a3c0fbeab1403.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_13,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ac6d89d88c04a1ab93a79acf893b5b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="c:%5CUsers%5Czhangguozhi%5CDesktop%5C1.png">
<meta property="og:image" content="c:%5CUsers%5Czhangguozhi%5CDesktop%5C2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/026a98c177324bad895f0554f8012a4e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5112cd64503b475c94e0a442389f736e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="article:published_time" content="2021-12-09T05:52:57.914Z">
<meta property="article:modified_time" content="2022-03-27T15:50:18.870Z">
<meta property="article:author" content="zhang0224gz">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://csdnimg.cn/release/blog_editor_html/release1.9.2/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=L9C2">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zhang0224gz.github.io/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://blog.csdn.net/Zhang_2002_GZ?type=blog" target="_blank">
          <img class="img-circle img-rotate" src="/images/flutter.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Eureka</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Study Notes &amp; Supplement</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Jiangsu, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zhang0224gz" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CET/">CET</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%99%BA%E8%83%BD%E8%BD%A6/">智能车</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%AD%E6%96%87/">语文</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SET4/" rel="tag">SET4</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tips/" rel="tag">tips</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="tag">初始化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" rel="tag">协议分析</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/" rel="tag">教育知识与能力</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/" rel="tag">通信原理</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/JAVA/" style="font-size: 13px;">JAVA</a> <a href="/tags/SET4/" style="font-size: 13px;">SET4</a> <a href="/tags/Web/" style="font-size: 13px;">Web</a> <a href="/tags/tips/" style="font-size: 14px;">tips</a> <a href="/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 14px;">初始化</a> <a href="/tags/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" style="font-size: 13.5px;">协议分析</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 14px;">密码学</a> <a href="/tags/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/" style="font-size: 13.5px;">教育知识与能力</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 14px;">数据结构</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 13px;">计算机组成原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 14px;">计算机网络</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/" style="font-size: 13.5px;">通信原理</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/23/%E7%AC%94%E8%AE%B0/JAVA/" class="title">JAVA基础入门</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-23T12:53:52.150Z" itemprop="datePublished">2022-09-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/13/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E5%9E%8B/" class="title">模型</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-13T14:41:44.711Z" itemprop="datePublished">2022-09-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/13/%E7%AC%94%E8%AE%B0/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%903/" class="title">第三章 网际协议IP</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-13T11:00:14.171Z" itemprop="datePublished">2022-09-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/11/%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/" class="title">补充知识：《信号与系统》第四章</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-11T06:22:39.544Z" itemprop="datePublished">2022-09-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/10/%E7%AC%94%E8%AE%B0/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/" class="title">第一章 绪论</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-10T14:27:24.699Z" itemprop="datePublished">2022-09-10</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C-%E4%B8%89-%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text"> 第二、三、四章 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.1.</span> <span class="toc-text"> 模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-bf%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.1.1.</span> <span class="toc-text"> -&gt; BF算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-kmp%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.1.2.</span> <span class="toc-text"> -&gt; KMP算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.0.1.</span> <span class="toc-text"> -&gt; 对称矩阵的压缩存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.0.2.</span> <span class="toc-text"> -&gt; 三角矩阵的压缩存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.0.3.</span> <span class="toc-text"> -&gt; 对角矩阵的压缩存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> 稀疏矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E4%B8%89%E5%85%83%E7%BB%84%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.2.0.1.</span> <span class="toc-text"> -&gt; 三元组顺序表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.0.2.</span> <span class="toc-text"> -&gt; 十字链表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text"> 第五章 树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB"><span class="toc-number">2.0.1.</span> <span class="toc-text"> 逻辑关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">2.0.2.</span> <span class="toc-text"> 树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%A6%E7%BB%93%E7%82%B9%E6%89%80%E6%8B%A5%E6%9C%89%E7%9A%84%E5%AD%90%E6%A0%91%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">2.0.2.1.</span> <span class="toc-text"> 结点的度：结点所拥有的子树的个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%BB%8F%E8%BF%87%E7%9A%84%E8%BE%B9%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">2.0.2.2.</span> <span class="toc-text"> 路径长度：路径上经过的边的个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%AB%98%E5%BA%A6%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B1%82%E6%95%B0"><span class="toc-number">2.0.2.3.</span> <span class="toc-text"> 树的深度（高度）：树中所有结点的最大层数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%E6%A0%91%E4%B8%AD%E6%AF%8F%E4%B8%80%E5%B1%82%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">2.0.2.4.</span> <span class="toc-text"> 树的宽度：树中每一层结点个数的最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.</span> <span class="toc-text"> 树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E5%92%8C%E5%B1%82%E5%BA%8F"><span class="toc-number">2.1.0.1.</span> <span class="toc-text"> -&gt;前序，中序，后序和层序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text"> 树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%8F%8C%E4%BA%B2%E5%AD%A9%E5%AD%90%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">2.2.0.1.</span> <span class="toc-text"> -&gt;双亲，孩子，孩子兄弟表示法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E6%96%9C%E6%A0%91%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.0.1.</span> <span class="toc-text"> -&gt;斜树，满二叉树，完全二叉树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="toc-number">2.4.</span> <span class="toc-text"> 二叉树性质</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-n0n21"><span class="toc-number">2.4.0.1.</span> <span class="toc-text"> -&gt; n0＝n2＋1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E7%AC%ACi%E5%B1%822i-1%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">2.4.0.2.</span> <span class="toc-text"> -&gt; 第i层：2**(i-1)个结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E6%9C%80%E5%A4%9A%E6%9C%892k-1%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">2.4.0.3.</span> <span class="toc-text"> -&gt;最多有2**(k-1)个结点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E6%B7%B1%E5%BA%A6log-n%E4%B8%8B%E5%8F%96%E6%95%B41"><span class="toc-number">2.4.0.4.</span> <span class="toc-text"> -&gt;深度：log n下取整+1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%8F%8C%E4%BA%B2i2%E5%B7%A6%E5%AD%A9%E5%AD%902i%E5%8F%B3%E5%AD%A9%E5%AD%902i1"><span class="toc-number">2.4.0.5.</span> <span class="toc-text"> -&gt;双亲i&#x2F;2，左孩子2i，右孩子2i+1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.</span> <span class="toc-text"> 二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E5%92%8C%E5%B1%82%E5%BA%8Fon"><span class="toc-number">2.5.0.1.</span> <span class="toc-text"> -&gt;前序，中序，后序和层序O(n)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.</span> <span class="toc-text"> 二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.0.1.</span> <span class="toc-text"> -&gt;顺序存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.0.2.</span> <span class="toc-text"> -&gt;二叉链表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.0.2.1.</span> <span class="toc-text"> -&gt;扩展二叉树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97"><span class="toc-number">2.7.</span> <span class="toc-text"> 森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.8.</span> <span class="toc-text"> 最优二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.0.1.</span> <span class="toc-text"> -&gt;哈夫曼算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">2.8.0.2.</span> <span class="toc-text"> -&gt;哈夫曼编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.9.</span> <span class="toc-text"> 线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text"> 第六章 图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%85%B3%E7%B3%BB-2"><span class="toc-number">3.0.1.</span> <span class="toc-text"> 逻辑关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">3.0.2.</span> <span class="toc-text"> 连通图（无向图）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE-%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">3.0.3.</span> <span class="toc-text"> 强连通图、强连通分量（有向图）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.0.4.</span> <span class="toc-text"> 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">3.0.4.1.</span> <span class="toc-text"> -&gt; 深度优先遍历和广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.5.</span> <span class="toc-text"> 存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E5%92%8C%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">3.0.5.1.</span> <span class="toc-text"> -&gt; 邻接矩阵和邻接表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text"> 最小生成树（无向图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-prim%E7%AE%97%E6%B3%95on2"><span class="toc-number">3.1.0.1.</span> <span class="toc-text"> -&gt; Prim算法O(n2)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-kruskal%E7%AE%97%E6%B3%95oelog2e"><span class="toc-number">3.1.0.2.</span> <span class="toc-text"> -&gt; Kruskal算法O(elog2e)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text"> 最短路径（有向图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-dijkstra%E7%AE%97%E6%B3%95on2"><span class="toc-number">3.2.0.1.</span> <span class="toc-text"> -&gt; Dijkstra算法O(n2)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-floyd%E7%AE%97%E6%B3%95on3"><span class="toc-number">3.2.0.2.</span> <span class="toc-text"> -&gt; Floyd算法O(n3)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-number">3.3.</span> <span class="toc-text"> 有向无环图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-aov%E7%BD%91%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-one"><span class="toc-number">3.3.0.1.</span> <span class="toc-text"> -&gt; AOV网和拓扑排序  O(n+e)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-aoe%E7%BD%91%E5%92%8C%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">3.3.0.2.</span> <span class="toc-text"> -&gt;AOE网和关键路径</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9F%A5%E6%89%BE%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text"> 第七章 查找技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.0.1.</span> <span class="toc-text"> 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">4.0.2.</span> <span class="toc-text"> 查找算法的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">4.0.3.</span> <span class="toc-text"> 查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">4.0.3.1.</span> <span class="toc-text"> 线性表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E8%A1%A8"><span class="toc-number">4.0.3.2.</span> <span class="toc-text"> 树表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">4.0.3.3.</span> <span class="toc-text"> 散列表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF"><span class="toc-number">5.</span> <span class="toc-text"> 第8章 排序技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">5.0.1.</span> <span class="toc-text"> 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">5.0.2.</span> <span class="toc-text"> 排序算法的性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E5%86%85%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.</span> <span class="toc-text"> 基于比较的内排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.1.</span> <span class="toc-text"> -&gt; 比较排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.1.1.</span> <span class="toc-text"> -&gt; 直接插入排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.1.2.</span> <span class="toc-text"> -&gt; 希尔排序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.2.</span> <span class="toc-text"> -&gt; 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E8%B5%B7%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.2.1.</span> <span class="toc-text"> -&gt; 起泡排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.2.2.</span> <span class="toc-text"> -&gt; 快速排序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.3.</span> <span class="toc-text"> -&gt; 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.3.1.</span> <span class="toc-text"> -&gt; 简单选择排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.3.2.</span> <span class="toc-text"> -&gt; 堆排序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.4.</span> <span class="toc-text"> -&gt; 归并排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">5.0.3.5.</span> <span class="toc-text"> -&gt; 基数排序</span></a></li></ol></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-笔记/数据结构/数据结构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      数据结构笔记
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
	  <time datetime="2021-12-09T05:52:57.914Z" itemprop="datePublished">2021-12-09</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="第二-三-四章-线性表"><a class="markdownIt-Anchor" href="#第二-三-四章-线性表"></a> 第二、三、四章 线性表</h2>
<p>字符串：线性表特例</p>
<p>多维数组：线性表推广（严格不是）</p>
<p>线性表（表）：具有相同类型的数据元素的有限序列</p>
<p>-&gt; 将元素类型限制为字符：字符串（串）：零个或多个字符组成的有限序列</p>
<p>串长：串中所包含的字符个数</p>
<p>空串：长度为 0 的串</p>
<p>子串：串中任意个连续的字符组成的子序列(包含空串)<br />
主串：包含子串的串<br />
子串的位置：子串的第一个字符在主串中的序号</p>
<p>串的存储结构</p>
<p>字符串通常采用顺序存储，即用数组存储</p>
<h4 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h4>
<h5 id="-bf算法"><a class="markdownIt-Anchor" href="#-bf算法"></a> -&gt; BF算法</h5>
<p>模式匹配：在主串 S 中寻找子串 T 的过程，T 也称为模式</p>
<p>如果匹配成功，返回 T 在 S 中的位置；否则返回 0</p>
<p>模式匹配问题有什么特点？</p>
<p>（1） 算法的一次执行时间：问题规模通常很大，常常在大量信息中进行匹配</p>
<p>（2） 算法改进所取得的积累效益：模式匹配操作经常被调用，执行频率高</p>
<p>数组的存储结构</p>
<p>如何存储（多维）数组呢？</p>
<p>数组没有插入和删除操作，所以，不用预留空间，适合采用顺序存储</p>
<p>按行优先：先存储行号较小的元素，行号相同者先存储列号较小的元素</p>
<p>按列优先：先存储列号较小的元素，列号相同者先存储行号较小的元素</p>
<h5 id="-kmp算法"><a class="markdownIt-Anchor" href="#-kmp算法"></a> -&gt; KMP算法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char[i]</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>c</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td style="text-align:center">nextval</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>4</td>
</tr>
</tbody>
</table>
<p><strong>一、过程：</strong><br />
<strong>求next值：</strong><br />
1.两个固定值：char[0]_next=-1; char[1]_next=0（一个，没有匹配的，长度为0）<br />
2.开始求：char[2]匹配出错，前面a!=b（两组字符不同），故next=0(重头开始）<br />
char[3]匹配出错，前面有aba, a(char[3]前面的a)和a（匹配必从第一个开始）相同，字符a长度为1，故next=1<br />
char[4]匹配出错，前面有abab,ab和ab相同，长度为2，故next=2<br />
char[5]匹配出错，前面有ababa，aba和aba(123和345)相同，长度为3，故next=3<br />
char[6]匹配出错，前面有ababab,abab和abab(1234和3456)相同,长度为4，故next=4<br />
<strong>求nextval值：</strong><br />
1.一个固定值：char[0]_nextval=-1<br />
2.开始求：char[1]_next=0(char[0]=a), a!=b,所以nextval=char[1]_next<br />
char[2]_next=0(char[0]=a),a==a,所以nextval=char[0]_nextval<br />
同理可得……</p>
<p><strong>二、总结：<br />
求next的值：</strong><br />
看当前字符的前面的一组字符是否有相似的一组字符（开头开始）与之相同，取其最大长度作为next的值<br />
<strong>求nextval值（修正值）：</strong><br />
当前字符的next值(索引值)所指向的字符是否和当前字符相同：相同则修正值为当前字符的next值所指向的字符的修正值；不同则去当前字符的next值</p>
<p><strong>三、例子再来一个：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>b</td>
<td>c</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>next</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>nextval</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>-1</td>
<td>0</td>
<td>5</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>**求next值：**next0=-1,next1=0<br />
a!=b,next2=0; abc不可能(ab!=bc),next3=0;<br />
0==3,next4=1; 01==34,next5=2;012==345,next6=3;<br />
abca==abca(1234==3456),next7=4; 01234==34567,next8=5<br />
1==8,next9=1<br />
**求nextval值：**nextval0=-1<br />
b!=char[next1]=a, nextval=next1=0<br />
c!=char[next2]=a, nextval=next2=0<br />
a==char[next3]=a,nextval=nextval0=-1<br />
同理可得……</p>
<p>这个思路也可以：</p>
<p>[(7条消息) KMP算法中计算next值和nextval的值_threecat.up的博客-CSDN博客_kmp算法next修正值计算方法<img src="https://csdnimg.cn/release/blog_editor_html/release1.9.2/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=L9C2" alt=" " /><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43919400/article/details/103736457">https://blog.csdn.net/qq_43919400/article/details/103736457</a>](</p>
<h3 id="特殊矩阵的压缩存储"><a class="markdownIt-Anchor" href="#特殊矩阵的压缩存储"></a> 特殊矩阵的压缩存储</h3>
<p>什么是特殊矩阵？</p>
<p>特殊矩阵：矩阵中很多值相同的元素并且它们的分布有一定的规律</p>
<p>特殊矩阵如何压缩存储？</p>
<p>为值相同的元素分配一个存储空间</p>
<p>特殊矩阵压缩存储后有什么要求吗？</p>
<p>保证<strong>随机存取</strong>，即在O(1)时间内寻址</p>
<h5 id="-对称矩阵的压缩存储"><a class="markdownIt-Anchor" href="#-对称矩阵的压缩存储"></a> -&gt; 对称矩阵的压缩存储</h5>
<p>如何压缩存储对称矩阵呢？	只存储下三角部分的元素</p>
<p>aij 在一维数组中的下标	k = i×(i-1)/2+ j-1</p>
<p>对称矩阵压缩存储后的寻址方法</p>
<p>对于下三角中的元素aij（i ≥ j）：k＝i×(i-1)/2＋j -1</p>
<p>对于上三角中的元素aij（i＜j），因为aij＝aji，则 k＝j×(j-1)/2＋i -1</p>
<h5 id="-三角矩阵的压缩存储"><a class="markdownIt-Anchor" href="#-三角矩阵的压缩存储"></a> -&gt; 三角矩阵的压缩存储</h5>
<p>如何压缩存储三角矩阵呢？</p>
<p>下（上）三角部分的元素；相同的常数只存储一个</p>
<p>下三角矩阵压缩存储后的寻址方法</p>
<p>对于下三角中的元素aij（i ≥ j）：k＝i×(i -1)/2 + j-1</p>
<p>对于上三角中的元素aij（i＜j）：k＝n×(n + 1)/2</p>
<h5 id="-对角矩阵的压缩存储"><a class="markdownIt-Anchor" href="#-对角矩阵的压缩存储"></a> -&gt; 对角矩阵的压缩存储</h5>
<p>对角矩阵：所有非零元素都集中在以<strong>主对角线为中心</strong>的带状区域中，所有其他元素都为零</p>
<h3 id="稀疏矩阵的压缩存储"><a class="markdownIt-Anchor" href="#稀疏矩阵的压缩存储"></a> 稀疏矩阵的压缩存储</h3>
<p>什么是稀疏矩阵？</p>
<p>稀疏矩阵：矩阵中有很多零元素，并且分布没有规律</p>
<p>稀疏矩阵如何压缩存储？</p>
<p>只存储非零元素，零元素不分配存储空间</p>
<p>如何只存储非零元素？</p>
<p>三元组：（行号，列号，非零元素值）</p>
<h5 id="-三元组顺序表"><a class="markdownIt-Anchor" href="#-三元组顺序表"></a> -&gt; 三元组顺序表</h5>
<p>三元组表：将稀疏矩阵的非零元素对应的三元组所构成的集合，按行优先的顺序排列成一个线性表</p>
<h5 id="-十字链表"><a class="markdownIt-Anchor" href="#-十字链表"></a> -&gt; 十字链表</h5>
<h2 id="第五章-树和二叉树"><a class="markdownIt-Anchor" href="#第五章-树和二叉树"></a> 第五章 树和二叉树</h2>
<p>树的前序遍历等价于二叉树的前序遍历！<br />
树的后序遍历等价于二叉树的中序遍历！</p>
<p>先访问该结点打标记，再孩子入队列-&gt;图结构时，不会造成重复入队<br />
先访问左右孩子入队列，再打标记 -&gt;图结构时会造成重复入队</p>
<h4 id="逻辑关系"><a class="markdownIt-Anchor" href="#逻辑关系"></a> 逻辑关系</h4>
<p>线性结构中，数据元素之间具有线性关系，逻辑关系表现为<strong>前驱-后继</strong>；</p>
<p>树结构中，结点之间具有层次关系，逻辑关系表现为<strong>双亲-孩子</strong></p>
<p>图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为<strong>邻接</strong></p>
<h4 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h4>
<p>树：n个结点(数据元素)的有限集合 ，当 n＝0 时，称为空树；任意一棵非空树 T 满足以下条件：<br />
（1）有且仅有一个特定的称为根的结点；<br />
（2）当 n＞1 时，除根结点之外的其余结点被分成 m（m &gt; 0）个互不相交的有限集合 T1,T2,… , Tm，其中每个集合又是一棵树，并称为这个根结点的子树。</p>
<p>​							*树的定义是采用递归方法</p>
<p>互不相交的具体含义是什么？<br />
结点：结点不能属于多个子树<br />
边：子树之间不能有关系<br />
*互不相交-&gt;没有回路-&gt;树结构具有层次性</p>
<h5 id="结点的度结点所拥有的子树的个数"><a class="markdownIt-Anchor" href="#结点的度结点所拥有的子树的个数"></a> 结点的度：结点所拥有的<strong>子树的个数</strong></h5>
<p>树的度：树中各结点度的最大值<br />
叶子结点：度为 0 的结点，也称为终端结点<br />
分支结点：度不为 0 的结点，也称为非终端结点</p>
<p>*<strong>在树结构中，逻辑关系表现为双亲——孩子</strong></p>
<p>路径：结点序列 n1, n2, …, nk 称为一条由 n1 至 nk 的路径，当且仅当满足如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k）</p>
<h5 id="路径长度路径上经过的边的个数"><a class="markdownIt-Anchor" href="#路径长度路径上经过的边的个数"></a> 路径长度：路径上经过的边的个数</h5>
<p>在树结构中，路径是<strong>唯一的</strong><br />
祖先、子孙：如果有一条路径从结点 x 到结点 y，则 x 称为 y 的祖先，而 y 称为 x 的子孙</p>
<p>结点所在层数：根结点的层数为 1；对其余结点，若某结点在第 k 层，则其孩子结点在第 k+1 层</p>
<h5 id="树的深度高度树中所有结点的最大层数"><a class="markdownIt-Anchor" href="#树的深度高度树中所有结点的最大层数"></a> 树的深度（高度）：树中所有结点的最大层数</h5>
<h5 id="树的宽度树中每一层结点个数的最大值"><a class="markdownIt-Anchor" href="#树的宽度树中每一层结点个数的最大值"></a> 树的宽度：树中每一层结点个数的最大值</h5>
<h3 id="树的遍历"><a class="markdownIt-Anchor" href="#树的遍历"></a> 树的遍历</h3>
<h5 id="-前序中序后序和层序"><a class="markdownIt-Anchor" href="#-前序中序后序和层序"></a> -&gt;前序，中序，后序和层序</h5>
<p>树的遍历：从<strong>根</strong>结点出发，按照某种<strong>次序</strong>访问树中所有结点，并且每个结点仅被<strong>访问</strong>一次</p>
<h3 id="树的存储结构"><a class="markdownIt-Anchor" href="#树的存储结构"></a> 树的存储结构</h3>
<h5 id="-双亲孩子孩子兄弟表示法"><a class="markdownIt-Anchor" href="#-双亲孩子孩子兄弟表示法"></a> -&gt;双亲，孩子，孩子兄弟表示法</h5>
<p>实现树的存储结构，关键是什么?	如何表示树中结点之间的逻辑关系</p>
<p>什么是存储结构?	数据元素及其逻辑关系在存储器中的表示</p>
<p>树中结点之间的逻辑关系是什么?<br />
思考问题的出发点：如何表示结点的双亲和孩子</p>
<h3 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h3>
<h5 id="-斜树满二叉树完全二叉树"><a class="markdownIt-Anchor" href="#-斜树满二叉树完全二叉树"></a> -&gt;斜树，满二叉树，完全二叉树</h5>
<p>二叉树： n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<p>二叉树是度为 2 的树吗？</p>
<p>二叉树是度小于等于 2 的树吗？</p>
<p>二叉树有什么特点？<br />
（1）每个结点最多有两棵子树<br />
（2）二叉树是有序的，其次序不能任意颠倒</p>
<p>左斜树：所有结点都只有左子树的二叉树<br />
右斜树：所有结点都只有右子树的二叉树<br />
斜树：左斜树和右斜树的统称</p>
<p>斜树有什么特点呢？<br />
（1）每一层只有一个结点<br />
（2）结点个数与其深度相同</p>
<p>*斜树是树结构的特例，是从树结构<strong>退化成了线性结构</strong></p>
<p>满二叉树：所有分支结点都存在左子树和右子树，并且所有<strong>叶子都在同一层</strong>上的二叉树</p>
<p>满二叉树有什么特点呢？<br />
（1）叶子只能出现在最下一层<br />
（2）只有度为 0 和度为 2 的结点<br />
（3）在同样深度的二叉树中结点个数最多<br />
（4）在同样深度的二叉树中叶子结点个数最多</p>
<p>满二叉树是树结构的特例，是<strong>最丰满</strong>的二叉树</p>
<p>完全二叉树：在满二叉树中，从最后一个结点开始，<strong>连续去掉任意</strong>个结点得到的二叉树</p>
<p>完全二叉树有什么特点呢？</p>
<p>（1）叶子结点只能出现在<strong>最下两层</strong>且最下层的叶子结点都集中在二叉树的<strong>左面</strong><br />
（2）完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有<strong>左孩子</strong><br />
（3）深度为 k 的完全二叉树在 k-1 层上一定是满二叉树<br />
（4）在同样结点个数的二叉树中，完全二叉树的<strong>深度最小</strong></p>
<h3 id="二叉树性质"><a class="markdownIt-Anchor" href="#二叉树性质"></a> 二叉树性质</h3>
<h5 id="-n0n21"><a class="markdownIt-Anchor" href="#-n0n21"></a> -&gt; <strong>n0＝n2＋1</strong></h5>
<p>性质 5-1：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: <strong>n0＝n2＋1</strong></p>
<p>n＝n0＋n1＋n2 ;n＝n1＋2n2＋1;n0＝n2＋1</p>
<h5 id="-第i层2i-1个结点"><a class="markdownIt-Anchor" href="#-第i层2i-1个结点"></a> -&gt; 第i层：2**(i-1)个结点</h5>
<p>性质 5-2：二叉树的第 i 层上最多有2i-1个结点（i≥1）</p>
<h5 id="-最多有2k-1个结点"><a class="markdownIt-Anchor" href="#-最多有2k-1个结点"></a> -&gt;最多有2**(k-1)个结点</h5>
<p>性质 5-3：一棵深度为 k 的二叉树中，最多有 2k-1个结点<br />
深度为 k 且具有 2k-1个结点的二叉树一定是满二叉树</p>
<h5 id="-深度log-n下取整1"><a class="markdownIt-Anchor" href="#-深度log-n下取整1"></a> -&gt;深度：log n下取整+1</h5>
<p>性质 5-4：具有 n 个结点的<strong>完全二叉树</strong>的深度为[ logn]  +1/log(n+1)上取整</p>
<h5 id="-双亲i2左孩子2i右孩子2i1"><a class="markdownIt-Anchor" href="#-双亲i2左孩子2i右孩子2i1"></a> -&gt;双亲i/2，左孩子2i，右孩子2i+1</h5>
<p>性质 5-5：对一棵具有 n 个结点的<strong>完全二叉树</strong>中从 1 开始按层序编号，对于任意的序号为 i（1≤i≤n）的结点（简称结点 i），有：<br />
（1）如果 i＞1，则结点 i 的<strong>双亲</strong>结点的序号为 <strong>i/2</strong>，否则结点 i 无双亲结点<br />
（2）如果 2i≤n，则结点 i 的<strong>左孩子</strong>的序号为 <strong>2i</strong>，否则结点 i 无左孩子<br />
（3）如果 2i+1≤n，则结点 i 的<strong>右孩子</strong>的序号为<strong>2i+1</strong>，否则结点 i 无右孩子</p>
<h3 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h3>
<h5 id="-前序中序后序和层序on"><a class="markdownIt-Anchor" href="#-前序中序后序和层序on"></a> -&gt;前序，中序，后序和层序O(n)</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BiTree</span>( )&#123;root = <span class="built_in">Creat</span>(root);&#125;</span><br><span class="line">    ~<span class="built_in">BiTree</span>( )&#123;<span class="built_in">Release</span>(root);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">( )</span></span>&#123;<span class="built_in">PreOrder</span>(root);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">( )</span></span>&#123;<span class="built_in">InOrder</span>(root);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">( )</span></span>&#123;<span class="built_in">PostOrder</span>(root);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LeverOrder</span><span class="params">( )</span></span>;                   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BiNode&lt;DataType&gt; *<span class="title">Creat</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;         </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;      </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;         </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;     </span><br><span class="line">    BiNode&lt;DataType&gt; *root;                           </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> BiTree&lt;DataType&gt; :: <span class="built_in">PreOrder</span>(BiNode&lt;DataType&gt; *bt) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span>;                         <span class="comment">//递归调用的结束条件</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; bt-&gt;data;                            <span class="comment">//访问根结点bt的数据域</span></span><br><span class="line">            <span class="built_in">PreOrder</span>(bt-&gt;lchild);                     <span class="comment">//前序递归遍历bt的左子树</span></span><br><span class="line">            <span class="built_in">PreOrder</span>(bt-&gt;rchild);                     <span class="comment">//前序递归遍历bt的右子树  </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> BiTree&lt;DataType&gt; :: <span class="built_in">LeverOrder</span>( )</span><br><span class="line">&#123;</span><br><span class="line">      BiNode&lt;DataType&gt; *Q[<span class="number">100</span>], *q = <span class="literal">nullptr</span>;  </span><br><span class="line">      <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;               </span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>; </span><br><span class="line">      Q[++rear] = root;                        </span><br><span class="line">      <span class="keyword">while</span> (front != rear)</span><br><span class="line">      &#123;</span><br><span class="line">           q = Q[++front];      cout &lt;&lt; q-&gt;data;   </span><br><span class="line">           <span class="keyword">if</span> (q-&gt;lchild != <span class="literal">nullptr</span>)  Q[++rear] = q-&gt;lchild;</span><br><span class="line">           <span class="keyword">if</span> (q-&gt;rchild != <span class="literal">nullptr</span>)  Q[++rear] = q-&gt;rchild;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二叉树的存储结构"><a class="markdownIt-Anchor" href="#二叉树的存储结构"></a> 二叉树的存储结构</h3>
<h5 id="-顺序存储结构"><a class="markdownIt-Anchor" href="#-顺序存储结构"></a> -&gt;顺序存储结构</h5>
<p>顺序存储结构的要求是什么？<br />
用一组连续的存储单元依次存储数据元素，由存储位置表示元素之间的逻辑关系</p>
<p>二叉树的顺序存储结构是用一维数组存储二叉树的结点，结点的<strong>存储位置（下标）<strong>应能体现结点之间的</strong>逻辑关系——父子关系</strong></p>
<p>缺点：浪费存储空间<br />
二叉树的顺序存储结构一般仅存储完全二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    PreOrder(a,<span class="number">2</span>*i,n);</span><br><span class="line">    PreOrder(a,<span class="number">2</span>*i+<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-二叉链表"><a class="markdownIt-Anchor" href="#-二叉链表"></a> -&gt;二叉链表</h5>
<p>二叉链表：二叉树的每个结点对应一个链表结点，链表结点存放结点的数据信息和指示左右孩子的指针</p>
<p>叶子结点的标志？ 左右孩子指针均为空</p>
<p>n 个结点的二叉链表有多少个空指针？ 2n-(n-1) = <strong>n+1</strong> 个空指针</p>
<p>如何由一种遍历序列生成该二叉树？<br />
<strong>扩展二叉树</strong>：将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值如 ‘#’</p>
<h6 id="-扩展二叉树"><a class="markdownIt-Anchor" href="#-扩展二叉树"></a> -&gt;扩展二叉树</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line">BiNode&lt;DataType&gt; *BiTree&lt;DataType&gt; :: Creat(BiNode&lt;DataType&gt; *bt)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">char</span> ch;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; ch;                                                <span class="comment">//输入结点的数据信息，假设为字符</span></span><br><span class="line">     <span class="keyword">if</span> (ch == ‘#’) bt = <span class="literal">nullptr</span>;                       <span class="comment">//建立一棵空树</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          bt = <span class="keyword">new</span> BiNode&lt;DataType&gt;;  bt-&gt;data = ch;        </span><br><span class="line">          bt-&gt;lchild = Creat(bt-&gt;lchild);          <span class="comment">//递归建立左子树</span></span><br><span class="line">          bt-&gt;rchild = Creat(bt-&gt;rchild);          <span class="comment">//递归建立右子树</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">扩展二叉树的前序遍历序列：A B # D # # C # #</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ba791e546c25415b879ea2440024371e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>
<h3 id="森林"><a class="markdownIt-Anchor" href="#森林"></a> 森林</h3>
<p>森林：m（m≥0）棵互不相交的树的集合</p>
<p>森林的遍历：按照某种<strong>次序</strong>(前序（根）、后序（根）)依次遍历构成森林的 m（m≥0）棵树</p>
<h3 id="最优二叉树"><a class="markdownIt-Anchor" href="#最优二叉树"></a> 最优二叉树</h3>
<p>叶子结点的权值：对叶子结点赋予的一个有意义的数值量</p>
<p>二叉树的带权路径长度：从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和</p>
<p>最优二叉树（哈夫曼树）：给定一组具有确定权值的叶子结点，带权路径长度最小的二叉树</p>
<p>最优二叉树有什么特点?<br />
（1）权值越大的叶子结点越靠近根结点<br />
（2）只有度为 0 和度为 2 的结点，<strong>不存在度为 1</strong> 的结点</p>
<h5 id="-哈夫曼算法"><a class="markdownIt-Anchor" href="#-哈夫曼算法"></a> -&gt;哈夫曼算法</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选取权值最小的两棵二叉树进行合并，重新排序，再选权值最小的两棵二叉树进行合并</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/9d2276eaa404489f959882f2550664f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:80%;" />
<h5 id="-哈夫曼编码"><a class="markdownIt-Anchor" href="#-哈夫曼编码"></a> -&gt;哈夫曼编码</h5>
<p>编码：给每一个对象标记一个二进制位串来表示一组对象</p>
<p>等长编码：用长度相等的二进制位串表示一组对象</p>
<p>编码的目的是什么?  数字化（编码效率取决于编码长度）</p>
<p>不等长编码：表示一组对象的二进制位串的长度不相等</p>
<p>设计不等长编码时，必须考虑解码的唯一性</p>
<p>前缀编码：在一组编码中，任一编码都不是其它任何编码的前缀</p>
<p>​			*<strong>前缀（无歧义）编码保证了在解码时不会有多种可能</strong></p>
<h3 id="线索二叉树"><a class="markdownIt-Anchor" href="#线索二叉树"></a> 线索二叉树</h3>
<p><img src="https://img-blog.csdnimg.cn/b0439d1cc7e74e7d9f2e1125889bd850.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>
<p>线索：指向前驱和和后继结点的指针</p>
<p>线索二叉树：加入线索的二叉树</p>
<p>缺点：指针和线索无法区分-&gt;加标记 0孩子,1前驱后继</p>
<p>以一定规则将二叉树中的结点排列成一个线性序列，使每个结点(除第一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继</p>
<p>优点：如果右链中中序后继，左链中中序前趋，则中序<strong>遍历的效率高</strong></p>
<h2 id="第六章-图"><a class="markdownIt-Anchor" href="#第六章-图"></a> 第六章 图</h2>
<p>单链表的逆置，寻找叶子结点，树的遍历，折半查找，哈夫曼树</p>
<h4 id="逻辑关系-2"><a class="markdownIt-Anchor" href="#逻辑关系-2"></a> 逻辑关系</h4>
<p>线性结构中，数据元素之间具有线性关系，逻辑关系表现为前驱-后继；</p>
<p>树结构中，结点之间具有层次关系，逻辑关系表现为双亲-孩子</p>
<p>图结构中，任意两个顶点之间都可能有关系，逻辑关系表现为邻接</p>
<h4 id="连通图无向图"><a class="markdownIt-Anchor" href="#连通图无向图"></a> 连通图（无向图）</h4>
<p>连通顶点：在无向图中，如果顶点vi和顶点vj(i≠j)之间有路径，则称顶点vi和vj是连通的</p>
<p>连通图：在无向图中，如果任意两个顶点都是连通的，则称该无向图是连通图</p>
<p>连通分量：非连通图的极大连通子图：含有极大顶点数，依附于这些顶点的所有边</p>
<h4 id="强连通图-强连通分量有向图"><a class="markdownIt-Anchor" href="#强连通图-强连通分量有向图"></a> 强连通图、强连通分量（有向图）</h4>
<p>强连通顶点：在有向图中，如果从顶点vi到顶点vj和从顶点vj到顶点vi均有路径，则称顶点vi和vj是强连通的</p>
<p>强连通图：在有向图中，如果任意两个顶点都是强连通的，则称该有向图是强连通图</p>
<p>强连通分量：非强连通图的极大连通子图</p>
<h4 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h4>
<p>图的遍历：从图中某一顶点出发访问图中所有顶，并且每个结点仅被访问一次</p>
<p>在图中，如何选取遍历的起始顶点？<br />
解决方案：将图中的顶点按任意顺序排列起来， 从编号最小的顶点开始</p>
<p>从某顶点出发能访问其他所有顶点吗？<br />
解决方案：多次调用图遍历算法</p>
<p>如何避免遍历不会因回路而陷入死循环？<br />
解决方案：附设访问标志数组visited[n]</p>
<p>采用什么次序依次访问图中所有顶点？</p>
<h5 id="-深度优先遍历和广度优先遍历"><a class="markdownIt-Anchor" href="#-深度优先遍历和广度优先遍历"></a> -&gt; 深度优先遍历和广度优先遍历</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">深度优先遍历DFTraverse（类似树的前序遍历）</span><br><span class="line">广度优先遍历BFTraverse（类似树的层序遍历）</span><br><span class="line">    </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> MGraph&lt;DataType&gt; :: DFTraverse(<span class="keyword">int</span> v)  </span><br><span class="line">&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; vertex[v]; visited[v] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">           <span class="keyword">if</span> (edge[v][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) </span><br><span class="line">                DFTraverse( j );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> MGraph&lt;DataType&gt; :: BFTraverse(<span class="keyword">int</span> v) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">int</span> w, j, Q[MaxSize];  <span class="comment">//采用顺序队列</span></span><br><span class="line">      <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;  <span class="comment">//初始化队列</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; vertex[v]; visited[v] = <span class="number">1</span>; Q[++rear] = v;  <span class="comment">//被访问顶点入队</span></span><br><span class="line">      <span class="keyword">while</span> (front != rear)  <span class="comment">//当队列非空时</span></span><br><span class="line">      &#123;</span><br><span class="line">            w = Q[++front];  <span class="comment">//将队头元素出队并送到v中</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vertexNum; j++)</span><br><span class="line">                 <span class="keyword">if</span> (edge[w][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> ) &#123;</span><br><span class="line">                       <span class="built_in">cout</span> &lt;&lt; vertex[j]; visited[j] = <span class="number">1</span>; Q[++rear] = j;</span><br><span class="line">                 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> ALGraph&lt;DataType&gt; :: DFTraverse(<span class="keyword">int</span> v)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> j;  EdgeNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; adjlist[v].vertex; visited[v] = <span class="number">1</span>;</span><br><span class="line">     p = adjlist[v].firstEdge;     </span><br><span class="line">     <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          j = p-&gt;adjvex;</span><br><span class="line">          <span class="keyword">if</span> (visited[j] == <span class="number">0</span>) DFTraverse(j);</span><br><span class="line">          p = p-&gt;next;           </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt;</span><br><span class="line"><span class="keyword">void</span> ALGraph&lt;DataType&gt; :: BFTraverse(<span class="keyword">int</span> v) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">int</span> w, j, Q[MaxSize]; <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;        </span><br><span class="line">     EdgeNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; adjlist[v].vertex; visited[v] = <span class="number">1</span>; Q[++rear] = v;  </span><br><span class="line">     <span class="keyword">while</span> (front != rear)             </span><br><span class="line">     &#123;</span><br><span class="line">          w = Q[++front];</span><br><span class="line">          p = adjlist[w].firstEdge;    </span><br><span class="line">          <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) </span><br><span class="line">          &#123;</span><br><span class="line">               j = p-&gt;adjvex;</span><br><span class="line">               <span class="keyword">if</span> (visited[j] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; adjlist[j].vertex; visited[j] = <span class="number">1</span>; Q[++rear] = j;</span><br><span class="line">          &#125;</span><br><span class="line">          p = p-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="存储结构"><a class="markdownIt-Anchor" href="#存储结构"></a> 存储结构</h4>
<h5 id="-邻接矩阵和邻接表"><a class="markdownIt-Anchor" href="#-邻接矩阵和邻接表"></a> -&gt; 邻接矩阵和邻接表</h5>
<img src="https://img-blog.csdnimg.cn/1ea4b934f19a436f8efde4bca5dec2c4.png" alt="img" style="zoom: 50%;" />
<img src="https://img-blog.csdnimg.cn/f8f08a83bb26413aba03147979db20f0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />
<p><img src="https://img-blog.csdnimg.cn/0d8a52f79699405db8763c127c1c7736.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;                       </span><br><span class="line">    EdgeNode *next;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DataType&gt; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode *firstEdge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>边表中的结点表示什么？对应图中的一条边</p>
<p><strong>设图有n个顶点e条边，邻接表的空间复杂度是多少？O(n+e)</strong></p>
<p>如何求顶点 v 的度？顶点 v 的边表中结点的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = adjlist[v].firstEdge; count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    count++; p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何求顶点 v 的所有邻接点?顶点 i 的边表中的所有结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = adjlist[v].firstEdge; </span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    j = p-&gt;adjvex;                      <span class="comment">//j是v的邻接点</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树无向图"><a class="markdownIt-Anchor" href="#最小生成树无向图"></a> 最小生成树（无向图）</h3>
<h5 id="-prim算法on2"><a class="markdownIt-Anchor" href="#-prim算法on2"></a> -&gt; Prim算法O(n2)</h5>
<p>生成树：连通图的生成树是包含全部顶点的一个极小连通子图（含有n-1条边）</p>
<p>生成树的代价：在无向连通网中，生成树上各边的权值之和</p>
<p>最小生成树(Minimum Spanning Tree) ：在无向连通网中，代价最小的生成树</p>
<p>贪心算法的应用：Prim算法，Kruskal算法和Boruvka算法<br />
Prim算法：先构造满足条件的候选最短边集，再查找最短边<br />
Kruskal算法：先查找最短边，再判断是否满足条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Prim算法 O(n2)</span><br><span class="line">*每步添加一条边及其相连的顶点(min)到一棵树，从而逐步生成最小生成树(可能不唯一，但代价唯一)</span><br><span class="line">通过第一个顶点，将第一个顶点和其他顶点的权值进行比较，找到最小边邻接的顶点</span><br><span class="line">该邻接顶点和剩余顶点比较，比第一个顶点和其权值小就替换进数组，找到更新后的最小边的邻接顶点……</span><br><span class="line">（创建一个数组存放当前顶点和邻接顶点的边，当邻接顶点和当前顶点的边权值更小就更新。每次找出更新的最小边，并将选择出的顶点从数组中标除去）</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h5 id="-kruskal算法oelog2e"><a class="markdownIt-Anchor" href="#-kruskal算法oelog2e"></a> -&gt; Kruskal算法O(elog2e)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">？Kruskal算法 O(elog2e)</span><br><span class="line">*将所有的点放入，每次选最小的边，但不能形成回路</span><br><span class="line">图采用什么存储结构呢？ 边集数组表示法</span><br><span class="line">Kruskal算法在图中存在相同权值的边时也有效</span><br><span class="line">如何存储连通分量呢？	并查集</span><br><span class="line">（并查集：集合中的元素组织成树的形式：</span><br><span class="line">（<span class="number">1</span>）查找两个元素是否属于同一集合：所在树的根结点是否相同</span><br><span class="line">（<span class="number">2</span>）合并两个集合——将一个集合的根结点作为另一个集合根结点的孩子）</span><br><span class="line">*如何判断两个顶点是否位于同一个连通分量呢？</span><br><span class="line">*如何合并两个连通分量呢？</span><br></pre></td></tr></table></figure>
<h3 id="最短路径有向图"><a class="markdownIt-Anchor" href="#最短路径有向图"></a> 最短路径（有向图）</h3>
<h5 id="-dijkstra算法on2"><a class="markdownIt-Anchor" href="#-dijkstra算法on2"></a> -&gt; Dijkstra算法O(n2)</h5>
<p>最短路径：非带权图——边数最少的路径</p>
<p>最短路径：带权图——边上的权值之和最少的路径</p>
<p>路径上第一个顶点称为源点；最后一个顶点称为终点</p>
<p>对于非带权图，如何求最短路径？ 广度优先遍历</p>
<p>对于带权图，如何求最短路径？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法	O(n2)</span><br><span class="line">针对一个源点，求出中转（mini)；将中转和剩下点连接，比剩下点与上一个点的路径短就替换，再在整合好的表中找到最短的</span><br><span class="line">当前最短路径中最小路为最终最短路（路径长度递增）</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>(dist,path)</th>
<th>v1</th>
<th>v2</th>
<th>v3</th>
<th>v4</th>
</tr>
</thead>
<tbody>
<tr>
<td>{v0}</td>
<td><strong>(10,‘v0v1’)</strong></td>
<td>(**,’ ')</td>
<td>(30,‘v0v3’)</td>
<td>(100,‘v0v4’)</td>
</tr>
<tr>
<td>{v0v1}</td>
<td></td>
<td>(60，‘v0v1v2’)</td>
<td><strong>(30,‘v0v3’)</strong></td>
<td>(100,‘v0v4’)</td>
</tr>
<tr>
<td>{v0v1v3}</td>
<td></td>
<td><strong>(50,‘v0v3v2’)</strong></td>
<td></td>
<td>(60,‘v0v3v4’)</td>
</tr>
<tr>
<td>{v0v1v3v2}</td>
<td></td>
<td></td>
<td></td>
<td><strong>(60,‘v0v3v2v4’)</strong></td>
</tr>
<tr>
<td>{v0v1v3v2v4}</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>疑惑性很大，如何当点&gt;2时，进行判断不同可能性（类似Prim但必须包含源点得出的路径？）</p>
<h5 id="-floyd算法on3"><a class="markdownIt-Anchor" href="#-floyd算法on3"></a> -&gt; Floyd算法O(n3)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Floyd算法 O(n3)</span><br><span class="line">*可有权值为负，但不能有负的回路(*)</span><br><span class="line">-&gt; 使用邻接矩阵</span><br><span class="line">初始化path0（两点相连的所有可能性<span class="number">9</span>种，以a/b/c为源点），在两点间插入a(保持源点不变，以a为源点的一行可忽视,<span class="number">6</span>种；如果值比原来小就替换)形成path1,在path1中插入b……同理……</span><br><span class="line">dist保存路径权值，path保存路径中的点</span><br><span class="line">-&gt;该算法将所有的可能性都计算出来，只有最后一步有效</span><br></pre></td></tr></table></figure>
<h3 id="有向无环图"><a class="markdownIt-Anchor" href="#有向无环图"></a> 有向无环图</h3>
<h5 id="-aov网和拓扑排序-one"><a class="markdownIt-Anchor" href="#-aov网和拓扑排序-one"></a> -&gt; AOV网和拓扑排序  O(n+e)</h5>
<p>什么是工程？工程有什么共性？<br />
几乎所有的工程都可以分为若干个称作<strong>活动</strong>的子工程<br />
某些活动之间通常存在一定的<strong>约束</strong>条件</p>
<p>AOV网（顶点表示活动的网）：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系</p>
<p>AOV网（activity on <strong>vertex</strong> network）</p>
<p>AOV网中出现回路意味着什么？活动之间的优先关系是矛盾的</p>
<p>拓扑序列:v2必须满足v0和v1才能成立（栗子：排课系统），<strong>可能不唯一</strong></p>
<p>拓扑排序：对一个有向图构造拓扑序列的过程</p>
<img src="https://img-blog.csdnimg.cn/2635027a5de44d329260cef95eb8c191.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:67%;" />
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">图采用什么存储结构呢？ 邻接表</span><br><span class="line">在邻接表中，如何求顶点的入度？	顶点表中增加入度域</span><br><span class="line">如何查找没有前驱的顶点？ 设置栈或队列</span><br><span class="line">成功标志：排完后，所有点都排序（<span class="literal">NULL</span>），不剩余点</span><br><span class="line">   <span class="number">1.</span>重复下述操作，直到输出全部顶点，或AOV网中不存在没有前驱的顶点</span><br><span class="line">    <span class="number">1.1</span>从AOV网中选择一个没有前驱的顶点并且输出；</span><br><span class="line">    <span class="number">1.2</span>从AOV网中删去该顶点，并且删去所有以该顶点为尾的弧； </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/205a54420f5b4f11bdddd6727c104a6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>
<h5 id="-aoe网和关键路径"><a class="markdownIt-Anchor" href="#-aoe网和关键路径"></a> -&gt;AOE网和关键路径</h5>
<p>什么是工程？工程有什么共性？<br />
几乎所有的工程都可以分为若干个称作活动的子工程<br />
活动之间存在某些制约关系<br />
每个活动通常需要一个持续的时间</p>
<p>源点：整个工程的开始点，其入度为0<br />
终点：整个工程的结束点，其出度为0</p>
<p>AOE网（边表示活动的网）：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间</p>
<p>AOE网（activity on <strong>edge</strong> network）</p>
<p>AOE网的性质：<br />
（1）只有在<strong>进入某顶点的各活动</strong>都已经结束，该顶点所代表的事件才能发生<br />
（2）只有在某顶点所代表的事件发生后，从<strong>该顶点出发的各活动</strong>才能开始</p>
<p>AOE网能够解决什么问题？<br />
（1） 完成整个工程至少需要多少时间?<br />
（2）为缩短完成工程所需的时间， 应当加快哪些活动?</p>
<p>关键路径：AOE网中从源点到终点的<strong>最长</strong>路径<br />
关键活动：关键路径上的活动</p>
<p>不按期完成关键活动就会影响整个工程的进度；换言之，要缩短整个工期，必须加快关键活动的进度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如何求关键路径呢？ 求关键活动</span><br><span class="line">如何求关键活动呢？关键活动为什么是关键的？</span><br><span class="line">关键活动的开始时间不能推迟-&gt;关键活动的最早开始时间和最晚开始时间相等</span><br><span class="line">    </span><br><span class="line"> <span class="number">1.</span> 计算各个活动的最早开始时间和最晚开始时间</span><br><span class="line"> <span class="number">2.</span> 计算各个活动的时间余量，时间余量为 <span class="number">0</span> 即为关键活动</span><br><span class="line"></span><br><span class="line">设带权有向图 G=(V，E)含有 n 个顶点 e 条边，设置 <span class="number">4</span> 个一维数组：</span><br><span class="line">（<span class="number">1</span>）事件的最早发生时间 ve[n] -&gt; 从v0=<span class="number">0</span>开始到该顶点的相加ai和取最大（正序计算）</span><br><span class="line">（<span class="number">2</span>）事件的最迟发生时间 vl[n] -&gt; 从v3=<span class="number">10</span>开始到该点减去ai被减差取最小（倒序计算）</span><br><span class="line">（<span class="number">3</span>）活动的最早开始时间 ae[e] -&gt; 等于ve[以ai为出度的事件] </span><br><span class="line">（<span class="number">4</span>）活动的最晚开始时间 al[e] -&gt; vl[以ai为入度的事件]-ai</span><br><span class="line">-&gt; al[i]-ae[i]=<span class="number">0</span></span><br><span class="line">    取为<span class="number">0</span>的相连作为关键路径</span><br><span class="line">书P205 表格</span><br><span class="line">    </span><br><span class="line">一个关键活动的延期，会影响延误工期；一个关键活动的提前，不一定提前工期</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/b359fd0e6209454ebe5a3c0fbeab1403.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 67%;" />
<h2 id="第七章-查找技术"><a class="markdownIt-Anchor" href="#第七章-查找技术"></a> 第七章 查找技术</h2>
<h4 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h4>
<p>关键码：可以标识一个**记录(数据元素、结点、顶点)**的某个数据项</p>
<p>键值：关键码的值</p>
<p>主关键码：可以唯一标识一个记录的关键码</p>
<p>次关键码：不能唯一标识一个记录的关键码</p>
<p><img src="https://img-blog.csdnimg.cn/5ac6d89d88c04a1ab93a79acf893b5b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>
<p>什么是查找？<br />
查找：在相同类型的记录构成的集合中找出满足给定条件的记录</p>
<p>静态查找 ：不涉及<strong>插入和删除操作</strong>的查找<br />
静态查找只注重<strong>查找效率</strong>，适用于：<br />
（1）查找集合一经生成，便只对其进行查找，而不进行插入和删除操作<br />
（2）经过一段时间的查找之后，集中地进行插入和删除等修改操作</p>
<p>动态查找 ：涉及插入和删除操作的查找<br />
动态查找要求<strong>插入、删除、查找</strong>均有较好的效率，适用于：查找与插入和删除操作在同一个阶段进行<br />
例如：当查找成功时，要删除查找到的记录<br />
当查找不成功时，要插入被查找的记录</p>
<p>查找结构 ：面向查找操作的数据结构 ，即查找基于的数据结构</p>
<p>查找基于的数据模型是什么？集合<br />
集合 ：线性表：适用于静态查找，顺序查找、折半查找等技术<br />
树  表：适用于动态查找，二叉排序树的查找技术<br />
散列表：静态查找和动态查找均适用，采用散列技术</p>
<h4 id="查找算法的性能"><a class="markdownIt-Anchor" href="#查找算法的性能"></a> 查找算法的性能</h4>
<p>如何评价查找算法的效率呢？和关键码的比较次数</p>
<p>关键码的比较次数与哪些因素有关呢？</p>
<p>平均查找长度ASL：查找算法进行的关键码比较次数的<strong>数学期望值</strong></p>
<h4 id="查找算法"><a class="markdownIt-Anchor" href="#查找算法"></a> 查找算法</h4>
<h5 id="线性表"><a class="markdownIt-Anchor" href="#线性表"></a> 线性表</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序查找（线性查找）O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">改进：设置“哨兵”，就是待查值，放在查找方向的尽头处，免去了每</span></span><br><span class="line"><span class="comment">一次比较后都要判断查找位置是否越界</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">不要求元素的有序性，插入、删除的性能是O(1)</span></span><br><span class="line"><span class="comment">查找性能是O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> LineSearch :: <span class="built_in">SeqSearch2</span>(<span class="keyword">int</span> k) </span><br><span class="line">&#123;   </span><br><span class="line">     <span class="keyword">int</span> i = n; </span><br><span class="line">     data[<span class="number">0</span>] = k; </span><br><span class="line">     <span class="keyword">while</span> (data[i] != k)</span><br><span class="line">        i--;</span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*折半查找（对半查找、二分查找）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在有序表（假设为递增）中，取中间记录作为比较对象，若给定值与中</span></span><br><span class="line"><span class="comment">间记录相等，则查找成功；若给定值小于中间记录，则在有序表的左半</span></span><br><span class="line"><span class="comment">区继续查找；若给定值大于中间记录，则在有序表的右半区继续查找。</span></span><br><span class="line"><span class="comment">不断重复上述过程，直到查找成功，或查找区域无记录，查找失败</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查找性能是O(log2n)</span></span><br><span class="line"><span class="comment">为保证元素的有序性，插入、删除要移动元素，性能是O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归算法：</span></span><br><span class="line"><span class="keyword">int</span> LineSearch :: <span class="built_in">BinSearch1</span>(<span class="keyword">int</span> k)                   <span class="comment">/*查找集合存储在r[1]~r[n]*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> mid, low = <span class="number">1</span>, high = n;                           <span class="comment">/*初始查找区间是[1, n]*/</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)                                     <span class="comment">/*当区间存在时*/</span></span><br><span class="line">    &#123; </span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;            </span><br><span class="line">        <span class="keyword">if</span> (k &lt; data[mid])  high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span> (k &gt; data[mid])  low = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;                                        <span class="comment">/*查找成功，返回元素序号*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                       <span class="comment">/*查找失败，返回0*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归算法：</span></span><br><span class="line"><span class="keyword">int</span> LineSearch :: <span class="built_in">BinSearch2</span>(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k) </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">0</span>;                                  <span class="comment">/*递归的边界条件*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; data[mid]) <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(low, mid<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; data[mid]) <span class="keyword">return</span> <span class="built_in">BinSearch2</span>(mid+<span class="number">1</span>, high, k); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;                                         <span class="comment">/*查找成功，返回序号*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判定树（折半查找判定树）：描述折半查找判定过程的二叉树</p>
<p>查找成功的平均比较次数 = (1×1+2×2+3×4+4×4)/11 = 3<br />
<img src="C:%5CUsers%5Czhangguozhi%5CDesktop%5C1.png" alt="1" /><br />
查找不成功的平均比较次数 = (3×4+4×8)/12 = 11/3</p>
<p><img src="C:%5CUsers%5Czhangguozhi%5CDesktop%5C2.png" alt="2" /></p>
<h5 id="树表"><a class="markdownIt-Anchor" href="#树表"></a> 树表</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉排序树（二叉查找树）：或者是一棵空的二叉树，或者是具有下列性质的二叉树：</span></span><br><span class="line"><span class="comment">（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值</span></span><br><span class="line"><span class="comment">（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值</span></span><br><span class="line"><span class="comment">（3）它的左右子树也都是二叉排序树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">中序序列是元素升序排序</span></span><br><span class="line"><span class="comment">存储：二叉链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BiSortTree</span>                              </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">BiSortTree</span>(<span class="keyword">int</span> a[ ], <span class="keyword">int</span> n);       </span><br><span class="line">     ~ <span class="built_in">BiSortTree</span>( ) &#123;<span class="built_in">Release</span>(root);&#125; </span><br><span class="line">     <span class="function">BiNode&lt;<span class="keyword">int</span>&gt; *<span class="title">InsertBST</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">InsertBST</span>(root, x);&#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">DeleteBST</span><span class="params">(BiNode&lt;<span class="keyword">int</span>&gt; *p, BiNode&lt;<span class="keyword">int</span>&gt; *f )</span></span>;      </span><br><span class="line">     <span class="function">BiNode&lt;<span class="keyword">int</span>&gt; *<span class="title">SearchBST</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">SearchBST</span>(root, k);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="function">BiNode&lt;<span class="keyword">int</span>&gt; *<span class="title">InsertBST</span><span class="params">(BiNode&lt;<span class="keyword">int</span>&gt; *bt , <span class="keyword">int</span> x)</span></span>;     </span><br><span class="line">     <span class="function">BiNode&lt;<span class="keyword">int</span>&gt; *<span class="title">SearchBST</span><span class="params">(BiNode&lt;<span class="keyword">int</span>&gt; *bt, <span class="keyword">int</span> k)</span></span>;    </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;DataType&gt; *bt)</span></span>;     </span><br><span class="line">     BiNode&lt;<span class="keyword">int</span>&gt; *root;                              </span><br><span class="line">&#125;;</span><br><span class="line">BiSortTree::<span class="built_in">BiSortTree</span>(<span class="keyword">int</span> a[ ], <span class="keyword">int</span> n)<span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">     root = <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">          root = <span class="built_in">InsertBST</span>(root, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BiNode&lt;<span class="keyword">int</span>&gt; * BiSortTree :: <span class="built_in">SearchBST</span>(BiNode&lt;<span class="keyword">int</span>&gt; *bt, <span class="keyword">int</span> k)<span class="comment">//查找函数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (bt-&gt;data == k) <span class="keyword">return</span> bt;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data &gt; k) <span class="keyword">return</span> <span class="built_in">SearchBST</span>(bt-&gt;lchild, k);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">SearchBST</span>(bt-&gt;rchild, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiNode&lt;<span class="keyword">int</span>&gt; * <span class="title">BiSortTree::InsertBST</span><span class="params">(BiNode&lt;<span class="keyword">int</span>&gt; *bt, <span class="keyword">int</span> x)</span><span class="comment">//插入函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) &#123;                </span><br><span class="line">          BiNode&lt;<span class="keyword">int</span>&gt; *s = <span class="keyword">new</span> BiNode&lt;<span class="keyword">int</span>&gt;; s-&gt;data = x;</span><br><span class="line">          s-&gt;lchild = s-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">          bt = s;</span><br><span class="line">          <span class="keyword">return</span> bt;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data &gt; x) bt-&gt;lchild = <span class="built_in">InsertBST</span>(bt-&gt;lchild, x);</span><br><span class="line">     <span class="keyword">else</span> bt-&gt;rchild = <span class="built_in">InsertBST</span>(bt-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">二叉排序树的性能分析</span><br><span class="line">最坏情况：退化为线性查找</span><br><span class="line">最好情况：相当于折半查找</span><br><span class="line">平均情况：<span class="built_in">O</span>(n) ~ <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">平衡二叉树（二叉排序树优化-&gt;深度尽可能小的二叉排序树）</span></span><br><span class="line"><span class="comment">二叉排序树的深度取决于给定查找集合的排列，即结点的插入顺序</span></span><br><span class="line"><span class="comment">平衡因子：该结点的左子树的深度减去右子树的深度</span></span><br><span class="line"><span class="comment">平衡二叉树：或者是一棵空的二叉排序树，或者是具有下列性质的二叉排序树：</span></span><br><span class="line"><span class="comment">（1）根结点的左子树和右子树的深度最多相差 1;</span></span><br><span class="line"><span class="comment">（2）根结点的左子树和右子树也都是平衡二叉树</span></span><br><span class="line"><span class="comment">在平衡二叉树中，结点的平衡因子是1、0 或 -1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">平衡调整</span></span><br><span class="line"><span class="comment">扁担原理：将根结点看成是扁担中肩膀的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">B树：一棵m阶的B树或者为空树，或者为满足下列特性的m叉树：</span></span><br><span class="line"><span class="comment">（1）每个结点至多有 m 棵子树；</span></span><br><span class="line"><span class="comment">（2）根结点至少有两棵子树；</span></span><br><span class="line"><span class="comment">（3）除根结点和叶子结点外，所有结点至少有[m/2]棵子树；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">散列的基本思想：在记录的关键码和存储地址之间建立一个确定的对应关系，通过计算得到待查记录的地址。</span></span><br><span class="line"><span class="comment">散列表：采用散列技术存储查找集合的连续存储空间。</span></span><br><span class="line"><span class="comment">散列函数：将关键码映射为散列表中适当存储位置的函数。</span></span><br><span class="line"><span class="comment">散列地址：由散列函数所得的存储地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj)。</span></span><br><span class="line"><span class="comment">同义词：ki 和 kj 相对于H 称做同义词。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">散列是一种完整的存储结构吗？</span></span><br><span class="line"><span class="comment">散列只是通过记录的关键码定位该记录，没有完整地表达记录之间的逻辑关系，所以，散列主要是面向查找的存储结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">散列技术能进行范围查找吗？适合于哪种类型的查找？</span></span><br><span class="line"><span class="comment">散列技术最适合回答的问题是：如果有的话，哪个记录的关键码等于待查值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">除留余数法	H(key)=key  mod  p </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">处理冲突的方法——开放定址法（数组）</span></span><br><span class="line"><span class="comment">对于给定的关键码key执行下述操作：</span></span><br><span class="line"><span class="comment">（1）计算散列地址：j = H(key)</span></span><br><span class="line"><span class="comment">（2）如果地址 j 的存储单元没有存储记录，则存储key对应的记录；</span></span><br><span class="line"><span class="comment">（3）如果在地址 j 发生冲突，则寻找一个空的散列地址，存储key对应的记录；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">闭散列表：用开放定址法处理冲突得到的散列表</span></span><br><span class="line"><span class="comment">线性探测法：从冲突位置的下一个位置起，依次寻找空的散列地址。</span></span><br><span class="line"><span class="comment">堆积：非同义词对同一个散列地址争夺的现象</span></span><br><span class="line"><span class="comment">二次探测法：以冲突位置为中心，跳跃式寻找空的散列地址。</span></span><br><span class="line"><span class="comment">Hi=(H(key)＋di) % m   （di = 12,-12,22,-22,… , q2,-q2(q≤m/2)）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">处理冲突的方法——拉链法（链表）</span></span><br><span class="line"><span class="comment">对于给定的关键码key执行下述操作：</span></span><br><span class="line"><span class="comment">（1）计算散列地址：j = H(key)</span></span><br><span class="line"><span class="comment">（2）将key对应的记录插入到同义词子表 j 中；（头插）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">同义词子表：所有散列地址相同的记录构成的单链表。</span></span><br><span class="line"><span class="comment">开散列表：用拉链法处理冲突得到的散列表。</span></span><br><span class="line"><span class="comment">开散列表中存储同义词子表的头指针，开散列表不会出现堆积现象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">散列查找的性能分析</span></span><br><span class="line"><span class="comment">散列技术的查找性能取决于什么？</span></span><br><span class="line"><span class="comment">产生冲突后，仍然是给定值与关键码进行比较</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">影响冲突产生的因素有什么？</span></span><br><span class="line"><span class="comment">（1）散列函数是否均匀</span></span><br><span class="line"><span class="comment">（2）处理冲突的方法 </span></span><br><span class="line"><span class="comment">（3）散列表的装填因子α= 表中填入的记录数/散列表的长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>堆积：非同义词对同一个散列地址争夺的现象<br />
冲突：对于两个不同关键码ki≠kj，有H(ki)＝H(kj)</p>
<p><img src="https://img-blog.csdnimg.cn/026a98c177324bad895f0554f8012a4e.png" alt="img" /></p>
<p><img src="https://img-blog.csdnimg.cn/5112cd64503b475c94e0a442389f736e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWmhhbmdfMjAwMl9HWg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>
<h2 id="第8章-排序技术"><a class="markdownIt-Anchor" href="#第8章-排序技术"></a> 第8章 排序技术</h2>
<h4 id="基本概念-2"><a class="markdownIt-Anchor" href="#基本概念-2"></a> 基本概念</h4>
<p>1.排序：给定一组<strong>记录（数据元素，结点，顶点）<strong>的集合{r1,r2,…,rn}，其相应的</strong>关键码</strong>分别为{k1,k2,…,kn},将这些记录排列为{s1,s2,…,sn}的序列，使得相应关键码满足<strong>升序或降序</strong>。<br />
（排序是对<strong>线性结构</strong>(数据模型)的一种操作）</p>
<p>2.排序码(关键码)：排序的依据</p>
<p>3.趟：在排序过程中，将待排序的记录序列扫描一遍称为一趟</p>
<p>4.排序算法的稳定性：相同关键码的相对次序经过排序保持不变<br />
（只是算法的一种属性，且有具体算法决定）</p>
<h4 id="排序算法的性能"><a class="markdownIt-Anchor" href="#排序算法的性能"></a> 排序算法的性能</h4>
<p>（1）时间性能：排序算法在各种情况（最好、最坏、平均）下的时间复杂度。<br />
例如，基于比较的内排序在排序过程中的基本操作：<br />
① 比较：关键码之间的比较；<br />
② 移动：记录从一个位置移动到另一个位置。</p>
<p>（2）空间性能：排序过程中占用的辅助存储空间。<br />
辅助存储空间是除了存放待排序记录占用的存储空间之外，执行算法所需要的其他存储空间。</p>
<table>
<thead>
<tr>
<th></th>
<th>直接插入排序</th>
<th>希尔排序</th>
<th>起泡排序</th>
<th>快速排序</th>
<th>简单选择排序</th>
<th>堆排序</th>
<th>归并排序</th>
</tr>
</thead>
<tbody>
<tr>
<td>最好情况</td>
<td>正序 O(n)</td>
<td>O(n**1.3)</td>
<td>正序 O(n)</td>
<td>都是中值O(nlog2n)</td>
<td>O(n2)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>最坏情况</td>
<td>逆序 O(n**2)</td>
<td></td>
<td>逆序 O(n**2)</td>
<td>正序逆序O(n**2)</td>
<td>O(n2)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>平均情况</td>
<td>O(n**2)</td>
<td></td>
<td>O(n**2)</td>
<td>O(nlog2n)</td>
<td>O(n2)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>稳定性</td>
<td>稳定</td>
<td>不稳定</td>
<td>稳定</td>
<td>不稳定</td>
<td>不稳定</td>
<td>不稳定</td>
<td>稳定</td>
</tr>
<tr>
<td>时间性能</td>
<td>O(n**2)</td>
<td>取决于增量序列O(n**2) ~ O(nlogn)</td>
<td>O(n**2)</td>
<td>O(nlog2n)</td>
<td>O(n**2)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
</tr>
<tr>
<td>空间性能</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(log2n)~O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>稳定性：直接插入排序，起泡排序，归并排序<br />
不稳定：希尔排序，快速排序，简单选择排序，堆排序</p>
<p>直接插入排序、简单选择排序和起泡排序 O(n2)<br />
堆排序、快速排序和归并排序 O(nlogn)<br />
希尔排序的时间性能取决于增量序列，介于O(n2)和O(nlog2n)之间</p>
<p>缓冲区应该是一个（队列 ）结构。<br />
最快的速度挑选出前10个最大的，采用（  堆排序）方法最好。<br />
（插入排序）可能会出现下面情况：在最后一趟开始之前，所有元素都不在最终位置上</p>
<h4 id="基于比较的内排序"><a class="markdownIt-Anchor" href="#基于比较的内排序"></a> 基于比较的内排序</h4>
<h5 id="-比较排序"><a class="markdownIt-Anchor" href="#-比较排序"></a> -&gt; 比较排序</h5>
<h6 id="-直接插入排序"><a class="markdownIt-Anchor" href="#-直接插入排序"></a> -&gt; 直接插入排序</h6>
<p><strong>直接插入排序</strong>：（正序）循环第k个元素开始，向前进行比较，大于就交换，小于就结束，进行下一趟<br />
-&gt;排序过程：前面k-1个有序，后面无序</p>
<h6 id="-希尔排序"><a class="markdownIt-Anchor" href="#-希尔排序"></a> -&gt; 希尔排序</h6>
<p><strong>希尔排序</strong>：步数为n，序列中索引值为(i += n)的作为一个子序列进行排序，再全部进行直接插入排序</p>
<h5 id="-交换排序"><a class="markdownIt-Anchor" href="#-交换排序"></a> -&gt; 交换排序</h5>
<h6 id="-起泡排序"><a class="markdownIt-Anchor" href="#-起泡排序"></a> -&gt; 起泡排序</h6>
<p><strong>起泡排序</strong>：两两比较，如果反序则交换<br />
-&gt;排序过程：后面k+1个有序，前面无序</p>
<h6 id="-快速排序"><a class="markdownIt-Anchor" href="#-快速排序"></a> -&gt; 快速排序</h6>
<p><strong>快速排序</strong>：将第一个作为中间值mid，从后向前找比mid小的，找到就交换位置，i++；从前向后开始找比mid大的，找到就交换位置,j–；重复，直到i&gt;=j,一趟结束。i==j的位置作为下一趟的mid值。</p>
<h5 id="-选择排序"><a class="markdownIt-Anchor" href="#-选择排序"></a> -&gt; 选择排序</h5>
<h6 id="-简单选择排序"><a class="markdownIt-Anchor" href="#-简单选择排序"></a> -&gt; 简单选择排序</h6>
<p><strong>简单选择排序</strong>：将前n-1个值和和该值后面的进行比较，找到最小的和该值交换<br />
-&gt;排序过程：前面k-1个有序，后面无序</p>
<h6 id="-堆排序"><a class="markdownIt-Anchor" href="#-堆排序"></a> -&gt; 堆排序</h6>
<p><strong>堆排序</strong>：（大根堆）原顺序作为层序形成完全二叉树，从大到小的根节点和孩子比较，小就交换，然后向下继续比较小就交换直到底。形成大根堆，将第一个0和最后一个n-1交换，剩下n-1个进行堆调整。</p>
<h5 id="-归并排序"><a class="markdownIt-Anchor" href="#-归并排序"></a> -&gt; 归并排序</h5>
<p><strong>归并排序</strong>：将序列划分为2**n个子序列进行单独排序，两两合并为2*n-1个子序列进行单独排序,一直到合并为一个排序</p>
<h5 id="-基数排序"><a class="markdownIt-Anchor" href="#-基数排序"></a> -&gt; 基数排序</h5>
<p><strong>基数排序</strong>：栗子三位数排序(有明显界限的个位，十位，百位)<br />
创建10个链表0<sub>9,先后按个位按0</sub>9连进属于的表头（尾插），结束将其串成整表，再按照十位做相同的行为</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zhang0224gz.github.io/2021/12/09/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构笔记" target="_blank" rel="external">https://zhang0224gz.github.io/2021/12/09/笔记/数据结构/数据结构/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://blog.csdn.net/Zhang_2002_GZ?type=blog" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/flutter.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://blog.csdn.net/Zhang_2002_GZ?type=blog" target="_blank"><span class="text-dark">Eureka</span><small class="ml-1x">Study Notes &amp; Supplement</small></a></h3>
        <div>Strong is beautiful!</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/12/22/Python/%E7%BB%86%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Python小知识点"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/12/06/%E8%8B%B1%E8%AF%AD/CET4--%E4%BD%9C%E6%96%87/" title="SET4-作文"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipaying.jpg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpaying.jpg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zhang0224gz" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>